From a71c043e8831819cffb9e347579f8c58f886206b Mon Sep 17 00:00:00 2001
From: Devi Sandeep Endluri V V <dendluri@codeaurora.org>
Date: Mon, 2 May 2016 14:17:17 -0700
Subject: [PATCH 2/7] Enable NSRM (Network Socket Request Manager).

NSRM is a feature to synchronize app socket requests
to reduce network signalling and there by save power.

Change-Id: Ic34b9c54404ba2156701da1f63232013978bf3a4
CRs-Fixed: 997493

Fix: Added safe check to prevent app crash.

PowerManagerService instance with respect to NSRM is
not handled properly which results in application crash.
Safe checks are added to prevent crashes.

Change-Id: I4ab69e85b1f0a7a4d018b844f4e3dc7f6e1410e8
CRs-Fixed: 1051580

Adding Synchronization for PowerManager mWakeLock.

Race Condition was causing Runtime Exception in
PowerManager.Lock Variable named mWakeLock. It was
occuring while releasing mWakeLock. So Adding Synchronization
Mechanism to Fix this Issue.

CRs-Fixed: 1017355
Change-Id: Ic0376b702298fa45e0d1cc426abb64933bfaa8dc
---
 core/java/android/app/IAlarmManager.aidl           |   2 +
 core/java/android/os/IDeviceIdleController.aidl    |   2 +
 core/java/android/os/IPowerManager.aidl            |   2 +
 .../com/android/server/AlarmManagerService.java    |  27 +++-
 .../com/android/server/DeviceIdleController.java   |  12 ++
 .../com/android/server/QCNsrmAlarmExtension.java   | 120 ++++++++++++++++
 .../android/server/power/PowerManagerService.java  |  29 +++-
 .../android/server/power/QCNsrmPowerExtension.java | 160 +++++++++++++++++++++
 8 files changed, 343 insertions(+), 11 deletions(-)
 create mode 100644 services/core/java/com/android/server/QCNsrmAlarmExtension.java
 create mode 100644 services/core/java/com/android/server/power/QCNsrmPowerExtension.java

diff --git a/core/java/android/app/IAlarmManager.aidl b/core/java/android/app/IAlarmManager.aidl
index 7b05b49..ab45e29 100644
--- a/core/java/android/app/IAlarmManager.aidl
+++ b/core/java/android/app/IAlarmManager.aidl
@@ -37,4 +37,6 @@ interface IAlarmManager {
     void remove(in PendingIntent operation, in IAlarmListener listener);
     long getNextWakeFromIdleTime();
     AlarmManager.AlarmClockInfo getNextAlarmClock(int userId);
+    // update the uids being synchronized by network socket request manager
+    void updateBlockedUids(int uid, boolean isBlocked);
 }
diff --git a/core/java/android/os/IDeviceIdleController.aidl b/core/java/android/os/IDeviceIdleController.aidl
index cc2af21..9cd7dfa 100644
--- a/core/java/android/os/IDeviceIdleController.aidl
+++ b/core/java/android/os/IDeviceIdleController.aidl
@@ -40,4 +40,6 @@ interface IDeviceIdleController {
     void exitIdle(String reason);
     boolean registerMaintenanceActivityListener(IMaintenanceActivityListener listener);
     void unregisterMaintenanceActivityListener(IMaintenanceActivityListener listener);
+    int getIdleStateDetailed();
+    int getLightIdleStateDetailed();
 }
diff --git a/core/java/android/os/IPowerManager.aidl b/core/java/android/os/IPowerManager.aidl
index 61f4760..45ae9fd 100644
--- a/core/java/android/os/IPowerManager.aidl
+++ b/core/java/android/os/IPowerManager.aidl
@@ -71,4 +71,6 @@ interface IPowerManager
 
     // sets the attention light (used by phone app only)
     void setAttentionLight(boolean on, int color);
+    // update the uids being synchronized by network socket request manager
+    void updateBlockedUids(int uid, boolean isBlocked);
 }
diff --git a/services/core/java/com/android/server/AlarmManagerService.java b/services/core/java/com/android/server/AlarmManagerService.java
index d1cf025..9d3f629 100644
--- a/services/core/java/com/android/server/AlarmManagerService.java
+++ b/services/core/java/com/android/server/AlarmManagerService.java
@@ -136,6 +136,7 @@ class AlarmManagerService extends SystemService {
     private long mLastWakeup;
     int mBroadcastRefCount = 0;
     PowerManager.WakeLock mWakeLock;
+    private QCNsrmAlarmExtension qcNsrmExt = new QCNsrmAlarmExtension(this);
     boolean mLastWakeLockUnimportantForLogging;
     ArrayList<Alarm> mPendingNonWakeupAlarms = new ArrayList<>();
     ArrayList<InFlight> mInFlight = new ArrayList<>();
@@ -1447,6 +1448,16 @@ class AlarmManagerService extends SystemService {
             if (!DumpUtils.checkDumpAndUsageStatsPermission(getContext(), TAG, pw)) return;
             dumpImpl(pw);
         }
+
+        @Override
+        /* updates the blocked uids, so if a wake lock is acquired to only fire
+         * alarm for it, it can be released.
+         */
+        public void updateBlockedUids(int uid, boolean isBlocked) {
+            synchronized(mLock) {
+                qcNsrmExt.processBlockedUids(uid, isBlocked, mWakeLock);
+            }
+        }
     };
 
     public final class LocalService {
@@ -2687,11 +2698,10 @@ class AlarmManagerService extends SystemService {
                 mWakeLock.setWorkSource(new WorkSource(uid));
                 return;
             }
+            // Something went wrong; fall back to attributing the lock to the OS
+            mWakeLock.setWorkSource(null);
         } catch (Exception e) {
         }
-
-        // Something went wrong; fall back to attributing the lock to the OS
-        mWakeLock.setWorkSource(null);
     }
 
     private class AlarmHandler extends Handler {
@@ -3017,9 +3027,13 @@ class AlarmManagerService extends SystemService {
             if (DEBUG_WAKELOCK) {
                 Slog.d(TAG, "mBroadcastRefCount -> " + mBroadcastRefCount);
             }
+            qcNsrmExt.removeTriggeredUid(inflight.mUid);
+
             if (mBroadcastRefCount == 0) {
                 mHandler.obtainMessage(AlarmHandler.REPORT_ALARMS_ACTIVE, 0).sendToTarget();
-                mWakeLock.release();
+                if (mWakeLock.isHeld()) {
+                    mWakeLock.release();
+                }
                 if (mInFlight.size() > 0) {
                     mLog.w("Finished all dispatches with " + mInFlight.size()
                             + " remaining inflights");
@@ -3172,7 +3186,9 @@ class AlarmManagerService extends SystemService {
                 setWakelockWorkSource(alarm.operation, alarm.workSource,
                         alarm.type, alarm.statsTag, (alarm.operation == null) ? alarm.uid : -1,
                         true);
+                if (!mWakeLock.isHeld()) {
                 mWakeLock.acquire();
+                }
                 mHandler.obtainMessage(AlarmHandler.REPORT_ALARMS_ACTIVE, 1).sendToTarget();
             }
             final InFlight inflight = new InFlight(AlarmManagerService.this,
@@ -3180,6 +3196,9 @@ class AlarmManagerService extends SystemService {
                     alarm.packageName, alarm.type, alarm.statsTag, nowELAPSED);
             mInFlight.add(inflight);
             mBroadcastRefCount++;
+            qcNsrmExt.addTriggeredUid((alarm.operation != null) ?
+                                    alarm.operation.getCreatorUid() :
+                                    alarm.uid);
 
             if (allowWhileIdle) {
                 // Record the last time this uid handled an ALLOW_WHILE_IDLE alarm.
diff --git a/services/core/java/com/android/server/DeviceIdleController.java b/services/core/java/com/android/server/DeviceIdleController.java
index 05c7504..2fb7739 100644
--- a/services/core/java/com/android/server/DeviceIdleController.java
+++ b/services/core/java/com/android/server/DeviceIdleController.java
@@ -1202,6 +1202,18 @@ public class DeviceIdleController extends SystemService
             return isPowerSaveWhitelistAppInternal(name);
         }
 
+        @Override public int getIdleStateDetailed() {
+            getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,
+                    null);
+            return mState;
+        }
+
+        @Override public int getLightIdleStateDetailed() {
+            getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,
+                    null);
+            return mLightState;
+        }
+
         @Override public void addPowerSaveTempWhitelistApp(String packageName, long duration,
                 int userId, String reason) throws RemoteException {
             addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);
diff --git a/services/core/java/com/android/server/QCNsrmAlarmExtension.java b/services/core/java/com/android/server/QCNsrmAlarmExtension.java
new file mode 100644
index 0000000..a042f72
--- /dev/null
+++ b/services/core/java/com/android/server/QCNsrmAlarmExtension.java
@@ -0,0 +1,120 @@
+/*
+ *Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ *Redistribution and use in source and binary forms, with or without
+ *modification, are permitted provided that the following conditions are
+ *met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ *WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ *ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ *BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ *OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ *IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.android.server;
+
+import android.os.Binder;
+import android.os.PowerManager;
+import android.os.Process;
+import android.util.Slog;
+
+import java.util.ArrayList;
+import java.util.Timer;
+import java.util.TimerTask;
+
+public final class QCNsrmAlarmExtension {
+    static final String TAG = "QCNsrmAlarmExtn";
+    static final boolean localLOGV = false;
+    private AlarmManagerService almHandle;
+
+    //track the blocked and triggered uids in AlarmManagerService
+    private static final ArrayList<Integer> mTriggeredUids = new ArrayList<Integer>();
+    private static final ArrayList<Integer> mBlockedUids = new ArrayList<Integer>();
+    private static final int BLOCKED_UID_CHECK_INTERVAL = 1000; // 1 sec.
+
+    public QCNsrmAlarmExtension(AlarmManagerService handle) {
+        almHandle = handle;
+    }
+
+    //AlarmManagerService extension Methods
+    protected void processBlockedUids(int uid, boolean isBlocked, PowerManager.WakeLock mWakeLock ){
+        if (localLOGV) Slog.v(TAG, "UpdateBlockedUids: uid = " + uid +
+                                  " isBlocked = " + isBlocked);
+        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
+            if (localLOGV) Slog.v(TAG, "UpdateBlockedUids is not allowed");
+            return;
+        }
+
+        if(isBlocked) {
+            if (localLOGV) Slog.v(TAG, "updating alarmMgr mBlockedUids "+
+                                       "with uid " + uid);
+            mBlockedUids.add(new Integer(uid));
+            Timer checkBlockedUidTimer = new Timer();
+            checkBlockedUidTimer.schedule( new CheckBlockedUidTimerTask(
+                                                   uid,
+                                                   mWakeLock),
+                                           BLOCKED_UID_CHECK_INTERVAL);
+        } else {
+            if (localLOGV) Slog.v(TAG, "clearing alarmMgr mBlockedUids ");
+            mBlockedUids.clear();
+        }
+    }
+
+    protected void addTriggeredUid (int uid){
+        if (localLOGV) Slog.v(TAG, "adding uid to mTriggeredUids uid=" + uid);
+        mTriggeredUids.add(new Integer(uid));
+
+    }
+
+    protected void removeTriggeredUid (int uid) {
+        if (localLOGV) Slog.v(TAG, "removing uid from mTriggeredUids uid= " + uid);
+        mTriggeredUids.remove(new Integer(uid));
+    }
+
+    protected boolean hasBlockedUid (int uid) {
+
+        return mBlockedUids.contains(uid);
+
+    }
+
+    class CheckBlockedUidTimerTask extends TimerTask {
+        private int mUid;
+        PowerManager.WakeLock mWakeLock;
+
+        CheckBlockedUidTimerTask(int uid, PowerManager.WakeLock lWakeLock) {
+            mUid = uid;
+            mWakeLock = lWakeLock;
+        }
+
+        @Override
+        public void run(){
+            if (mBlockedUids.contains(mUid) && mTriggeredUids.contains(mUid)) {
+                synchronized(almHandle.mLock) {
+                    if (mWakeLock.isHeld()) {
+                        mWakeLock.release();
+                        if (localLOGV)
+                            Slog.v(TAG, "CheckBlockedUidTimerTask: AM "+
+                                   "WakeLock Released Internally!!");
+                    }
+                }
+                return;
+            }
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/power/PowerManagerService.java b/services/core/java/com/android/server/power/PowerManagerService.java
index 29e0082..2896d22 100644
--- a/services/core/java/com/android/server/power/PowerManagerService.java
+++ b/services/core/java/com/android/server/power/PowerManagerService.java
@@ -142,7 +142,7 @@ public final class PowerManagerService extends SystemService
     private static final int MSG_WAKE_UP = 5;
 
     // Dirty bit: mWakeLocks changed
-    private static final int DIRTY_WAKE_LOCKS = 1 << 0;
+    protected static final int DIRTY_WAKE_LOCKS = 1 << 0;
     // Dirty bit: mWakefulness changed
     private static final int DIRTY_WAKEFULNESS = 1 << 1;
     // Dirty bit: user activity was poked or may have timed out
@@ -259,7 +259,7 @@ public final class PowerManagerService extends SystemService
 
     // A bitfield that indicates what parts of the power state have
     // changed and need to be recalculated.
-    private int mDirty;
+    protected int mDirty;
 
     // Indicates whether the device is awake or asleep or somewhere in between.
     // This is distinct from the screen power state, which is managed separately.
@@ -278,7 +278,7 @@ public final class PowerManagerService extends SystemService
     private final ArrayList<SuspendBlocker> mSuspendBlockers = new ArrayList<SuspendBlocker>();
 
     // Table of all wake locks acquired by applications.
-    private final ArrayList<WakeLock> mWakeLocks = new ArrayList<WakeLock>();
+    protected final ArrayList<WakeLock> mWakeLocks = new ArrayList<WakeLock>();
 
     // A bitfield that summarizes the state of all active wakelocks.
     private int mWakeLockSummary;
@@ -559,6 +559,8 @@ public final class PowerManagerService extends SystemService
 
     // Some uids have actually changed while mUidsChanging was true.
     private boolean mUidsChanged;
+    private QCNsrmPowerExtension qcNsrmPowExt;
+
 
     // True if theater mode is enabled
     private boolean mTheaterModeEnabled;
@@ -672,6 +674,7 @@ public final class PowerManagerService extends SystemService
         mAmbientDisplayConfiguration = new AmbientDisplayConfiguration(mContext);
         mBatterySaverPolicy = new BatterySaverPolicy(mHandler);
 
+        qcNsrmPowExt = new QCNsrmPowerExtension(this);
         synchronized (mLock) {
             mWakeLockSuspendBlocker = createSuspendBlockerLocked("PowerManagerService.WakeLocks");
             mDisplaySuspendBlocker = createSuspendBlockerLocked("PowerManagerService.Display");
@@ -1119,6 +1122,7 @@ public final class PowerManagerService extends SystemService
                 }
                 mWakeLocks.add(wakeLock);
                 setWakeLockDisabledStateLocked(wakeLock);
+                qcNsrmPowExt.checkPmsBlockedWakelocks(uid, pid, flags, tag, wakeLock);
                 notifyAcquire = true;
             }
 
@@ -1271,7 +1275,7 @@ public final class PowerManagerService extends SystemService
         return -1;
     }
 
-    private void notifyWakeLockAcquiredLocked(WakeLock wakeLock) {
+    protected void notifyWakeLockAcquiredLocked(WakeLock wakeLock) {
         if (mSystemReady && !wakeLock.mDisabled) {
             wakeLock.mNotifiedAcquired = true;
             mNotifier.onWakeLockAcquired(wakeLock.mFlags, wakeLock.mTag, wakeLock.mPackageName,
@@ -1327,7 +1331,7 @@ public final class PowerManagerService extends SystemService
         }
     }
 
-    private void notifyWakeLockReleasedLocked(WakeLock wakeLock) {
+    protected void notifyWakeLockReleasedLocked(WakeLock wakeLock) {
         if (mSystemReady && wakeLock.mNotifiedAcquired) {
             wakeLock.mNotifiedAcquired = false;
             wakeLock.mAcquireTime = 0;
@@ -1683,7 +1687,7 @@ public final class PowerManagerService extends SystemService
      * each time something important changes, and ensure that we do it the same
      * way each time.  The point is to gather all of the transition logic here.
      */
-    private void updatePowerStateLocked() {
+    protected void updatePowerStateLocked() {
         if (!mSystemReady || mDirty == 0) {
             return;
         }
@@ -3919,7 +3923,7 @@ public final class PowerManagerService extends SystemService
     /**
      * Represents a wake lock that has been acquired by an application.
      */
-    private final class WakeLock implements IBinder.DeathRecipient {
+    protected final class WakeLock implements IBinder.DeathRecipient {
         public final IBinder mLock;
         public int mFlags;
         public String mTag;
@@ -4715,6 +4719,17 @@ public final class PowerManagerService extends SystemService
                 Binder.restoreCallingIdentity(ident);
             }
         }
+
+        @Override
+        /* updates the blocked uids, so if a wake lock is acquired for it
+         * can be released.
+         */
+        public void updateBlockedUids(int uid, boolean isBlocked) {
+            synchronized(mLock) {
+                qcNsrmPowExt.processPmsBlockedUid(uid, isBlocked,
+                                                             mWakeLocks);
+            }
+        }
     }
 
     @VisibleForTesting
diff --git a/services/core/java/com/android/server/power/QCNsrmPowerExtension.java b/services/core/java/com/android/server/power/QCNsrmPowerExtension.java
new file mode 100644
index 0000000..632d5c1
--- /dev/null
+++ b/services/core/java/com/android/server/power/QCNsrmPowerExtension.java
@@ -0,0 +1,160 @@
+/*
+ *Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ *Redistribution and use in source and binary forms, with or without
+ *modification, are permitted provided that the following conditions are
+ *met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ *WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ *ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ *BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ *BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ *OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ *IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.android.server.power;
+
+import java.util.ArrayList;
+
+import android.os.Binder;
+import android.os.PowerManager;
+import android.os.Process;
+import android.util.Slog;
+
+public final class QCNsrmPowerExtension {
+    static final String TAG = "QCNsrmPowerExtn";
+    static final boolean localLOGV = false;
+    private PowerManagerService pmHandle;
+
+    //track the blocked uids in PowerManagerService.
+    private final ArrayList<Integer> mPmsBlockedUids = new ArrayList<Integer>();
+
+    public QCNsrmPowerExtension (PowerManagerService handle) {
+       pmHandle = handle ;
+    }
+
+    protected void checkPmsBlockedWakelocks (
+        int uid, int pid, int flags,
+        String tag, PowerManagerService.WakeLock pMwakeLock
+        ) {
+        if(mPmsBlockedUids.contains(new Integer(uid)) && uid != Process.myUid()) {
+            // wakelock acquisition for blocked uid, disable it.
+            if (localLOGV) {
+                Slog.d(TAG, "uid is blocked disabling wakeLock flags=0x" +
+                       Integer.toHexString(flags) + " tag=" + tag + " uid=" +
+                       uid + " pid =" + pid);
+            }
+            updatePmsBlockedWakelock(pMwakeLock, true);
+        }
+    }
+
+    private boolean checkWorkSourceObjectId (
+        int uid, PowerManagerService.WakeLock wl
+        ) {
+        try {
+            for (int index = 0; index < wl.mWorkSource.size(); index++) {
+                if (uid == wl.mWorkSource.get(index)) {
+                    if (localLOGV) Slog.v(TAG, "WS uid matched");
+                    return true;
+                }
+            }
+        }
+        catch (Exception e) {
+            return false;
+        }
+        return false;
+    }
+
+    protected boolean processPmsBlockedUid (
+        int uid, boolean isBlocked,
+        ArrayList<PowerManagerService.WakeLock> mWakeLocks
+        ) {
+        boolean changed = false;
+        if (updatePmsBlockedUidAllowed(uid, isBlocked))
+            return changed;
+
+        for (int index = 0; index < mWakeLocks.size(); index++) {
+            PowerManagerService.WakeLock wl = mWakeLocks.get(index);
+            if(wl != null) {
+                // update the wakelock for the blocked uid
+                if ((wl.mOwnerUid == uid || checkWorkSourceObjectId(uid, wl))
+                    || (wl.mTag.startsWith("*sync*") && wl.mOwnerUid ==
+                        Process.SYSTEM_UID)) {
+                    if(updatePmsBlockedWakelock(wl, isBlocked)) {
+                        changed = true;
+                    }
+                }
+            }
+        }
+        if(changed) {
+            pmHandle.mDirty |= pmHandle.DIRTY_WAKE_LOCKS;
+            pmHandle.updatePowerStateLocked();
+        }
+        return changed;
+    }
+
+    protected boolean updatePmsBlockedUidAllowed (
+        int uid, boolean isBlocked
+        ) {
+        if (localLOGV) Slog.v(TAG, "updateBlockedUids: uid = " + uid +
+                               "isBlocked = " + isBlocked);
+        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
+            if (localLOGV) Slog.v(TAG, "UpdateBlockedUids is not allowed");
+            return true;
+        }
+        updatePmsBlockedUids(uid, isBlocked);
+        return false;
+    }
+
+    private void updatePmsBlockedUids (int uid, boolean isBlocked) {
+        if(isBlocked) {
+            if (localLOGV) Slog.v(TAG, "adding powerMgr mPmBlockedUids "+
+                                  "with uid "+ uid);
+            mPmsBlockedUids.add(new Integer(uid));
+        }
+        else {
+            if (localLOGV) Slog.v(TAG, "clearing powerMgr mPmBlockedUids ");
+            mPmsBlockedUids.clear();
+        }
+    }
+
+    private boolean updatePmsBlockedWakelock (
+        PowerManagerService.WakeLock wakeLock, boolean update
+        ) {
+        if (wakeLock != null && ((wakeLock.mFlags &
+                                  PowerManager.WAKE_LOCK_LEVEL_MASK
+                                  ) == PowerManager.PARTIAL_WAKE_LOCK )) {
+            if (wakeLock.mDisabled != update && pmHandle != null) {
+                wakeLock.mDisabled = update;
+                  if (localLOGV) Slog.v(TAG, "updatePmsBlockWakelock pmHandle "+pmHandle);
+                if (wakeLock.mDisabled) {
+                    // This wake lock is no longer being respected.
+                    pmHandle.notifyWakeLockReleasedLocked(wakeLock);
+                } else {
+                    pmHandle.notifyWakeLockAcquiredLocked(wakeLock);
+                }
+                return true;
+            }
+            else {
+               if (localLOGV) Slog.v(TAG, "updatePmsBlockWakelock pmHandle "+pmHandle );
+            }
+        }
+        return false;
+    }
+}
+
-- 
2.7.4

