From 350b4bf421b62db96ad564dfc9aad8706d0b79f9 Mon Sep 17 00:00:00 2001
From: Michael Bestas <mkbestas@lineageos.org>
Date: Sat, 3 Feb 2018 17:34:13 +0200
Subject: [PATCH 06/12] SUW: rebrand step 1: update paths

Change-Id: Ic63e83de56659750a9d75fe577187c0d9f25147f
---
 res/raw/cm_wizard_script.xml                       |   77 -
 res/raw/cm_wizard_script_user.xml                  |   27 -
 res/raw/lineage_wizard_script.xml                  |   77 +
 res/raw/lineage_wizard_script_user.xml             |   27 +
 .../setupwizard/BaseSetupWizardActivity.java       |  667 -----
 .../setupwizard/BluetoothSetupActivity.java        |   57 -
 .../setupwizard/CaptivePortalSetupActivity.java    |  149 --
 .../setupwizard/ChooseDataSimActivity.java         |  498 ----
 .../cyanogenmod/setupwizard/DateTimeActivity.java  |  444 ----
 .../setupwizard/FingerprintActivity.java           |   84 -
 .../cyanogenmod/setupwizard/FinishActivity.java    |  235 --
 .../setupwizard/LineageSettingsActivity.java       |  243 --
 .../cyanogenmod/setupwizard/LocaleActivity.java    |  258 --
 .../setupwizard/LocationSettingsActivity.java      |  219 --
 .../setupwizard/MobileDataActivity.java            |  334 ---
 .../cyanogenmod/setupwizard/PartnerReceiver.java   |   29 -
 .../setupwizard/ScreenLockActivity.java            |   78 -
 .../setupwizard/SetupWizardActivity.java           |   63 -
 .../cyanogenmod/setupwizard/SetupWizardApp.java    |  132 -
 .../setupwizard/SetupWizardExitActivity.java       |   62 -
 .../setupwizard/SetupWizardExitService.java        |   44 -
 .../setupwizard/SetupWizardTestActivity.java       |   73 -
 .../setupwizard/SimMissingActivity.java            |   90 -
 .../cyanogenmod/setupwizard/SubBaseActivity.java   |  173 --
 .../cyanogenmod/setupwizard/WelcomeActivity.java   |   67 -
 .../cyanogenmod/setupwizard/WifiSetupActivity.java |   50 -
 .../util/EnableAccessibilityController.java        |  277 ---
 .../setupwizard/util/NetworkMonitor.java           |  126 -
 .../cyanogenmod/setupwizard/util/PhoneMonitor.java |  487 ----
 .../setupwizard/util/SetupWizardUtils.java         |  380 ---
 .../setupwizard/widget/LocalePicker.java           | 2607 --------------------
 .../setupwizard/widget/ScrimInsetsFrameLayout.java |  142 --
 .../setupwizard/wizardmanager/WizardAction.java    |  182 --
 .../setupwizard/wizardmanager/WizardManager.java   |  208 --
 .../setupwizard/wizardmanager/WizardScript.java    |  212 --
 .../wizardmanager/WizardTransitions.java           |  109 -
 .../setupwizard/BaseSetupWizardActivity.java       |  667 +++++
 .../setupwizard/BluetoothSetupActivity.java        |   57 +
 .../setupwizard/CaptivePortalSetupActivity.java    |  149 ++
 .../setupwizard/ChooseDataSimActivity.java         |  498 ++++
 .../lineageos/setupwizard/DateTimeActivity.java    |  444 ++++
 .../lineageos/setupwizard/FingerprintActivity.java |   84 +
 src/org/lineageos/setupwizard/FinishActivity.java  |  235 ++
 .../setupwizard/LineageSettingsActivity.java       |  243 ++
 src/org/lineageos/setupwizard/LocaleActivity.java  |  258 ++
 .../setupwizard/LocationSettingsActivity.java      |  219 ++
 .../lineageos/setupwizard/MobileDataActivity.java  |  334 +++
 src/org/lineageos/setupwizard/PartnerReceiver.java |   29 +
 .../lineageos/setupwizard/ScreenLockActivity.java  |   78 +
 .../lineageos/setupwizard/SetupWizardActivity.java |   63 +
 src/org/lineageos/setupwizard/SetupWizardApp.java  |  132 +
 .../setupwizard/SetupWizardExitActivity.java       |   62 +
 .../setupwizard/SetupWizardExitService.java        |   44 +
 .../setupwizard/SetupWizardTestActivity.java       |   73 +
 .../lineageos/setupwizard/SimMissingActivity.java  |   90 +
 src/org/lineageos/setupwizard/SubBaseActivity.java |  173 ++
 src/org/lineageos/setupwizard/WelcomeActivity.java |   67 +
 .../lineageos/setupwizard/WifiSetupActivity.java   |   50 +
 .../util/EnableAccessibilityController.java        |  277 +++
 .../lineageos/setupwizard/util/NetworkMonitor.java |  126 +
 .../lineageos/setupwizard/util/PhoneMonitor.java   |  487 ++++
 .../setupwizard/util/SetupWizardUtils.java         |  380 +++
 .../lineageos/setupwizard/widget/LocalePicker.java | 2607 ++++++++++++++++++++
 .../setupwizard/widget/ScrimInsetsFrameLayout.java |  142 ++
 .../setupwizard/wizardmanager/WizardAction.java    |  182 ++
 .../setupwizard/wizardmanager/WizardManager.java   |  208 ++
 .../setupwizard/wizardmanager/WizardScript.java    |  212 ++
 .../wizardmanager/WizardTransitions.java           |  109 +
 tests/res/layout/cmaccount_test.xml                |   40 -
 tests/res/layout/setupwizard_test.xml              |   40 +
 .../setupwizard/tests/ManualTestActivity.java      |  182 --
 .../setupwizard/tests/ManualTestActivity.java      |  182 ++
 72 files changed, 9105 insertions(+), 9105 deletions(-)
 delete mode 100644 res/raw/cm_wizard_script.xml
 delete mode 100644 res/raw/cm_wizard_script_user.xml
 create mode 100644 res/raw/lineage_wizard_script.xml
 create mode 100644 res/raw/lineage_wizard_script_user.xml
 delete mode 100644 src/com/cyanogenmod/setupwizard/BaseSetupWizardActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/BluetoothSetupActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/CaptivePortalSetupActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/ChooseDataSimActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/DateTimeActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/FingerprintActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/FinishActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/LineageSettingsActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/LocaleActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/LocationSettingsActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/MobileDataActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/PartnerReceiver.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/ScreenLockActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SetupWizardActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SetupWizardApp.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SetupWizardExitActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SetupWizardExitService.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SetupWizardTestActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SimMissingActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/SubBaseActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/WelcomeActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/WifiSetupActivity.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/util/EnableAccessibilityController.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/util/NetworkMonitor.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/util/PhoneMonitor.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/util/SetupWizardUtils.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/widget/LocalePicker.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/widget/ScrimInsetsFrameLayout.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/wizardmanager/WizardAction.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/wizardmanager/WizardManager.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/wizardmanager/WizardScript.java
 delete mode 100644 src/com/cyanogenmod/setupwizard/wizardmanager/WizardTransitions.java
 create mode 100644 src/org/lineageos/setupwizard/BaseSetupWizardActivity.java
 create mode 100644 src/org/lineageos/setupwizard/BluetoothSetupActivity.java
 create mode 100644 src/org/lineageos/setupwizard/CaptivePortalSetupActivity.java
 create mode 100644 src/org/lineageos/setupwizard/ChooseDataSimActivity.java
 create mode 100644 src/org/lineageos/setupwizard/DateTimeActivity.java
 create mode 100644 src/org/lineageos/setupwizard/FingerprintActivity.java
 create mode 100644 src/org/lineageos/setupwizard/FinishActivity.java
 create mode 100644 src/org/lineageos/setupwizard/LineageSettingsActivity.java
 create mode 100644 src/org/lineageos/setupwizard/LocaleActivity.java
 create mode 100644 src/org/lineageos/setupwizard/LocationSettingsActivity.java
 create mode 100644 src/org/lineageos/setupwizard/MobileDataActivity.java
 create mode 100644 src/org/lineageos/setupwizard/PartnerReceiver.java
 create mode 100644 src/org/lineageos/setupwizard/ScreenLockActivity.java
 create mode 100644 src/org/lineageos/setupwizard/SetupWizardActivity.java
 create mode 100644 src/org/lineageos/setupwizard/SetupWizardApp.java
 create mode 100644 src/org/lineageos/setupwizard/SetupWizardExitActivity.java
 create mode 100644 src/org/lineageos/setupwizard/SetupWizardExitService.java
 create mode 100644 src/org/lineageos/setupwizard/SetupWizardTestActivity.java
 create mode 100644 src/org/lineageos/setupwizard/SimMissingActivity.java
 create mode 100644 src/org/lineageos/setupwizard/SubBaseActivity.java
 create mode 100644 src/org/lineageos/setupwizard/WelcomeActivity.java
 create mode 100644 src/org/lineageos/setupwizard/WifiSetupActivity.java
 create mode 100644 src/org/lineageos/setupwizard/util/EnableAccessibilityController.java
 create mode 100644 src/org/lineageos/setupwizard/util/NetworkMonitor.java
 create mode 100644 src/org/lineageos/setupwizard/util/PhoneMonitor.java
 create mode 100644 src/org/lineageos/setupwizard/util/SetupWizardUtils.java
 create mode 100644 src/org/lineageos/setupwizard/widget/LocalePicker.java
 create mode 100644 src/org/lineageos/setupwizard/widget/ScrimInsetsFrameLayout.java
 create mode 100644 src/org/lineageos/setupwizard/wizardmanager/WizardAction.java
 create mode 100644 src/org/lineageos/setupwizard/wizardmanager/WizardManager.java
 create mode 100644 src/org/lineageos/setupwizard/wizardmanager/WizardScript.java
 create mode 100644 src/org/lineageos/setupwizard/wizardmanager/WizardTransitions.java
 delete mode 100644 tests/res/layout/cmaccount_test.xml
 create mode 100644 tests/res/layout/setupwizard_test.xml
 delete mode 100644 tests/src/com/cyanogenmod/setupwizard/tests/ManualTestActivity.java
 create mode 100644 tests/src/org/lineageos/setupwizard/tests/ManualTestActivity.java

diff --git a/res/raw/cm_wizard_script.xml b/res/raw/cm_wizard_script.xml
deleted file mode 100644
index 486443e..0000000
--- a/res/raw/cm_wizard_script.xml
+++ /dev/null
@@ -1,77 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<!--
-     Copyright (C) 2016 The CyanogenMod Project
-     Copyright (C) 2017 The LineageOS Project
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<WizardScript xmlns:wizard="http://schemas.android.com/apk/res/com.google.android.setupwizard"
-    wizard:firstAction="bluetooth_setup">
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_BLUETOOTH_SETUP;end" id="bluetooth_setup">
-        <result wizard:action="welcome" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_WELCOME;end" id="welcome">
-        <result wizard:action="locale" />
-    </WizardAction>
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_LOCALE;end" id="locale">
-        <result wizard:action="datetime" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_DATETIME;end" id="datetime">
-        <result wizard:action="wifi_setup" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_WIFI_SETUP;end" id="wifi_setup">
-        <result wizard:resultCode="1" wizard:action="sim_missing" wizard:name="no_sim" />
-        <result wizard:action="choose_data_sim" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SIM_MISSING;end" id="sim_missing">
-        <result wizard:resultCode="1" wizard:action="location_settings" wizard:name="skip_sim" />
-        <result wizard:action="choose_data_sim" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_CHOOSE_DATA_SIM;end" id="choose_data_sim">
-        <result wizard:action="enable_mobile_data" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_ENABLE_MOBILE_DATA;end" id="enable_mobile_data">
-        <result wizard:action="location_settings" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_LOCATION_SETTINGS;end" id="location_settings">
-        <result wizard:action="lineage_settings" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SETTINGS;end" id="lineage_settings">
-        <result wizard:action="fingerprint_settings" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_FINGERPRINT_SETTINGS;end" id="fingerprint_settings">
-        <result wizard:action="lockscreen_settings" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_LOCKSCREEN_SETTINGS;end" id="lockscreen_settings">
-        <result wizard:action="finish" />
-    </WizardAction>
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SETUP_COMPLETE;end" id="finish">
-        <result wizard:action="exit" />
-    </WizardAction>
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.EXIT;end" id="exit" />
-
-</WizardScript>
diff --git a/res/raw/cm_wizard_script_user.xml b/res/raw/cm_wizard_script_user.xml
deleted file mode 100644
index 6a9fb19..0000000
--- a/res/raw/cm_wizard_script_user.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<!--
-     Copyright (C) 2016 The CyanogenMod Project
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-        http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<WizardScript xmlns:wizard="http://schemas.android.com/apk/res/com.google.android.setupwizard"
-              wizard:firstAction="finish">
-
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SETUP_COMPLETE;end" id="finish">
-        <result wizard:action="exit" />
-    </WizardAction>
-    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.EXIT;end" id="exit" />
-
-</WizardScript>
diff --git a/res/raw/lineage_wizard_script.xml b/res/raw/lineage_wizard_script.xml
new file mode 100644
index 0000000..486443e
--- /dev/null
+++ b/res/raw/lineage_wizard_script.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!--
+     Copyright (C) 2016 The CyanogenMod Project
+     Copyright (C) 2017 The LineageOS Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<WizardScript xmlns:wizard="http://schemas.android.com/apk/res/com.google.android.setupwizard"
+    wizard:firstAction="bluetooth_setup">
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_BLUETOOTH_SETUP;end" id="bluetooth_setup">
+        <result wizard:action="welcome" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_WELCOME;end" id="welcome">
+        <result wizard:action="locale" />
+    </WizardAction>
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_LOCALE;end" id="locale">
+        <result wizard:action="datetime" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_DATETIME;end" id="datetime">
+        <result wizard:action="wifi_setup" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_WIFI_SETUP;end" id="wifi_setup">
+        <result wizard:resultCode="1" wizard:action="sim_missing" wizard:name="no_sim" />
+        <result wizard:action="choose_data_sim" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SIM_MISSING;end" id="sim_missing">
+        <result wizard:resultCode="1" wizard:action="location_settings" wizard:name="skip_sim" />
+        <result wizard:action="choose_data_sim" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_CHOOSE_DATA_SIM;end" id="choose_data_sim">
+        <result wizard:action="enable_mobile_data" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_ENABLE_MOBILE_DATA;end" id="enable_mobile_data">
+        <result wizard:action="location_settings" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_LOCATION_SETTINGS;end" id="location_settings">
+        <result wizard:action="lineage_settings" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SETTINGS;end" id="lineage_settings">
+        <result wizard:action="fingerprint_settings" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_FINGERPRINT_SETTINGS;end" id="fingerprint_settings">
+        <result wizard:action="lockscreen_settings" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_LOCKSCREEN_SETTINGS;end" id="lockscreen_settings">
+        <result wizard:action="finish" />
+    </WizardAction>
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SETUP_COMPLETE;end" id="finish">
+        <result wizard:action="exit" />
+    </WizardAction>
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.EXIT;end" id="exit" />
+
+</WizardScript>
diff --git a/res/raw/lineage_wizard_script_user.xml b/res/raw/lineage_wizard_script_user.xml
new file mode 100644
index 0000000..6a9fb19
--- /dev/null
+++ b/res/raw/lineage_wizard_script_user.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!--
+     Copyright (C) 2016 The CyanogenMod Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<WizardScript xmlns:wizard="http://schemas.android.com/apk/res/com.google.android.setupwizard"
+              wizard:firstAction="finish">
+
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.LINEAGE_SETUP_COMPLETE;end" id="finish">
+        <result wizard:action="exit" />
+    </WizardAction>
+    <WizardAction wizard:uri="intent:#Intent;action=com.cyanogenmod.setupwizard.EXIT;end" id="exit" />
+
+</WizardScript>
diff --git a/src/com/cyanogenmod/setupwizard/BaseSetupWizardActivity.java b/src/com/cyanogenmod/setupwizard/BaseSetupWizardActivity.java
deleted file mode 100644
index 56ee309..0000000
--- a/src/com/cyanogenmod/setupwizard/BaseSetupWizardActivity.java
+++ /dev/null
@@ -1,667 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.android.setupwizardlib.util.ResultCodes.RESULT_ACTIVITY_NOT_FOUND;
-import static com.android.setupwizardlib.util.ResultCodes.RESULT_RETRY;
-import static com.android.setupwizardlib.util.ResultCodes.RESULT_SKIP;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_EMERGENCY_DIAL;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_NEXT;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ACTION_ID;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_FIRST_RUN;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_HAS_MULTIPLE_USERS;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_RESULT_CODE;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_USE_IMMERSIVE;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.app.Activity;
-import android.app.ActivityManager;
-import android.content.ActivityNotFoundException;
-import android.content.Intent;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.net.wifi.WifiManager;
-import android.os.Bundle;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.util.Log;
-import android.view.View;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.android.setupwizard.navigationbar.SetupWizardNavBar;
-import com.android.setupwizard.navigationbar.SetupWizardNavBar.NavigationBarListener;
-import com.android.setupwizardlib.util.SystemBarHelper;
-import com.android.setupwizardlib.util.WizardManagerHelper;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-import java.util.List;
-
-public abstract class BaseSetupWizardActivity extends Activity implements NavigationBarListener {
-
-    public static final String TAG = BaseSetupWizardActivity.class.getSimpleName();
-
-    protected static final int TRANSITION_ID_NONE = -1;
-    protected static final int TRANSITION_ID_DEFAULT = 1;
-    protected static final int TRANSITION_ID_SLIDE = 2;
-    protected static final int TRANSITION_ID_FADE = 3;
-
-    protected static final int NEXT_REQUEST = 10000;
-    protected static final int EMERGENCY_DIAL_ACTIVITY_REQUEST = 10038;
-    protected static final int WIFI_ACTIVITY_REQUEST = 10004;
-    protected static final int BLUETOOTH_ACTIVITY_REQUEST = 10100;
-    protected static final int FINGERPRINT_ACTIVITY_REQUEST = 10101;
-    protected static final int SCREENLOCK_ACTIVITY_REQUEST = 10102;
-
-    private SetupWizardNavBar mNavigationBar;
-
-    protected boolean mIsActivityVisible = false;
-    protected boolean mIsExiting = false;
-    private boolean mIsFirstRun = true;
-    protected boolean mIsGoingBack = false;
-    private boolean mIsPrimaryUser;
-    private int mResultCode = 0;
-    private Intent mResultData;
-
-    @Override
-    protected void onCreate(@Nullable Bundle savedInstanceState) {
-        if (LOGV) {
-            logActivityState("onCreate savedInstanceState=" + savedInstanceState);
-        }
-        super.onCreate(savedInstanceState);
-        mIsPrimaryUser = UserHandle.myUserId() == 0;
-        initLayout();
-    }
-
-    @Override
-    protected void onStart() {
-        if (LOGV) {
-            logActivityState("onStart");
-        }
-        super.onStart();
-        exitIfSetupComplete();
-    }
-
-    @Override
-    protected void onRestart() {
-        if (LOGV) {
-            logActivityState("onRestart");
-        }
-        super.onRestart();
-    }
-
-    @Override
-    protected void onResume() {
-        if (LOGV) {
-            logActivityState("onResume");
-        }
-        super.onResume();
-        if (mIsGoingBack) {
-            if (!mIsExiting) {
-                applyBackwardTransition(getTransition());
-            }
-        } else if (!mIsExiting) {
-            applyForwardTransition(getTransition());
-        }
-    }
-
-    @Override
-    protected void onPause() {
-        if (LOGV) {
-            logActivityState("onPause");
-        }
-        super.onPause();
-    }
-
-    @Override
-    protected void onStop() {
-        if (LOGV) {
-            logActivityState("onStop");
-        }
-        super.onStop();
-    }
-
-    @Override
-    protected void onDestroy() {
-        if (LOGV) {
-            logActivityState("onDestroy");
-        }
-        super.onDestroy();
-    }
-
-    @Override
-    public void onAttachedToWindow() {
-        if (LOGV) {
-            logActivityState("onAttachedToWindow");
-        }
-        mIsActivityVisible = true;
-        super.onAttachedToWindow();
-    }
-
-    @Override
-    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
-        if (LOGV) {
-            Log.v(TAG, "onRestoreInstanceState(" + savedInstanceState + ")");
-        }
-        super.onRestoreInstanceState(savedInstanceState);
-        int currentId = savedInstanceState.getInt("currentFocus", -1);
-        if (currentId != -1) {
-            View view = findViewById(currentId);
-            if (view != null) {
-                view.requestFocus();
-            }
-        }
-    }
-
-    @Override
-    protected void onSaveInstanceState(@NonNull Bundle outState) {
-        super.onSaveInstanceState(outState);
-        View current = getCurrentFocus();
-        outState.putInt("currentFocus", current != null ? current.getId() : -1);
-        if (LOGV) {
-            Log.v(TAG, "onSaveInstanceState(" + outState + ")");
-        }
-    }
-
-    @Override
-    public void onNavigationBarCreated(SetupWizardNavBar bar) {
-        mNavigationBar = bar;
-        bar.setUseImmersiveMode(true);
-        bar.getView().addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
-            @Override
-            public void onLayoutChange(View view, int left, int top, int right, int bottom,
-                                       int oldLeft, int oldTop, int oldRight, int oldBottom) {
-                view.requestApplyInsets();
-            }
-        });
-    }
-
-    protected void setBackDrawable(Drawable drawable) {
-        if (mNavigationBar != null) {
-            mNavigationBar.getBackButton().setCompoundDrawables(drawable, null, null, null);
-        }
-    }
-
-    protected void setNextDrawable(Drawable drawable) {
-        if (mNavigationBar != null) {
-            mNavigationBar.getBackButton().setCompoundDrawables(null, null, drawable, null);
-        }
-    }
-
-    public void setBackAllowed(boolean allowed) {
-        SystemBarHelper.setBackButtonVisible(getWindow(), allowed);
-        if (mNavigationBar != null) {
-            Button backButton = mNavigationBar.getBackButton();
-            backButton.setEnabled(allowed);
-        }
-    }
-
-    protected boolean isBackAllowed() {
-        if (mNavigationBar != null) {
-            mNavigationBar.getBackButton().isEnabled();
-        }
-        return false;
-    }
-
-    public void setNextAllowed(boolean allowed) {
-        if (mNavigationBar != null) {
-            mNavigationBar.getNextButton().setEnabled(allowed);
-        }
-    }
-
-    protected boolean isNextAllowed() {
-        if (mNavigationBar != null) {
-            mNavigationBar.getNextButton().isEnabled();
-        }
-        return false;
-    }
-
-    protected void onNextPressed() {
-        nextAction(NEXT_REQUEST);
-    }
-
-    protected void setNextText(int resId) {
-        if (mNavigationBar != null) {
-            mNavigationBar.getNextButton().setText(resId);
-        }
-    }
-
-    protected void setBackText(int resId) {
-        if (mNavigationBar != null) {
-            mNavigationBar.getBackButton().setText(resId);
-        }
-    }
-
-    protected void hideNextButton() {
-        if (mNavigationBar != null) {
-            Animation fadeOut = AnimationUtils.loadAnimation(this, android.R.anim.fade_out);
-            final Button next = mNavigationBar.getNextButton();
-            next.startAnimation(fadeOut);
-            next.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    protected Intent getResultData() {
-        return null;
-    }
-
-    @Override
-    public void onBackPressed() {
-        if (LOGV) {
-            Log.v(TAG, "onBackPressed()");
-        }
-        setResultCode(RESULT_CANCELED, getResultData());
-        super.onBackPressed();
-    }
-
-    public void onNavigateBack() {
-        onBackPressed();
-    }
-
-    public void onNavigateNext() {
-        onNextPressed();
-    }
-
-    protected void startEmergencyDialer() {
-        try {
-            startFirstRunActivityForResult(new Intent(ACTION_EMERGENCY_DIAL),
-                    EMERGENCY_DIAL_ACTIVITY_REQUEST);
-            applyForwardTransition(TRANSITION_ID_DEFAULT);
-        } catch (ActivityNotFoundException e) {
-            Log.e(TAG, "Can't find the emergency dialer: com.android.phone.EmergencyDialer.DIAL");
-        }
-    }
-
-    protected void onSetupStart() {
-        SetupWizardUtils.disableCaptivePortalDetection(getApplicationContext());
-        SetupWizardUtils.disableStatusBar(getApplicationContext());
-        SystemBarHelper.hideSystemBars(getWindow());
-        tryEnablingWifi();
-    }
-
-
-    protected void exitIfSetupComplete() {
-        if (WizardManagerHelper.isUserSetupComplete(this)) {
-            Log.i(TAG, "Starting activity with USER_SETUP_COMPLETE=true");
-            startSetupWizardExitActivity();
-            setResult(RESULT_CANCELED, null);
-            finishAllAppTasks();
-        }
-    }
-
-    protected void finishAllAppTasks() {
-        List<ActivityManager.AppTask> appTasks =
-                getSystemService(ActivityManager.class).getAppTasks();
-
-        for (ActivityManager.AppTask task : appTasks) {
-            if (LOGV) {
-                Log.v(TAG, "Finishing task=" + task.toString());
-            }
-            task.finishAndRemoveTask();
-        }
-        finish();
-    }
-
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (LOGV) {
-            Log.v(TAG, "onActivityResult(" + getRequestName(requestCode) + ", " +
-                    getResultName(requestCode, resultCode) + ")");
-        }
-        mIsGoingBack = true;
-        if (requestCode != NEXT_REQUEST || resultCode != RESULT_CANCELED) {
-            if (requestCode == EMERGENCY_DIAL_ACTIVITY_REQUEST) {
-                applyBackwardTransition(TRANSITION_ID_DEFAULT);
-                return;
-            }
-            if (resultCode == RESULT_CANCELED) {
-                finish();
-            } else {
-                nextAction(resultCode);
-            }
-        }
-    }
-
-    public void finish() {
-        if (LOGV) {
-            Log.v(TAG, "finish");
-        }
-        super.finish();
-        if (isResumed() && mResultCode == RESULT_CANCELED) {
-            applyBackwardTransition(getTransition());
-        }
-        mIsExiting = true;
-    }
-
-    protected void finishAction() {
-        finishAction(RESULT_CANCELED);
-    }
-
-    protected void finishAction(int resultCode) {
-        finishAction(resultCode, null);
-    }
-
-    protected void finishAction(int resultCode, Intent data) {
-        if (resultCode != 0) {
-            nextAction(resultCode, data);
-        }
-        finish();
-    }
-
-    protected void setResultCode(int resultCode) {
-        setResultCode(resultCode, getResultData());
-    }
-
-    protected void setResultCode(int resultCode, Intent data) {
-        if (LOGV) {
-            Log.v(TAG, "setResultCode result=" + getResultName(0, resultCode) + " data=" + data);
-        }
-        mResultCode = resultCode;
-        mResultData = data;
-        setResult(resultCode, data);
-    }
-
-    protected void nextAction(int resultCode) {
-        nextAction(resultCode, null);
-    }
-
-    protected void nextAction(int resultCode, Intent data) {
-        if (LOGV) {
-            Log.v(TAG, "nextAction resultCode=" + resultCode +
-                    " data=" + data + " this=" + this);
-        }
-        if (resultCode == 0) {
-            throw new IllegalArgumentException("Cannot call nextAction with RESULT_CANCELED");
-        }
-        setResultCode(resultCode, data);
-        sendActionResults();
-    }
-
-    public void startActivity(Intent intent) {
-        super.startActivity(intent);
-        if (isResumed() && mIsActivityVisible) {
-            applyForwardTransition(getTransition());
-        }
-        mIsExiting = true;
-    }
-
-    public void startActivityForResult(Intent intent, int requestCode) {
-        super.startActivityForResult(intent, requestCode);
-        if (isResumed() && mIsActivityVisible) {
-            applyForwardTransition(getTransition());
-        }
-        mIsExiting = true;
-    }
-
-    protected void sendActionResults() {
-        if (LOGV) {
-            Log.v(TAG, "sendActionResults resultCode=" + mResultCode + " data=" + mResultData);
-        }
-        Intent intent = new Intent(ACTION_NEXT);
-        intent.putExtra(EXTRA_SCRIPT_URI, getIntent().getStringExtra(EXTRA_SCRIPT_URI));
-        intent.putExtra(EXTRA_ACTION_ID, getIntent().getStringExtra(EXTRA_ACTION_ID));
-        intent.putExtra(EXTRA_RESULT_CODE, mResultCode);
-        if (!(mResultData == null || mResultData.getExtras() == null)) {
-            intent.putExtras(mResultData.getExtras());
-        }
-        startActivityForResult(intent, NEXT_REQUEST);
-    }
-
-    protected void applyForwardTransition(int transitionId) {
-        if (transitionId == TRANSITION_ID_SLIDE) {
-            overridePendingTransition(R.anim.suw_slide_next_in, R.anim.suw_slide_next_out);
-        } else if (transitionId == TRANSITION_ID_FADE) {
-            overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
-        } else if (transitionId == TRANSITION_ID_DEFAULT) {
-            TypedArray typedArray = obtainStyledAttributes(android.R.style.Animation_Activity,
-                    new int[]{android.R.attr.activityOpenEnterAnimation,
-                            android.R.attr.activityOpenExitAnimation});
-            overridePendingTransition(typedArray.getResourceId(0, 0),
-                    typedArray.getResourceId(1, 0));
-            typedArray.recycle();
-        } else if (transitionId == TRANSITION_ID_NONE) {
-            overridePendingTransition(0, 0);
-        }
-    }
-
-    protected void applyBackwardTransition(int transitionId) {
-        if (transitionId == TRANSITION_ID_SLIDE) {
-            overridePendingTransition(R.anim.suw_slide_back_in, R.anim.suw_slide_back_out);
-        } else if (transitionId == TRANSITION_ID_FADE) {
-            overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
-        } else if (transitionId == TRANSITION_ID_DEFAULT) {
-            TypedArray typedArray = obtainStyledAttributes(android.R.style.Animation_Activity,
-                    new int[]{android.R.attr.activityCloseEnterAnimation,
-                    android.R.attr.activityCloseExitAnimation});
-            overridePendingTransition(typedArray.getResourceId(0, 0),
-                    typedArray.getResourceId(1, 0));
-            typedArray.recycle();
-        } else if (transitionId == TRANSITION_ID_NONE) {
-            overridePendingTransition(0, 0);
-        }
-    }
-
-    protected void hideBackButton() {
-        if (mNavigationBar != null) {
-            Animation fadeOut = AnimationUtils.loadAnimation(this, android.R.anim.fade_out);
-            final Button back = mNavigationBar.getBackButton();
-            back.startAnimation(fadeOut);
-            back.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    protected int getTransition() {
-        return TRANSITION_ID_DEFAULT;
-    }
-
-    protected boolean tryEnablingWifi() {
-        WifiManager wifiManager = getSystemService(WifiManager.class);
-        if (wifiManager != null && !wifiManager.isWifiEnabled()) {
-            return wifiManager.setWifiEnabled(true);
-        }
-        return false;
-    }
-
-    private void startSetupWizardExitActivity() {
-        if (LOGV) {
-            Log.v(TAG, "startSetupWizardExitActivity()");
-        }
-        startFirstRunActivity(new Intent(this, SetupWizardExitActivity.class));
-    }
-
-    protected void startFirstRunActivity(Intent intent) {
-        if (LOGV) {
-            Log.v(TAG, "starting activity " + intent);
-        }
-        intent.putExtra(EXTRA_FIRST_RUN, isFirstRun());
-        intent.putExtra(EXTRA_HAS_MULTIPLE_USERS, hasMultipleUsers());
-        intent.putExtra(EXTRA_USE_IMMERSIVE, true);
-        startActivity(intent);
-    }
-
-    protected void startFirstRunActivityForResult(Intent intent, int requestCode) {
-        if (LOGV) {
-            Log.v(TAG, "startFirstRunActivityForResult requestCode=" + requestCode);
-        }
-        intent.putExtra(EXTRA_FIRST_RUN, isFirstRun());
-        intent.putExtra(EXTRA_HAS_MULTIPLE_USERS, hasMultipleUsers());
-        intent.putExtra(EXTRA_USE_IMMERSIVE, true);
-        startActivityForResult(intent, requestCode);
-    }
-
-
-    protected boolean isFirstRun() {
-        return mIsFirstRun;
-    }
-
-    protected boolean isPrimaryUser() {
-        return mIsPrimaryUser;
-    }
-
-    public boolean hasMultipleUsers() {
-        return ((UserManager) getSystemService(USER_SERVICE)).getUsers().size() > 1;
-    }
-
-    protected void logActivityState(String prefix) {
-        Log.v(TAG, prefix + " isResumed=" + isResumed() + " isFinishing=" +
-                isFinishing() + " isDestroyed=" + isDestroyed());
-    }
-
-    protected static String getRequestName(int requestCode) {
-        StringBuilder sb = new StringBuilder();
-        switch (requestCode) {
-            case NEXT_REQUEST:
-                sb.append("NEXT_REQUEST");
-                break;
-            case EMERGENCY_DIAL_ACTIVITY_REQUEST:
-                sb.append("EMERGENCY_DIAL_ACTIVITY_REQUEST");
-                break;
-            case WIFI_ACTIVITY_REQUEST:
-                sb.append("WIFI_ACTIVITY_REQUEST");
-                break;
-            case BLUETOOTH_ACTIVITY_REQUEST:
-                sb.append("BLUETOOTH_ACTIVITY_REQUEST");
-                break;
-            case FINGERPRINT_ACTIVITY_REQUEST:
-                sb.append("FINGERPRINT_ACTIVITY_REQUEST");
-                break;
-            case SCREENLOCK_ACTIVITY_REQUEST:
-                sb.append("SCREENLOCK_ACTIVITY_REQUEST");
-                break;
-        }
-        sb.append("(").append(requestCode).append(")");
-        return sb.toString();
-    }
-
-    protected static String getResultName(int requestCode, int resultCode) {
-        StringBuilder sb = new StringBuilder();
-        switch (requestCode) {
-            case WIFI_ACTIVITY_REQUEST:
-                switch (resultCode) {
-                    case RESULT_OK:
-                        sb.append("RESULT_OK");
-                        break;
-                    case RESULT_CANCELED:
-                        sb.append("RESULT_CANCELED");
-                        break;
-                    case RESULT_SKIP:
-                        sb.append("RESULT_WIFI_SKIP");
-                        break;
-                    default:
-                        break;
-                }
-            case BLUETOOTH_ACTIVITY_REQUEST:
-                switch (resultCode) {
-                    case RESULT_OK:
-                        sb.append("RESULT_OK");
-                        break;
-                    case RESULT_CANCELED:
-                        sb.append("RESULT_CANCELED");
-                        break;
-                    case RESULT_SKIP:
-                        sb.append("RESULT_BLUETOOTH_SKIP");
-                        break;
-                    default:
-                        break;
-                }
-            case FINGERPRINT_ACTIVITY_REQUEST:
-                switch (resultCode) {
-                    case RESULT_OK:
-                        sb.append("RESULT_OK");
-                        break;
-                    case RESULT_CANCELED:
-                        sb.append("RESULT_CANCELED");
-                        break;
-                    case RESULT_SKIP:
-                        sb.append("RESULT_FINGERPRINT_SKIP");
-                        break;
-                    default:
-                        break;
-                }
-            case SCREENLOCK_ACTIVITY_REQUEST:
-                switch (resultCode) {
-                    case RESULT_OK:
-                        sb.append("RESULT_OK");
-                        break;
-                    case RESULT_CANCELED:
-                        sb.append("RESULT_CANCELED");
-                        break;
-                    case RESULT_SKIP:
-                        sb.append("RESULT_SCREENLOCK_SKIP");
-                        break;
-                    default:
-                        break;
-                }
-            default:
-                switch (resultCode) {
-                    case RESULT_OK:
-                        sb.append("RESULT_OK");
-                        break;
-                    case RESULT_CANCELED:
-                        sb.append("RESULT_CANCELED");
-                        break;
-                    case RESULT_SKIP:
-                        sb.append("RESULT_SKIP");
-                        break;
-                    case RESULT_RETRY:
-                        sb.append("RESULT_RETRY");
-                        break;
-                    case RESULT_ACTIVITY_NOT_FOUND:
-                        sb.append("RESULT_ACTIVITY_NOT_FOUND");
-                        break;
-                }
-                break;
-        }
-        sb.append("(").append(resultCode).append(")");
-        return sb.toString();
-    }
-
-    private void initLayout() {
-        if (getLayoutResId() != -1) {
-            setContentView(getLayoutResId());
-        }
-        if (getTitleResId() != -1) {
-            TextView title = (TextView) findViewById(android.R.id.title);
-            title.setText(getTitleResId());
-        }
-        if (getIconResId() != -1) {
-            ImageView icon = (ImageView) findViewById(R.id.header_icon);
-            icon.setImageResource(getIconResId());
-            icon.setVisibility(View.VISIBLE);
-        }
-    }
-
-    protected int getLayoutResId() {
-        return -1;
-    }
-
-    protected int getTitleResId() {
-        return -1;
-    }
-
-    protected int getIconResId() {
-        return -1;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/BluetoothSetupActivity.java b/src/com/cyanogenmod/setupwizard/BluetoothSetupActivity.java
deleted file mode 100644
index a8b8d88..0000000
--- a/src/com/cyanogenmod/setupwizard/BluetoothSetupActivity.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_BLUETOOTH;
-
-import android.content.Intent;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-public class BluetoothSetupActivity extends SubBaseActivity {
-
-    public static final String TAG = BluetoothSetupActivity.class.getSimpleName();
-
-    private static final String ACTION_CONNECT_INPUT =
-            "com.google.android.intent.action.CONNECT_INPUT";
-
-    private static final String INTENT_EXTRA_NO_INPUT_MODE = "no_input_mode";
-
-    @Override
-    protected void onStartSubactivity() {
-        try {
-            Intent intent = new Intent();
-            intent.setComponent(SetupWizardUtils.mTvAddAccessorySettingsActivity);
-            intent.setAction(ACTION_CONNECT_INPUT);
-            intent.putExtra(INTENT_EXTRA_NO_INPUT_MODE, true);
-            startActivityForResult(intent, REQUEST_CODE_SETUP_BLUETOOTH);
-        } catch (Exception e) {
-            Log.e(TAG, "Error starting bluetooth setup", e);
-            nextAction(RESULT_OK);
-            SetupWizardUtils.disableComponent(this, BluetoothSetupActivity.class);
-            finish();
-        }
-    }
-
-    @Override
-    protected int getSubactivityNextTransition() {
-        nextAction(RESULT_OK);
-        return TRANSITION_ID_SLIDE;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/CaptivePortalSetupActivity.java b/src/com/cyanogenmod/setupwizard/CaptivePortalSetupActivity.java
deleted file mode 100644
index 1b7cc07..0000000
--- a/src/com/cyanogenmod/setupwizard/CaptivePortalSetupActivity.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_CAPTIVE_PORTAL;
-
-import android.content.Context;
-import android.content.Intent;
-import android.net.CaptivePortal;
-import android.net.ConnectivityManager;
-import android.net.ICaptivePortal;
-import android.os.AsyncTask;
-import android.provider.Settings;
-import android.util.Log;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.Random;
-
-public class CaptivePortalSetupActivity extends SubBaseActivity {
-
-    public static final String TAG = CaptivePortalSetupActivity.class.getSimpleName();
-
-    private static final String DEFAULT_SERVER = "clients3.google.com";
-    private static final int CAPTIVE_PORTAL_SOCKET_TIMEOUT_MS = 10000;
-
-    private URL mCaptivePortalUrl;
-
-    @Override
-    protected void onStartSubactivity() {
-        String server = Settings.Global.getString(getContentResolver(), "captive_portal_server");
-        if (server == null) server = DEFAULT_SERVER;
-        try {
-            mCaptivePortalUrl = new URL("http://" + server + "/generate_204");
-        } catch (MalformedURLException e) {
-            Log.e(TAG, "Not a valid url" + e);
-        }
-        CheckForCaptivePortalTask
-                .checkForCaptivePortal(mCaptivePortalUrl, this, true);
-    }
-
-    @Override
-    protected int getSubactivityNextTransition() {
-        return TRANSITION_ID_FADE;
-    }
-
-    private static class CheckForCaptivePortalTask extends AsyncTask<Void, Void, Boolean> {
-
-        private final URL captivePortalUrl;
-        private final CaptivePortalSetupActivity captivePortalSetupActivity;
-        private static CheckForCaptivePortalTask sTask = null;
-        private String responseToken;
-
-        public CheckForCaptivePortalTask(URL captivePortalUrl,
-                CaptivePortalSetupActivity captivePortalSetupActivity) {
-            this.captivePortalUrl = captivePortalUrl;
-            this.captivePortalSetupActivity = captivePortalSetupActivity;
-        }
-
-        public static void checkForCaptivePortal(URL captivePortalUrl,
-                CaptivePortalSetupActivity captivePortalSetupActivity, boolean cancelAndRecreateIfRunning) {
-            if (sTask == null || sTask.getStatus() == Status.FINISHED) {
-                sTask = new CheckForCaptivePortalTask(captivePortalUrl, captivePortalSetupActivity);
-                sTask.execute();
-
-            } else if (cancelAndRecreateIfRunning) {
-                sTask.cancel(true);
-                sTask = new CheckForCaptivePortalTask(captivePortalUrl, captivePortalSetupActivity);
-                sTask.execute();
-            }
-        }
-
-        @Override
-        protected Boolean doInBackground(Void... params) {
-            if (captivePortalUrl == null) return false;
-            HttpURLConnection urlConnection = null;
-            try {
-                urlConnection = (HttpURLConnection) captivePortalUrl.openConnection();
-                urlConnection.setInstanceFollowRedirects(false);
-                urlConnection.setConnectTimeout(CAPTIVE_PORTAL_SOCKET_TIMEOUT_MS);
-                urlConnection.setReadTimeout(CAPTIVE_PORTAL_SOCKET_TIMEOUT_MS);
-                urlConnection.setUseCaches(false);
-                urlConnection.getInputStream();
-                // We got a valid response, but not from the real google
-                final int responseCode = urlConnection.getResponseCode();
-                if (responseCode == 408 || responseCode == 504) {
-                    // If we timeout here, we'll try and go through captive portal login
-                    return true;
-                }
-                return urlConnection.getResponseCode() != 204;
-            } catch (IOException e) {
-                Log.e(TAG, "Captive portal check - probably not a portal: exception "
-                        + e);
-                return false;
-            } finally {
-                if (urlConnection != null) {
-                    urlConnection.disconnect();
-                }
-            }
-        }
-
-        @Override
-        protected void onPostExecute(Boolean isPortal) {
-            if (isPortal) {
-                final Context context = captivePortalSetupActivity.getApplicationContext();
-                responseToken = String.valueOf(new Random().nextLong());
-                final Intent intent = new Intent(
-                        ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
-                intent.putExtra(Intent.EXTRA_TEXT, responseToken);
-                intent.putExtra(ConnectivityManager.EXTRA_NETWORK,
-                        ConnectivityManager.from(context)
-                                .getNetworkForType(ConnectivityManager.TYPE_WIFI));
-                intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL,
-                        new CaptivePortal(new ICaptivePortal.Stub() {
-                            @Override
-                            public void appResponse(int response) {}
-                        }));
-                intent.putExtra("status_bar_color",
-                        context.getResources().getColor(R.color.primary_dark));
-                intent.putExtra("action_bar_color", context.getResources().getColor(
-                        R.color.primary_dark));
-                intent.putExtra("progress_bar_color", context.getResources().getColor(
-                        R.color.accent));
-                captivePortalSetupActivity.startSubactivity(intent, REQUEST_CODE_SETUP_CAPTIVE_PORTAL);
-            } else {
-                captivePortalSetupActivity.finishAction(RESULT_OK);
-                captivePortalSetupActivity.finish();
-            }
-        }
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/ChooseDataSimActivity.java b/src/com/cyanogenmod/setupwizard/ChooseDataSimActivity.java
deleted file mode 100644
index 725ade9..0000000
--- a/src/com/cyanogenmod/setupwizard/ChooseDataSimActivity.java
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.os.Bundle;
-import android.os.Handler;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.Log;
-import android.util.SparseArray;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.AnimationUtils;
-import android.widget.CheckBox;
-import android.widget.ImageView;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-
-import com.cyanogenmod.setupwizard.util.PhoneMonitor;
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-import java.util.List;
-
-public class ChooseDataSimActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = ChooseDataSimActivity.class.getSimpleName();
-
-    private ViewGroup mPageView;
-    private ProgressBar mProgressBar;
-    private SparseArray<TextView> mNameViews;
-    private SparseArray<ImageView> mSignalViews;
-    private SparseArray<CheckBox> mCheckBoxes;
-    private SparseArray<View> mRows;
-
-    private SparseArray<SubscriptionInfo> mSubInfoRecords;
-    private SparseArray<SignalStrength> mSignalStrengths;
-    private SparseArray<ServiceState> mServiceStates;
-
-    private boolean mIsAttached = false;
-    private boolean mRadioReady = false;
-
-    private PhoneMonitor mPhoneMonitor;
-
-    private boolean mDisabledForSwitch = false;
-
-    private final Handler mHandler = new Handler();
-
-    private final Runnable mRadioReadyRunnable = new Runnable() {
-        @Override
-        public void run() {
-            // If we timeout out waiting for the radio, Oh well.
-            if (!mRadioReady) {
-                mRadioReady = true;
-                checkForRadioReady();
-            }
-        }
-    };
-
-    private View.OnClickListener mSetDataSimClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            SubscriptionInfo subInfoRecord = (SubscriptionInfo)view.getTag();
-            if (subInfoRecord != null) {
-                changeDataSub(subInfoRecord);
-            }
-        }
-    };
-
-    private PhoneMonitor.SubscriptionStateListener mSubscriptionStateListener =
-            new PhoneMonitor.SubscriptionStateListener() {
-                @Override
-                public void onServiceStateChanged(int subId, ServiceState serviceState) {
-                    if (LOGV) {
-                        Log.v(TAG, "onServiceStateChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", serviceState=" + serviceState.toString() +
-                                '}');
-                    }
-                    SubscriptionInfo subInfoRecord =
-                            mPhoneMonitor.getActiveSubscriptionInfo(subId);
-                    mRadioReady = SetupWizardUtils.isRadioReady(
-                            ChooseDataSimActivity.this, serviceState);
-                    checkForRadioReady();
-                    mServiceStates.put(subInfoRecord.getSimSlotIndex(), serviceState);
-                    updateSignalStrength(subInfoRecord);
-                }
-
-                @Override
-                public void onDataConnectionStateChanged(int subId, int state, int networkType) {
-                    if (LOGV) {
-                        Log.v(TAG, "onDataConnectionStateChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", state=" + state +
-                                '}');
-                    }
-                    onDefaultDataSubscriptionChanged(subId);
-                }
-
-                @Override
-                public void onDefaultDataSubscriptionChanged(int subId) {
-                    if (LOGV) {
-                        Log.v(TAG, "onDefaultDataSubscriptionChanged{" +
-                                "subId='" + subId + '\'' +
-                                '}');
-                    }
-                    final int currentDataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
-                    if (currentDataSubId != subId) {
-                        updateCurrentDataSub();
-                        hideProgress();
-                        enableViews(true);
-                    }
-                    checkSimChangingState(currentDataSubId, subId);
-                }
-
-                @Override
-                public void onDefaultDataSubscriptionChangeRequested(int currentSubId,
-                        int newSubId) {
-                    if (LOGV) {
-                        Log.v(TAG, "onDefaultDataSubscriptionChangeRequested{" +
-                                "currentSubId='" + currentSubId + '\'' +
-                                ", newSubId=" + newSubId +
-                                '}');
-                    }
-                    checkSimChangingState(currentSubId, newSubId);
-                }
-
-                @Override
-                public void onSignalStrengthsChanged(int subId, SignalStrength signalStrength) {
-                    if (LOGV) {
-                        Log.v(TAG, "onSignalStrengthsChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", signalStrength=" + signalStrength.toString() +
-                                '}');
-                    }
-                    SubscriptionInfo subInfoRecord =
-                            mPhoneMonitor.getActiveSubscriptionInfo(subId);
-                    mSignalStrengths.put(subInfoRecord.getSimSlotIndex(), signalStrength);
-                    updateSignalStrength(subInfoRecord);
-                }
-
-                @Override
-                public void onSimStateChanged(int subId, int simState) {
-                    if (LOGV) {
-                        Log.v(TAG, "onSimStateChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", simState=" + simState +
-                                '}');
-                    }
-                    updateSignalStrengths();
-                    updateCurrentDataSub();
-                }
-            };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setNextText(R.string.next);
-        mPhoneMonitor = PhoneMonitor.getInstance();
-        mPageView = (ViewGroup) findViewById(R.id.page_view);
-        mProgressBar = (ProgressBar) findViewById(R.id.progress);
-        List<SubscriptionInfo> subInfoRecords = mPhoneMonitor.getActiveSubscriptionInfoList();
-        int simCount =
-                subInfoRecords != null ? subInfoRecords.size() : 0;
-        mSubInfoRecords = new SparseArray<>(simCount);
-        for (SubscriptionInfo subInfoRecord : subInfoRecords) {
-            mSubInfoRecords.put(subInfoRecord.getSimSlotIndex(), subInfoRecord);
-            updateSignalStrength(subInfoRecord);
-        }
-        mNameViews = new SparseArray<>(simCount);
-        mSignalViews = new SparseArray<>(simCount);
-        mCheckBoxes = new SparseArray<>(simCount);
-        mRows = new SparseArray<>(simCount);
-        mServiceStates = new SparseArray<>(simCount);
-        mSignalStrengths = new SparseArray<>(simCount);
-        LayoutInflater inflater = LayoutInflater.from(this);
-        for (int i = 0; i < simCount; i++) {
-            View simRow = inflater.inflate(R.layout.data_sim_row, null);
-            mPageView.addView(simRow);
-            SubscriptionInfo subInfoRecord = mSubInfoRecords.valueAt(i);
-            simRow.setTag(subInfoRecord);
-            simRow.setOnClickListener(mSetDataSimClickListener);
-            int slot = subInfoRecord.getSimSlotIndex();
-            mNameViews.put(slot, (TextView) simRow.findViewById(R.id.sim_title));
-            mSignalViews.put(slot, (ImageView) simRow.findViewById(R.id.signal));
-            mCheckBoxes.put(slot, (CheckBox) simRow.findViewById(R.id.enable_check));
-            mRows.put(slot, simRow);
-            mPageView.addView(inflater.inflate(R.layout.divider, null));
-        }
-        updateSignalStrengths();
-        updateCurrentDataSub();
-
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mIsAttached = false;
-        mPhoneMonitor.removeListener(mSubscriptionStateListener);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mIsAttached = true;
-        mPhoneMonitor.addListener(mSubscriptionStateListener);
-        mRadioReady = SetupWizardUtils.isRadioReady(this, null);
-        updateSignalStrengths();
-        updateCurrentDataSub();
-        checkForRadioReady();
-        if (mRadioReady) {
-            final int currentDataSub = SubscriptionManager.getDefaultDataSubscriptionId();
-            checkSimChangingState(currentDataSub, currentDataSub);
-        }
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    private void checkForRadioReady() {
-        if (mRadioReady) {
-            mHandler.removeCallbacks(mRadioReadyRunnable);
-            showPage();
-            final int currentDataSub = SubscriptionManager.getDefaultDataSubscriptionId();
-            checkSimChangingState(currentDataSub, currentDataSub);
-            return;
-        } else {
-            enableViews(false);
-            showProgress();
-            if (!mHandler.hasCallbacks(mRadioReadyRunnable)) {
-                mHandler.postDelayed(mRadioReadyRunnable, SetupWizardApp.RADIO_READY_TIMEOUT);
-            }
-        }
-    }
-
-    private void showPage() {
-        mPageView.setVisibility(View.VISIBLE);
-        if (!mPageView.isShown()) {
-            mPageView.startAnimation(
-                    AnimationUtils.loadAnimation(this, R.anim.translucent_enter));
-        }
-    }
-
-    private void showProgress() {
-        if (!mProgressBar.isShown()) {
-            mProgressBar.setVisibility(View.VISIBLE);
-            mProgressBar.startAnimation(
-                    AnimationUtils.loadAnimation(this, R.anim.translucent_enter));
-        }
-    }
-
-    private void hideProgress() {
-        if (mProgressBar.isShown()) {
-            mProgressBar.startAnimation(
-                    AnimationUtils.loadAnimation(this, R.anim.translucent_exit));
-            mProgressBar.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    private void updateSignalStrengths() {
-        if (mIsAttached) {
-            for (int i = 0; i < mSubInfoRecords.size(); i++) {
-                updateSignalStrength(mSubInfoRecords.valueAt(i));
-            }
-        }
-    }
-
-    private void changeDataSub(SubscriptionInfo subInfoRecord) {
-        final int currentDataSub = SubscriptionManager.getDefaultDataSubscriptionId();
-        final int requestedDataSub = subInfoRecord.getSubscriptionId();
-        if (LOGV) {
-            Log.v(TAG, "changeDataSub{" +
-                    "currentDataSub='" + currentDataSub + '\'' +
-                    ", requestedDataSub=" + requestedDataSub +
-                    '}');
-        }
-        if (currentDataSub != requestedDataSub) {
-            mPhoneMonitor.changeDataSub(requestedDataSub);
-            setDataSubChecked(subInfoRecord);
-            checkSimChangingState(currentDataSub, requestedDataSub);
-        }
-    }
-
-    private void checkSimChangingState(int currentDataSubId, int changingToDataSubId) {
-        if (LOGV) {
-            Log.v(TAG, "checkSimChangingState{" +
-                    "currentDataSubId='" + currentDataSubId + '\'' +
-                    "changingToDataSubId='" + changingToDataSubId + '\'' +
-                    "mIsAttached='" + mIsAttached + '\'' +
-                    ", mRadioReady=" + mRadioReady +
-                    '}');
-        }
-        if (mIsAttached && mRadioReady) {
-            if (currentDataSubId != changingToDataSubId) {
-                showProgress();
-                enableViews(false);
-            } else {
-                hideProgress();
-                enableViews(true);
-            }
-        }
-    }
-
-    private void setDataSubChecked(SubscriptionInfo subInfoRecord) {
-        if (mIsAttached) {
-            for (int i = 0; i < mCheckBoxes.size(); i++) {
-                int key = mCheckBoxes.keyAt(i);
-                if (subInfoRecord.getSimSlotIndex() == key) {
-                    mCheckBoxes.get(key).setChecked(true);
-                } else {
-                    mCheckBoxes.get(key).setChecked(false);
-                }
-            }
-        }
-    }
-
-    private void updateCurrentDataSub() {
-        if (mIsAttached) {
-            for (int i = 0; i < mSubInfoRecords.size(); i++) {
-                SubscriptionInfo subInfoRecord = mSubInfoRecords.valueAt(i);
-                int slot = subInfoRecord.getSimSlotIndex();
-                mCheckBoxes.get(slot).setChecked(SubscriptionManager.getDefaultDataSubscriptionId()
-                        == subInfoRecord.getSubscriptionId());
-                if (LOGV) {
-                    Log.v(TAG, "updateCurrentDataSub{" +
-                            "currentDataSubId='" + SubscriptionManager
-                            .getDefaultDataSubscriptionId() + '\'' +
-                            "subInfoRecord.getSubscriptionId()='" +
-                            subInfoRecord.getSubscriptionId() +
-                            '}');
-                }
-            }
-        }
-    }
-
-    private void enableViews(boolean enabled) {
-        mDisabledForSwitch = !enabled;
-        enableRows(enabled);
-        setNextAllowed(enabled);
-    }
-
-    private void enableRows(boolean enabled) {
-        for (int i = 0; i < mRows.size(); i++) {
-            final View v =  mRows.get(mRows.keyAt(i));
-            v.setEnabled(enabled);
-            final SubscriptionInfo subInfoRecord = (SubscriptionInfo)v.getTag();
-            if (subInfoRecord != null) {
-                updateCarrierText(subInfoRecord);
-            }
-        }
-    }
-
-    private void updateCarrierText(SubscriptionInfo subInfoRecord) {
-        if (mIsAttached) {
-            String name = mPhoneMonitor.getSimOperatorName(subInfoRecord.getSubscriptionId());
-            if (TextUtils.isEmpty(name)) {
-                name = mPhoneMonitor.getNetworkOperatorName(subInfoRecord.getSubscriptionId());
-            }
-            ServiceState serviceState = mServiceStates.get(subInfoRecord.getSimSlotIndex());
-            final int slot = subInfoRecord.getSimSlotIndex();
-            final View v = mRows.get(slot);
-            if (TextUtils.isEmpty(name)) {
-                if (serviceState != null && serviceState.isEmergencyOnly()) {
-                    name = getString(R.string.setup_mobile_data_emergency_only);
-                } else {
-                    name = getString(R.string.setup_mobile_data_no_service);
-                }
-                if (v != null) {
-                    v.setEnabled(false);
-                }
-            } else {
-                if (v != null && !mDisabledForSwitch) {
-                    v.setEnabled(true);
-                }
-            }
-            String formattedName =
-                    getString(R.string.data_sim_name,
-                            slot + 1, name);
-            mNameViews.get(slot).setText(formattedName);
-        }
-    }
-
-    private void updateSignalStrength(SubscriptionInfo subInfoRecord) {
-        if (mIsAttached) {
-            ImageView signalView = mSignalViews.get(subInfoRecord.getSimSlotIndex());
-            SignalStrength signalStrength = mSignalStrengths.get(subInfoRecord.getSimSlotIndex());
-            if (LOGV) {
-                Log.v(TAG, "updateSignalStrength{" +
-                        "signalStrength='" + signalStrength + '\'' +
-                        "signalStrengthLevel='" + ((signalStrength != null) ?
-                        signalStrength.getLevel() : "null") + '\'' +
-                        ", subInfoRecord.getSimSlotIndex() =" + subInfoRecord.getSimSlotIndex()  +
-                        '}');
-            }
-            if (!hasService(subInfoRecord)) {
-                signalView.setImageResource(R.drawable.ic_signal_no_signal);
-            } else {
-                if (signalStrength != null) {
-                    int resId;
-                    switch (signalStrength.getLevel()) {
-                        case 4:
-                            resId = R.drawable.ic_signal_4;
-                            break;
-                        case 3:
-                            resId = R.drawable.ic_signal_3;
-                            break;
-                        case 2:
-                            resId = R.drawable.ic_signal_2;
-                            break;
-                        case 1:
-                            resId = R.drawable.ic_signal_1;
-                            break;
-                        default:
-                            resId = R.drawable.ic_signal_0;
-                            break;
-                    }
-                    signalView.setImageResource(resId);
-                }
-            }
-            updateCarrierText(subInfoRecord);
-        }
-    }
-
-    private boolean hasService(SubscriptionInfo subInfoRecord) {
-        boolean retVal;
-        ServiceState serviceState = mServiceStates.get(subInfoRecord.getSimSlotIndex());
-        if (serviceState == null) {
-            serviceState  = mPhoneMonitor
-                    .getServiceStateForSubscriber(subInfoRecord.getSubscriptionId());
-            mServiceStates.put(subInfoRecord.getSimSlotIndex(), serviceState);
-        }
-        if (serviceState != null) {
-            if (LOGV) {
-                Log.v(TAG, "hasService{" +
-                        "serviceState.getVoiceRegState()='" + serviceState.getVoiceRegState() + '\'' +
-                        "serviceState.getVoiceRegState()='" + serviceState.getVoiceRegState() + '\'' +
-                        ", subInfoRecord.getSimSlotIndex() =" + subInfoRecord.getSimSlotIndex()  +
-                        '}');
-            }
-            // Consider the device to be in service if either voice or data service is available.
-            // Some SIM cards are marketed as data-only and do not support voice service, and on
-            // these SIM cards, we want to show signal bars for data service as well as the "no
-            // service" or "emergency calls only" text that indicates that voice is not available.
-            switch(serviceState.getVoiceRegState()) {
-                case ServiceState.STATE_POWER_OFF:
-                    retVal = false;
-                    break;
-                case ServiceState.STATE_OUT_OF_SERVICE:
-                case ServiceState.STATE_EMERGENCY_ONLY:
-                    retVal = serviceState.getDataRegState() == ServiceState.STATE_IN_SERVICE;
-                    break;
-                default:
-                    retVal = true;
-            }
-        } else {
-            retVal = false;
-        }
-        return retVal;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.choose_data_sim_page;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_choose_data_sim;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_sim;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/DateTimeActivity.java b/src/com/cyanogenmod/setupwizard/DateTimeActivity.java
deleted file mode 100644
index c9f65b4..0000000
--- a/src/com/cyanogenmod/setupwizard/DateTimeActivity.java
+++ /dev/null
@@ -1,444 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import android.app.AlarmManager;
-import android.app.DatePickerDialog;
-import android.app.Dialog;
-import android.app.DialogFragment;
-import android.app.TimePickerDialog;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.res.XmlResourceParser;
-import android.os.Bundle;
-import android.os.Handler;
-import android.text.format.DateFormat;
-import android.util.Log;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.DatePicker;
-import android.widget.ImageView;
-import android.widget.SimpleAdapter;
-import android.widget.Spinner;
-import android.widget.TextView;
-import android.widget.TimePicker;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.TimeZone;
-
-public class DateTimeActivity extends BaseSetupWizardActivity implements
-        TimePickerDialog.OnTimeSetListener, DatePickerDialog.OnDateSetListener {
-
-    public static final String TAG = DateTimeActivity.class.getSimpleName();
-
-    private static final String KEY_ID = "id";  // value: String
-    private static final String KEY_DISPLAYNAME = "name";  // value: String
-    private static final String KEY_GMT = "gmt";  // value: String
-    private static final String KEY_OFFSET = "offset";  // value: int (Integer)
-    private static final String XMLTAG_TIMEZONE = "timezone";
-
-    private static final int HOURS_1 = 60 * 60000;
-
-    private TimeZone mCurrentTimeZone;
-    private View mDateView;
-    private View mTimeView;
-    private TextView mDateTextView;
-    private TextView mTimeTextView;
-
-
-    private final Handler mHandler = new Handler();
-
-    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-                updateTimeAndDateDisplay();
-        }
-    };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setNextText(R.string.next);
-
-        final Spinner spinner = (Spinner) findViewById(R.id.timezone_list);
-        final SimpleAdapter adapter = constructTimezoneAdapter(this, false);
-        mCurrentTimeZone = TimeZone.getDefault();
-        mDateView = findViewById(R.id.date_item);
-        mDateView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                showDatePicker();
-            }
-        });
-        mTimeView = findViewById(R.id.time_item);
-        mTimeView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                showTimePicker();
-            }
-        });
-        mDateTextView = (TextView)findViewById(R.id.date_text);
-        mTimeTextView = (TextView)findViewById(R.id.time_text);
-        // Pre-select current/default timezone
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                int tzIndex = getTimeZoneIndex(adapter, mCurrentTimeZone);
-                spinner.setAdapter(adapter);
-                if (tzIndex != -1) {
-                    spinner.setSelection(tzIndex);
-                }
-                spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-                    @Override
-                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long id) {
-                        final Map<?, ?> map = (Map<?, ?>) adapterView.getItemAtPosition(position);
-                        final String tzId = (String) map.get(KEY_ID);
-                        if (mCurrentTimeZone != null && !mCurrentTimeZone.getID().equals(tzId)) {
-                            // Update the system timezone value
-                            final AlarmManager alarm = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
-                            alarm.setTimeZone(tzId);
-                            mCurrentTimeZone = TimeZone.getTimeZone(tzId);
-                        }
-
-                    }
-
-                    @Override
-                    public void onNothingSelected(AdapterView<?> adapterView) {
-                    }
-                });
-            }
-        });
-        // Pre-select current/default date if epoch
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                final Calendar calendar = Calendar.getInstance();
-                final boolean isEpoch = calendar.get(Calendar.YEAR) == 1970;
-                if (isEpoch) {
-                    // If epoch, set date to build date
-                    long timestamp = SetupWizardUtils.getBuildDateTimestamp();
-                    if (timestamp > 0) {
-                        calendar.setTimeInMillis(timestamp * 1000);
-                        setDate(DateTimeActivity.this, calendar.get(Calendar.YEAR),
-                                calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
-                    } else {
-                        // no build date available, use a sane default
-                        setDate(DateTimeActivity.this, 2017, Calendar.JANUARY, 1);
-                    }
-                }
-            }
-        });
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        // Register for time ticks and other reasons for time change
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(Intent.ACTION_TIME_TICK);
-        filter.addAction(Intent.ACTION_TIME_CHANGED);
-        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
-        registerReceiver(mIntentReceiver, filter, null, null);
-
-        updateTimeAndDateDisplay();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        unregisterReceiver(mIntentReceiver);
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.setup_datetime_page;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_datetime;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_datetime;
-    }
-
-    @Override
-    public void onDateSet(DatePicker view, int year, int month, int day) {
-            setDate(this, year, month, day);
-            updateTimeAndDateDisplay();
-    }
-
-    @Override
-    public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
-            setTime(this, hourOfDay, minute);
-            updateTimeAndDateDisplay();
-    }
-
-    private void showDatePicker() {
-        DatePickerFragment datePickerFragment = DatePickerFragment.newInstance();
-        datePickerFragment.show(getFragmentManager(), DatePickerFragment.TAG);
-    }
-
-    private void showTimePicker() {
-        TimePickerFragment timePickerFragment = TimePickerFragment.newInstance();
-        timePickerFragment.show(getFragmentManager(), TimePickerFragment.TAG);
-    }
-
-    private void updateTimeAndDateDisplay() {
-        java.text.DateFormat shortDateFormat = DateFormat.getDateFormat(this);
-        final Calendar now = Calendar.getInstance();
-        mTimeTextView.setText(DateFormat.getTimeFormat(this).format(now.getTime()));
-        mDateTextView.setText(shortDateFormat.format(now.getTime()));
-    }
-
-    private static SimpleAdapter constructTimezoneAdapter(Context context,
-            boolean sortedByName) {
-        final String[] from = new String[] {KEY_DISPLAYNAME, KEY_GMT};
-        final int[] to = new int[] {android.R.id.text1, android.R.id.text2};
-
-        final String sortKey = (sortedByName ? KEY_DISPLAYNAME : KEY_OFFSET);
-        final TimeZoneComparator comparator = new TimeZoneComparator(sortKey);
-        final List<HashMap<String, Object>> sortedList = getZones(context);
-        Collections.sort(sortedList, comparator);
-        final SimpleAdapter adapter = new SimpleAdapter(context,
-                sortedList,
-                R.layout.date_time_setup_custom_list_item_2,
-                from,
-                to);
-
-        return adapter;
-    }
-
-    private static List<HashMap<String, Object>> getZones(Context context) {
-        final List<HashMap<String, Object>> myData = new ArrayList();
-        final long date = Calendar.getInstance().getTimeInMillis();
-        try {
-            XmlResourceParser xrp = context.getResources().getXml(R.xml.timezones);
-            while (xrp.next() != XmlResourceParser.START_TAG)
-                continue;
-            xrp.next();
-            while (xrp.getEventType() != XmlResourceParser.END_TAG) {
-                while (xrp.getEventType() != XmlResourceParser.START_TAG) {
-                    if (xrp.getEventType() == XmlResourceParser.END_DOCUMENT) {
-                        return myData;
-                    }
-                    xrp.next();
-                }
-                if (xrp.getName().equals(XMLTAG_TIMEZONE)) {
-                    String id = xrp.getAttributeValue(0);
-                    String displayName = xrp.nextText();
-                    addItem(myData, id, displayName, date);
-                }
-                while (xrp.getEventType() != XmlResourceParser.END_TAG) {
-                    xrp.next();
-                }
-                xrp.next();
-            }
-            xrp.close();
-        } catch (XmlPullParserException xppe) {
-            Log.e(TAG, "Ill-formatted timezones.xml file");
-        } catch (java.io.IOException ioe) {
-            Log.e(TAG, "Unable to read timezones.xml file");
-        }
-
-        return myData;
-    }
-
-    private static void addItem(
-            List<HashMap<String, Object>> myData, String id, String displayName, long date) {
-        final HashMap<String, Object> map = new HashMap();
-        map.put(KEY_ID, id);
-        map.put(KEY_DISPLAYNAME, displayName);
-        final TimeZone tz = TimeZone.getTimeZone(id);
-        final int offset = tz.getOffset(date);
-        final int p = Math.abs(offset);
-        final StringBuilder name = new StringBuilder();
-        name.append("GMT");
-
-        if (offset < 0) {
-            name.append('-');
-        } else {
-            name.append('+');
-        }
-
-        name.append(p / (HOURS_1));
-        name.append(':');
-
-        int min = p / 60000;
-        min %= 60;
-
-        if (min < 10) {
-            name.append('0');
-        }
-        name.append(min);
-
-        map.put(KEY_GMT, name.toString());
-        map.put(KEY_OFFSET, offset);
-
-        myData.add(map);
-    }
-
-    private static int getTimeZoneIndex(SimpleAdapter adapter, TimeZone tz) {
-        final String defaultId = tz.getID();
-        final int listSize = adapter.getCount();
-        for (int i = 0; i < listSize; i++) {
-            // Using HashMap<String, Object> induces unnecessary warning.
-            final HashMap<?,?> map = (HashMap<?,?>)adapter.getItem(i);
-            final String id = (String)map.get(KEY_ID);
-            if (defaultId.equals(id)) {
-                // If current timezone is in this list, move focus to it
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    private static void setDate(Context context, int year, int month, int day) {
-        Calendar c = Calendar.getInstance();
-
-        c.set(Calendar.YEAR, year);
-        c.set(Calendar.MONTH, month);
-        c.set(Calendar.DAY_OF_MONTH, day);
-        long when = c.getTimeInMillis();
-
-        if (when / 1000 < Integer.MAX_VALUE) {
-            ((AlarmManager) context.getSystemService(Context.ALARM_SERVICE)).setTime(when);
-        }
-    }
-
-    private static void setTime(Context context, int hourOfDay, int minute) {
-        Calendar c = Calendar.getInstance();
-
-        c.set(Calendar.HOUR_OF_DAY, hourOfDay);
-        c.set(Calendar.MINUTE, minute);
-        c.set(Calendar.SECOND, 0);
-        c.set(Calendar.MILLISECOND, 0);
-        long when = c.getTimeInMillis();
-
-        if (when / 1000 < Integer.MAX_VALUE) {
-            ((AlarmManager) context.getSystemService(Context.ALARM_SERVICE)).setTime(when);
-        }
-    }
-
-    private static class TimeZoneComparator implements Comparator<HashMap<?, ?>> {
-        private String mSortingKey;
-
-        public TimeZoneComparator(String sortingKey) {
-            mSortingKey = sortingKey;
-        }
-
-        public void setSortingKey(String sortingKey) {
-            mSortingKey = sortingKey;
-        }
-
-        public int compare(HashMap<?, ?> map1, HashMap<?, ?> map2) {
-            Object value1 = map1.get(mSortingKey);
-            Object value2 = map2.get(mSortingKey);
-
-            /*
-             * This should never happen, but just in-case, put non-comparable
-             * items at the end.
-             */
-            if (!isComparable(value1)) {
-                return isComparable(value2) ? 1 : 0;
-            } else if (!isComparable(value2)) {
-                return -1;
-            }
-
-            return ((Comparable) value1).compareTo(value2);
-        }
-
-        private boolean isComparable(Object value) {
-            return (value != null) && (value instanceof Comparable);
-        }
-    }
-
-    public static class TimePickerFragment extends DialogFragment
-            implements TimePickerDialog.OnTimeSetListener {
-
-        private static String TAG = TimePickerFragment.class.getSimpleName();
-
-        public static TimePickerFragment newInstance() {
-            TimePickerFragment frag = new TimePickerFragment();
-            return frag;
-        }
-
-        @Override
-        public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
-            ((DateTimeActivity)getActivity()).onTimeSet(view, hourOfDay, minute);
-        }
-
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            final Calendar calendar = Calendar.getInstance();
-            return new TimePickerDialog(
-                    getActivity(),
-                    this,
-                    calendar.get(Calendar.HOUR_OF_DAY),
-                    calendar.get(Calendar.MINUTE),
-                    DateFormat.is24HourFormat(getActivity()));
-        }
-
-    }
-
-    public static class DatePickerFragment extends DialogFragment
-            implements DatePickerDialog.OnDateSetListener {
-
-        private static String TAG = DatePickerFragment.class.getSimpleName();
-
-        public static DatePickerFragment newInstance() {
-            DatePickerFragment frag = new DatePickerFragment();
-            return frag;
-        }
-
-        @Override
-        public void onDateSet(DatePicker view, int year, int month, int day) {
-            ((DateTimeActivity)getActivity()).onDateSet(view, year, month, day);
-        }
-
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            final Calendar calendar = Calendar.getInstance();
-            return new DatePickerDialog(
-                    getActivity(),
-                    this,
-                    calendar.get(Calendar.YEAR),
-                    calendar.get(Calendar.MONTH),
-                    calendar.get(Calendar.DAY_OF_MONTH));
-        }
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/FingerprintActivity.java b/src/com/cyanogenmod/setupwizard/FingerprintActivity.java
deleted file mode 100644
index b7c678b..0000000
--- a/src/com/cyanogenmod/setupwizard/FingerprintActivity.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_SETUP_FINGERPRINT;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ALLOW_SKIP;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_AUTO_FINISH;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_DETAILS;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_FIRST_RUN;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_MATERIAL_LIGHT;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_THEME;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_TITLE;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_USE_IMMERSIVE;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_FINGERPRINT;
-
-import android.content.Intent;
-import android.view.View;
-
-public class FingerprintActivity extends SubBaseActivity {
-
-    public static final String TAG = FingerprintActivity.class.getSimpleName();
-
-    @Override
-    protected void onStartSubactivity() {
-        setNextAllowed(true);
-        findViewById(R.id.setup_fingerprint).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                launchFingerprintSetup();
-            }
-        });
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.setup_fingerprint;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.fingerprint_setup_title;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_fingerprint;
-    }
-
-    private void launchFingerprintSetup() {
-        Intent intent = new Intent(ACTION_SETUP_FINGERPRINT);
-        intent.putExtra(EXTRA_FIRST_RUN, true);
-        intent.putExtra(EXTRA_ALLOW_SKIP, true);
-        intent.putExtra(EXTRA_USE_IMMERSIVE, true);
-        intent.putExtra(EXTRA_THEME, EXTRA_MATERIAL_LIGHT);
-        intent.putExtra(EXTRA_AUTO_FINISH, false);
-            /*intent.putExtra(LockPatternUtils.LOCKSCREEN_FINGERPRINT_FALLBACK, true);*/
-        intent.putExtra(EXTRA_TITLE,
-                getString(R.string.settings_fingerprint_setup_title));
-        intent.putExtra(EXTRA_DETAILS,
-                getString(R.string.settings_fingerprint_setup_details));
-        startSubactivity(intent, REQUEST_CODE_SETUP_FINGERPRINT);
-    }
-
-    @Override
-    protected int getSubactivityNextTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/FinishActivity.java b/src/com/cyanogenmod/setupwizard/FinishActivity.java
deleted file mode 100644
index b2ae9a6..0000000
--- a/src/com/cyanogenmod/setupwizard/FinishActivity.java
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.DISABLE_NAV_KEYS;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_APPLY_DEFAULT_THEME;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_BUTTON_BACKLIGHT;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_PRIVACY_GUARD;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_SEND_METRICS;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.animation.Animator;
-import android.app.Activity;
-import android.app.WallpaperManager;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.ActivityInfo;
-import android.graphics.Bitmap;
-import android.graphics.Point;
-import android.os.Bundle;
-import android.os.Handler;
-import android.preference.PreferenceManager;
-import android.view.View;
-import android.view.ViewAnimationUtils;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.widget.ImageView;
-import android.widget.ProgressBar;
-
-import com.android.setupwizardlib.util.WizardManagerHelper;
-
-import com.cyanogenmod.setupwizard.util.EnableAccessibilityController;
-
-import lineageos.hardware.LineageHardwareManager;
-import lineageos.providers.LineageSettings;
-
-public class FinishActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = FinishActivity.class.getSimpleName();
-
-    private ImageView mReveal;
-
-    private EnableAccessibilityController mEnableAccessibilityController;
-
-    private SetupWizardApp mSetupWizardApp;
-
-    private final Handler mHandler = new Handler();
-
-    private volatile boolean mIsFinishing = false;
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (LOGV) {
-            logActivityState("onCreate savedInstanceState=" + savedInstanceState);
-        }
-        mSetupWizardApp = (SetupWizardApp) getApplication();
-        mReveal = (ImageView) findViewById(R.id.reveal);
-        mEnableAccessibilityController =
-                EnableAccessibilityController.getInstance(getApplicationContext());
-        setNextText(R.string.start);
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.finish_activity;
-    }
-
-    @Override
-    public void finish() {
-        super.finish();
-        overridePendingTransition(R.anim.translucent_enter, R.anim.translucent_exit);
-    }
-
-    @Override
-    public void onNavigateNext() {
-        applyForwardTransition(TRANSITION_ID_NONE);
-        startFinishSequence();
-    }
-
-    private void finishSetup() {
-        if (!mIsFinishing) {
-            mIsFinishing = true;
-            setupRevealImage();
-        }
-    }
-
-    private void startFinishSequence() {
-        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);
-        hideBackButton();
-        hideNextButton();
-        finishSetup();
-    }
-
-    private void setupRevealImage() {
-        final Point p = new Point();
-        getWindowManager().getDefaultDisplay().getRealSize(p);
-        final WallpaperManager wallpaperManager =
-                WallpaperManager.getInstance(this);
-        wallpaperManager.forgetLoadedWallpaper();
-        final Bitmap wallpaper = wallpaperManager.getBitmap();
-        Bitmap cropped = null;
-        if (wallpaper != null) {
-            cropped = Bitmap.createBitmap(wallpaper, 0,
-                    0, Math.min(p.x, wallpaper.getWidth()),
-                    Math.min(p.y, wallpaper.getHeight()));
-        }
-        if (cropped != null) {
-            mReveal.setScaleType(ImageView.ScaleType.CENTER_CROP);
-            mReveal.setImageBitmap(cropped);
-        } else {
-            mReveal.setBackground(wallpaperManager
-                    .getBuiltInDrawable(p.x, p.y, false, 0, 0));
-        }
-        animateOut();
-    }
-
-    private void animateOut() {
-        int cx = (mReveal.getLeft() + mReveal.getRight()) / 2;
-        int cy = (mReveal.getTop() + mReveal.getBottom()) / 2;
-        int finalRadius = Math.max(mReveal.getWidth(), mReveal.getHeight());
-        Animator anim =
-                ViewAnimationUtils.createCircularReveal(mReveal, cx, cy, 0, finalRadius);
-        anim.setDuration(900);
-        anim.addListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animation) {
-                mReveal.setVisibility(View.VISIBLE);
-            }
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                mHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        completeSetup();
-                    }
-                });
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animation) {}
-
-            @Override
-            public void onAnimationRepeat(Animator animation) {}
-        });
-        anim.start();
-    }
-
-    private void completeSetup() {
-        if (mEnableAccessibilityController != null) {
-            mEnableAccessibilityController.onDestroy();
-        }
-        handlePrivacyGuard(mSetupWizardApp);
-        handleEnableMetrics(mSetupWizardApp);
-        handleNavKeys(mSetupWizardApp);
-        final WallpaperManager wallpaperManager =
-                WallpaperManager.getInstance(mSetupWizardApp);
-        wallpaperManager.forgetLoadedWallpaper();
-        finishAllAppTasks();
-        Intent intent = WizardManagerHelper.getNextIntent(getIntent(),
-                Activity.RESULT_OK);
-        startActivityForResult(intent, NEXT_REQUEST);
-    }
-
-    private static void handleEnableMetrics(SetupWizardApp setupWizardApp) {
-        Bundle privacyData = setupWizardApp.getSettingsBundle();
-        if (privacyData != null
-                && privacyData.containsKey(KEY_SEND_METRICS)) {
-            LineageSettings.Secure.putInt(setupWizardApp.getContentResolver(),
-                    LineageSettings.Secure.STATS_COLLECTION, privacyData.getBoolean(KEY_SEND_METRICS)
-                            ? 1 : 0);
-        }
-    }
-
-    private static void handlePrivacyGuard(SetupWizardApp setupWizardApp) {
-        Bundle mPrivacyData = setupWizardApp.getSettingsBundle();
-        if (mPrivacyData != null && mPrivacyData.containsKey(KEY_PRIVACY_GUARD)) {
-            LineageSettings.Secure.putInt(setupWizardApp.getContentResolver(),
-                    LineageSettings.Secure.PRIVACY_GUARD_DEFAULT,
-                    mPrivacyData.getBoolean(KEY_PRIVACY_GUARD) ? 1 : 0);
-        }
-    }
-
-    private static void handleNavKeys(SetupWizardApp setupWizardApp) {
-        if (setupWizardApp.getSettingsBundle().containsKey(DISABLE_NAV_KEYS)) {
-            writeDisableNavkeysOption(setupWizardApp,
-                    setupWizardApp.getSettingsBundle().getBoolean(DISABLE_NAV_KEYS));
-        }
-    }
-
-    private static void writeDisableNavkeysOption(Context context, boolean enabled) {
-        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
-
-        LineageSettings.Global.putInt(context.getContentResolver(),
-                LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, enabled ? 1 : 0);
-        LineageHardwareManager hardware = LineageHardwareManager.getInstance(context);
-        hardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, enabled);
-
-        /* Save/restore button timeouts to disable them in softkey mode */
-        if (enabled) {
-            LineageSettings.Secure.putInt(context.getContentResolver(),
-                    LineageSettings.Secure.BUTTON_BRIGHTNESS, 0);
-        } else {
-            int currentBrightness = LineageSettings.Secure.getInt(context.getContentResolver(),
-                    LineageSettings.Secure.BUTTON_BRIGHTNESS, 100);
-            int oldBright = prefs.getInt(KEY_BUTTON_BACKLIGHT,
-                    currentBrightness);
-            LineageSettings.Secure.putInt(context.getContentResolver(),
-                    LineageSettings.Secure.BUTTON_BRIGHTNESS, oldBright);
-        }
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/LineageSettingsActivity.java b/src/com/cyanogenmod/setupwizard/LineageSettingsActivity.java
deleted file mode 100644
index 6ebdb77..0000000
--- a/src/com/cyanogenmod/setupwizard/LineageSettingsActivity.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.DISABLE_NAV_KEYS;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_APPLY_DEFAULT_THEME;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_PRIVACY_GUARD;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_SEND_METRICS;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.RemoteException;
-import android.text.Spannable;
-import android.text.SpannableString;
-import android.text.SpannableStringBuilder;
-import android.text.Spanned;
-import android.text.method.LinkMovementMethod;
-import android.text.style.ClickableSpan;
-import android.util.Log;
-import android.view.IWindowManager;
-import android.view.View;
-import android.view.WindowManagerGlobal;
-import android.widget.CheckBox;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.android.setupwizardlib.util.WizardManagerHelper;
-
-import com.cyanogenmod.setupwizard.R;
-
-import lineageos.hardware.LineageHardwareManager;
-import lineageos.providers.LineageSettings;
-
-public class LineageSettingsActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = LineageSettingsActivity.class.getSimpleName();
-
-    public static final String PRIVACY_POLICY_URI = "http://lineageos.org/legal";
-
-    private SetupWizardApp mSetupWizardApp;
-
-    private View mMetricsRow;
-    private View mNavKeysRow;
-    private View mPrivacyGuardRow;
-    private CheckBox mMetrics;
-    private CheckBox mNavKeys;
-    private CheckBox mPrivacyGuard;
-
-    private boolean mHideNavKeysRow = false;
-
-    private View.OnClickListener mMetricsClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            boolean checked = !mMetrics.isChecked();
-            mMetrics.setChecked(checked);
-            mSetupWizardApp.getSettingsBundle().putBoolean(KEY_SEND_METRICS, checked);
-        }
-    };
-
-    private View.OnClickListener mNavKeysClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            boolean checked = !mNavKeys.isChecked();
-            mNavKeys.setChecked(checked);
-            mSetupWizardApp.getSettingsBundle().putBoolean(DISABLE_NAV_KEYS, checked);
-        }
-    };
-
-    private View.OnClickListener mPrivacyGuardClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            boolean checked = !mPrivacyGuard.isChecked();
-            mPrivacyGuard.setChecked(checked);
-            mSetupWizardApp.getSettingsBundle().putBoolean(KEY_PRIVACY_GUARD, checked);
-        }
-    };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mSetupWizardApp = (SetupWizardApp) getApplication();
-        setNextText(R.string.next);
-        String privacy_policy = getString(R.string.services_privacy_policy);
-        String policySummary = getString(R.string.services_explanation, privacy_policy);
-        SpannableString ss = new SpannableString(policySummary);
-        ClickableSpan clickableSpan = new ClickableSpan() {
-            @Override
-            public void onClick(View textView) {
-                // At this point of the setup, the device has already been unlocked (if frp
-                // had been enabled), so there should be no issues regarding security
-                final Intent intent = new Intent(Intent.ACTION_VIEW,
-                        Uri.parse(PRIVACY_POLICY_URI));
-                try {
-                    startActivity(intent);
-                } catch (Exception e) {
-                    Log.e(TAG, "Unable to start activity " + intent.toString(), e);
-                }
-            }
-        };
-        ss.setSpan(clickableSpan,
-                policySummary.length() - privacy_policy.length() - 1,
-                policySummary.length() - 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-        TextView privacyPolicy = (TextView) findViewById(R.id.privacy_policy);
-        privacyPolicy.setMovementMethod(LinkMovementMethod.getInstance());
-        privacyPolicy.setText(ss);
-
-        mMetricsRow = findViewById(R.id.metrics);
-        mMetricsRow.setOnClickListener(mMetricsClickListener);
-        String metricsHelpImproveCM =
-                getString(R.string.services_help_improve_cm, getString(R.string.os_name));
-        String metricsSummary = getString(R.string.services_metrics_label,
-                metricsHelpImproveCM, getString(R.string.os_name));
-        final SpannableStringBuilder metricsSpan = new SpannableStringBuilder(metricsSummary);
-        metricsSpan.setSpan(new android.text.style.StyleSpan(android.graphics.Typeface.BOLD),
-                0, metricsHelpImproveCM.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
-        TextView metrics = (TextView) findViewById(R.id.enable_metrics_summary);
-        metrics.setText(metricsSpan);
-        mMetrics = (CheckBox) findViewById(R.id.enable_metrics_checkbox);
-
-        mNavKeysRow = findViewById(R.id.nav_keys);
-        mNavKeysRow.setOnClickListener(mNavKeysClickListener);
-        mNavKeys = (CheckBox) findViewById(R.id.nav_keys_checkbox);
-        boolean needsNavBar = true;
-        try {
-            IWindowManager windowManager = WindowManagerGlobal.getWindowManagerService();
-            needsNavBar = windowManager.needsNavigationBar();
-        } catch (RemoteException e) {
-        }
-        mHideNavKeysRow = hideKeyDisabler(this);
-        if (mHideNavKeysRow || needsNavBar) {
-            mNavKeysRow.setVisibility(View.GONE);
-        } else {
-            boolean navKeysDisabled = isKeyDisablerActive(this);
-            mNavKeys.setChecked(navKeysDisabled);
-        }
-
-        mPrivacyGuardRow = findViewById(R.id.privacy_guard);
-        mPrivacyGuardRow.setOnClickListener(mPrivacyGuardClickListener);
-        mPrivacyGuard = (CheckBox) findViewById(R.id.privacy_guard_checkbox);
-        mPrivacyGuard.setChecked(LineageSettings.Secure.getInt(getContentResolver(),
-                LineageSettings.Secure.PRIVACY_GUARD_DEFAULT, 0) == 1);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        updateDisableNavkeysOption();
-        updateMetricsOption();
-        updatePrivacyGuardOption();
-    }
-
-    @Override
-    public void onNavigateBack() {
-        onBackPressed();
-    }
-
-    @Override
-    public void onNavigateNext() {
-        Intent intent = WizardManagerHelper.getNextIntent(getIntent(), Activity.RESULT_OK);
-        startActivityForResult(intent, 1);
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.setup_lineage_settings;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_services;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_features;
-    }
-
-    private void updateMetricsOption() {
-        final Bundle myPageBundle = mSetupWizardApp.getSettingsBundle();
-        boolean metricsChecked =
-                !myPageBundle.containsKey(KEY_SEND_METRICS) || myPageBundle
-                        .getBoolean(KEY_SEND_METRICS);
-        mMetrics.setChecked(metricsChecked);
-        myPageBundle.putBoolean(KEY_SEND_METRICS, metricsChecked);
-    }
-
-    private void updateDisableNavkeysOption() {
-        if (!mHideNavKeysRow) {
-            final Bundle myPageBundle = mSetupWizardApp.getSettingsBundle();
-            boolean enabled = LineageSettings.Secure.getInt(getContentResolver(),
-                    LineageSettings.Secure.DEV_FORCE_SHOW_NAVBAR, 0) != 0;
-            boolean checked = myPageBundle.containsKey(DISABLE_NAV_KEYS) ?
-                    myPageBundle.getBoolean(DISABLE_NAV_KEYS) :
-                    enabled;
-            mNavKeys.setChecked(checked);
-            myPageBundle.putBoolean(DISABLE_NAV_KEYS, checked);
-        }
-    }
-
-    private void updatePrivacyGuardOption() {
-        final Bundle bundle = mSetupWizardApp.getSettingsBundle();
-        boolean enabled = LineageSettings.Secure.getInt(getContentResolver(),
-                LineageSettings.Secure.PRIVACY_GUARD_DEFAULT, 0) != 0;
-        boolean checked = bundle.containsKey(KEY_PRIVACY_GUARD) ?
-                bundle.getBoolean(KEY_PRIVACY_GUARD) :
-                enabled;
-        mPrivacyGuard.setChecked(checked);
-        bundle.putBoolean(KEY_PRIVACY_GUARD, checked);
-    }
-
-    private static boolean hideKeyDisabler(Context context) {
-        final LineageHardwareManager hardware = LineageHardwareManager.getInstance(context);
-        return !hardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE);
-    }
-
-    private static boolean isKeyDisablerActive(Context context) {
-        final LineageHardwareManager hardware = LineageHardwareManager.getInstance(context);
-        return hardware.get(LineageHardwareManager.FEATURE_KEY_DISABLE);
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/LocaleActivity.java b/src/com/cyanogenmod/setupwizard/LocaleActivity.java
deleted file mode 100644
index b622d7a..0000000
--- a/src/com/cyanogenmod/setupwizard/LocaleActivity.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Handler;
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.view.View;
-import android.widget.ArrayAdapter;
-import android.widget.ImageView;
-import android.widget.NumberPicker;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.android.internal.telephony.MccTable;
-import com.android.internal.telephony.TelephonyIntents;
-import com.android.setupwizardlib.util.WizardManagerHelper;
-
-import com.cyanogenmod.setupwizard.R;
-import com.cyanogenmod.setupwizard.widget.LocalePicker;
-
-import java.util.List;
-import java.util.Locale;
-
-public class LocaleActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = LocaleActivity.class.getSimpleName();
-
-    private ArrayAdapter<com.android.internal.app.LocalePicker.LocaleInfo> mLocaleAdapter;
-    private Locale mCurrentLocale;
-    private int[] mAdapterIndices;
-    private LocalePicker mLanguagePicker;
-    private FetchUpdateSimLocaleTask mFetchUpdateSimLocaleTask;
-    private final Handler mHandler = new Handler();
-    private boolean mPendingLocaleUpdate;
-    private boolean mPaused = true;
-
-    private final Runnable mUpdateLocale = new Runnable() {
-        public void run() {
-            if (mCurrentLocale != null) {
-                mLanguagePicker.setEnabled(false);
-                com.android.internal.app.LocalePicker.updateLocale(mCurrentLocale);
-            }
-        }
-    };
-
-    private final BroadcastReceiver mSimChangedReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
-                fetchAndUpdateSimLocale();
-            }
-        }
-    };
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setNextText(R.string.next);
-        mLanguagePicker = (LocalePicker) findViewById(R.id.locale_list);
-        loadLanguages();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mPaused = true;
-        unregisterReceiver(mSimChangedReceiver);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mPaused = false;
-        registerReceiver(mSimChangedReceiver,
-                new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
-        if (mLanguagePicker != null) {
-            mLanguagePicker.setEnabled(true);
-        }
-        if (mPendingLocaleUpdate) {
-            mPendingLocaleUpdate = false;
-            fetchAndUpdateSimLocale();
-        }
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.setup_locale;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_locale;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_locale;
-    }
-
-    private void loadLanguages() {
-        mLocaleAdapter = com.android.internal.app.LocalePicker.constructAdapter(this,
-                R.layout.locale_picker_item, R.id.locale);
-        mCurrentLocale = Locale.getDefault();
-        fetchAndUpdateSimLocale();
-        mAdapterIndices = new int[mLocaleAdapter.getCount()];
-        int currentLocaleIndex = 0;
-        String [] labels = new String[mLocaleAdapter.getCount()];
-        for (int i=0; i<mAdapterIndices.length; i++) {
-            com.android.internal.app.LocalePicker.LocaleInfo localLocaleInfo =
-                    mLocaleAdapter.getItem(i);
-            Locale localLocale = localLocaleInfo.getLocale();
-            if (localLocale.equals(mCurrentLocale)) {
-                currentLocaleIndex = i;
-            }
-            mAdapterIndices[i] = i;
-            labels[i] = localLocaleInfo.getLabel();
-        }
-        mLanguagePicker.setDisplayedValues(labels);
-        mLanguagePicker.setMaxValue(labels.length - 1);
-        mLanguagePicker.setValue(currentLocaleIndex);
-        mLanguagePicker.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);
-        mLanguagePicker.setOnValueChangedListener(new LocalePicker.OnValueChangeListener() {
-            public void onValueChange(LocalePicker picker, int oldVal, int newVal) {
-                setLocaleFromPicker();
-            }
-        });
-        mLanguagePicker.setOnScrollListener(new LocalePicker.OnScrollListener() {
-            @Override
-            public void onScrollStateChange(LocalePicker view, int scrollState) {
-                if (scrollState == SCROLL_STATE_TOUCH_SCROLL) {
-                    ((SetupWizardApp)getApplication()).setIgnoreSimLocale(true);
-                }
-            }
-        });
-    }
-
-    private void setLocaleFromPicker() {
-        ((SetupWizardApp)getApplication()).setIgnoreSimLocale(true);
-        int i = mAdapterIndices[mLanguagePicker.getValue()];
-        final com.android.internal.app.LocalePicker.LocaleInfo localLocaleInfo = mLocaleAdapter.getItem(i);
-        onLocaleChanged(localLocaleInfo.getLocale());
-    }
-
-    private void onLocaleChanged(Locale paramLocale) {
-        mLanguagePicker.setEnabled(true);
-        Resources localResources = getResources();
-        Configuration localConfiguration1 = localResources.getConfiguration();
-        Configuration localConfiguration2 = new Configuration();
-        localConfiguration2.locale = paramLocale;
-        localResources.updateConfiguration(localConfiguration2, null);
-        localResources.updateConfiguration(localConfiguration1, null);
-        mHandler.removeCallbacks(mUpdateLocale);
-        mCurrentLocale = paramLocale;
-        mHandler.postDelayed(mUpdateLocale, 1000);
-    }
-
-    private void fetchAndUpdateSimLocale() {
-        if (((SetupWizardApp)getApplication()).ignoreSimLocale() || isDestroyed()) {
-            return;
-        }
-        if (mPaused) {
-            mPendingLocaleUpdate = true;
-            return;
-        }
-        if (mFetchUpdateSimLocaleTask != null) {
-            mFetchUpdateSimLocaleTask.cancel(true);
-        }
-        mFetchUpdateSimLocaleTask = new FetchUpdateSimLocaleTask();
-        mFetchUpdateSimLocaleTask.execute();
-    }
-
-    private class FetchUpdateSimLocaleTask extends AsyncTask<Void, Void, Locale> {
-        @Override
-        protected Locale doInBackground(Void... params) {
-            Locale locale = null;
-            Activity activity = LocaleActivity.this;
-            if (!activity.isFinishing() || !activity.isDestroyed()) {
-                // If the sim is currently pin locked, return
-                TelephonyManager telephonyManager = (TelephonyManager)
-                        activity.getSystemService(Context.TELEPHONY_SERVICE);
-                int state = telephonyManager.getSimState();
-                if(state == TelephonyManager.SIM_STATE_PIN_REQUIRED ||
-                        state == TelephonyManager.SIM_STATE_PUK_REQUIRED) {
-                    return null;
-                }
-
-                final SubscriptionManager subscriptionManager =
-                        SubscriptionManager.from(activity);
-                List<SubscriptionInfo> activeSubs =
-                        subscriptionManager.getActiveSubscriptionInfoList();
-                if (activeSubs == null || activeSubs.isEmpty()) {
-                    return null;
-                }
-
-                // Fetch locale for active sim's MCC
-                int mcc = activeSubs.get(0).getMcc();
-                locale = MccTable.getLocaleFromMcc(activity, mcc, null);
-
-                // If that fails, fall back to preferred languages reported
-                // by the sim
-                if (locale == null) {
-                    String localeString = telephonyManager.getLocaleFromDefaultSim();
-                    if (localeString != null) {
-                        locale = Locale.forLanguageTag(localeString);
-
-                    }
-                }
-            }
-            return locale;
-        }
-
-        @Override
-        protected void onPostExecute(Locale simLocale) {
-            if (simLocale != null && !simLocale.equals(mCurrentLocale)) {
-                if (!((SetupWizardApp)getApplication()).ignoreSimLocale() && !isDestroyed()) {
-                    String label = getString(R.string.sim_locale_changed,
-                            simLocale.getDisplayName());
-                    Toast.makeText(LocaleActivity.this, label, Toast.LENGTH_SHORT).show();
-                    onLocaleChanged(simLocale);
-                    ((SetupWizardApp)getApplication()).setIgnoreSimLocale(true);
-                }
-            }
-        }
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/LocationSettingsActivity.java b/src/com/cyanogenmod/setupwizard/LocationSettingsActivity.java
deleted file mode 100644
index 039c3a0..0000000
--- a/src/com/cyanogenmod/setupwizard/LocationSettingsActivity.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import android.content.ContentResolver;
-import android.content.Intent;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.View;
-import android.widget.CheckBox;
-import android.widget.TextView;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-public class LocationSettingsActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG =
-            LocationSettingsActivity.class.getSimpleName().substring(0, 22);
-
-    private View mLocationRow;
-    private View mBatteryRow;
-    private View mNetworkRow;
-    private CheckBox mNetwork;
-    private CheckBox mBattery;
-    private CheckBox mLocationAccess;
-
-    private ContentResolver mContentResolver;
-
-
-    /** Broadcast intent action when the location mode is about to change. */
-    private static final String MODE_CHANGING_ACTION =
-            "com.android.settings.location.MODE_CHANGING";
-    private static final String CURRENT_MODE_KEY = "CURRENT_MODE";
-    private static final String NEW_MODE_KEY = "NEW_MODE";
-
-    private int mCurrentMode = Settings.Secure.LOCATION_MODE_OFF;
-
-    private View.OnClickListener mLocationClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            onToggleLocationAccess(!mLocationAccess.isChecked());
-        }
-    };
-
-    private View.OnClickListener mBatteryClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            onToggleBatterySaving(!mBattery.isChecked());
-        }
-    };
-
-    private View.OnClickListener mNetworkClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            onToggleNetwork(!mNetwork.isChecked());
-        }
-    };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setNextText(R.string.next);
-
-        mContentResolver = getContentResolver();
-        TextView summaryView = (TextView) findViewById(android.R.id.summary);
-        summaryView.setText(R.string.location_services_summary);
-        mLocationRow = findViewById(R.id.location);
-        mLocationRow.setOnClickListener(mLocationClickListener);
-        mLocationAccess = (CheckBox) findViewById(R.id.location_checkbox);
-        mBatteryRow = findViewById(R.id.battery_saving);
-        mBatteryRow.setOnClickListener(mBatteryClickListener);
-        mBattery = (CheckBox) findViewById(R.id.battery_saving_checkbox);
-        mNetworkRow = findViewById(R.id.network);
-        mNetworkRow.setOnClickListener(mNetworkClickListener);
-        mNetwork = (CheckBox) findViewById(R.id.network_checkbox);
-        TextView networkSummary = (TextView) findViewById(R.id.network_summary);
-        final boolean hasTelephony = SetupWizardUtils.hasTelephony(this);
-        if (hasTelephony) {
-            networkSummary.setText(R.string.location_network_telephony);
-        } else {
-            networkSummary.setText(R.string.location_network);
-        }
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        refreshLocationMode();
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.location_settings;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_location;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_location;
-    }
-
-    private void setLocationMode(int mode) {
-        Intent intent = new Intent(MODE_CHANGING_ACTION);
-        intent.putExtra(CURRENT_MODE_KEY, mCurrentMode);
-        intent.putExtra(NEW_MODE_KEY, mode);
-        sendBroadcast(intent, android.Manifest.permission.WRITE_SECURE_SETTINGS);
-        Settings.Secure.putInt(mContentResolver, Settings.Secure.LOCATION_MODE, mode);
-        refreshLocationMode();
-    }
-
-    private void refreshLocationMode() {
-        int mode = Settings.Secure.getInt(mContentResolver, Settings.Secure.LOCATION_MODE,
-                Settings.Secure.LOCATION_MODE_OFF);
-
-        if (mCurrentMode != mode) {
-            mCurrentMode = mode;
-            if (Log.isLoggable(TAG, Log.INFO)) {
-                Log.i(TAG, "Location mode has been changed");
-            }
-            updateLocationToggles(mode);
-        }
-    }
-
-    private void updateLocationToggles(int mode) {
-        switch (mode) {
-            case Settings.Secure.LOCATION_MODE_OFF:
-                mLocationAccess.setChecked(false);
-                mBattery.setChecked(false);
-                mBattery.setEnabled(false);
-                mBatteryRow.setEnabled(false);
-                mNetwork.setChecked(false);
-                mNetwork.setEnabled(false);
-                mNetworkRow.setEnabled(false);
-                break;
-            case Settings.Secure.LOCATION_MODE_SENSORS_ONLY:
-                mLocationAccess.setChecked(true);
-                mBattery.setChecked(false);
-                mBattery.setEnabled(true);
-                mBatteryRow.setEnabled(true);
-                mNetwork.setChecked(false);
-                mNetwork.setEnabled(true);
-                mNetworkRow.setEnabled(true);
-                break;
-            case Settings.Secure.LOCATION_MODE_BATTERY_SAVING:
-                mLocationAccess.setChecked(true);
-                mBattery.setChecked(true);
-                mNetwork.setChecked(false);
-                mNetwork.setEnabled(false);
-                mNetworkRow.setEnabled(false);
-                break;
-            case Settings.Secure.LOCATION_MODE_HIGH_ACCURACY:
-                mLocationAccess.setChecked(true);
-                mNetwork.setChecked(true);
-                mBattery.setChecked(false);
-                mBattery.setEnabled(false);
-                mBatteryRow.setEnabled(false);
-                break;
-            default:
-                mLocationAccess.setChecked(false);
-                mBattery.setChecked(false);
-                mBattery.setEnabled(false);
-                mBatteryRow.setEnabled(false);
-                mNetwork.setChecked(false);
-                mNetwork.setEnabled(false);
-                mNetworkRow.setEnabled(false);
-                break;
-        }
-    }
-
-    private void onToggleLocationAccess(boolean checked) {
-        if (checked) {
-            setLocationMode(Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
-        } else {
-            setLocationMode(Settings.Secure.LOCATION_MODE_OFF);
-        }
-    }
-
-    private void onToggleBatterySaving(boolean checked) {
-        if (checked) {
-            setLocationMode(Settings.Secure.LOCATION_MODE_BATTERY_SAVING);
-        } else {
-            setLocationMode(Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
-        }
-    }
-
-    private void onToggleNetwork(boolean checked) {
-        if (checked) {
-            setLocationMode(Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);
-        } else {
-            setLocationMode(Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
-        }
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/MobileDataActivity.java b/src/com/cyanogenmod/setupwizard/MobileDataActivity.java
deleted file mode 100644
index cb7bf18..0000000
--- a/src/com/cyanogenmod/setupwizard/MobileDataActivity.java
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.os.Bundle;
-import android.os.Handler;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.AnimationUtils;
-import android.widget.ImageView;
-import android.widget.ProgressBar;
-import android.widget.Switch;
-import android.widget.TextView;
-
-import com.cyanogenmod.setupwizard.util.NetworkMonitor;
-import com.cyanogenmod.setupwizard.util.PhoneMonitor;
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-public class MobileDataActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = MobileDataActivity.class.getSimpleName();
-
-    private static final int DC_READY_TIMEOUT = 20 * 1000;
-
-    private ProgressBar mProgressBar;
-    private View mEnableDataRow;
-    private Switch mEnableMobileData;
-    private ImageView mSignalView;
-    private TextView mNameView;
-
-    private TelephonyManager mPhone;
-    private SignalStrength mSignalStrength;
-    private ServiceState mServiceState;
-    private PhoneMonitor mPhoneMonitor;
-    private NetworkMonitor mNetworkMonitor;
-
-    private boolean mIsAttached = false;
-
-    private final Handler mHandler = new Handler();
-
-    private final Runnable mRadioReadyRunnable = new Runnable() {
-        @Override
-        public void run() {
-            hideWaitForRadio();
-        }
-    };
-
-    private final Runnable mDataConnectionReadyRunnable = new Runnable() {
-        @Override
-        public void run() {
-            onDataStateReady();
-        }
-    };
-
-    private PhoneMonitor.SubscriptionStateListener mSubscriptionStateListener =
-            new PhoneMonitor.SubscriptionStateListener() {
-                @Override
-                public void onServiceStateChanged(int subId, ServiceState serviceState) {
-                    if (LOGV) {
-                        Log.v(TAG, "onServiceStateChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", serviceState=" + serviceState.toString() +
-                                '}');
-                    }
-                    if (SetupWizardUtils.isRadioReady(MobileDataActivity.this, serviceState)) {
-                        hideWaitForRadio();
-                    }
-                    mServiceState = serviceState;
-                    updateSignalStrength();
-                }
-
-                @Override
-                public void onDataConnectionStateChanged(int subId, int state, int networkType) {
-                    if (LOGV) {
-                        Log.v(TAG, "onDataConnectionStateChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", state=" + state +
-                                '}');
-                    }
-                    if (state == TelephonyManager.DATA_CONNECTED) {
-                        onDataStateReady();
-                    }
-                }
-
-                @Override
-                public void onDefaultDataSubscriptionChanged(int subId) {}
-
-                @Override
-                public void onDefaultDataSubscriptionChangeRequested(int currentSubId,
-                        int newSubId) {}
-
-                @Override
-                public void onSignalStrengthsChanged(int subId, SignalStrength signalStrength) {
-                    if (LOGV) {
-                        Log.v(TAG, "onSignalStrengthsChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", signalStrength=" + signalStrength.toString() +
-                                '}');
-                    }
-                    mSignalStrength = signalStrength;
-                    updateSignalStrength();
-                }
-
-                @Override
-                public void onSimStateChanged(int subId, int simState) {
-                    if (LOGV) {
-                        Log.v(TAG, "onSimStateChanged{" +
-                                "subId='" + subId + '\'' +
-                                ", simState=" + simState +
-                                '}');
-                    }
-                }
-            };
-
-    private View.OnClickListener mEnableDataClickListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            boolean checked = !mEnableMobileData.isChecked();
-            SetupWizardUtils.setMobileDataEnabled(MobileDataActivity.this, checked);
-            mEnableMobileData.setChecked(checked);
-            if (checked && !mNetworkMonitor.isWifiConnected()) {
-                waitForData();
-            } else {
-                onDataStateReady();
-            }
-        }
-    };
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mPhoneMonitor = PhoneMonitor.getInstance();
-        mNetworkMonitor = NetworkMonitor.getInstance();
-        setNextText(R.string.next);
-
-        mProgressBar = (ProgressBar) findViewById(R.id.progress);
-        mEnableDataRow = findViewById(R.id.data);
-        mEnableDataRow.setOnClickListener(mEnableDataClickListener);
-        mEnableMobileData = (Switch) findViewById(R.id.data_switch);
-        mSignalView =  (ImageView) findViewById(R.id.signal);
-        mNameView =  (TextView) findViewById(R.id.enable_data_title);
-        updateDataConnectionStatus();
-        updateSignalStrength();
-
-    }
-
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mIsAttached = true;
-        mPhone = getSystemService(TelephonyManager.class);
-        mPhoneMonitor.addListener(mSubscriptionStateListener);
-        updateDataConnectionStatus();
-        updateSignalStrength();
-        if (SetupWizardUtils.isRadioReady(this, null)) {
-            hideWaitForRadio();
-        } else {
-            mHandler.postDelayed(mRadioReadyRunnable, SetupWizardApp.RADIO_READY_TIMEOUT);
-        }
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mIsAttached = false;
-        mPhoneMonitor.removeListener(mSubscriptionStateListener);
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    private void hideWaitForRadio() {
-        if (mProgressBar.isShown()) {
-            mHandler.removeCallbacks(mRadioReadyRunnable);
-            // Something else, like data enablement, may have grabbed
-            // the "hold" status. Kill it only if "Next" is active
-            if (isNextAllowed()) {
-                mProgressBar.setVisibility(View.INVISIBLE);
-            }
-        }
-    }
-
-    private void waitForData() {
-        if (!mProgressBar.isShown()) {
-            mProgressBar.setVisibility(View.VISIBLE);
-            mProgressBar.startAnimation(
-                    AnimationUtils.loadAnimation(this, R.anim.translucent_enter));
-            mEnableDataRow.setEnabled(false);
-            setNextAllowed(false);
-            mHandler.postDelayed(mDataConnectionReadyRunnable, DC_READY_TIMEOUT);
-        }
-    }
-
-    private void onDataStateReady() {
-        mHandler.removeCallbacks(mDataConnectionReadyRunnable);
-        if ((mProgressBar.isShown()) ||
-                !isNextAllowed()) {
-            mProgressBar.startAnimation(
-                    AnimationUtils.loadAnimation(this, R.anim.translucent_exit));
-            mProgressBar.setVisibility(View.INVISIBLE);
-            mEnableDataRow.setEnabled(true);
-            setNextAllowed(true);
-        }
-    }
-
-    private void updateCarrierText() {
-        if (mIsAttached) {
-            String name = mPhone.getSimOperatorName(SubscriptionManager.getDefaultSubscriptionId());
-            if (TextUtils.isEmpty(name)) {
-                name = mPhone.getNetworkOperatorName(SubscriptionManager.getDefaultSubscriptionId());
-            }
-            if (TextUtils.isEmpty(name)) {
-                if (mServiceState != null && mServiceState.isEmergencyOnly()) {
-                    name = getString(R.string.setup_mobile_data_emergency_only);
-                } else {
-                    name = getString(R.string.setup_mobile_data_no_service);
-                }
-            }
-            mNameView.setText(name);
-        }
-    }
-
-    private void updateSignalStrength() {
-        if (mIsAttached) {
-            if (LOGV) {
-                Log.v(TAG, "updateSignalStrength{" +
-                        "signalStrength='" + mSignalStrength + '\'' +
-                        "signalStrengthLevel='" + ((mSignalStrength != null) ?
-                        mSignalStrength.getLevel() : "null") + '\'' +
-                        '}');
-            }
-            if (!hasService()) {
-                mSignalView.setImageResource(R.drawable.ic_signal_no_signal);
-            } else {
-                if (mSignalStrength != null) {
-                    int resId;
-                    switch (mSignalStrength.getLevel()) {
-                        case 4:
-                            resId = R.drawable.ic_signal_4;
-                            break;
-                        case 3:
-                            resId = R.drawable.ic_signal_3;
-                            break;
-                        case 2:
-                            resId = R.drawable.ic_signal_2;
-                            break;
-                        case 1:
-                            resId = R.drawable.ic_signal_1;
-                            break;
-                        default:
-                            resId = R.drawable.ic_signal_0;
-                            break;
-                    }
-                    mSignalView.setImageResource(resId);
-                }
-            }
-            updateCarrierText();
-        }
-    }
-
-    private void updateDataConnectionStatus() {
-        mEnableMobileData.setChecked(SetupWizardUtils.isMobileDataEnabled(this));
-    }
-
-    private boolean hasService() {
-        boolean retVal;
-        if (mServiceState == null) {
-            mServiceState  =  TelephonyManager.from(this)
-                    .getServiceStateForSubscriber(SubscriptionManager.getDefaultSubscriptionId());
-        }
-        if (mServiceState != null) {
-            // Consider the device to be in service if either voice or data service is available.
-            // Some SIM cards are marketed as data-only and do not support voice service, and on
-            // these SIM cards, we want to show signal bars for data service as well as the "no
-            // service" or "emergency calls only" text that indicates that voice is not available.
-            switch(mServiceState.getVoiceRegState()) {
-                case ServiceState.STATE_POWER_OFF:
-                    retVal = false;
-                    break;
-                case ServiceState.STATE_OUT_OF_SERVICE:
-                case ServiceState.STATE_EMERGENCY_ONLY:
-                    retVal = mServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE;
-                    break;
-                default:
-                    retVal = true;
-            }
-        } else {
-            retVal = false;
-        }
-        return retVal;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.mobile_data_settings;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_mobile_data;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_mobile_data;
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/PartnerReceiver.java b/src/com/cyanogenmod/setupwizard/PartnerReceiver.java
deleted file mode 100644
index 7a85961..0000000
--- a/src/com/cyanogenmod/setupwizard/PartnerReceiver.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.cyanogenmod.setupwizard;
-
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class PartnerReceiver extends BroadcastReceiver {
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        // Do nothing
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/ScreenLockActivity.java b/src/com/cyanogenmod/setupwizard/ScreenLockActivity.java
deleted file mode 100644
index 7b53f7d..0000000
--- a/src/com/cyanogenmod/setupwizard/ScreenLockActivity.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_SETUP_LOCKSCREEN;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_DETAILS;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_TITLE;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_LOCKSCREEN;
-
-import android.content.Intent;
-import android.view.View;
-
-public class ScreenLockActivity extends SubBaseActivity {
-
-    public static final String TAG = ScreenLockActivity.class.getSimpleName();
-
-    @Override
-    protected void onStartSubactivity() {
-        setNextAllowed(true);
-        findViewById(R.id.setup_lockscreen).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                launchLockscreenSetup();
-            }
-        });
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.setup_lockscreen;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.lockscreen_setup_title;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_lock_screen;
-    }
-
-    private void launchLockscreenSetup() {
-        Intent intent = new Intent(ACTION_SETUP_LOCKSCREEN);
-        intent.putExtra(EXTRA_TITLE,
-                getString(R.string.settings_lockscreen_setup_title));
-        intent.putExtra(EXTRA_DETAILS,
-                getString(R.string.settings_lockscreen_setup_details));
-        intent.putExtra(SetupWizardApp.EXTRA_ALLOW_SKIP, true);
-        startSubactivity(intent, REQUEST_CODE_SETUP_LOCKSCREEN);
-    }
-
-    @Override
-    protected int getSubactivityNextTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/SetupWizardActivity.java b/src/com/cyanogenmod/setupwizard/SetupWizardActivity.java
deleted file mode 100644
index 244f666..0000000
--- a/src/com/cyanogenmod/setupwizard/SetupWizardActivity.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_LOAD;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.annotation.Nullable;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-import com.cyanogenmod.setupwizard.wizardmanager.WizardManager;
-
-public class SetupWizardActivity extends BaseSetupWizardActivity {
-    private static final String TAG = SetupWizardActivity.class.getSimpleName();
-
-    @Override
-    protected void onCreate(@Nullable Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (LOGV) {
-            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
-        }
-        if (SetupWizardUtils.hasGMS(this)) {
-            if (LOGV) {
-                Log.v(TAG, "Has GMS disabling local wizard manager");
-            }
-            SetupWizardUtils.disableComponentsForGMS(this);
-            finish();
-        } else {
-            onSetupStart();
-            SetupWizardUtils.resetComponent(this, WizardManager.class);
-            Intent intent = new Intent(ACTION_LOAD);
-            if (isPrimaryUser()) {
-                intent.putExtra(EXTRA_SCRIPT_URI, getString(R.string.cm_wizard_script_uri));
-            } else {
-                intent.putExtra(EXTRA_SCRIPT_URI, getString(R.string.cm_wizard_script_user_uri));
-            }
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | FLAG_GRANT_READ_URI_PERMISSION);
-            startActivity(intent);
-            finish();
-        }
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/SetupWizardApp.java b/src/com/cyanogenmod/setupwizard/SetupWizardApp.java
deleted file mode 100644
index fa5fc6f..0000000
--- a/src/com/cyanogenmod/setupwizard/SetupWizardApp.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2013 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-
-import android.app.Application;
-import android.os.Bundle;
-import android.os.Handler;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.util.NetworkMonitor;
-import com.cyanogenmod.setupwizard.util.PhoneMonitor;
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-import com.cyanogenmod.setupwizard.wizardmanager.WizardManager;
-
-public class SetupWizardApp extends Application {
-
-    public static final String TAG = SetupWizardApp.class.getSimpleName();
-    // Leave this off for release
-    public static final boolean DEBUG = false;
-    /* Verbose Logging */
-    public static final boolean LOGV = Log.isLoggable(TAG, Log.VERBOSE);
-
-    public static final String ACTION_FINISHED = "com.cyanogenmod.setupwizard.SETUP_FINISHED";
-    public static final String ACTION_SETUP_WIFI = "android.net.wifi.PICK_WIFI_NETWORK";
-    public static final String ACTION_SETUP_FINGERPRINT = "android.settings.FINGERPRINT_SETUP";
-    public static final String ACTION_SETUP_LOCKSCREEN = "com.android.settings.SETUP_LOCK_SCREEN";
-    public static final String ACTION_EMERGENCY_DIAL = "com.android.phone.EmergencyDialer.DIAL";
-    public static final String ACTION_NEXT = "com.android.wizard.NEXT";
-    public static final String ACTION_LOAD = "com.android.wizard.LOAD";
-
-
-    public static final String EXTRA_FIRST_RUN = "firstRun";
-    public static final String EXTRA_ALLOW_SKIP = "allowSkip";
-    public static final String EXTRA_AUTO_FINISH = "wifi_auto_finish_on_connect";
-    public static final String EXTRA_USE_IMMERSIVE = "useImmersiveMode";
-    public static final String EXTRA_HAS_MULTIPLE_USERS = "hasMultipleUsers";
-    public static final String EXTRA_THEME = "theme";
-    public static final String EXTRA_MATERIAL_LIGHT = "material_light";
-    public static final String EXTRA_TITLE = "title";
-    public static final String EXTRA_DETAILS = "details";
-    public static final String EXTRA_SCRIPT_URI = "scriptUri";
-    public static final String EXTRA_ACTION_ID = "actionId";
-    public static final String EXTRA_RESULT_CODE = "com.android.setupwizard.ResultCode";
-    public static final String EXTRA_PREFS_SHOW_BUTTON_BAR = "extra_prefs_show_button_bar";
-    public static final String EXTRA_PREFS_SET_BACK_TEXT = "extra_prefs_set_back_text";
-
-    public static final String KEY_DETECT_CAPTIVE_PORTAL = "captive_portal_detection_enabled";
-    public static final String KEY_SEND_METRICS = "send_metrics";
-    public static final String DISABLE_NAV_KEYS = "disable_nav_keys";
-    public static final String KEY_APPLY_DEFAULT_THEME = "apply_default_theme";
-    public static final String KEY_BUTTON_BACKLIGHT = "pre_navbar_button_backlight";
-    public static final String KEY_PRIVACY_GUARD = "privacy_guard_default";
-
-    private static final String[] THEME_PACKAGES = {
-            "org.cyanogenmod.theme.chooser",
-            "org.cyanogenmod.theme.chooser2",
-            "com.cyngn.theme.chooser",
-            "com.cyngn.themestore"
-    };
-
-    public static final int REQUEST_CODE_SETUP_WIFI = 0;
-    public static final int REQUEST_CODE_SETUP_CAPTIVE_PORTAL= 4;
-    public static final int REQUEST_CODE_SETUP_BLUETOOTH= 5;
-    public static final int REQUEST_CODE_SETUP_FINGERPRINT = 7;
-    public static final int REQUEST_CODE_SETUP_LOCKSCREEN = 9;
-
-    public static final int RADIO_READY_TIMEOUT = 10 * 1000;
-
-    private boolean mIsRadioReady = false;
-    private boolean mIgnoreSimLocale = false;
-
-    private final Bundle mSettingsBundle = new Bundle();
-    private final Handler mHandler = new Handler();
-
-    private final Runnable mRadioTimeoutRunnable = new Runnable() {
-        @Override
-        public void run() {
-            mIsRadioReady = true;
-        }
-    };
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        if (LOGV) {
-            Log.v(TAG, "onCreate()");
-        }
-        NetworkMonitor.initInstance(this);
-        PhoneMonitor.initInstance(this);
-        SetupWizardUtils.disableComponentsForMissingFeatures(this);
-        mHandler.postDelayed(mRadioTimeoutRunnable, SetupWizardApp.RADIO_READY_TIMEOUT);
-    }
-
-    public boolean isRadioReady() {
-        return mIsRadioReady;
-    }
-
-    public void setRadioReady(boolean radioReady) {
-        if (!mIsRadioReady && radioReady) {
-            mHandler.removeCallbacks(mRadioTimeoutRunnable);
-        }
-        mIsRadioReady = radioReady;
-    }
-
-    public boolean ignoreSimLocale() {
-        return mIgnoreSimLocale;
-    }
-
-    public void setIgnoreSimLocale(boolean ignoreSimLocale) {
-        mIgnoreSimLocale = ignoreSimLocale;
-    }
-
-    public Bundle getSettingsBundle() {
-        return mSettingsBundle;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/SetupWizardExitActivity.java b/src/com/cyanogenmod/setupwizard/SetupWizardExitActivity.java
deleted file mode 100644
index 321a426..0000000
--- a/src/com/cyanogenmod/setupwizard/SetupWizardExitActivity.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK;
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.annotation.Nullable;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.android.setupwizardlib.util.SystemBarHelper;
-
-import com.cyanogenmod.setupwizard.util.PhoneMonitor;
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-public class SetupWizardExitActivity extends BaseSetupWizardActivity {
-
-    private static final String TAG = SetupWizardExitActivity.class.getSimpleName();
-
-    @Override
-    protected void onCreate(@Nullable Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (LOGV) {
-            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
-        }
-        SystemBarHelper.showSystemBars(getWindow(), this);
-        SetupWizardUtils.enableStatusBar(this);
-        SetupWizardUtils.enableCaptivePortalDetection(this);
-        PhoneMonitor.onSetupFinished();
-        launchHome();
-        finish();
-        applyForwardTransition(TRANSITION_ID_FADE);
-        Intent i = new Intent();
-        i.setClassName(getPackageName(), SetupWizardExitService.class.getName());
-        startService(i);
-    }
-
-    private void launchHome() {
-        startActivity(new Intent("android.intent.action.MAIN")
-                .addCategory("android.intent.category.HOME")
-                .addFlags(FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK));
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/SetupWizardExitService.java b/src/com/cyanogenmod/setupwizard/SetupWizardExitService.java
deleted file mode 100644
index c3243b9..0000000
--- a/src/com/cyanogenmod/setupwizard/SetupWizardExitService.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.annotation.Nullable;
-import android.app.IntentService;
-import android.content.Intent;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-public class SetupWizardExitService extends IntentService {
-
-    private static final String TAG = "SUWExitService";
-
-    public SetupWizardExitService() {
-        super(TAG);
-    }
-
-    @Override
-    protected void onHandleIntent(@Nullable Intent intent) {
-        if (LOGV) {
-            Log.v(TAG, "onHandleIntent intent=" + intent.toString());
-        }
-        SetupWizardUtils.finishSetupWizard(this);
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/SetupWizardTestActivity.java b/src/com/cyanogenmod/setupwizard/SetupWizardTestActivity.java
deleted file mode 100644
index 5f978b7..0000000
--- a/src/com/cyanogenmod/setupwizard/SetupWizardTestActivity.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static android.content.pm.PackageManager.GET_ACTIVITIES;
-import static android.content.pm.PackageManager.GET_RECEIVERS;
-import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.content.pm.PackageManager.MATCH_DISABLED_COMPONENTS;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.net.wifi.WifiConfiguration;
-import android.net.wifi.WifiManager;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-import java.util.List;
-
-public class SetupWizardTestActivity extends Activity {
-
-    private static final String TAG = SetupWizardTestActivity.class.getSimpleName();
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (LOGV) {
-            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
-        }
-        if (SetupWizardUtils.isOwner()) {
-            Settings.Global.putInt(getContentResolver(), "device_provisioned", 0);
-        }
-        Settings.Secure.putInt(getContentResolver(), "user_setup_complete", 0);
-        SetupWizardUtils.resetComponentSets(this, GET_ACTIVITIES |
-                GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
-        forgetAllWifi();
-        Intent setupIntent = new Intent("android.intent.action.MAIN")
-                .addCategory("android.intent.category.HOME")
-                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_GRANT_READ_URI_PERMISSION);
-        SetupWizardUtils.disableComponentsForMissingFeatures(this);
-        startActivity(setupIntent);
-        finish();
-    }
-
-    private void forgetAllWifi() {
-        WifiManager wm = getSystemService(WifiManager.class);
-        if (wm != null) {
-            List<WifiConfiguration> configs = wm.getConfiguredNetworks();
-            if (configs != null) {
-                for (WifiConfiguration config : configs) {
-                    wm.forget(config.networkId, null);
-                }
-            }
-        }
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/SimMissingActivity.java b/src/com/cyanogenmod/setupwizard/SimMissingActivity.java
deleted file mode 100644
index 7369f7d..0000000
--- a/src/com/cyanogenmod/setupwizard/SimMissingActivity.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import android.os.Bundle;
-import android.widget.ImageView;
-
-import com.android.setupwizardlib.util.ResultCodes;
-
-import com.cyanogenmod.setupwizard.util.PhoneMonitor;
-
-public class SimMissingActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = SimMissingActivity.class.getSimpleName();
-
-    private static final int SIM_DEFAULT = 0;
-    private static final int SIM_SIDE = 1;
-    private static final int SIM_BACK = 2;
-
-    private PhoneMonitor mPhoneMonitor;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mPhoneMonitor = PhoneMonitor.getInstance();
-        if (!mPhoneMonitor.simMissing()) {
-            finishAction(RESULT_OK);
-        }
-        setNextText(R.string.skip);
-        final int simLocation = getResources().getInteger(
-                R.integer.sim_image_type);
-        ImageView simLogo = ((ImageView)findViewById(R.id.sim_slot_image));
-        switch (simLocation) {
-            case SIM_SIDE:
-                simLogo.setImageResource(R.drawable.sim_side);
-                break;
-            case SIM_BACK:
-                simLogo.setImageResource(R.drawable.sim_back);
-                break;
-            default:
-                simLogo.setImageResource(R.drawable.sim);
-                simLogo.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
-        }
-    }
-
-    @Override
-    public void onNavigateNext() {
-        if (mPhoneMonitor.simMissing()) {
-            nextAction(ResultCodes.RESULT_SKIP);
-        } else {
-            super.onNavigateNext();
-        }
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.sim_missing_page;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.setup_sim_missing;
-    }
-
-    @Override
-    protected int getIconResId() {
-        return R.drawable.ic_sim;
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/SubBaseActivity.java b/src/com/cyanogenmod/setupwizard/SubBaseActivity.java
deleted file mode 100644
index ae44a69..0000000
--- a/src/com/cyanogenmod/setupwizard/SubBaseActivity.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-
-import static android.content.Intent.FLAG_ACTIVITY_FORWARD_RESULT;
-
-import static com.android.setupwizardlib.util.ResultCodes.RESULT_ACTIVITY_NOT_FOUND;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ACTION_ID;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.annotation.NonNull;
-import android.content.ActivityNotFoundException;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.TextView;
-
-public abstract class SubBaseActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = SubBaseActivity.class.getSimpleName();
-
-    private boolean mIsSubactivityNotFound = false;
-    private int mRequestCode;
-
-    protected abstract void onStartSubactivity();
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        if (LOGV) {
-            Log.d(TAG, "onCreate savedInstanceState=" + savedInstanceState);
-        }
-        super.onCreate(savedInstanceState);
-        setNextText(R.string.skip);
-        setNextAllowed(false);
-        if (savedInstanceState == null) {
-            onStartSubactivity();
-        }
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        mIsActivityVisible = true;
-    }
-
-    @Override
-    protected void onSaveInstanceState(@NonNull Bundle outState) {
-        outState.putInt("request_code", mRequestCode);
-        super.onSaveInstanceState(outState);
-    }
-
-    @Override
-    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
-        super.onRestoreInstanceState(savedInstanceState);
-        mRequestCode = savedInstanceState.getInt("request_code");
-    }
-
-    protected void startSubactivity(Intent subactivityIntent, int requestCode) {
-        mRequestCode = requestCode;
-        Intent intent = getIntent();
-        if (intent.hasExtra(EXTRA_SCRIPT_URI)) {
-            subactivityIntent.putExtra(EXTRA_SCRIPT_URI, intent.getStringExtra(EXTRA_SCRIPT_URI));
-            subactivityIntent.putExtra(EXTRA_ACTION_ID, intent.getStringExtra(EXTRA_ACTION_ID));
-        }
-        boolean activityForwardsResult =
-                (subactivityIntent.getFlags() & FLAG_ACTIVITY_FORWARD_RESULT) != 0;
-        if (activityForwardsResult) {
-            try {
-                startFirstRunActivity(subactivityIntent);
-                setResultCode(RESULT_OK);
-                finish();
-            } catch (ActivityNotFoundException e) {
-                Log.w(TAG, "activity not found; start next screen and finish; intent="
-                        + intent);
-                mIsSubactivityNotFound = true;
-                nextAction(RESULT_ACTIVITY_NOT_FOUND);
-                finish();
-                return;
-            }
-        }
-        startFirstRunActivityForResult(subactivityIntent, requestCode);
-        mIsSubactivityNotFound = false;
-        applyForwardTransition(getSubactivityPreviousTransition());
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        Bundle extras = null;
-        if (LOGV) {
-            Log.v(TAG, "onActivityResult(" + getRequestName(requestCode) +
-                    ", " + getResultName(requestCode, resultCode));
-        }
-        if (requestCode == mRequestCode) {
-            StringBuilder append = new StringBuilder().append("subactivity result {")
-                    .append(getRequestName(requestCode)).append(", ")
-                    .append(getResultName(mRequestCode, resultCode)).append(", ");
-            if (data != null) {
-                extras = data.getExtras();
-            }
-            Log.i(TAG, append.append(extras).append("}").toString());
-            onSubactivityResult(requestCode, resultCode, data);
-        } else if (resultCode == RESULT_CANCELED) {
-            onStartSubactivity();
-            mIsGoingBack = true;
-            applyBackwardTransition(getSubactivityNextTransition());
-        } else {
-            super.onActivityResult(requestCode, resultCode, data);
-        }
-    }
-
-    protected void onSubactivityResult(int requestCode, int resultCode, Intent data) {
-        if (LOGV) {
-            StringBuilder append = new StringBuilder().append("onSubactivityResult(")
-                    .append(getRequestName(requestCode)).append(", ")
-                    .append(getResultName(requestCode, resultCode)).append(", ");
-            Bundle extras = null;
-            if (data != null) {
-                extras = data.getExtras();
-            }
-            Log.v(TAG, append.append(extras).append(")").toString());
-        }
-        if (resultCode != RESULT_CANCELED) {
-            applyForwardTransition(getSubactivityNextTransition());
-            nextAction(resultCode, data);
-        } else if (mIsSubactivityNotFound) {
-            nextAction(RESULT_ACTIVITY_NOT_FOUND);
-            finish();
-        } else {
-            applyBackwardTransition(getSubactivityPreviousTransition());
-            finishAction(RESULT_CANCELED, data);
-        }
-    }
-
-    protected int getSubactivityPreviousTransition() {
-        return TRANSITION_ID_DEFAULT;
-    }
-
-    protected int getSubactivityNextTransition() {
-        return TRANSITION_ID_DEFAULT;
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_FADE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.setup_loading_page;
-    }
-
-    @Override
-    protected int getTitleResId() {
-        return R.string.loading;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/WelcomeActivity.java b/src/com/cyanogenmod/setupwizard/WelcomeActivity.java
deleted file mode 100644
index 061cfbe..0000000
--- a/src/com/cyanogenmod/setupwizard/WelcomeActivity.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import android.os.Bundle;
-import android.view.MotionEvent;
-import android.view.View;
-
-import com.cyanogenmod.setupwizard.util.EnableAccessibilityController;
-
-public class WelcomeActivity extends BaseSetupWizardActivity {
-
-    public static final String TAG = WelcomeActivity.class.getSimpleName();
-
-    private View mRootView;
-    private EnableAccessibilityController mEnableAccessibilityController;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mRootView = findViewById(R.id.root);
-        setNextText(R.string.next);
-        setBackText(R.string.emergency_call);
-        setBackDrawable(null);
-        mEnableAccessibilityController =
-                EnableAccessibilityController.getInstance(getApplicationContext());
-        mRootView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                return mEnableAccessibilityController.onTouchEvent(event);
-            }
-        });
-    }
-
-    @Override
-    public void onBackPressed() {}
-
-    @Override
-    public void onNavigateBack() {
-        startEmergencyDialer();
-    }
-
-    @Override
-    protected int getTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-    @Override
-    protected int getLayoutResId() {
-        return R.layout.welcome_activity;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/WifiSetupActivity.java b/src/com/cyanogenmod/setupwizard/WifiSetupActivity.java
deleted file mode 100644
index ec49dd3..0000000
--- a/src/com/cyanogenmod/setupwizard/WifiSetupActivity.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_SETUP_WIFI;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_MATERIAL_LIGHT;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_WIFI;
-
-import android.content.Intent;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-public class WifiSetupActivity extends SubBaseActivity {
-
-    public static final String TAG = WifiSetupActivity.class.getSimpleName();
-
-
-    @Override
-    protected void onStartSubactivity() {
-        tryEnablingWifi();
-        Intent intent = new Intent(ACTION_SETUP_WIFI);
-        if (SetupWizardUtils.hasLeanback(this)) {
-            intent.setComponent(SetupWizardUtils.mTvwifisettingsActivity);
-        }
-        intent.putExtra(SetupWizardApp.EXTRA_PREFS_SHOW_BUTTON_BAR, true);
-        intent.putExtra(SetupWizardApp.EXTRA_PREFS_SET_BACK_TEXT , false);
-        startSubactivity(intent, REQUEST_CODE_SETUP_WIFI);
-    }
-
-    @Override
-    protected int getSubactivityNextTransition() {
-        return TRANSITION_ID_SLIDE;
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/util/EnableAccessibilityController.java b/src/com/cyanogenmod/setupwizard/util/EnableAccessibilityController.java
deleted file mode 100644
index 17eb782..0000000
--- a/src/com/cyanogenmod/setupwizard/util/EnableAccessibilityController.java
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not
- * use this file except in compliance with the License. You may obtain a copy of
- * the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.cyanogenmod.setupwizard.util;
-
-import android.accessibilityservice.AccessibilityServiceInfo;
-import android.app.ActivityManager;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.pm.ServiceInfo;
-import android.media.AudioManager;
-import android.media.Ringtone;
-import android.media.RingtoneManager;
-import android.os.Handler;
-import android.os.Message;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.UserManager;
-import android.provider.Settings;
-import android.speech.tts.TextToSpeech;
-import android.util.MathUtils;
-import android.view.IWindowManager;
-import android.view.MotionEvent;
-import android.view.accessibility.AccessibilityManager;
-import android.view.accessibility.IAccessibilityManager;
-
-import com.android.internal.R;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-public class EnableAccessibilityController {
-
-    private static final int SPEAK_WARNING_DELAY_MILLIS = 5000;
-    private static final int ENABLE_ACCESSIBILITY_DELAY_MILLIS = 12000;
-
-    public static final int MESSAGE_SPEAK_WARNING = 1;
-    public static final int MESSAGE_SPEAK_ENABLE_CANCELED = 2;
-    public static final int MESSAGE_ENABLE_ACCESSIBILITY = 3;
-
-    private final Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(Message message) {
-            switch (message.what) {
-                case MESSAGE_SPEAK_WARNING: {
-                    // TODO: Fix these or remove these
-                    //String text = mContext.getString(R.string.continue_to_enable_accessibility);
-                    //mTts.speak(text, TextToSpeech.QUEUE_FLUSH, null);
-                } break;
-                case MESSAGE_SPEAK_ENABLE_CANCELED: {
-                    //String text = mContext.getString(R.string.enable_accessibility_canceled);
-                    //mTts.speak(text, TextToSpeech.QUEUE_FLUSH, null);
-                } break;
-                case MESSAGE_ENABLE_ACCESSIBILITY: {
-                    enableAccessibility();
-                    //mTone.play();
-                    //mTts.speak(mContext.getString(R.string.accessibility_enabled),
-                    //        TextToSpeech.QUEUE_FLUSH, null);
-                } break;
-            }
-        }
-    };
-
-    private final IWindowManager mWindowManager = IWindowManager.Stub.asInterface(
-            ServiceManager.getService("window"));
-
-    private final IAccessibilityManager mAccessibilityManager = IAccessibilityManager
-            .Stub.asInterface(ServiceManager.getService("accessibility"));
-
-
-    private final Context mContext;
-    private final UserManager mUserManager;
-    private final TextToSpeech mTts;
-    private final Ringtone mTone;
-
-    private final float mTouchSlop;
-
-    private boolean mDestroyed;
-
-    private float mFirstPointerDownX;
-    private float mFirstPointerDownY;
-    private float mSecondPointerDownX;
-    private float mSecondPointerDownY;
-
-    private static EnableAccessibilityController sInstance;
-
-    private EnableAccessibilityController(Context context) {
-        mContext = context;
-        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
-        mTts = new TextToSpeech(context, new TextToSpeech.OnInitListener() {
-            @Override
-            public void onInit(int status) {
-                if (mDestroyed) {
-                    mTts.shutdown();
-                }
-            }
-        });
-        mTone = RingtoneManager.getRingtone(context, Settings.System.DEFAULT_NOTIFICATION_URI);
-        mTone.setStreamType(AudioManager.STREAM_MUSIC);
-        mTouchSlop = context.getResources().getDimensionPixelSize(
-                R.dimen.accessibility_touch_slop);
-    }
-
-    public static EnableAccessibilityController getInstance(Context context) {
-        if (sInstance == null) {
-            sInstance = new EnableAccessibilityController(context);
-        }
-        return sInstance;
-    }
-
-    public static boolean canEnableAccessibilityViaGesture(Context context) {
-        AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(context);
-        // Accessibility is enabled and there is an enabled speaking
-        // accessibility service, then we have nothing to do.
-        if (accessibilityManager.isEnabled()
-                && !accessibilityManager.getEnabledAccessibilityServiceList(
-                AccessibilityServiceInfo.FEEDBACK_SPOKEN).isEmpty()) {
-            return false;
-        }
-
-        // If there is a speaking service
-        // installed we are good to go, otherwise there is nothing to do.
-        return getInstalledSpeakingAccessibilityServices(context).isEmpty();
-    }
-
-    private static List<AccessibilityServiceInfo> getInstalledSpeakingAccessibilityServices(
-            Context context) {
-        List<AccessibilityServiceInfo> services = new ArrayList<AccessibilityServiceInfo>();
-        services.addAll(AccessibilityManager.getInstance(context)
-                .getInstalledAccessibilityServiceList());
-        Iterator<AccessibilityServiceInfo> iterator = services.iterator();
-        while (iterator.hasNext()) {
-            AccessibilityServiceInfo service = iterator.next();
-            if ((service.feedbackType & AccessibilityServiceInfo.FEEDBACK_SPOKEN) == 0) {
-                iterator.remove();
-            }
-        }
-        return services;
-    }
-
-    public void onDestroy() {
-        mDestroyed = true;
-    }
-
-    public boolean onTouchEvent(MotionEvent event) {
-        final int pointerCount = event.getPointerCount();
-        final int action = event.getActionMasked();
-
-        if (pointerCount != 2) {
-            cancel();
-            return true;
-        }
-
-        switch (action) {
-            case MotionEvent.ACTION_DOWN:
-            case MotionEvent.ACTION_POINTER_DOWN: {
-                mFirstPointerDownX = event.getX(0);
-                mFirstPointerDownY = event.getY(0);
-                mSecondPointerDownX = event.getX(1);
-                mSecondPointerDownY = event.getY(1);
-                mHandler.sendEmptyMessageDelayed(MESSAGE_SPEAK_WARNING,
-                        SPEAK_WARNING_DELAY_MILLIS);
-                mHandler.sendEmptyMessageDelayed(MESSAGE_ENABLE_ACCESSIBILITY,
-                        ENABLE_ACCESSIBILITY_DELAY_MILLIS);
-            }
-            break;
-            case MotionEvent.ACTION_MOVE: {
-                final float firstPointerMove = MathUtils.dist(event.getX(0),
-                        event.getY(0), mFirstPointerDownX, mFirstPointerDownY);
-                if (Math.abs(firstPointerMove) > mTouchSlop) {
-                    cancel();
-                }
-                final float secondPointerMove = MathUtils.dist(event.getX(1),
-                        event.getY(1), mSecondPointerDownX, mSecondPointerDownY);
-                if (Math.abs(secondPointerMove) > mTouchSlop) {
-                    cancel();
-                }
-            }
-            break;
-            case MotionEvent.ACTION_UP:
-            case MotionEvent.ACTION_POINTER_UP:
-            case MotionEvent.ACTION_CANCEL: {
-                cancel();
-            }
-            break;
-        }
-        return true;
-    }
-
-    private void cancel() {
-        if (mHandler.hasMessages(MESSAGE_SPEAK_WARNING)) {
-            mHandler.removeMessages(MESSAGE_SPEAK_WARNING);
-        } else if (mHandler.hasMessages(MESSAGE_ENABLE_ACCESSIBILITY)) {
-            mHandler.sendEmptyMessage(MESSAGE_SPEAK_ENABLE_CANCELED);
-        }
-        mHandler.removeMessages(MESSAGE_ENABLE_ACCESSIBILITY);
-    }
-
-    private void enableAccessibility() {
-        List<AccessibilityServiceInfo> services = getInstalledSpeakingAccessibilityServices(
-                mContext);
-        if (services.isEmpty()) {
-            return;
-        }
-        boolean keyguardLocked = false;
-        try {
-            keyguardLocked = mWindowManager.isKeyguardLocked();
-        } catch (RemoteException re) {
-            /* ignore */
-        }
-
-        final boolean hasMoreThanOneUser = mUserManager.getUsers().size() > 1;
-
-        AccessibilityServiceInfo service = services.get(0);
-        boolean enableTouchExploration = (service.flags
-                & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
-        // Try to find a service supporting explore by touch.
-        if (!enableTouchExploration) {
-            final int serviceCount = services.size();
-            for (int i = 1; i < serviceCount; i++) {
-                AccessibilityServiceInfo candidate = services.get(i);
-                if ((candidate.flags & AccessibilityServiceInfo
-                        .FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0) {
-                    enableTouchExploration = true;
-                    service = candidate;
-                    break;
-                }
-            }
-        }
-
-        ServiceInfo serviceInfo = service.getResolveInfo().serviceInfo;
-        ComponentName componentName = new ComponentName(serviceInfo.packageName, serviceInfo.name);
-        if (!keyguardLocked || !hasMoreThanOneUser) {
-            final int userId = ActivityManager.getCurrentUser();
-            String enabledServiceString = componentName.flattenToString();
-            ContentResolver resolver = mContext.getContentResolver();
-            // Enable one speaking accessibility service.
-            Settings.Secure.putStringForUser(resolver,
-                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
-                    enabledServiceString, userId);
-            // Allow the services we just enabled to toggle touch exploration.
-            Settings.Secure.putStringForUser(resolver,
-                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
-                    enabledServiceString, userId);
-            // Enable touch exploration.
-            if (enableTouchExploration) {
-                Settings.Secure.putIntForUser(resolver, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
-                        1, userId);
-            }
-            // Turn on accessibility mode last.
-            Settings.Secure.putIntForUser(resolver, Settings.Secure.ACCESSIBILITY_ENABLED,
-                    1, userId);
-        } else if (keyguardLocked) {
-            try {
-                mAccessibilityManager.temporaryEnableAccessibilityStateUntilKeyguardRemoved(
-                        componentName, enableTouchExploration);
-            } catch (RemoteException re) {
-                /* ignore */
-            }
-        }
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/util/NetworkMonitor.java b/src/com/cyanogenmod/setupwizard/util/NetworkMonitor.java
deleted file mode 100644
index 0cc1d9e..0000000
--- a/src/com/cyanogenmod/setupwizard/util/NetworkMonitor.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.util;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Handler;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.SetupWizardApp;
-
-public class NetworkMonitor {
-
-    public static final String TAG = NetworkMonitor.class.getSimpleName();
-
-    private static NetworkMonitor sInstance;
-
-    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
-        public void onReceive(Context context, Intent intent) {
-            if (LOGV) {
-                Log.v(TAG, intent.toString());
-            }
-            NetworkMonitor.this.updateNetworkStatus(context);
-        }
-    };
-    private Context mContext = null;
-    private boolean mNetworkConnected = false;
-    private NetworkInfo mNetworkInfo = null;
-
-    public static void initInstance(Context context) {
-        if (sInstance == null) {
-            sInstance = new NetworkMonitor(context.getApplicationContext());
-        }
-    }
-
-    public static NetworkMonitor getInstance() {
-        return sInstance;
-    }
-
-    public NetworkMonitor(Context context) {
-        mContext = context;
-        if (LOGV) {
-            Log.v(TAG, "Starting NetworkMonitor");
-        }
-        IntentFilter filter = new IntentFilter();
-        filter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
-        context.registerReceiver(mBroadcastReceiver, filter);
-        new Handler().post(new Runnable() {
-            public void run() {
-                updateNetworkStatus(mContext);
-            }
-        });
-    }
-
-    public boolean isNetworkConnected() {
-        if (LOGV) {
-            Log.v(TAG, "isNetworkConnected() returns " + mNetworkConnected);
-        }
-        return mNetworkConnected;
-    }
-
-    public boolean isWifiConnected() {
-        boolean wifiConnected = (!mNetworkConnected || mNetworkInfo == null) ?
-                false :
-                mNetworkInfo.getType() == 1;
-        if (LOGV) {
-            Log.v(TAG, "isWifiConnected() returns " + wifiConnected);
-        }
-        return wifiConnected;
-    }
-
-    public boolean checkIsNetworkConnected() {
-        updateNetworkStatus(mContext);
-        return isNetworkConnected();
-    }
-
-    private void onNetworkConnected(NetworkInfo ni) {
-        if (LOGV) {
-            Log.v(TAG, "onNetworkConnected()");
-        }
-        mNetworkConnected = true;
-        mNetworkInfo = ni;
-    }
-
-    private void onNetworkDisconnected() {
-        if (LOGV) {
-            Log.v(TAG, "onNetworkDisconnected()");
-        }
-        mNetworkConnected = false;
-        mNetworkInfo = null;
-    }
-
-    private boolean updateNetworkStatus(Context context) {
-        ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
-        if (cm != null) {
-            NetworkInfo ni = cm.getActiveNetworkInfo();
-            boolean isConnected = ni != null ? ni.isConnected() : false;
-            if (isConnected && !mNetworkConnected) {
-                onNetworkConnected(ni);
-            } else if (!isConnected && mNetworkConnected) {
-                onNetworkDisconnected();
-            }
-        }
-        return mNetworkConnected;
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/util/PhoneMonitor.java b/src/com/cyanogenmod/setupwizard/util/PhoneMonitor.java
deleted file mode 100644
index ec8ba4c..0000000
--- a/src/com/cyanogenmod/setupwizard/util/PhoneMonitor.java
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.util;
-
-import static android.telephony.PhoneStateListener.LISTEN_DATA_CONNECTION_STATE;
-import static android.telephony.PhoneStateListener.LISTEN_NONE;
-import static android.telephony.PhoneStateListener.LISTEN_SERVICE_STATE;
-import static android.telephony.PhoneStateListener.LISTEN_SIGNAL_STRENGTHS;
-import static android.telephony.ServiceState.STATE_EMERGENCY_ONLY;
-import static android.telephony.ServiceState.STATE_IN_SERVICE;
-import static android.telephony.ServiceState.STATE_OUT_OF_SERVICE;
-import static android.telephony.ServiceState.STATE_POWER_OFF;
-import static android.telephony.TelephonyManager.DATA_CONNECTED;
-import static android.telephony.TelephonyManager.DATA_CONNECTING;
-import static android.telephony.TelephonyManager.DATA_DISCONNECTED;
-import static android.telephony.TelephonyManager.DATA_SUSPENDED;
-import static android.telephony.TelephonyManager.DATA_UNKNOWN;
-import static android.telephony.TelephonyManager.PHONE_TYPE_CDMA;
-import static android.telephony.TelephonyManager.PHONE_TYPE_GSM;
-import static android.telephony.TelephonyManager.PHONE_TYPE_NONE;
-import static android.telephony.TelephonyManager.PHONE_TYPE_SIP;
-import static android.telephony.TelephonyManager.SIM_STATE_ABSENT;
-import static android.telephony.TelephonyManager.SIM_STATE_CARD_IO_ERROR;
-import static android.telephony.TelephonyManager.SIM_STATE_NETWORK_LOCKED;
-import static android.telephony.TelephonyManager.SIM_STATE_PIN_REQUIRED;
-import static android.telephony.TelephonyManager.SIM_STATE_PUK_REQUIRED;
-import static android.telephony.TelephonyManager.SIM_STATE_READY;
-import static android.telephony.TelephonyManager.SIM_STATE_UNKNOWN;
-
-import static com.android.internal.telephony.PhoneConstants.LTE_ON_CDMA_TRUE;
-import static com.android.internal.telephony.PhoneConstants.LTE_ON_CDMA_UNKNOWN;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.SystemProperties;
-import android.telephony.PhoneStateListener;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
-import android.telephony.TelephonyManager;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.telephony.PhoneConstants;
-import com.android.internal.telephony.TelephonyIntents;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-
-public class PhoneMonitor {
-
-    public static final String TAG = PhoneMonitor.class.getSimpleName();
-
-    private static PhoneMonitor sInstance;
-    private Context mContext;
-    private TelephonyManager mTelephony;
-    private SubscriptionManager mSubscriptionManager;
-    private ArrayList<SubscriptionStateListener> mListeners = new ArrayList<>();
-    private SparseArray<SubscriptionStateTracker> mTrackers = new SparseArray<>();
-
-    private int mChangingToDataSubId = -1;
-
-    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
-                final int sub = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1);
-                final int state = mTelephony.getSimState(sub);
-                simStateChanged(sub, state);
-            } else if (intent.getAction()
-                    .equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
-                ddsHasChanged(intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1));
-            }
-        }
-    };
-
-    private class SubscriptionStateTracker extends PhoneStateListener {
-
-        private ServiceState mServiceState;
-        private int mSubId = -1;
-
-        public SubscriptionStateTracker(int subId) {
-            super(subId);
-            mSubId = subId;
-        }
-
-        public void onServiceStateChanged(ServiceState serviceState) {
-            mServiceState = serviceState;
-            if (LOGV) {
-                logPhoneState("onServiceStateChanged state=\"" + serviceState + "\" ");
-            }
-            for (SubscriptionStateListener listener : mListeners) {
-                listener.onServiceStateChanged(mSubId, serviceState);
-            }
-        }
-
-        public void onDataConnectionStateChanged(int state, int networkType) {
-            for (SubscriptionStateListener listener : mListeners) {
-                listener.onDataConnectionStateChanged(mSubId, state, networkType);
-            }
-        }
-
-        public void onSignalStrengthsChanged(SignalStrength signalStrength) {
-            for (SubscriptionStateListener listener : mListeners) {
-                listener.onSignalStrengthsChanged(mSubId, signalStrength);
-            }
-        }
-    }
-
-    private final OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
-            new OnSubscriptionsChangedListener() {
-        public void onSubscriptionsChanged() {
-            if (LOGV) {
-                Log.d(TAG, "Subscriptions changed");
-            }
-            super.onSubscriptionsChanged();
-            updatePhoneStateTrackers();
-        }
-    };
-
-    public static void initInstance(Context context) {
-        if (sInstance == null) {
-            sInstance = new PhoneMonitor(context.getApplicationContext());
-        }
-    }
-
-    public static void onSetupFinished() {
-        if (sInstance != null) {
-            sInstance.mContext.unregisterReceiver(sInstance.mIntentReceiver);
-        }
-    }
-
-    public static PhoneMonitor getInstance() {
-        return sInstance;
-    }
-
-    public PhoneMonitor(Context context) {
-        mContext = context;
-        if (LOGV) {
-            Log.v(TAG, "Starting PhoneMonitor");
-        }
-        mTelephony = mContext.getSystemService(TelephonyManager.class);
-        if (mTelephony != null) {
-            mSubscriptionManager = SubscriptionManager.from(mContext);
-            mSubscriptionManager.addOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
-            updatePhoneStateTrackers();
-        }
-        // Register for DDS changes
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
-        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
-        context.registerReceiver(mIntentReceiver, filter, null, null);
-    }
-
-    private void updatePhoneStateTrackers() {
-        int i = 0;
-        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
-        HashSet<Integer> subIdSet = new HashSet(Arrays.asList(subIds));
-        if (LOGV) {
-            Log.v(TAG, "Register PhoneStateListeners for " + subIdSet);
-        }
-        for (int i2 = 0; i2 < mTrackers.size(); i2++) {
-            if (!subIdSet.contains(Integer.valueOf(mTrackers.keyAt(i2)))) {
-                mTelephony.listen(mTrackers.valueAt(i2), LISTEN_NONE);
-                mTrackers.removeAt(i2);
-            }
-        }
-        int length = subIds.length;
-        while (i < length) {
-            int subId = subIds[i];
-            if (mTrackers.indexOfKey(subId) < 0) {
-                SubscriptionStateTracker tracker = new SubscriptionStateTracker(subId);
-                mTrackers.put(subId, tracker);
-                mTelephony.listen(tracker, LISTEN_SERVICE_STATE
-                        | LISTEN_SIGNAL_STRENGTHS
-                        | LISTEN_DATA_CONNECTION_STATE);
-            }
-            i++;
-        }
-    }
-
-    public void addListener(SubscriptionStateListener listener) {
-        mListeners.add(listener);
-    }
-
-    public void removeListener(SubscriptionStateListener listener) {
-        mListeners.remove(listener);
-    }
-
-    public SubscriptionInfo getActiveSubscriptionInfo(int subId) {
-        return mSubscriptionManager.getActiveSubscriptionInfo(subId);
-    }
-
-    public List<SubscriptionInfo> getActiveSubscriptionInfoList() {
-        return mSubscriptionManager.getActiveSubscriptionInfoList();
-    }
-
-    public String getSimOperatorName(int subId) {
-        return mTelephony.getSimOperatorName(subId);
-    }
-
-    public String getNetworkOperatorName(int subId) {
-        return mTelephony.getNetworkOperatorName(subId);
-    }
-
-    public ServiceState getServiceStateForSubscriber(int subId) {
-        return mTelephony.getServiceStateForSubscriber(subId);
-    }
-
-    public void changeDataSub(int subId) {
-        if (LOGV) {
-            Log.v(TAG, "changeDataSub{" +
-                    "subId='" + subId + '\'' +
-                    ", mChangingToDataSubId=" + mChangingToDataSubId +
-                    '}');
-        }
-        if (mChangingToDataSubId != subId) {
-            mSubscriptionManager.setDefaultDataSubId(subId);
-            for (SubscriptionStateListener subscriptionStateListener : mListeners) {
-                subscriptionStateListener
-                        .onDefaultDataSubscriptionChangeRequested(mChangingToDataSubId, subId);
-            }
-            mChangingToDataSubId = subId;
-        }
-    }
-
-    private void ddsHasChanged(int subId) {
-        if (subId > -1) {
-            for (SubscriptionStateListener subscriptionStateListener : mListeners) {
-                subscriptionStateListener.onDefaultDataSubscriptionChanged(subId);
-            }
-        }
-    }
-
-    private void simStateChanged(int subId, int simState) {
-        if (LOGV) {
-            Log.v(TAG,
-                    "simStateChanged(" + subId + ", " + simState + ")");
-        }
-        for (SubscriptionStateListener subscriptionStateListener : mListeners) {
-            subscriptionStateListener.onSimStateChanged(subId, simState);
-        }
-    }
-
-    public boolean simMissing() {
-        if (mTelephony == null) {
-            return false;
-        }
-        List<SubscriptionInfo> subs = mSubscriptionManager.getActiveSubscriptionInfoList();
-        if (subs != null) {
-            for (SubscriptionInfo sub : subs) {
-                int simState = mTelephony.getSimState(sub.getSimSlotIndex());
-                if (LOGV) {
-                    Log.v(TAG, "getSimState(" + sub.getSubscriptionId() + ") == " + simState);
-                }
-                int subId = sub.getSubscriptionId();
-                boolean isGsm = isGSM(subId);
-                boolean isLte = isLte(subId);
-                if ((isGsm || isLte) && simState != 1) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    // We only care that each slot has a sim
-    public boolean allSimsInserted() {
-        int simSlotCount = mTelephony.getSimCount();
-        for (int i = 0; i < simSlotCount; i++) {
-            int state = mTelephony.getSimState(i);
-            if (state == TelephonyManager.SIM_STATE_ABSENT) {
-                return false;
-            }
-        }
-        return simSlotCount == mSubscriptionManager.getActiveSubscriptionInfoCount();
-    }
-
-    public boolean isGSM(int subId) {
-        return mTelephony.getCurrentPhoneType(subId) == PHONE_TYPE_GSM;
-    }
-
-    public boolean isLte(int subId) {
-        return getLteOnCdmaMode(subId) == LTE_ON_CDMA_TRUE;
-    }
-
-    public int getLteOnCdmaMode(int subId) {
-        if (mTelephony == null || mTelephony.getLteOnCdmaMode(subId) == LTE_ON_CDMA_UNKNOWN) {
-            return SystemProperties.getInt("telephony.lteOnCdmaDevice", LTE_ON_CDMA_UNKNOWN);
-        }
-        return mTelephony.getLteOnCdmaMode(subId);
-    }
-
-    private void logPhoneState(String prefix) {
-        if (LOGV) {
-            Log.v(TAG, prefix + getPhoneState());
-        }
-    }
-
-    private String getPhoneTypeName() {
-        return getPhoneTypeName(mTelephony != null ? mTelephony.getCurrentPhoneType() : -1);
-    }
-
-    private int getMcc() {
-        return mContext.getResources().getConfiguration().mcc;
-    }
-
-    private int getMnc() {
-        return mContext.getResources().getConfiguration().mnc;
-    }
-
-    private String getPhoneTypeName(int phoneType) {
-        StringBuilder sb = new StringBuilder();
-        switch (phoneType) {
-            case PHONE_TYPE_NONE:
-                sb.append("PHONE_TYPE_NONE");
-                break;
-            case PHONE_TYPE_GSM:
-                sb.append("PHONE_TYPE_GSM");
-                break;
-            case PHONE_TYPE_CDMA:
-                sb.append("PHONE_TYPE_CDMA");
-                break;
-            case PHONE_TYPE_SIP:
-                sb.append("PHONE_TYPE_SIP");
-                break;
-        }
-        sb.append("(").append(phoneType).append(")");
-        return sb.toString();
-    }
-
-    private String getNetworkTypeName() {
-        return mTelephony != null ? mTelephony.getNetworkTypeName() : "";
-    }
-
-    private String getSubscriptionSimStateName(int subId) {
-        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
-        if (subInfo == null) {
-            return "SIM_STATE_UNKNOWN";
-        }
-        return mTelephony != null ?
-                getSimStateName(mTelephony.getSimState(subInfo.getSimSlotIndex())) : "";
-    }
-
-    private String getDataStateName() {
-        return mTelephony != null ? getDataStateName(mTelephony.getDataState()) : "";
-    }
-
-    private String getDataStateName(int dataState) {
-        StringBuilder sb = new StringBuilder();
-        switch (dataState) {
-            case DATA_UNKNOWN:
-                sb.append("DATA_UNKNOWN");
-                break;
-            case DATA_DISCONNECTED:
-                sb.append("DATA_DISCONNECTED");
-                break;
-            case DATA_CONNECTING:
-                sb.append("DATA_CONNECTING");
-                break;
-            case DATA_CONNECTED:
-                sb.append("DATA_CONNECTED");
-                break;
-            case DATA_SUSPENDED:
-                sb.append("DATA_SUSPENDED");
-                break;
-        }
-        sb.append("(").append(dataState).append(")");
-        return sb.toString();
-    }
-
-    private String getSimStateName(int simState) {
-        StringBuilder sb = new StringBuilder();
-        switch (simState) {
-            case SIM_STATE_UNKNOWN:
-                sb.append("SIM_STATE_UNKNOWN");
-                break;
-            case SIM_STATE_ABSENT:
-                sb.append("SIM_STATE_ABSENT");
-                break;
-            case SIM_STATE_PIN_REQUIRED:
-                sb.append("SIM_STATE_PIN_REQUIRED");
-                break;
-            case SIM_STATE_PUK_REQUIRED:
-                sb.append("SIM_STATE_PUK_REQUIRED");
-                break;
-            case SIM_STATE_NETWORK_LOCKED:
-                sb.append("SIM_STATE_NETWORK_LOCKED");
-                break;
-            case SIM_STATE_READY:
-                sb.append("SIM_STATE_READY");
-                break;
-            case SIM_STATE_CARD_IO_ERROR:
-                sb.append("SIM_STATE_CARD_IO_ERROR");
-                break;
-        }
-        sb.append("(").append(simState).append(")");
-        return sb.toString();
-    }
-
-    private String getVoiceServiceStateName(int subId) {
-        return getServiceStateName(getVoiceRegState(subId));
-    }
-
-    private String getDataServiceStateName(int subId) {
-        return getServiceStateName(getDataRegState(subId));
-    }
-
-    private int getVoiceRegState(int subId) {
-        SubscriptionStateTracker tracker = mTrackers.get(subId);
-        ServiceState serviceState = tracker != null ? tracker.mServiceState : null;
-        return serviceState != null ? serviceState.getVoiceRegState() : -1;
-    }
-
-    private int getDataRegState(int subId) {
-        SubscriptionStateTracker tracker = mTrackers.get(subId);
-        ServiceState serviceState = tracker != null ? tracker.mServiceState : null;
-        return serviceState != null ? serviceState.getDataRegState() : -1;
-    }
-
-    private String getServiceStateName(int serviceState) {
-        StringBuilder sb = new StringBuilder();
-        switch (serviceState) {
-            case STATE_IN_SERVICE:
-                sb.append("STATE_IN_SERVICE");
-                break;
-            case STATE_OUT_OF_SERVICE:
-                sb.append("STATE_OUT_OF_SERVICE");
-                break;
-            case STATE_EMERGENCY_ONLY:
-                sb.append("STATE_EMERGENCY_ONLY");
-                break;
-            case STATE_POWER_OFF:
-                sb.append("STATE_POWER_OFF");
-                break;
-        }
-        sb.append("(").append(serviceState).append(")");
-        return sb.toString();
-    }
-
-    private String getPhoneState() {
-        StringBuilder states = new StringBuilder();
-        for (int subId : mSubscriptionManager.getActiveSubscriptionIdList()) {
-            states.append(" ").append(getPhoneState(subId));
-        }
-        return getPhoneTypeName() + " \"" + getNetworkTypeName() + "\"" + " mcc" + getMcc() +
-                "mnc" + getMnc() + " " + getDataStateName() + " " + states.toString();
-    }
-
-    private String getPhoneState(int subId) {
-        return "{ " + getSubscriptionSimStateName(subId) + " Voice:"
-                + getVoiceServiceStateName(subId)
-                + " Data:" + getDataServiceStateName(subId) + "  }";
-    }
-
-    public interface SubscriptionStateListener {
-        void onServiceStateChanged(int subId, ServiceState serviceState);
-        void onDataConnectionStateChanged(int subId, int state, int networkType);
-        void onDefaultDataSubscriptionChanged(int subId);
-        void onDefaultDataSubscriptionChangeRequested(int currentSubId, int newSubId);
-        void onSignalStrengthsChanged(int subId, SignalStrength signalStrength);
-        void onSimStateChanged(int subId, int simState);
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/util/SetupWizardUtils.java b/src/com/cyanogenmod/setupwizard/util/SetupWizardUtils.java
deleted file mode 100644
index c1269ca..0000000
--- a/src/com/cyanogenmod/setupwizard/util/SetupWizardUtils.java
+++ /dev/null
@@ -1,380 +0,0 @@
-/*
- * Copyright (C) 2013 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.util;
-
-import static android.app.StatusBarManager.DISABLE_NONE;
-import static android.app.StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
-import static android.app.StatusBarManager.DISABLE_SEARCH;
-import static android.content.Context.MODE_PRIVATE;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_ACTIVITIES;
-import static android.content.pm.PackageManager.GET_RECEIVERS;
-import static android.content.pm.PackageManager.GET_SERVICES;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_DETECT_CAPTIVE_PORTAL;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.app.StatusBarManager;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.ComponentInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
-import android.hardware.fingerprint.FingerprintManager;
-import android.os.Binder;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.net.ConnectivityManager;
-import android.provider.Settings;
-import android.telephony.ServiceState;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.cyanogenmod.setupwizard.BluetoothSetupActivity;
-import com.cyanogenmod.setupwizard.ChooseDataSimActivity;
-import com.cyanogenmod.setupwizard.FingerprintActivity;
-import com.cyanogenmod.setupwizard.MobileDataActivity;
-import com.cyanogenmod.setupwizard.SetupWizardApp;
-import com.cyanogenmod.setupwizard.SimMissingActivity;
-import com.cyanogenmod.setupwizard.WifiSetupActivity;
-import com.cyanogenmod.setupwizard.wizardmanager.WizardManager;
-
-import org.lineageos.internal.util.PackageManagerUtils;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import lineageos.providers.LineageSettings;
-
-public class SetupWizardUtils {
-
-    private static final String TAG = SetupWizardUtils.class.getSimpleName();
-
-    private static final String GMS_PACKAGE = "com.google.android.gms";
-    private static final String GMS_SUW_PACKAGE = "com.google.android.setupwizard";
-    private static final String GMS_TV_SUW_PACKAGE = "com.google.android.tungsten.setupwraith";
-
-    private static final String PROP_BUILD_DATE = "ro.build.date.utc";
-
-    private SetupWizardUtils(){}
-
-    public static SharedPreferences getPrefs(Context context) {
-        return context.getSharedPreferences("SetupWizardPrefs", MODE_PRIVATE);
-    }
-
-    public static boolean isMobileDataEnabled(Context context) {
-        try {
-            TelephonyManager tm = context.getSystemService(TelephonyManager.class);
-            return tm.getDataEnabled();
-        } catch (Exception e) {
-            return false;
-        }
-    }
-
-    public static void setMobileDataEnabled(Context context, boolean enabled) {
-        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
-        if (tm.isMultiSimEnabled()) {
-            int phoneId = SubscriptionManager.from(context).getDefaultDataPhoneId();
-            android.provider.Settings.Global.putInt(context.getContentResolver(),
-                    android.provider.Settings.Global.MOBILE_DATA + phoneId, enabled ? 1 : 0);
-            int subId = SubscriptionManager.getDefaultDataSubscriptionId();
-            tm.setDataEnabled(subId, enabled);
-        } else {
-            android.provider.Settings.Global.putInt(context.getContentResolver(),
-                    android.provider.Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
-            tm.setDataEnabled(enabled);
-        }
-    }
-
-    public static boolean hasWifi(Context context) {
-        PackageManager packageManager = context.getPackageManager();
-        return packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI);
-    }
-
-    public static boolean hasTelephony(Context context) {
-        PackageManager packageManager = context.getPackageManager();
-        return packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
-    }
-
-    public static boolean isMultiSimDevice(Context context) {
-        TelephonyManager tm =
-                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-        return tm.isMultiSimEnabled();
-    }
-
-    public static boolean isRadioReady(Context context, ServiceState state) {
-        final SetupWizardApp setupWizardApp = (SetupWizardApp)context.getApplicationContext();
-        if (setupWizardApp.isRadioReady()) {
-            return true;
-        } else {
-            final boolean ready = state != null
-                    && state.getState() != ServiceState.STATE_POWER_OFF;
-            setupWizardApp.setRadioReady(ready);
-            return ready;
-        }
-
-    }
-
-    public static boolean isOwner() {
-        return UserHandle.myUserId() == 0;
-    }
-
-    public static void disableCaptivePortalDetection(Context context) {
-        Settings.Global.putInt(context.getContentResolver(), KEY_DETECT_CAPTIVE_PORTAL, 0);
-    }
-
-    public static void enableCaptivePortalDetection(Context context) {
-        Settings.Global.putInt(context.getContentResolver(), KEY_DETECT_CAPTIVE_PORTAL, 1);
-    }
-
-    public static void disableStatusBar(Context context) {
-        StatusBarManager statusBarManager = context.getSystemService(StatusBarManager.class);
-        if (statusBarManager != null) {
-            statusBarManager.disable(DISABLE_NOTIFICATION_ALERTS | DISABLE_SEARCH
-            );
-        } else {
-            Log.w(SetupWizardApp.TAG,
-                    "Skip disabling notfications - could not get StatusBarManager");
-        }
-    }
-
-    public static void enableStatusBar(Context context) {
-        StatusBarManager statusBarManager = context.getSystemService(StatusBarManager.class);
-        if(statusBarManager != null) {
-            Log.i(SetupWizardApp.TAG, "Enabling notfications - StatusBarManager");
-            statusBarManager.disable(DISABLE_NONE);
-        } else {
-            Log.i(SetupWizardApp.TAG, "Skip enabling notfications - StatusBarManager is null");
-        }
-    }
-
-    public static boolean hasGMS(Context context) {
-        if (PackageManagerUtils.isAppInstalled(context, GMS_PACKAGE) &&
-                PackageManagerUtils.isAppInstalled(context, GMS_SUW_PACKAGE)) {
-            PackageManager packageManager = context.getPackageManager();
-            if (LOGV) {
-                Log.v(TAG, GMS_SUW_PACKAGE + " state = " +
-                        packageManager.getApplicationEnabledSetting(GMS_SUW_PACKAGE));
-            }
-            return packageManager.getApplicationEnabledSetting(GMS_SUW_PACKAGE) !=
-                    COMPONENT_ENABLED_STATE_DISABLED;
-        }
-        return false;
-    }
-
-    public static boolean isPackageInstalled(Context context, String packageName) {
-        PackageManager pm = context.getPackageManager();
-        try {
-            pm.getPackageInfo(packageName, GET_ACTIVITIES);
-            return true;
-        } catch (PackageManager.NameNotFoundException e) {
-            return false;
-        }
-    }
-
-    public static void finishSetupWizard(Context context) {
-        ContentResolver contentResolver = context.getContentResolver();
-        Settings.Global.putInt(contentResolver,
-                Settings.Global.DEVICE_PROVISIONED, 1);
-        Settings.Secure.putInt(contentResolver,
-                Settings.Secure.USER_SETUP_COMPLETE, 1);
-
-        disableComponent(context, WizardManager.class);
-        disableHome(context);
-        context.sendStickyBroadcastAsUser(
-                new Intent(SetupWizardApp.ACTION_FINISHED),
-                Binder.getCallingUserHandle());
-        disableComponentSets(context, GET_RECEIVERS | GET_SERVICES);
-    }
-
-    public static boolean isEthernetConnected(Context context) {
-        ConnectivityManager cm = (ConnectivityManager) context.
-            getSystemService(Context.CONNECTIVITY_SERVICE);
-
-        return (cm.getActiveNetworkInfo() != null &&
-                cm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_ETHERNET);
-    }
-
-    public static boolean hasLeanback(Context context) {
-        PackageManager packageManager = context.getPackageManager();
-        return packageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
-    }
-
-    public static boolean hasFingerprint(Context context) {
-        FingerprintManager fingerprintManager = (FingerprintManager)
-                context.getSystemService(Context.FINGERPRINT_SERVICE);
-        return fingerprintManager.isHardwareDetected();
-    }
-
-    public static boolean simMissing() {
-        return PhoneMonitor.getInstance().simMissing();
-    }
-
-    public static void disableComponentsForMissingFeatures(Context context) {
-        if (!hasLeanback(context)) {
-            disableComponent(context, BluetoothSetupActivity.class);
-        }
-        if (!hasFingerprint(context)) {
-            disableComponent(context, FingerprintActivity.class);
-        }
-        if (!hasTelephony(context)) {
-            disableComponent(context, MobileDataActivity.class);
-            disableComponent(context, SimMissingActivity.class);
-            disableComponent(context, ChooseDataSimActivity.class);
-        }
-        if (!SetupWizardUtils.isMultiSimDevice(context)) {
-            disableComponent(context, ChooseDataSimActivity.class);
-        } else if (simMissing()) {
-            disableComponent(context, MobileDataActivity.class);
-            disableComponent(context, ChooseDataSimActivity.class);
-        }
-        if (!SetupWizardUtils.hasWifi(context) ||
-            isEthernetConnected(context)) {
-            disableComponent(context, WifiSetupActivity.class);
-        }
-
-        // Google's ATV SUW is shipped as it requires platform signature.
-        // Disable it if GMS is not installed by user.
-        if (hasLeanback(context) &&
-            !PackageManagerUtils.isAppInstalled(context, GMS_PACKAGE)) {
-            disableApplication(context, GMS_TV_SUW_PACKAGE);
-        }
-    }
-
-    public static void disableComponentsForGMS(Context context) {
-        disableComponent(context, WizardManager.class);
-        disableHome(context);
-    }
-
-    public static void disableHome(Context context) {
-        ComponentName homeComponent = getHomeComponent(context);
-        if (homeComponent != null) {
-            setComponentEnabledState(context, homeComponent, COMPONENT_ENABLED_STATE_DISABLED);
-        } else {
-            Log.w(TAG, "Home component not found. Skipping.");
-        }
-    }
-
-    public static ComponentName getHomeComponent(Context context) {
-        Intent intent = new Intent("android.intent.action.MAIN");
-        intent.addCategory("android.intent.category.HOME");
-        intent.setPackage(context.getPackageName());
-        ComponentName comp = intent.resolveActivity(context.getPackageManager());
-        if (SetupWizardApp.LOGV) {
-            Log.v(TAG, "resolveActivity for intent=" + intent + " returns " + comp);
-        }
-        return comp;
-    }
-
-    public static void disableApplication(Context context, String appname) {
-        context.getPackageManager().setApplicationEnabledSetting(appname,
-                COMPONENT_ENABLED_STATE_DISABLED, 0);
-    }
-
-    public static void disableComponentSets(Context context, int flags) {
-        setComponentListEnabledState(context, getComponentSets(context, flags),
-                COMPONENT_ENABLED_STATE_DISABLED);
-    }
-
-    public static void disableComponent(Context context, Class cls) {
-        setComponentEnabledState(context, new ComponentName(context, cls),
-                COMPONENT_ENABLED_STATE_DISABLED);
-    }
-
-    public static void enableComponent(Context context, Class<?> cls) {
-        setComponentEnabledState(context, new ComponentName(context, cls),
-                COMPONENT_ENABLED_STATE_ENABLED);
-    }
-
-    public static void resetComponentSets(Context context, int flags) {
-        setComponentListEnabledState(context, getComponentSets(context, flags),
-                COMPONENT_ENABLED_STATE_DEFAULT);
-    }
-
-    public static void resetComponent(Context context, Class<?> cls) {
-        setComponentEnabledState(context, new ComponentName(context, cls),
-                COMPONENT_ENABLED_STATE_DEFAULT);
-    }
-
-
-    public static void setComponentEnabledState(Context context, ComponentName componentName,
-            int enabledState) {
-        context.getPackageManager().setComponentEnabledSetting(componentName,
-                enabledState, DONT_KILL_APP);
-    }
-
-    public static void setComponentListEnabledState(Context context,
-            List<ComponentName> componentNames, int enabledState) {
-        for (ComponentName componentName : componentNames) {
-            setComponentEnabledState(context, componentName, enabledState);
-        }
-    }
-
-    public static List<ComponentName> getComponentSets(Context context, int flags) {
-        int i = 0;
-        List<ComponentName> componentNames = new ArrayList();
-        try {
-            PackageInfo allInfo = context.getPackageManager()
-                    .getPackageInfo(context.getPackageName(), flags);
-            if (allInfo != null) {
-                if (allInfo.activities != null && (flags & GET_ACTIVITIES) != 0) {
-                    for (ComponentInfo info : allInfo.activities) {
-                        componentNames.add(new ComponentName(context, info.name));
-                    }
-                }
-                if (allInfo.receivers != null && (flags & GET_RECEIVERS) != 0) {
-                    for (ComponentInfo info2 : allInfo.receivers) {
-                        componentNames.add(new ComponentName(context, info2.name));
-                    }
-                }
-                if (allInfo.services != null && (flags & GET_SERVICES) != 0) {
-                    ServiceInfo[] serviceInfoArr = allInfo.services;
-                    int length = serviceInfoArr.length;
-                    while (i < length) {
-                        componentNames.add(new ComponentName(context, serviceInfoArr[i].name));
-                        i++;
-                    }
-                }
-            }
-        } catch (PackageManager.NameNotFoundException e) {
-        }
-        return componentNames;
-    }
-
-
-    public static final ComponentName mTvwifisettingsActivity =
-            new ComponentName("com.android.tv.settings",
-                    "com.android.tv.settings.connectivity.setup.WifiSetupActivity");
-
-    public static final ComponentName mTvAddAccessorySettingsActivity =
-            new ComponentName("com.android.tv.settings",
-                    "com.android.tv.settings.accessories.AddAccessoryActivity");
-
-    public static long getBuildDateTimestamp() {
-        return SystemProperties.getLong(PROP_BUILD_DATE, 0);
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/widget/LocalePicker.java b/src/com/cyanogenmod/setupwizard/widget/LocalePicker.java
deleted file mode 100644
index d063687..0000000
--- a/src/com/cyanogenmod/setupwizard/widget/LocalePicker.java
+++ /dev/null
@@ -1,2607 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.widget;
-
-import com.cyanogenmod.setupwizard.R;
-
-import android.annotation.Widget;
-import android.content.Context;
-import android.content.res.ColorStateList;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.Paint.Align;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.text.InputFilter;
-import android.text.InputType;
-import android.text.Spanned;
-import android.text.TextUtils;
-import android.text.method.NumberKeyListener;
-import android.util.AttributeSet;
-import android.util.SparseArray;
-import android.util.TypedValue;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.VelocityTracker;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.accessibility.AccessibilityEvent;
-import android.view.accessibility.AccessibilityManager;
-import android.view.accessibility.AccessibilityNodeInfo;
-import android.view.accessibility.AccessibilityNodeProvider;
-import android.view.animation.DecelerateInterpolator;
-import android.view.inputmethod.EditorInfo;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.Scroller;
-import android.widget.TextView;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-
-import libcore.icu.LocaleData;
-
-/**
- * A widget that enables the user to select a number form a predefined range.
- * There are two flavors of this widget and which one is presented to the user
- * depends on the current theme.
- * <ul>
- * <li>
- * If the current theme is derived from {@link android.R.style#Theme} the widget
- * presents the current value as an editable input field with an increment button
- * above and a decrement button below. Long pressing the buttons allows for a quick
- * change of the current value. Tapping on the input field allows to type in
- * a desired value.
- * </li>
- * <li>
- * If the current theme is derived from {@link android.R.style#Theme_Holo} or
- * {@link android.R.style#Theme_Holo_Light} the widget presents the current
- * value as an editable input field with a lesser value above and a greater
- * value below. Tapping on the lesser or greater value selects it by animating
- * the number axis up or down to make the chosen value current. Flinging up
- * or down allows for multiple increments or decrements of the current value.
- * Long pressing on the lesser and greater values also allows for a quick change
- * of the current value. Tapping on the current value allows to type in a
- * desired value.
- * </li>
- * </ul>
- * <p>
- * For an example of using this widget, see {@link android.widget.TimePicker}.
- * </p>
- */
-@Widget
-public class LocalePicker extends LinearLayout {
-
-    /**
-     * The number of items show in the selector wheel.
-     */
-    private static int sSelectorWheelItemCount = 3;
-
-    /**
-     * The default update interval during long press.
-     */
-    private static final long DEFAULT_LONG_PRESS_UPDATE_INTERVAL = 300;
-
-    /**
-     * The index of the middle selector item.
-     */
-    private static int sSelectorMiddleItemIndex = sSelectorWheelItemCount / 2;
-
-    /**
-     * The coefficient by which to adjust (divide) the max fling velocity.
-     */
-    private static final int SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT = 8;
-
-    /**
-     * The the duration for adjusting the selector wheel.
-     */
-    private static final int SELECTOR_ADJUSTMENT_DURATION_MILLIS = 800;
-
-    /**
-     * The duration of scrolling while snapping to a given position.
-     */
-    private static final int SNAP_SCROLL_DURATION = 300;
-
-    /**
-     * The strength of fading in the top and bottom while drawing the selector.
-     */
-    private static final float TOP_AND_BOTTOM_FADING_EDGE_STRENGTH = 0.9f;
-
-    /**
-     * The default unscaled height of the selection divider.
-     */
-    private static final int UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT = 1;
-
-    /**
-     * The default unscaled distance between the selection dividers.
-     */
-    private static final int UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE = 48;
-
-    /**
-     * The resource id for the default layout.
-     */
-    private static final int DEFAULT_LAYOUT_RESOURCE_ID =
-            R.layout.locale_picker;
-
-    /**
-     * Constant for unspecified size.
-     */
-    private static final int SIZE_UNSPECIFIED = -1;
-
-    /**
-     * Use a custom NumberPicker formatting callback to use two-digit minutes
-     * strings like "01". Keeping a static formatter etc. is the most efficient
-     * way to do this; it avoids creating temporary objects on every call to
-     * format().
-     */
-    private static class TwoDigitFormatter implements LocalePicker.Formatter {
-        final StringBuilder mBuilder = new StringBuilder();
-
-        char mZeroDigit;
-        java.util.Formatter mFmt;
-
-        final Object[] mArgs = new Object[1];
-
-        TwoDigitFormatter() {
-            final Locale locale = Locale.getDefault();
-            init(locale);
-        }
-
-        private void init(Locale locale) {
-            mFmt = createFormatter(locale);
-            mZeroDigit = getZeroDigit(locale);
-        }
-
-        public String format(int value) {
-            final Locale currentLocale = Locale.getDefault();
-            if (mZeroDigit != getZeroDigit(currentLocale)) {
-                init(currentLocale);
-            }
-            mArgs[0] = value;
-            mBuilder.delete(0, mBuilder.length());
-            mFmt.format("%02d", mArgs);
-            return mFmt.toString();
-        }
-
-        private static char getZeroDigit(Locale locale) {
-            return LocaleData.get(locale).zeroDigit;
-        }
-
-        private java.util.Formatter createFormatter(Locale locale) {
-            return new java.util.Formatter(mBuilder, locale);
-        }
-    }
-
-    private static final TwoDigitFormatter sTwoDigitFormatter = new TwoDigitFormatter();
-
-    /**
-     * @hide
-     */
-    public static final Formatter getTwoDigitFormatter() {
-        return sTwoDigitFormatter;
-    }
-
-    /**
-     * The increment button.
-     */
-    private final ImageButton mIncrementButton;
-
-    /**
-     * The decrement button.
-     */
-    private final ImageButton mDecrementButton;
-
-    /**
-     * The text for showing the current value.
-     */
-    private final EditText mInputText;
-
-    /**
-     * The distance between the two selection dividers.
-     */
-    private final int mSelectionDividersDistance;
-
-    /**
-     * The min height of this widget.
-     */
-    private final int mMinHeight;
-
-    /**
-     * The max height of this widget.
-     */
-    private final int mMaxHeight;
-
-    /**
-     * The max width of this widget.
-     */
-    private final int mMinWidth;
-
-    /**
-     * The max width of this widget.
-     */
-    private int mMaxWidth;
-
-    /**
-     * Flag whether to compute the max width.
-     */
-    private final boolean mComputeMaxWidth;
-
-    /**
-     * The height of the text.
-     */
-    private final int mTextSize;
-
-    /**
-     * The height of the gap between text elements if the selector wheel.
-     */
-    private int mSelectorTextGapHeight;
-
-    /**
-     * The values to be displayed instead the indices.
-     */
-    private String[] mDisplayedValues;
-
-    /**
-     * Lower value of the range of numbers allowed for the NumberPicker
-     */
-    private int mMinValue;
-
-    /**
-     * Upper value of the range of numbers allowed for the NumberPicker
-     */
-    private int mMaxValue;
-
-    /**
-     * Current value of this NumberPicker
-     */
-    private int mValue;
-
-    /**
-     * Listener to be notified upon current value change.
-     */
-    private OnValueChangeListener mOnValueChangeListener;
-
-    /**
-     * Listener to be notified upon scroll state change.
-     */
-    private OnScrollListener mOnScrollListener;
-
-    /**
-     * Formatter for for displaying the current value.
-     */
-    private Formatter mFormatter;
-
-    /**
-     * The speed for updating the value form long press.
-     */
-    private long mLongPressUpdateInterval = DEFAULT_LONG_PRESS_UPDATE_INTERVAL;
-
-    /**
-     * Cache for the string representation of selector indices.
-     */
-    private final SparseArray<String> mSelectorIndexToStringCache = new SparseArray<String>();
-
-    /**
-     * The selector indices whose value are show by the selector.
-     */
-    private final int[] mSelectorIndices;
-
-    /**
-     * The {@link android.graphics.Paint} for drawing the selector.
-     */
-    private final Paint mSelectorWheelPaint;
-
-    /**
-     * The {@link android.graphics.drawable.Drawable} for pressed virtual (increment/decrement) buttons.
-     */
-    private final Drawable mVirtualButtonPressedDrawable;
-
-    /**
-     * The height of a selector element (text + gap).
-     */
-    private int mSelectorElementHeight;
-
-    /**
-     * The initial offset of the scroll selector.
-     */
-    private int mInitialScrollOffset = Integer.MIN_VALUE;
-
-    /**
-     * The current offset of the scroll selector.
-     */
-    private int mCurrentScrollOffset;
-
-    /**
-     * The {@link android.widget.Scroller} responsible for flinging the selector.
-     */
-    private final Scroller mFlingScroller;
-
-    /**
-     * The {@link android.widget.Scroller} responsible for adjusting the selector.
-     */
-    private final Scroller mAdjustScroller;
-
-    /**
-     * The previous Y coordinate while scrolling the selector.
-     */
-    private int mPreviousScrollerY;
-
-    /**
-     * Handle to the reusable command for setting the input text selection.
-     */
-    private SetSelectionCommand mSetSelectionCommand;
-
-    /**
-     * Handle to the reusable command for changing the current value from long
-     * press by one.
-     */
-    private ChangeCurrentByOneFromLongPressCommand mChangeCurrentByOneFromLongPressCommand;
-
-    /**
-     * Command for beginning an edit of the current value via IME on long press.
-     */
-    private BeginSoftInputOnLongPressCommand mBeginSoftInputOnLongPressCommand;
-
-    /**
-     * The Y position of the last down event.
-     */
-    private float mLastDownEventY;
-
-    /**
-     * The time of the last down event.
-     */
-    private long mLastDownEventTime;
-
-    /**
-     * The Y position of the last down or move event.
-     */
-    private float mLastDownOrMoveEventY;
-
-    /**
-     * Determines speed during touch scrolling.
-     */
-    private VelocityTracker mVelocityTracker;
-
-    /**
-     * @see android.view.ViewConfiguration#getScaledTouchSlop()
-     */
-    private int mTouchSlop;
-
-    /**
-     * @see android.view.ViewConfiguration#getScaledMinimumFlingVelocity()
-     */
-    private int mMinimumFlingVelocity;
-
-    /**
-     * @see android.view.ViewConfiguration#getScaledMaximumFlingVelocity()
-     */
-    private int mMaximumFlingVelocity;
-
-    /**
-     * Flag whether the selector should wrap around.
-     */
-    private boolean mWrapSelectorWheel;
-
-    /**
-     * The back ground color used to optimize scroller fading.
-     */
-    private final int mSolidColor;
-
-    /**
-     * Flag whether this widget has a selector wheel.
-     */
-    private final boolean mHasSelectorWheel;
-
-    /**
-     * Divider for showing item to be selected while scrolling
-     */
-    private final Drawable mSelectionDivider;
-
-    /**
-     * The height of the selection divider.
-     */
-    private final int mSelectionDividerHeight;
-
-    /**
-     * The current scroll state of the number picker.
-     */
-    private int mScrollState = OnScrollListener.SCROLL_STATE_IDLE;
-
-    /**
-     * Flag whether to ignore move events - we ignore such when we show in IME
-     * to prevent the content from scrolling.
-     */
-    private boolean mIngonreMoveEvents;
-
-    /**
-     * Flag whether to show soft input on tap.
-     */
-    private boolean mShowSoftInputOnTap;
-
-    /**
-     * The top of the top selection divider.
-     */
-    private int mTopSelectionDividerTop;
-
-    /**
-     * The bottom of the bottom selection divider.
-     */
-    private int mBottomSelectionDividerBottom;
-
-    /**
-     * The virtual id of the last hovered child.
-     */
-    private int mLastHoveredChildVirtualViewId;
-
-    /**
-     * Whether the increment virtual button is pressed.
-     */
-    private boolean mIncrementVirtualButtonPressed;
-
-    /**
-     * Whether the decrement virtual button is pressed.
-     */
-    private boolean mDecrementVirtualButtonPressed;
-
-    /**
-     * Provider to report to clients the semantic structure of this widget.
-     */
-    private AccessibilityNodeProviderImpl mAccessibilityNodeProvider;
-
-    /**
-     * Helper class for managing pressed state of the virtual buttons.
-     */
-    private final PressedStateHelper mPressedStateHelper;
-
-    /**
-     * The keycode of the last handled DPAD down event.
-     */
-    private int mLastHandledDownDpadKeyCode = -1;
-
-    /**
-     * Interface to listen for changes of the current value.
-     */
-    public interface OnValueChangeListener {
-
-        /**
-         * Called upon a change of the current value.
-         *
-         * @param picker The NumberPicker associated with this listener.
-         * @param oldVal The previous value.
-         * @param newVal The new value.
-         */
-        void onValueChange(LocalePicker picker, int oldVal, int newVal);
-    }
-
-    /**
-     * Interface to listen for the picker scroll state.
-     */
-    public interface OnScrollListener {
-
-        /**
-         * The view is not scrolling.
-         */
-        public static int SCROLL_STATE_IDLE = 0;
-
-        /**
-         * The user is scrolling using touch, and his finger is still on the screen.
-         */
-        public static int SCROLL_STATE_TOUCH_SCROLL = 1;
-
-        /**
-         * The user had previously been scrolling using touch and performed a fling.
-         */
-        public static int SCROLL_STATE_FLING = 2;
-
-        /**
-         * Callback invoked while the number picker scroll state has changed.
-         *
-         * @param view The view whose scroll state is being reported.
-         * @param scrollState The current scroll state. One of
-         *            {@link #SCROLL_STATE_IDLE},
-         *            {@link #SCROLL_STATE_TOUCH_SCROLL} or
-         *            {@link #SCROLL_STATE_IDLE}.
-         */
-        public void onScrollStateChange(LocalePicker view, int scrollState);
-    }
-
-    /**
-     * Interface used to format current value into a string for presentation.
-     */
-    public interface Formatter {
-
-        /**
-         * Formats a string representation of the current value.
-         *
-         * @param value The currently selected value.
-         * @return A formatted string representation.
-         */
-        public String format(int value);
-    }
-
-    /**
-     * Create a new number picker.
-     *
-     * @param context The application environment.
-     */
-    public LocalePicker(Context context) {
-        this(context, null);
-    }
-
-    /**
-     * Create a new number picker.
-     *
-     * @param context The application environment.
-     * @param attrs A collection of attributes.
-     */
-    public LocalePicker(Context context, AttributeSet attrs) {
-        this(context, attrs, R.attr.localePickerStyle);
-    }
-
-    /**
-     * Create a new number picker
-     *
-     * @param context the application environment.
-     * @param attrs a collection of attributes.
-     * @param defStyle The default style to apply to this view.
-     */
-    public LocalePicker(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        sSelectorWheelItemCount = context.getResources().getInteger(R.integer.local_picker_items);
-        sSelectorMiddleItemIndex = context.getResources().getInteger(R.integer.local_picker_items)/2;
-        mSelectorIndices= new int[sSelectorWheelItemCount];
-        // process style attributes
-        TypedArray attributesArray = context.obtainStyledAttributes(
-                attrs, R.styleable.LocalePicker, defStyle, 0);
-        final int layoutResId = attributesArray.getResourceId(
-                R.styleable.LocalePicker_internalLayout, DEFAULT_LAYOUT_RESOURCE_ID);
-
-        mHasSelectorWheel = true;
-
-        mSolidColor = attributesArray.getColor(R.styleable.LocalePicker_solidColor, 0);
-
-        mSelectionDivider = attributesArray.getDrawable(R.styleable.LocalePicker_selectionDivider);
-
-        final int defSelectionDividerHeight = (int) TypedValue.applyDimension(
-                TypedValue.COMPLEX_UNIT_DIP, UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT,
-                getResources().getDisplayMetrics());
-        mSelectionDividerHeight = attributesArray.getDimensionPixelSize(
-                R.styleable.LocalePicker_selectionDividerHeight, defSelectionDividerHeight);
-
-        final int defSelectionDividerDistance = (int) TypedValue.applyDimension(
-                TypedValue.COMPLEX_UNIT_DIP, UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE,
-                getResources().getDisplayMetrics());
-        mSelectionDividersDistance = attributesArray.getDimensionPixelSize(
-                R.styleable.LocalePicker_selectionDividersDistance, defSelectionDividerDistance);
-
-        mMinHeight = attributesArray.getDimensionPixelSize(
-                R.styleable.LocalePicker_internalMinHeight, SIZE_UNSPECIFIED);
-
-        mMaxHeight = attributesArray.getDimensionPixelSize(
-                R.styleable.LocalePicker_internalMaxHeight, SIZE_UNSPECIFIED);
-        if (mMinHeight != SIZE_UNSPECIFIED && mMaxHeight != SIZE_UNSPECIFIED
-                && mMinHeight > mMaxHeight) {
-            throw new IllegalArgumentException("minHeight > maxHeight");
-        }
-
-        mMinWidth = attributesArray.getDimensionPixelSize(
-                R.styleable.LocalePicker_internalMinWidth, SIZE_UNSPECIFIED);
-
-        mMaxWidth = attributesArray.getDimensionPixelSize(
-                R.styleable.LocalePicker_internalMaxWidth, SIZE_UNSPECIFIED);
-        if (mMinWidth != SIZE_UNSPECIFIED && mMaxWidth != SIZE_UNSPECIFIED
-                && mMinWidth > mMaxWidth) {
-            throw new IllegalArgumentException("minWidth > maxWidth");
-        }
-
-        mComputeMaxWidth = (mMaxWidth == SIZE_UNSPECIFIED);
-
-        mVirtualButtonPressedDrawable = attributesArray.getDrawable(
-                R.styleable.LocalePicker_virtualButtonPressedDrawable);
-
-        attributesArray.recycle();
-
-        mPressedStateHelper = new PressedStateHelper();
-
-        // By default Linearlayout that we extend is not drawn. This is
-        // its draw() method is not called but dispatchDraw() is called
-        // directly (see ViewGroup.drawChild()). However, this class uses
-        // the fading edge effect implemented by View and we need our
-        // draw() method to be called. Therefore, we declare we will draw.
-        setWillNotDraw(!mHasSelectorWheel);
-
-        LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
-                Context.LAYOUT_INFLATER_SERVICE);
-        inflater.inflate(layoutResId, this, true);
-
-        OnClickListener onClickListener = new OnClickListener() {
-            public void onClick(View v) {
-                hideSoftInput();
-                mInputText.clearFocus();
-                if (v.getId() == R.id.lp__increment) {
-                    changeValueByOne(true);
-                } else {
-                    changeValueByOne(false);
-                }
-            }
-        };
-
-        OnLongClickListener onLongClickListener = new OnLongClickListener() {
-            public boolean onLongClick(View v) {
-                hideSoftInput();
-                mInputText.clearFocus();
-                if (v.getId() == R.id.lp__increment) {
-                    postChangeCurrentByOneFromLongPress(true, 0);
-                } else {
-                    postChangeCurrentByOneFromLongPress(false, 0);
-                }
-                return true;
-            }
-        };
-
-        // increment button
-        if (!mHasSelectorWheel) {
-            mIncrementButton = (ImageButton) findViewById(R.id.lp__increment);
-            mIncrementButton.setOnClickListener(onClickListener);
-            mIncrementButton.setOnLongClickListener(onLongClickListener);
-        } else {
-            mIncrementButton = null;
-        }
-
-        // decrement button
-        if (!mHasSelectorWheel) {
-            mDecrementButton = (ImageButton) findViewById(R.id.lp__decrement);
-            mDecrementButton.setOnClickListener(onClickListener);
-            mDecrementButton.setOnLongClickListener(onLongClickListener);
-        } else {
-            mDecrementButton = null;
-        }
-
-        // input text
-        mInputText = (EditText) findViewById(R.id.localepicker_input);
-        mInputText.setOnFocusChangeListener(new OnFocusChangeListener() {
-            public void onFocusChange(View v, boolean hasFocus) {
-                if (hasFocus) {
-                    mInputText.selectAll();
-                } else {
-                    mInputText.setSelection(0, 0);
-                    validateInputTextView(v);
-                }
-            }
-        });
-        mInputText.setFilters(new InputFilter[] {
-            new InputTextFilter()
-        });
-
-        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
-        mInputText.setImeOptions(EditorInfo.IME_ACTION_DONE);
-
-        // initialize constants
-        ViewConfiguration configuration = ViewConfiguration.get(context);
-        mTouchSlop = configuration.getScaledTouchSlop();
-        mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
-        mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity()
-                / SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT;
-        mTextSize = (int) mInputText.getTextSize();
-
-        // create the selector wheel paint
-        Paint paint = new Paint();
-        paint.setAntiAlias(true);
-        paint.setTextAlign(Align.CENTER);
-        paint.setTextSize(mTextSize);
-        paint.setTypeface(mInputText.getTypeface());
-        ColorStateList colors = mInputText.getTextColors();
-        int color = colors.getColorForState(ENABLED_STATE_SET, Color.WHITE);
-        paint.setColor(color);
-        mSelectorWheelPaint = paint;
-
-        // create the fling and adjust scrollers
-        mFlingScroller = new Scroller(getContext(), null, true);
-        mAdjustScroller = new Scroller(getContext(), new DecelerateInterpolator(2.5f));
-
-        updateInputTextView();
-
-        // If not explicitly specified this view is important for accessibility.
-        if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
-            setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
-        }
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        if (!mHasSelectorWheel) {
-            super.onLayout(changed, left, top, right, bottom);
-            return;
-        }
-        final int msrdWdth = getMeasuredWidth();
-        final int msrdHght = getMeasuredHeight();
-
-        // Input text centered horizontally.
-        final int inptTxtMsrdWdth = mInputText.getMeasuredWidth();
-        final int inptTxtMsrdHght = mInputText.getMeasuredHeight();
-        final int inptTxtLeft = (msrdWdth - inptTxtMsrdWdth) / 2;
-        final int inptTxtTop = (msrdHght - inptTxtMsrdHght) / 2;
-        final int inptTxtRight = inptTxtLeft + inptTxtMsrdWdth;
-        final int inptTxtBottom = inptTxtTop + inptTxtMsrdHght;
-        mInputText.layout(inptTxtLeft, inptTxtTop, inptTxtRight, inptTxtBottom);
-
-        if (changed) {
-            // need to do all this when we know our size
-            initializeSelectorWheel();
-            initializeFadingEdges();
-            mTopSelectionDividerTop = (getHeight() - mSelectionDividersDistance) / 2
-                    - mSelectionDividerHeight;
-            mBottomSelectionDividerBottom = mTopSelectionDividerTop + 2 * mSelectionDividerHeight
-                    + mSelectionDividersDistance;
-        }
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        if (!mHasSelectorWheel) {
-            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-            return;
-        }
-        // Try greedily to fit the max width and height.
-        final int newWidthMeasureSpec = makeMeasureSpec(widthMeasureSpec, mMaxWidth);
-        final int newHeightMeasureSpec = makeMeasureSpec(heightMeasureSpec, mMaxHeight);
-        super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
-        // Flag if we are measured with width or height less than the respective min.
-        final int widthSize = resolveSizeAndStateRespectingMinSize(mMinWidth, getMeasuredWidth(),
-                widthMeasureSpec);
-        final int heightSize = resolveSizeAndStateRespectingMinSize(mMinHeight, getMeasuredHeight(),
-                heightMeasureSpec);
-        setMeasuredDimension(widthSize, heightSize);
-    }
-
-    /**
-     * Move to the final position of a scroller. Ensures to force finish the scroller
-     * and if it is not at its final position a scroll of the selector wheel is
-     * performed to fast forward to the final position.
-     *
-     * @param scroller The scroller to whose final position to get.
-     * @return True of the a move was performed, i.e. the scroller was not in final position.
-     */
-    private boolean moveToFinalScrollerPosition(Scroller scroller) {
-        scroller.forceFinished(true);
-        int amountToScroll = scroller.getFinalY() - scroller.getCurrY();
-        int futureScrollOffset = (mCurrentScrollOffset + amountToScroll) % mSelectorElementHeight;
-        int overshootAdjustment = mInitialScrollOffset - futureScrollOffset;
-        if (overshootAdjustment != 0) {
-            if (Math.abs(overshootAdjustment) > mSelectorElementHeight / 2) {
-                if (overshootAdjustment > 0) {
-                    overshootAdjustment -= mSelectorElementHeight;
-                } else {
-                    overshootAdjustment += mSelectorElementHeight;
-                }
-            }
-            amountToScroll += overshootAdjustment;
-            scrollBy(0, amountToScroll);
-            return true;
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent event) {
-        if (!mHasSelectorWheel || !isEnabled()) {
-            return false;
-        }
-        final int action = event.getActionMasked();
-        switch (action) {
-            case MotionEvent.ACTION_DOWN: {
-                removeAllCallbacks();
-                mInputText.setVisibility(View.INVISIBLE);
-                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
-                mLastDownEventTime = event.getEventTime();
-                mIngonreMoveEvents = false;
-                mShowSoftInputOnTap = false;
-                // Handle pressed state before any state change.
-                if (mLastDownEventY < mTopSelectionDividerTop) {
-                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
-                        mPressedStateHelper.buttonPressDelayed(
-                                PressedStateHelper.BUTTON_DECREMENT);
-                    }
-                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
-                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
-                        mPressedStateHelper.buttonPressDelayed(
-                                PressedStateHelper.BUTTON_INCREMENT);
-                    }
-                }
-                // Make sure we support flinging inside scrollables.
-                getParent().requestDisallowInterceptTouchEvent(true);
-                if (!mFlingScroller.isFinished()) {
-                    mFlingScroller.forceFinished(true);
-                    mAdjustScroller.forceFinished(true);
-                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
-                } else if (!mAdjustScroller.isFinished()) {
-                    mFlingScroller.forceFinished(true);
-                    mAdjustScroller.forceFinished(true);
-                } else if (mLastDownEventY < mTopSelectionDividerTop) {
-                    hideSoftInput();
-                    postChangeCurrentByOneFromLongPress(
-                            false, ViewConfiguration.getLongPressTimeout());
-                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
-                    hideSoftInput();
-                    postChangeCurrentByOneFromLongPress(
-                            true, ViewConfiguration.getLongPressTimeout());
-                } else {
-                    mShowSoftInputOnTap = true;
-                    postBeginSoftInputOnLongPressCommand();
-                }
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        if (!isEnabled() || !mHasSelectorWheel) {
-            return false;
-        }
-        if (mVelocityTracker == null) {
-            mVelocityTracker = VelocityTracker.obtain();
-        }
-        mVelocityTracker.addMovement(event);
-        int action = event.getActionMasked();
-        switch (action) {
-            case MotionEvent.ACTION_MOVE: {
-                if (mIngonreMoveEvents) {
-                    break;
-                }
-                float currentMoveY = event.getY();
-                if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
-                    int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
-                    if (deltaDownY > mTouchSlop) {
-                        removeAllCallbacks();
-                        onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
-                    }
-                } else {
-                    int deltaMoveY = (int) ((currentMoveY - mLastDownOrMoveEventY));
-                    scrollBy(0, deltaMoveY);
-                    invalidate();
-                }
-                mLastDownOrMoveEventY = currentMoveY;
-            } break;
-            case MotionEvent.ACTION_UP: {
-                removeBeginSoftInputCommand();
-                removeChangeCurrentByOneFromLongPress();
-                mPressedStateHelper.cancel();
-                VelocityTracker velocityTracker = mVelocityTracker;
-                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
-                int initialVelocity = (int) velocityTracker.getYVelocity();
-                if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
-                    fling(initialVelocity);
-                    onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
-                } else {
-                    int eventY = (int) event.getY();
-                    int deltaMoveY = (int) Math.abs(eventY - mLastDownEventY);
-                    long deltaTime = event.getEventTime() - mLastDownEventTime;
-                    if (deltaMoveY <= mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
-                        if (mShowSoftInputOnTap) {
-                            mShowSoftInputOnTap = false;
-                            showSoftInput();
-                        } else {
-                            int selectorIndexOffset = (eventY / mSelectorElementHeight)
-                                    - sSelectorMiddleItemIndex;
-                            if (selectorIndexOffset > 0) {
-                                changeValueByOne(true);
-                                mPressedStateHelper.buttonTapped(
-                                        PressedStateHelper.BUTTON_INCREMENT);
-                            } else if (selectorIndexOffset < 0) {
-                                changeValueByOne(false);
-                                mPressedStateHelper.buttonTapped(
-                                        PressedStateHelper.BUTTON_DECREMENT);
-                            }
-                        }
-                    } else {
-                        ensureScrollWheelAdjusted();
-                    }
-                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
-                }
-                mVelocityTracker.recycle();
-                mVelocityTracker = null;
-            } break;
-        }
-        return true;
-    }
-
-    @Override
-    public boolean dispatchTouchEvent(MotionEvent event) {
-        final int action = event.getActionMasked();
-        switch (action) {
-            case MotionEvent.ACTION_CANCEL:
-            case MotionEvent.ACTION_UP:
-                removeAllCallbacks();
-                break;
-        }
-        return super.dispatchTouchEvent(event);
-    }
-
-    @Override
-    public boolean dispatchKeyEvent(KeyEvent event) {
-        final int keyCode = event.getKeyCode();
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_DPAD_CENTER:
-            case KeyEvent.KEYCODE_ENTER:
-                removeAllCallbacks();
-                break;
-            case KeyEvent.KEYCODE_DPAD_DOWN:
-            case KeyEvent.KEYCODE_DPAD_UP:
-                if (!mHasSelectorWheel) {
-                    break;
-                }
-                switch (event.getAction()) {
-                    case KeyEvent.ACTION_DOWN:
-                        if (mWrapSelectorWheel || (keyCode == KeyEvent.KEYCODE_DPAD_DOWN)
-                                ? getValue() < getMaxValue() : getValue() > getMinValue()) {
-                            requestFocus();
-                            mLastHandledDownDpadKeyCode = keyCode;
-                            removeAllCallbacks();
-                            if (mFlingScroller.isFinished()) {
-                                changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
-                            }
-                            return true;
-                        }
-                        break;
-                    case KeyEvent.ACTION_UP:
-                        if (mLastHandledDownDpadKeyCode == keyCode) {
-                            mLastHandledDownDpadKeyCode = -1;
-                            return true;
-                        }
-                        break;
-                }
-        }
-        return super.dispatchKeyEvent(event);
-    }
-
-    @Override
-    public boolean dispatchTrackballEvent(MotionEvent event) {
-        final int action = event.getActionMasked();
-        switch (action) {
-            case MotionEvent.ACTION_CANCEL:
-            case MotionEvent.ACTION_UP:
-                removeAllCallbacks();
-                break;
-        }
-        return super.dispatchTrackballEvent(event);
-    }
-
-    @Override
-    protected boolean dispatchHoverEvent(MotionEvent event) {
-        if (!mHasSelectorWheel) {
-            return super.dispatchHoverEvent(event);
-        }
-        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
-            final int eventY = (int) event.getY();
-            final int hoveredVirtualViewId;
-            if (eventY < mTopSelectionDividerTop) {
-                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_DECREMENT;
-            } else if (eventY > mBottomSelectionDividerBottom) {
-                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INCREMENT;
-            } else {
-                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INPUT;
-            }
-            final int action = event.getActionMasked();
-            AccessibilityNodeProviderImpl provider =
-                (AccessibilityNodeProviderImpl) getAccessibilityNodeProvider();
-            switch (action) {
-                case MotionEvent.ACTION_HOVER_ENTER: {
-                    provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
-                            AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
-                    mLastHoveredChildVirtualViewId = hoveredVirtualViewId;
-                    provider.performAction(hoveredVirtualViewId,
-                            AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
-                } break;
-                case MotionEvent.ACTION_HOVER_MOVE: {
-                    if (mLastHoveredChildVirtualViewId != hoveredVirtualViewId
-                            && mLastHoveredChildVirtualViewId != View.NO_ID) {
-                        provider.sendAccessibilityEventForVirtualView(
-                                mLastHoveredChildVirtualViewId,
-                                AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
-                        provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
-                                AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
-                        mLastHoveredChildVirtualViewId = hoveredVirtualViewId;
-                        provider.performAction(hoveredVirtualViewId,
-                                AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
-                    }
-                } break;
-                case MotionEvent.ACTION_HOVER_EXIT: {
-                    provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
-                            AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
-                    mLastHoveredChildVirtualViewId = View.NO_ID;
-                } break;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public void computeScroll() {
-        Scroller scroller = mFlingScroller;
-        if (scroller.isFinished()) {
-            scroller = mAdjustScroller;
-            if (scroller.isFinished()) {
-                return;
-            }
-        }
-        scroller.computeScrollOffset();
-        int currentScrollerY = scroller.getCurrY();
-        if (mPreviousScrollerY == 0) {
-            mPreviousScrollerY = scroller.getStartY();
-        }
-        scrollBy(0, currentScrollerY - mPreviousScrollerY);
-        mPreviousScrollerY = currentScrollerY;
-        if (scroller.isFinished()) {
-            onScrollerFinished(scroller);
-        } else {
-            invalidate();
-        }
-    }
-
-    @Override
-    public void setEnabled(boolean enabled) {
-        super.setEnabled(enabled);
-        if (!mHasSelectorWheel) {
-            mIncrementButton.setEnabled(enabled);
-        }
-        if (!mHasSelectorWheel) {
-            mDecrementButton.setEnabled(enabled);
-        }
-        mInputText.setEnabled(enabled);
-    }
-
-    @Override
-    public void scrollBy(int x, int y) {
-        int[] selectorIndices = mSelectorIndices;
-        if (!mWrapSelectorWheel && y > 0
-                && selectorIndices[sSelectorMiddleItemIndex] <= mMinValue) {
-            mCurrentScrollOffset = mInitialScrollOffset;
-            return;
-        }
-        if (!mWrapSelectorWheel && y < 0
-                && selectorIndices[sSelectorMiddleItemIndex] >= mMaxValue) {
-            mCurrentScrollOffset = mInitialScrollOffset;
-            return;
-        }
-        mCurrentScrollOffset += y;
-        while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
-            mCurrentScrollOffset -= mSelectorElementHeight;
-            decrementSelectorIndices(selectorIndices);
-            setValueInternal(selectorIndices[sSelectorMiddleItemIndex], true);
-            if (!mWrapSelectorWheel && selectorIndices[sSelectorMiddleItemIndex] <= mMinValue) {
-                mCurrentScrollOffset = mInitialScrollOffset;
-            }
-        }
-        while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
-            mCurrentScrollOffset += mSelectorElementHeight;
-            incrementSelectorIndices(selectorIndices);
-            setValueInternal(selectorIndices[sSelectorMiddleItemIndex], true);
-            if (!mWrapSelectorWheel && selectorIndices[sSelectorMiddleItemIndex] >= mMaxValue) {
-                mCurrentScrollOffset = mInitialScrollOffset;
-            }
-        }
-    }
-
-    @Override
-    public int getSolidColor() {
-        return mSolidColor;
-    }
-
-    /**
-     * Sets the listener to be notified on change of the current value.
-     *
-     * @param onValueChangedListener The listener.
-     */
-    public void setOnValueChangedListener(OnValueChangeListener onValueChangedListener) {
-        mOnValueChangeListener = onValueChangedListener;
-    }
-
-    /**
-     * Set listener to be notified for scroll state changes.
-     *
-     * @param onScrollListener The listener.
-     */
-    public void setOnScrollListener(OnScrollListener onScrollListener) {
-        mOnScrollListener = onScrollListener;
-    }
-
-    /**
-     * Set the formatter to be used for formatting the current value.
-     * <p>
-     * Note: If you have provided alternative values for the values this
-     * formatter is never invoked.
-     * </p>
-     *
-     * @param formatter The formatter object. If formatter is <code>null</code>,
-     *            {@link String#valueOf(int)} will be used.
-     *@see #setDisplayedValues(String[])
-     */
-    public void setFormatter(Formatter formatter) {
-        if (formatter == mFormatter) {
-            return;
-        }
-        mFormatter = formatter;
-        initializeSelectorWheelIndices();
-        updateInputTextView();
-    }
-
-    /**
-     * Set the current value for the number picker.
-     * <p>
-     * If the argument is less than the {@link LocalePicker#getMinValue()} and
-     * {@link LocalePicker#getWrapSelectorWheel()} is <code>false</code> the
-     * current value is set to the {@link LocalePicker#getMinValue()} value.
-     * </p>
-     * <p>
-     * If the argument is less than the {@link LocalePicker#getMinValue()} and
-     * {@link LocalePicker#getWrapSelectorWheel()} is <code>true</code> the
-     * current value is set to the {@link LocalePicker#getMaxValue()} value.
-     * </p>
-     * <p>
-     * If the argument is less than the {@link LocalePicker#getMaxValue()} and
-     * {@link LocalePicker#getWrapSelectorWheel()} is <code>false</code> the
-     * current value is set to the {@link LocalePicker#getMaxValue()} value.
-     * </p>
-     * <p>
-     * If the argument is less than the {@link LocalePicker#getMaxValue()} and
-     * {@link LocalePicker#getWrapSelectorWheel()} is <code>true</code> the
-     * current value is set to the {@link LocalePicker#getMinValue()} value.
-     * </p>
-     *
-     * @param value The current value.
-     * @see #setWrapSelectorWheel(boolean)
-     * @see #setMinValue(int)
-     * @see #setMaxValue(int)
-     */
-    public void setValue(int value) {
-        setValueInternal(value, false);
-    }
-
-    /**
-     * Shows the soft input for its input text.
-     */
-    private void showSoftInput() {
-        InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
-        if (inputMethodManager != null) {
-            if (mHasSelectorWheel) {
-                mInputText.setVisibility(View.VISIBLE);
-            }
-            mInputText.requestFocus();
-            inputMethodManager.showSoftInput(mInputText, 0);
-        }
-    }
-
-    /**
-     * Hides the soft input if it is active for the input text.
-     */
-    private void hideSoftInput() {
-        InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
-        if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
-            inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
-            if (mHasSelectorWheel) {
-                mInputText.setVisibility(View.INVISIBLE);
-            }
-        }
-    }
-
-    /**
-     * Computes the max width if no such specified as an attribute.
-     */
-    private void tryComputeMaxWidth() {
-        if (!mComputeMaxWidth) {
-            return;
-        }
-        int maxTextWidth = 0;
-        if (mDisplayedValues == null) {
-            float maxDigitWidth = 0;
-            for (int i = 0; i <= 9; i++) {
-                final float digitWidth = mSelectorWheelPaint.measureText(formatNumberWithLocale(i));
-                if (digitWidth > maxDigitWidth) {
-                    maxDigitWidth = digitWidth;
-                }
-            }
-            int numberOfDigits = 0;
-            int current = mMaxValue;
-            while (current > 0) {
-                numberOfDigits++;
-                current = current / 10;
-            }
-            maxTextWidth = (int) (numberOfDigits * maxDigitWidth);
-        } else {
-            final int valueCount = mDisplayedValues.length;
-            for (int i = 0; i < valueCount; i++) {
-                final float textWidth = mSelectorWheelPaint.measureText(mDisplayedValues[i]);
-                if (textWidth > maxTextWidth) {
-                    maxTextWidth = (int) textWidth;
-                }
-            }
-        }
-        maxTextWidth += mInputText.getPaddingLeft() + mInputText.getPaddingRight();
-        if (mMaxWidth != maxTextWidth) {
-            if (maxTextWidth > mMinWidth) {
-                mMaxWidth = maxTextWidth;
-            } else {
-                mMaxWidth = mMinWidth;
-            }
-            invalidate();
-        }
-    }
-
-    /**
-     * Gets whether the selector wheel wraps when reaching the min/max value.
-     *
-     * @return True if the selector wheel wraps.
-     *
-     * @see #getMinValue()
-     * @see #getMaxValue()
-     */
-    public boolean getWrapSelectorWheel() {
-        return mWrapSelectorWheel;
-    }
-
-    /**
-     * Sets whether the selector wheel shown during flinging/scrolling should
-     * wrap around the {@link LocalePicker#getMinValue()} and
-     * {@link LocalePicker#getMaxValue()} values.
-     * <p>
-     * By default if the range (max - min) is more than the number of items shown
-     * on the selector wheel the selector wheel wrapping is enabled.
-     * </p>
-     * <p>
-     * <strong>Note:</strong> If the number of items, i.e. the range (
-     * {@link #getMaxValue()} - {@link #getMinValue()}) is less than
-     * the number of items shown on the selector wheel, the selector wheel will
-     * not wrap. Hence, in such a case calling this method is a NOP.
-     * </p>
-     *
-     * @param wrapSelectorWheel Whether to wrap.
-     */
-    public void setWrapSelectorWheel(boolean wrapSelectorWheel) {
-        final boolean wrappingAllowed = (mMaxValue - mMinValue) >= mSelectorIndices.length;
-        if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != mWrapSelectorWheel) {
-            mWrapSelectorWheel = wrapSelectorWheel;
-        }
-    }
-
-    /**
-     * Sets the speed at which the numbers be incremented and decremented when
-     * the up and down buttons are long pressed respectively.
-     * <p>
-     * The default value is 300 ms.
-     * </p>
-     *
-     * @param intervalMillis The speed (in milliseconds) at which the numbers
-     *            will be incremented and decremented.
-     */
-    public void setOnLongPressUpdateInterval(long intervalMillis) {
-        mLongPressUpdateInterval = intervalMillis;
-    }
-
-    /**
-     * Returns the value of the picker.
-     *
-     * @return The value.
-     */
-    public int getValue() {
-        return mValue;
-    }
-
-    /**
-     * Returns the min value of the picker.
-     *
-     * @return The min value
-     */
-    public int getMinValue() {
-        return mMinValue;
-    }
-
-    /**
-     * Sets the min value of the picker.
-     *
-     * @param minValue The min value inclusive.
-     *
-     * <strong>Note:</strong> The length of the displayed values array
-     * set via {@link #setDisplayedValues(String[])} must be equal to the
-     * range of selectable numbers which is equal to
-     * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
-     */
-    public void setMinValue(int minValue) {
-        if (mMinValue == minValue) {
-            return;
-        }
-        if (minValue < 0) {
-            throw new IllegalArgumentException("minValue must be >= 0");
-        }
-        mMinValue = minValue;
-        if (mMinValue > mValue) {
-            mValue = mMinValue;
-        }
-        boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
-        setWrapSelectorWheel(wrapSelectorWheel);
-        initializeSelectorWheelIndices();
-        updateInputTextView();
-        tryComputeMaxWidth();
-        invalidate();
-    }
-
-    /**
-     * Returns the max value of the picker.
-     *
-     * @return The max value.
-     */
-    public int getMaxValue() {
-        return mMaxValue;
-    }
-
-    /**
-     * Sets the max value of the picker.
-     *
-     * @param maxValue The max value inclusive.
-     *
-     * <strong>Note:</strong> The length of the displayed values array
-     * set via {@link #setDisplayedValues(String[])} must be equal to the
-     * range of selectable numbers which is equal to
-     * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
-     */
-    public void setMaxValue(int maxValue) {
-        if (mMaxValue == maxValue) {
-            return;
-        }
-        if (maxValue < 0) {
-            throw new IllegalArgumentException("maxValue must be >= 0");
-        }
-        mMaxValue = maxValue;
-        if (mMaxValue < mValue) {
-            mValue = mMaxValue;
-        }
-        boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
-        setWrapSelectorWheel(wrapSelectorWheel);
-        initializeSelectorWheelIndices();
-        updateInputTextView();
-        tryComputeMaxWidth();
-        invalidate();
-    }
-
-    /**
-     * Gets the values to be displayed instead of string values.
-     *
-     * @return The displayed values.
-     */
-    public String[] getDisplayedValues() {
-        return mDisplayedValues;
-    }
-
-    /**
-     * Sets the values to be displayed.
-     *
-     * @param displayedValues The displayed values.
-     *
-     * <strong>Note:</strong> The length of the displayed values array
-     * must be equal to the range of selectable numbers which is equal to
-     * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
-     */
-    public void setDisplayedValues(String[] displayedValues) {
-        if (mDisplayedValues == displayedValues) {
-            return;
-        }
-        mDisplayedValues = displayedValues;
-        if (mDisplayedValues != null) {
-            // Allow text entry rather than strictly numeric entry.
-            mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT
-                    | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
-        } else {
-            mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
-        }
-        updateInputTextView();
-        initializeSelectorWheelIndices();
-        tryComputeMaxWidth();
-    }
-
-    @Override
-    protected float getTopFadingEdgeStrength() {
-        return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
-    }
-
-    @Override
-    protected float getBottomFadingEdgeStrength() {
-        return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        removeAllCallbacks();
-    }
-
-    @Override
-    protected void onDraw(Canvas canvas) {
-        if (!mHasSelectorWheel) {
-            super.onDraw(canvas);
-            return;
-        }
-        float x = (mRight - mLeft) / 2;
-        float y = mCurrentScrollOffset;
-
-        // draw the virtual buttons pressed state if needed
-        if (mVirtualButtonPressedDrawable != null
-                && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
-            if (mDecrementVirtualButtonPressed) {
-                mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
-                mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
-                mVirtualButtonPressedDrawable.draw(canvas);
-            }
-            if (mIncrementVirtualButtonPressed) {
-                mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
-                mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight,
-                        mBottom);
-                mVirtualButtonPressedDrawable.draw(canvas);
-            }
-        }
-
-        // draw the selector wheel
-        int[] selectorIndices = mSelectorIndices;
-        for (int i = 0; i < selectorIndices.length; i++) {
-            int selectorIndex = selectorIndices[i];
-            String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
-            // Do not draw the middle item if input is visible since the input
-            // is shown only if the wheel is static and it covers the middle
-            // item. Otherwise, if the user starts editing the text via the
-            // IME he may see a dimmed version of the old value intermixed
-            // with the new one.
-            if (i != sSelectorMiddleItemIndex || mInputText.getVisibility() != VISIBLE) {
-                canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
-            }
-            y += mSelectorElementHeight;
-        }
-
-        // draw the selection dividers
-        if (mSelectionDivider != null) {
-            // draw the top divider
-            int topOfTopDivider = mTopSelectionDividerTop;
-            int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
-            mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
-            mSelectionDivider.draw(canvas);
-
-            // draw the bottom divider
-            int bottomOfBottomDivider = mBottomSelectionDividerBottom;
-            int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
-            mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
-            mSelectionDivider.draw(canvas);
-        }
-    }
-
-    @Override
-    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
-        super.onInitializeAccessibilityEvent(event);
-        event.setClassName(LocalePicker.class.getName());
-        event.setScrollable(true);
-        event.setScrollY((mMinValue + mValue) * mSelectorElementHeight);
-        event.setMaxScrollY((mMaxValue - mMinValue) * mSelectorElementHeight);
-    }
-
-    @Override
-    public AccessibilityNodeProvider getAccessibilityNodeProvider() {
-        if (!mHasSelectorWheel) {
-            return super.getAccessibilityNodeProvider();
-        }
-        if (mAccessibilityNodeProvider == null) {
-            mAccessibilityNodeProvider = new AccessibilityNodeProviderImpl();
-        }
-        return mAccessibilityNodeProvider;
-    }
-
-    /**
-     * Makes a measure spec that tries greedily to use the max value.
-     *
-     * @param measureSpec The measure spec.
-     * @param maxSize The max value for the size.
-     * @return A measure spec greedily imposing the max size.
-     */
-    private int makeMeasureSpec(int measureSpec, int maxSize) {
-        if (maxSize == SIZE_UNSPECIFIED) {
-            return measureSpec;
-        }
-        final int size = MeasureSpec.getSize(measureSpec);
-        final int mode = MeasureSpec.getMode(measureSpec);
-        switch (mode) {
-            case MeasureSpec.EXACTLY:
-                return measureSpec;
-            case MeasureSpec.AT_MOST:
-                return MeasureSpec.makeMeasureSpec(Math.min(size, maxSize), MeasureSpec.EXACTLY);
-            case MeasureSpec.UNSPECIFIED:
-                return MeasureSpec.makeMeasureSpec(maxSize, MeasureSpec.EXACTLY);
-            default:
-                throw new IllegalArgumentException("Unknown measure mode: " + mode);
-        }
-    }
-
-    /**
-     * Utility to reconcile a desired size and state, with constraints imposed
-     * by a MeasureSpec. Tries to respect the min size, unless a different size
-     * is imposed by the constraints.
-     *
-     * @param minSize The minimal desired size.
-     * @param measuredSize The currently measured size.
-     * @param measureSpec The current measure spec.
-     * @return The resolved size and state.
-     */
-    private int resolveSizeAndStateRespectingMinSize(
-            int minSize, int measuredSize, int measureSpec) {
-        if (minSize != SIZE_UNSPECIFIED) {
-            final int desiredWidth = Math.max(minSize, measuredSize);
-            return resolveSizeAndState(desiredWidth, measureSpec, 0);
-        } else {
-            return measuredSize;
-        }
-    }
-
-    /**
-     * Resets the selector indices and clear the cached string representation of
-     * these indices.
-     */
-    private void initializeSelectorWheelIndices() {
-        mSelectorIndexToStringCache.clear();
-        int[] selectorIndices = mSelectorIndices;
-        int current = getValue();
-        for (int i = 0; i < mSelectorIndices.length; i++) {
-            int selectorIndex = current + (i - sSelectorMiddleItemIndex);
-            if (mWrapSelectorWheel) {
-                selectorIndex = getWrappedSelectorIndex(selectorIndex);
-            }
-            selectorIndices[i] = selectorIndex;
-            ensureCachedScrollSelectorValue(selectorIndices[i]);
-        }
-    }
-
-    /**
-     * Sets the current value of this NumberPicker.
-     *
-     * @param current The new value of the NumberPicker.
-     * @param notifyChange Whether to notify if the current value changed.
-     */
-    private void setValueInternal(int current, boolean notifyChange) {
-        if (mValue == current) {
-            return;
-        }
-        // Wrap around the values if we go past the start or end
-        if (mWrapSelectorWheel) {
-            current = getWrappedSelectorIndex(current);
-        } else {
-            current = Math.max(current, mMinValue);
-            current = Math.min(current, mMaxValue);
-        }
-        int previous = mValue;
-        mValue = current;
-        updateInputTextView();
-        if (notifyChange) {
-            notifyChange(previous, current);
-        }
-        initializeSelectorWheelIndices();
-        invalidate();
-    }
-
-    /**
-     * Changes the current value by one which is increment or
-     * decrement based on the passes argument.
-     * decrement the current value.
-     *
-     * @param increment True to increment, false to decrement.
-     */
-     private void changeValueByOne(boolean increment) {
-        if (mHasSelectorWheel) {
-            mInputText.setVisibility(View.INVISIBLE);
-            if (!moveToFinalScrollerPosition(mFlingScroller)) {
-                moveToFinalScrollerPosition(mAdjustScroller);
-            }
-            mPreviousScrollerY = 0;
-            if (increment) {
-                mFlingScroller.startScroll(0, 0, 0, -mSelectorElementHeight, SNAP_SCROLL_DURATION);
-            } else {
-                mFlingScroller.startScroll(0, 0, 0, mSelectorElementHeight, SNAP_SCROLL_DURATION);
-            }
-            invalidate();
-        } else {
-            if (increment) {
-                setValueInternal(mValue + 1, true);
-            } else {
-                setValueInternal(mValue - 1, true);
-            }
-        }
-    }
-
-    private void initializeSelectorWheel() {
-        initializeSelectorWheelIndices();
-        int[] selectorIndices = mSelectorIndices;
-        int totalTextHeight = selectorIndices.length * mTextSize;
-        float totalTextGapHeight = (mBottom - mTop) - totalTextHeight;
-        float textGapCount = selectorIndices.length;
-        mSelectorTextGapHeight = (int) (totalTextGapHeight / textGapCount + 0.5f);
-        mSelectorElementHeight = mTextSize + mSelectorTextGapHeight;
-        // Ensure that the middle item is positioned the same as the text in
-        // mInputText
-        int editTextTextPosition = mInputText.getBaseline() + mInputText.getTop();
-        mInitialScrollOffset = editTextTextPosition
-                - (mSelectorElementHeight * sSelectorMiddleItemIndex);
-        mCurrentScrollOffset = mInitialScrollOffset;
-        updateInputTextView();
-    }
-
-    private void initializeFadingEdges() {
-        setVerticalFadingEdgeEnabled(true);
-        setFadingEdgeLength((mBottom - mTop - mTextSize) / 2);
-    }
-
-    /**
-     * Callback invoked upon completion of a given <code>scroller</code>.
-     */
-    private void onScrollerFinished(Scroller scroller) {
-        if (scroller == mFlingScroller) {
-            if (!ensureScrollWheelAdjusted()) {
-                updateInputTextView();
-            }
-            onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
-        } else {
-            if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
-                updateInputTextView();
-            }
-        }
-    }
-
-    /**
-     * Handles transition to a given <code>scrollState</code>
-     */
-    private void onScrollStateChange(int scrollState) {
-        if (mScrollState == scrollState) {
-            return;
-        }
-        mScrollState = scrollState;
-        if (mOnScrollListener != null) {
-            mOnScrollListener.onScrollStateChange(this, scrollState);
-        }
-    }
-
-    /**
-     * Flings the selector with the given <code>velocityY</code>.
-     */
-    private void fling(int velocityY) {
-        mPreviousScrollerY = 0;
-
-        if (velocityY > 0) {
-            mFlingScroller.fling(0, 0, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
-        } else {
-            mFlingScroller.fling(0, Integer.MAX_VALUE, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
-        }
-
-        invalidate();
-    }
-
-    /**
-     * @return The wrapped index <code>selectorIndex</code> value.
-     */
-    private int getWrappedSelectorIndex(int selectorIndex) {
-        if (selectorIndex > mMaxValue) {
-            return mMinValue + (selectorIndex - mMaxValue) % (mMaxValue - mMinValue) - 1;
-        } else if (selectorIndex < mMinValue) {
-            return mMaxValue - (mMinValue - selectorIndex) % (mMaxValue - mMinValue) + 1;
-        }
-        return selectorIndex;
-    }
-
-    /**
-     * Increments the <code>selectorIndices</code> whose string representations
-     * will be displayed in the selector.
-     */
-    private void incrementSelectorIndices(int[] selectorIndices) {
-        for (int i = 0; i < selectorIndices.length - 1; i++) {
-            selectorIndices[i] = selectorIndices[i + 1];
-        }
-        int nextScrollSelectorIndex = selectorIndices[selectorIndices.length - 2] + 1;
-        if (mWrapSelectorWheel && nextScrollSelectorIndex > mMaxValue) {
-            nextScrollSelectorIndex = mMinValue;
-        }
-        selectorIndices[selectorIndices.length - 1] = nextScrollSelectorIndex;
-        ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
-    }
-
-    /**
-     * Decrements the <code>selectorIndices</code> whose string representations
-     * will be displayed in the selector.
-     */
-    private void decrementSelectorIndices(int[] selectorIndices) {
-        for (int i = selectorIndices.length - 1; i > 0; i--) {
-            selectorIndices[i] = selectorIndices[i - 1];
-        }
-        int nextScrollSelectorIndex = selectorIndices[1] - 1;
-        if (mWrapSelectorWheel && nextScrollSelectorIndex < mMinValue) {
-            nextScrollSelectorIndex = mMaxValue;
-        }
-        selectorIndices[0] = nextScrollSelectorIndex;
-        ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
-    }
-
-    /**
-     * Ensures we have a cached string representation of the given <code>
-     * selectorIndex</code> to avoid multiple instantiations of the same string.
-     */
-    private void ensureCachedScrollSelectorValue(int selectorIndex) {
-        SparseArray<String> cache = mSelectorIndexToStringCache;
-        String scrollSelectorValue = cache.get(selectorIndex);
-        if (scrollSelectorValue != null) {
-            return;
-        }
-        if (selectorIndex < mMinValue || selectorIndex > mMaxValue) {
-            scrollSelectorValue = "";
-        } else {
-            if (mDisplayedValues != null) {
-                int displayedValueIndex = selectorIndex - mMinValue;
-                scrollSelectorValue = mDisplayedValues[displayedValueIndex];
-            } else {
-                scrollSelectorValue = formatNumber(selectorIndex);
-            }
-        }
-        cache.put(selectorIndex, scrollSelectorValue);
-    }
-
-    private String formatNumber(int value) {
-        return (mFormatter != null) ? mFormatter.format(value) : formatNumberWithLocale(value);
-    }
-
-    private void validateInputTextView(View v) {
-        String str = String.valueOf(((TextView) v).getText());
-        if (TextUtils.isEmpty(str)) {
-            // Restore to the old value as we don't allow empty values
-            updateInputTextView();
-        } else {
-            // Check the new value and ensure it's in range
-            int current = getSelectedPos(str.toString());
-            setValueInternal(current, true);
-        }
-    }
-
-    /**
-     * Updates the view of this NumberPicker. If displayValues were specified in
-     * the string corresponding to the index specified by the current value will
-     * be returned. Otherwise, the formatter specified in {@link #setFormatter}
-     * will be used to format the number.
-     *
-     * @return Whether the text was updated.
-     */
-    private boolean updateInputTextView() {
-        /*
-         * If we don't have displayed values then use the current number else
-         * find the correct value in the displayed values for the current
-         * number.
-         */
-        String text = (mDisplayedValues == null) ? formatNumber(mValue)
-                : mDisplayedValues[mValue - mMinValue];
-        if (!TextUtils.isEmpty(text) && !text.equals(mInputText.getText().toString())) {
-            mInputText.setText(text);
-            return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Notifies the listener, if registered, of a change of the value of this
-     * NumberPicker.
-     */
-    private void notifyChange(int previous, int current) {
-        if (mOnValueChangeListener != null) {
-            mOnValueChangeListener.onValueChange(this, previous, mValue);
-        }
-    }
-
-    /**
-     * Posts a command for changing the current value by one.
-     *
-     * @param increment Whether to increment or decrement the value.
-     */
-    private void postChangeCurrentByOneFromLongPress(boolean increment, long delayMillis) {
-        if (mChangeCurrentByOneFromLongPressCommand == null) {
-            mChangeCurrentByOneFromLongPressCommand = new ChangeCurrentByOneFromLongPressCommand();
-        } else {
-            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
-        }
-        mChangeCurrentByOneFromLongPressCommand.setStep(increment);
-        postDelayed(mChangeCurrentByOneFromLongPressCommand, delayMillis);
-    }
-
-    /**
-     * Removes the command for changing the current value by one.
-     */
-    private void removeChangeCurrentByOneFromLongPress() {
-        if (mChangeCurrentByOneFromLongPressCommand != null) {
-            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
-        }
-    }
-
-    /**
-     * Posts a command for beginning an edit of the current value via IME on
-     * long press.
-     */
-    private void postBeginSoftInputOnLongPressCommand() {
-        if (mBeginSoftInputOnLongPressCommand == null) {
-            mBeginSoftInputOnLongPressCommand = new BeginSoftInputOnLongPressCommand();
-        } else {
-            removeCallbacks(mBeginSoftInputOnLongPressCommand);
-        }
-        postDelayed(mBeginSoftInputOnLongPressCommand, ViewConfiguration.getLongPressTimeout());
-    }
-
-    /**
-     * Removes the command for beginning an edit of the current value via IME.
-     */
-    private void removeBeginSoftInputCommand() {
-        if (mBeginSoftInputOnLongPressCommand != null) {
-            removeCallbacks(mBeginSoftInputOnLongPressCommand);
-        }
-    }
-
-    /**
-     * Removes all pending callback from the message queue.
-     */
-    private void removeAllCallbacks() {
-        if (mChangeCurrentByOneFromLongPressCommand != null) {
-            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
-        }
-        if (mSetSelectionCommand != null) {
-            removeCallbacks(mSetSelectionCommand);
-        }
-        if (mBeginSoftInputOnLongPressCommand != null) {
-            removeCallbacks(mBeginSoftInputOnLongPressCommand);
-        }
-        mPressedStateHelper.cancel();
-    }
-
-    /**
-     * @return The selected index given its displayed <code>value</code>.
-     */
-    private int getSelectedPos(String value) {
-        if (mDisplayedValues == null) {
-            try {
-                return Integer.parseInt(value);
-            } catch (NumberFormatException e) {
-                // Ignore as if it's not a number we don't care
-            }
-        } else {
-            for (int i = 0; i < mDisplayedValues.length; i++) {
-                // Don't force the user to type in jan when ja will do
-                value = value.toLowerCase();
-                if (mDisplayedValues[i].toLowerCase().startsWith(value)) {
-                    return mMinValue + i;
-                }
-            }
-
-            /*
-             * The user might have typed in a number into the month field i.e.
-             * 10 instead of OCT so support that too.
-             */
-            try {
-                return Integer.parseInt(value);
-            } catch (NumberFormatException e) {
-
-                // Ignore as if it's not a number we don't care
-            }
-        }
-        return mMinValue;
-    }
-
-    /**
-     * Posts an {@link SetSelectionCommand} from the given <code>selectionStart
-     * </code> to <code>selectionEnd</code>.
-     */
-    private void postSetSelectionCommand(int selectionStart, int selectionEnd) {
-        if (mSetSelectionCommand == null) {
-            mSetSelectionCommand = new SetSelectionCommand();
-        } else {
-            removeCallbacks(mSetSelectionCommand);
-        }
-        mSetSelectionCommand.mSelectionStart = selectionStart;
-        mSetSelectionCommand.mSelectionEnd = selectionEnd;
-        post(mSetSelectionCommand);
-    }
-
-    /**
-     * The numbers accepted by the input text's {@link android.view.LayoutInflater.Filter}
-     */
-    private static final char[] DIGIT_CHARACTERS = new char[] {
-            // Latin digits are the common case
-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-            // Arabic-Indic
-            '\u0660', '\u0661', '\u0662', '\u0663', '\u0664', '\u0665', '\u0666', '\u0667', '\u0668'
-            , '\u0669',
-            // Extended Arabic-Indic
-            '\u06f0', '\u06f1', '\u06f2', '\u06f3', '\u06f4', '\u06f5', '\u06f6', '\u06f7', '\u06f8'
-            , '\u06f9'
-    };
-
-    /**
-     * Filter for accepting only valid indices or prefixes of the string
-     * representation of valid indices.
-     */
-    class InputTextFilter extends NumberKeyListener {
-
-        // XXX This doesn't allow for range limits when controlled by a
-        // soft input method!
-        public int getInputType() {
-            return InputType.TYPE_CLASS_TEXT;
-        }
-
-        @Override
-        protected char[] getAcceptedChars() {
-            return DIGIT_CHARACTERS;
-        }
-
-        @Override
-        public CharSequence filter(
-                CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {
-            if (mDisplayedValues == null) {
-                CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
-                if (filtered == null) {
-                    filtered = source.subSequence(start, end);
-                }
-
-                String result = String.valueOf(dest.subSequence(0, dstart)) + filtered
-                        + dest.subSequence(dend, dest.length());
-
-                if ("".equals(result)) {
-                    return result;
-                }
-                int val = getSelectedPos(result);
-
-                /*
-                 * Ensure the user can't type in a value greater than the max
-                 * allowed. We have to allow less than min as the user might
-                 * want to delete some numbers and then type a new number.
-                 * And prevent multiple-"0" that exceeds the length of upper
-                 * bound number.
-                 */
-                if (val > mMaxValue || result.length() > String.valueOf(mMaxValue).length()) {
-                    return "";
-                } else {
-                    return filtered;
-                }
-            } else {
-                CharSequence filtered = String.valueOf(source.subSequence(start, end));
-                if (TextUtils.isEmpty(filtered)) {
-                    return "";
-                }
-                String result = String.valueOf(dest.subSequence(0, dstart)) + filtered
-                        + dest.subSequence(dend, dest.length());
-                String str = String.valueOf(result).toLowerCase();
-                for (String val : mDisplayedValues) {
-                    String valLowerCase = val.toLowerCase();
-                    if (valLowerCase.startsWith(str)) {
-                        postSetSelectionCommand(result.length(), val.length());
-                        return val.subSequence(dstart, val.length());
-                    }
-                }
-                return "";
-            }
-        }
-    }
-
-    /**
-     * Ensures that the scroll wheel is adjusted i.e. there is no offset and the
-     * middle element is in the middle of the widget.
-     *
-     * @return Whether an adjustment has been made.
-     */
-    private boolean ensureScrollWheelAdjusted() {
-        // adjust to the closest value
-        int deltaY = mInitialScrollOffset - mCurrentScrollOffset;
-        if (deltaY != 0) {
-            mPreviousScrollerY = 0;
-            if (Math.abs(deltaY) > mSelectorElementHeight / 2) {
-                deltaY += (deltaY > 0) ? -mSelectorElementHeight : mSelectorElementHeight;
-            }
-            mAdjustScroller.startScroll(0, 0, 0, deltaY, SELECTOR_ADJUSTMENT_DURATION_MILLIS);
-            invalidate();
-            return true;
-        }
-        return false;
-    }
-
-    class PressedStateHelper implements Runnable {
-        public static final int BUTTON_INCREMENT = 1;
-        public static final int BUTTON_DECREMENT = 2;
-
-        private final int MODE_PRESS = 1;
-        private final int MODE_TAPPED = 2;
-
-        private int mManagedButton;
-        private int mMode;
-
-        public void cancel() {
-            mMode = 0;
-            mManagedButton = 0;
-            LocalePicker.this.removeCallbacks(this);
-            if (mIncrementVirtualButtonPressed) {
-                mIncrementVirtualButtonPressed = false;
-                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
-            }
-            mDecrementVirtualButtonPressed = false;
-            if (mDecrementVirtualButtonPressed) {
-                invalidate(0, 0, mRight, mTopSelectionDividerTop);
-            }
-        }
-
-        public void buttonPressDelayed(int button) {
-            cancel();
-            mMode = MODE_PRESS;
-            mManagedButton = button;
-            LocalePicker.this.postDelayed(this, ViewConfiguration.getTapTimeout());
-        }
-
-        public void buttonTapped(int button) {
-            cancel();
-            mMode = MODE_TAPPED;
-            mManagedButton = button;
-            LocalePicker.this.post(this);
-        }
-
-        @Override
-        public void run() {
-            switch (mMode) {
-                case MODE_PRESS: {
-                    switch (mManagedButton) {
-                        case BUTTON_INCREMENT: {
-                            mIncrementVirtualButtonPressed = true;
-                            invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
-                        } break;
-                        case BUTTON_DECREMENT: {
-                            mDecrementVirtualButtonPressed = true;
-                            invalidate(0, 0, mRight, mTopSelectionDividerTop);
-                        }
-                    }
-                } break;
-                case MODE_TAPPED: {
-                    switch (mManagedButton) {
-                        case BUTTON_INCREMENT: {
-                            if (!mIncrementVirtualButtonPressed) {
-                                LocalePicker.this.postDelayed(this,
-                                        ViewConfiguration.getPressedStateDuration());
-                            }
-                            mIncrementVirtualButtonPressed ^= true;
-                            invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
-                        } break;
-                        case BUTTON_DECREMENT: {
-                            if (!mDecrementVirtualButtonPressed) {
-                                LocalePicker.this.postDelayed(this,
-                                        ViewConfiguration.getPressedStateDuration());
-                            }
-                            mDecrementVirtualButtonPressed ^= true;
-                            invalidate(0, 0, mRight, mTopSelectionDividerTop);
-                        }
-                    }
-                } break;
-            }
-        }
-    }
-
-    /**
-     * Command for setting the input text selection.
-     */
-    class SetSelectionCommand implements Runnable {
-        private int mSelectionStart;
-
-        private int mSelectionEnd;
-
-        public void run() {
-            mInputText.setSelection(mSelectionStart, mSelectionEnd);
-        }
-    }
-
-    /**
-     * Command for changing the current value from a long press by one.
-     */
-    class ChangeCurrentByOneFromLongPressCommand implements Runnable {
-        private boolean mIncrement;
-
-        private void setStep(boolean increment) {
-            mIncrement = increment;
-        }
-
-        @Override
-        public void run() {
-            changeValueByOne(mIncrement);
-            postDelayed(this, mLongPressUpdateInterval);
-        }
-    }
-
-    /**
-     * @hide
-     */
-    public static class CustomEditText extends EditText {
-
-        public CustomEditText(Context context, AttributeSet attrs) {
-            super(context, attrs);
-        }
-
-        @Override
-        public void onEditorAction(int actionCode) {
-            super.onEditorAction(actionCode);
-            if (actionCode == EditorInfo.IME_ACTION_DONE) {
-                clearFocus();
-            }
-        }
-    }
-
-    /**
-     * Command for beginning soft input on long press.
-     */
-    class BeginSoftInputOnLongPressCommand implements Runnable {
-
-        @Override
-        public void run() {
-            showSoftInput();
-            mIngonreMoveEvents = true;
-        }
-    }
-
-    /**
-     * Class for managing virtual view tree rooted at this picker.
-     */
-    class AccessibilityNodeProviderImpl extends AccessibilityNodeProvider {
-        private static final int UNDEFINED = Integer.MIN_VALUE;
-
-        private static final int VIRTUAL_VIEW_ID_INCREMENT = 1;
-
-        private static final int VIRTUAL_VIEW_ID_INPUT = 2;
-
-        private static final int VIRTUAL_VIEW_ID_DECREMENT = 3;
-
-        private final Rect mTempRect = new Rect();
-
-        private final int[] mTempArray = new int[2];
-
-        private int mAccessibilityFocusedView = UNDEFINED;
-
-        @Override
-        public AccessibilityNodeInfo createAccessibilityNodeInfo(int virtualViewId) {
-            switch (virtualViewId) {
-                case View.NO_ID:
-                    return createAccessibilityNodeInfoForNumberPicker( mScrollX, mScrollY,
-                            mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
-                case VIRTUAL_VIEW_ID_DECREMENT:
-                    return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_DECREMENT,
-                            getVirtualDecrementButtonText(), mScrollX, mScrollY,
-                            mScrollX + (mRight - mLeft),
-                            mTopSelectionDividerTop + mSelectionDividerHeight);
-                case VIRTUAL_VIEW_ID_INPUT:
-                    return createAccessibiltyNodeInfoForInputText(mScrollX,
-                            mTopSelectionDividerTop + mSelectionDividerHeight,
-                            mScrollX + (mRight - mLeft),
-                            mBottomSelectionDividerBottom - mSelectionDividerHeight);
-                case VIRTUAL_VIEW_ID_INCREMENT:
-                    return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_INCREMENT,
-                            getVirtualIncrementButtonText(), mScrollX,
-                            mBottomSelectionDividerBottom - mSelectionDividerHeight,
-                            mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
-            }
-            return super.createAccessibilityNodeInfo(virtualViewId);
-        }
-
-        @Override
-        public List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String searched,
-                int virtualViewId) {
-            if (TextUtils.isEmpty(searched)) {
-                return Collections.emptyList();
-            }
-            String searchedLowerCase = searched.toLowerCase();
-            List<AccessibilityNodeInfo> result = new ArrayList<AccessibilityNodeInfo>();
-            switch (virtualViewId) {
-                case View.NO_ID: {
-                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
-                            VIRTUAL_VIEW_ID_DECREMENT, result);
-                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
-                            VIRTUAL_VIEW_ID_INPUT, result);
-                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
-                            VIRTUAL_VIEW_ID_INCREMENT, result);
-                    return result;
-                }
-                case VIRTUAL_VIEW_ID_DECREMENT:
-                case VIRTUAL_VIEW_ID_INCREMENT:
-                case VIRTUAL_VIEW_ID_INPUT: {
-                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase, virtualViewId,
-                            result);
-                    return result;
-                }
-            }
-            return super.findAccessibilityNodeInfosByText(searched, virtualViewId);
-        }
-
-        @Override
-        public boolean performAction(int virtualViewId, int action, Bundle arguments) {
-            switch (virtualViewId) {
-                case View.NO_ID: {
-                    switch (action) {
-                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView != virtualViewId) {
-                                mAccessibilityFocusedView = virtualViewId;
-                                requestAccessibilityFocus();
-                                return true;
-                            }
-                        } return false;
-                        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView == virtualViewId) {
-                                mAccessibilityFocusedView = UNDEFINED;
-                                clearAccessibilityFocus();
-                                return true;
-                            }
-                            return false;
-                        }
-                        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
-                            if (LocalePicker.this.isEnabled()
-                                    && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
-                                changeValueByOne(true);
-                                return true;
-                            }
-                        } return false;
-                        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
-                            if (LocalePicker.this.isEnabled()
-                                    && (getWrapSelectorWheel() || getValue() > getMinValue())) {
-                                changeValueByOne(false);
-                                return true;
-                            }
-                        } return false;
-                    }
-                } break;
-                case VIRTUAL_VIEW_ID_INPUT: {
-                    switch (action) {
-                        case AccessibilityNodeInfo.ACTION_FOCUS: {
-                            if (LocalePicker.this.isEnabled() && !mInputText.isFocused()) {
-                                return mInputText.requestFocus();
-                            }
-                        } break;
-                        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS: {
-                            if (LocalePicker.this.isEnabled() && mInputText.isFocused()) {
-                                mInputText.clearFocus();
-                                return true;
-                            }
-                            return false;
-                        }
-                        case AccessibilityNodeInfo.ACTION_CLICK: {
-                            if (LocalePicker.this.isEnabled()) {
-                                showSoftInput();
-                                return true;
-                            }
-                            return false;
-                        }
-                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView != virtualViewId) {
-                                mAccessibilityFocusedView = virtualViewId;
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
-                                mInputText.invalidate();
-                                return true;
-                            }
-                        } return false;
-                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView == virtualViewId) {
-                                mAccessibilityFocusedView = UNDEFINED;
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
-                                mInputText.invalidate();
-                                return true;
-                            }
-                        } return false;
-                        default: {
-                            return mInputText.performAccessibilityAction(action, arguments);
-                        }
-                    }
-                } return false;
-                case VIRTUAL_VIEW_ID_INCREMENT: {
-                    switch (action) {
-                        case AccessibilityNodeInfo.ACTION_CLICK: {
-                            if (LocalePicker.this.isEnabled()) {
-                                LocalePicker.this.changeValueByOne(true);
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_CLICKED);
-                                return true;
-                            }
-                        } return false;
-                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView != virtualViewId) {
-                                mAccessibilityFocusedView = virtualViewId;
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
-                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
-                                return true;
-                            }
-                        } return false;
-                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView == virtualViewId) {
-                                mAccessibilityFocusedView = UNDEFINED;
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
-                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
-                                return true;
-                            }
-                        } return false;
-                    }
-                } return false;
-                case VIRTUAL_VIEW_ID_DECREMENT: {
-                    switch (action) {
-                        case AccessibilityNodeInfo.ACTION_CLICK: {
-                            if (LocalePicker.this.isEnabled()) {
-                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
-                                LocalePicker.this.changeValueByOne(increment);
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_CLICKED);
-                                return true;
-                            }
-                        } return false;
-                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView != virtualViewId) {
-                                mAccessibilityFocusedView = virtualViewId;
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
-                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
-                                return true;
-                            }
-                        } return false;
-                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
-                            if (mAccessibilityFocusedView == virtualViewId) {
-                                mAccessibilityFocusedView = UNDEFINED;
-                                sendAccessibilityEventForVirtualView(virtualViewId,
-                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
-                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
-                                return true;
-                            }
-                        } return false;
-                    }
-                } return false;
-            }
-            return super.performAction(virtualViewId, action, arguments);
-        }
-
-        public void sendAccessibilityEventForVirtualView(int virtualViewId, int eventType) {
-            switch (virtualViewId) {
-                case VIRTUAL_VIEW_ID_DECREMENT: {
-                    if (hasVirtualDecrementButton()) {
-                        sendAccessibilityEventForVirtualButton(virtualViewId, eventType,
-                                getVirtualDecrementButtonText());
-                    }
-                } break;
-                case VIRTUAL_VIEW_ID_INPUT: {
-                    sendAccessibilityEventForVirtualText(eventType);
-                } break;
-                case VIRTUAL_VIEW_ID_INCREMENT: {
-                    if (hasVirtualIncrementButton()) {
-                        sendAccessibilityEventForVirtualButton(virtualViewId, eventType,
-                                getVirtualIncrementButtonText());
-                    }
-                } break;
-            }
-        }
-
-        private void sendAccessibilityEventForVirtualText(int eventType) {
-            if (AccessibilityManager.getInstance(mContext).isEnabled()) {
-                AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
-                mInputText.onInitializeAccessibilityEvent(event);
-                mInputText.onPopulateAccessibilityEvent(event);
-                event.setSource(LocalePicker.this, VIRTUAL_VIEW_ID_INPUT);
-                requestSendAccessibilityEvent(LocalePicker.this, event);
-            }
-        }
-
-        private void sendAccessibilityEventForVirtualButton(int virtualViewId, int eventType,
-                String text) {
-            if (AccessibilityManager.getInstance(mContext).isEnabled()) {
-                AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
-                event.setClassName(Button.class.getName());
-                event.setPackageName(mContext.getPackageName());
-                event.getText().add(text);
-                event.setEnabled(LocalePicker.this.isEnabled());
-                event.setSource(LocalePicker.this, virtualViewId);
-                requestSendAccessibilityEvent(LocalePicker.this, event);
-            }
-        }
-
-        private void findAccessibilityNodeInfosByTextInChild(String searchedLowerCase,
-                int virtualViewId, List<AccessibilityNodeInfo> outResult) {
-            switch (virtualViewId) {
-                case VIRTUAL_VIEW_ID_DECREMENT: {
-                    String text = getVirtualDecrementButtonText();
-                    if (!TextUtils.isEmpty(text)
-                            && text.toString().toLowerCase().contains(searchedLowerCase)) {
-                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_DECREMENT));
-                    }
-                } return;
-                case VIRTUAL_VIEW_ID_INPUT: {
-                    CharSequence text = mInputText.getText();
-                    if (!TextUtils.isEmpty(text) &&
-                            text.toString().toLowerCase().contains(searchedLowerCase)) {
-                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT));
-                        return;
-                    }
-                    CharSequence contentDesc = mInputText.getText();
-                    if (!TextUtils.isEmpty(contentDesc) &&
-                            contentDesc.toString().toLowerCase().contains(searchedLowerCase)) {
-                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT));
-                        return;
-                    }
-                } break;
-                case VIRTUAL_VIEW_ID_INCREMENT: {
-                    String text = getVirtualIncrementButtonText();
-                    if (!TextUtils.isEmpty(text)
-                            && text.toString().toLowerCase().contains(searchedLowerCase)) {
-                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INCREMENT));
-                    }
-                } return;
-            }
-        }
-
-        private AccessibilityNodeInfo createAccessibiltyNodeInfoForInputText(
-                int left, int top, int right, int bottom) {
-            AccessibilityNodeInfo info = mInputText.createAccessibilityNodeInfo();
-            info.setSource(LocalePicker.this, VIRTUAL_VIEW_ID_INPUT);
-            if (mAccessibilityFocusedView != VIRTUAL_VIEW_ID_INPUT) {
-                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
-            }
-            if (mAccessibilityFocusedView == VIRTUAL_VIEW_ID_INPUT) {
-                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
-            }
-            Rect boundsInParent = mTempRect;
-            boundsInParent.set(left, top, right, bottom);
-            info.setVisibleToUser(isVisibleToUser(boundsInParent));
-            info.setBoundsInParent(boundsInParent);
-            Rect boundsInScreen = boundsInParent;
-            int[] locationOnScreen = mTempArray;
-            getLocationOnScreen(locationOnScreen);
-            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
-            info.setBoundsInScreen(boundsInScreen);
-            return info;
-        }
-
-        private AccessibilityNodeInfo createAccessibilityNodeInfoForVirtualButton(int virtualViewId,
-                String text, int left, int top, int right, int bottom) {
-            AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
-            info.setClassName(Button.class.getName());
-            info.setPackageName(mContext.getPackageName());
-            info.setSource(LocalePicker.this, virtualViewId);
-            info.setParent(LocalePicker.this);
-            info.setText(text);
-            info.setClickable(true);
-            info.setLongClickable(true);
-            info.setEnabled(LocalePicker.this.isEnabled());
-            Rect boundsInParent = mTempRect;
-            boundsInParent.set(left, top, right, bottom);
-            info.setVisibleToUser(isVisibleToUser(boundsInParent));
-            info.setBoundsInParent(boundsInParent);
-            Rect boundsInScreen = boundsInParent;
-            int[] locationOnScreen = mTempArray;
-            getLocationOnScreen(locationOnScreen);
-            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
-            info.setBoundsInScreen(boundsInScreen);
-
-            if (mAccessibilityFocusedView != virtualViewId) {
-                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
-            }
-            if (mAccessibilityFocusedView == virtualViewId) {
-                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
-            }
-            if (LocalePicker.this.isEnabled()) {
-                info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
-            }
-
-            return info;
-        }
-
-        private AccessibilityNodeInfo createAccessibilityNodeInfoForNumberPicker(int left, int top,
-                int right, int bottom) {
-            AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
-            info.setClassName(LocalePicker.class.getName());
-            info.setPackageName(mContext.getPackageName());
-            info.setSource(LocalePicker.this);
-
-            if (hasVirtualDecrementButton()) {
-                info.addChild(LocalePicker.this, VIRTUAL_VIEW_ID_DECREMENT);
-            }
-            info.addChild(LocalePicker.this, VIRTUAL_VIEW_ID_INPUT);
-            if (hasVirtualIncrementButton()) {
-                info.addChild(LocalePicker.this, VIRTUAL_VIEW_ID_INCREMENT);
-            }
-
-            info.setParent((View) getParentForAccessibility());
-            info.setEnabled(LocalePicker.this.isEnabled());
-            info.setScrollable(true);
-
-            final float applicationScale =
-                getContext().getResources().getCompatibilityInfo().applicationScale;
-
-            Rect boundsInParent = mTempRect;
-            boundsInParent.set(left, top, right, bottom);
-            boundsInParent.scale(applicationScale);
-            info.setBoundsInParent(boundsInParent);
-
-            info.setVisibleToUser(isVisibleToUser());
-
-            Rect boundsInScreen = boundsInParent;
-            int[] locationOnScreen = mTempArray;
-            getLocationOnScreen(locationOnScreen);
-            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
-            boundsInScreen.scale(applicationScale);
-            info.setBoundsInScreen(boundsInScreen);
-
-            if (mAccessibilityFocusedView != View.NO_ID) {
-                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
-            }
-            if (mAccessibilityFocusedView == View.NO_ID) {
-                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
-            }
-            if (LocalePicker.this.isEnabled()) {
-                if (getWrapSelectorWheel() || getValue() < getMaxValue()) {
-                    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
-                }
-                if (getWrapSelectorWheel() || getValue() > getMinValue()) {
-                    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
-                }
-            }
-
-            return info;
-        }
-
-        private boolean hasVirtualDecrementButton() {
-            return getWrapSelectorWheel() || getValue() > getMinValue();
-        }
-
-        private boolean hasVirtualIncrementButton() {
-            return getWrapSelectorWheel() || getValue() < getMaxValue();
-        }
-
-        private String getVirtualDecrementButtonText() {
-            int value = mValue - 1;
-            if (mWrapSelectorWheel) {
-                value = getWrappedSelectorIndex(value);
-            }
-            if (value >= mMinValue) {
-                return (mDisplayedValues == null) ? formatNumber(value)
-                        : mDisplayedValues[value - mMinValue];
-            }
-            return null;
-        }
-
-        private String getVirtualIncrementButtonText() {
-            int value = mValue + 1;
-            if (mWrapSelectorWheel) {
-                value = getWrappedSelectorIndex(value);
-            }
-            if (value <= mMaxValue) {
-                return (mDisplayedValues == null) ? formatNumber(value)
-                        : mDisplayedValues[value - mMinValue];
-            }
-            return null;
-        }
-    }
-
-    static private String formatNumberWithLocale(int value) {
-        return String.format(Locale.getDefault(), "%d", value);
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/widget/ScrimInsetsFrameLayout.java b/src/com/cyanogenmod/setupwizard/widget/ScrimInsetsFrameLayout.java
deleted file mode 100644
index 662e3a8..0000000
--- a/src/com/cyanogenmod/setupwizard/widget/ScrimInsetsFrameLayout.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright 2014 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.widget;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.support.v4.view.ViewCompat;
-import android.util.AttributeSet;
-import android.widget.FrameLayout;
-
-import com.cyanogenmod.setupwizard.R;
-
-/**
- * A layout that draws something in the insets passed to {@link #fitSystemWindows(android.graphics.Rect)}, i.e. the area above UI chrome
- * (status and navigation bars, overlay action bars).
- */
-public class ScrimInsetsFrameLayout extends FrameLayout {
-    private Drawable mInsetForeground;
-
-    private Rect mInsets;
-    private Rect mTempRect = new Rect();
-    private OnInsetsCallback mOnInsetsCallback;
-
-    public ScrimInsetsFrameLayout(Context context) {
-        super(context);
-        init(context, null, 0);
-    }
-
-    public ScrimInsetsFrameLayout(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init(context, attrs, 0);
-    }
-
-    public ScrimInsetsFrameLayout(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        init(context, attrs, defStyle);
-    }
-
-    private void init(Context context, AttributeSet attrs, int defStyle) {
-        final TypedArray a = context.obtainStyledAttributes(attrs,
-                R.styleable.ScrimInsetsView, defStyle, 0);
-        if (a == null) {
-            return;
-        }
-        mInsetForeground = a.getDrawable(R.styleable.ScrimInsetsView_insetForeground);
-        a.recycle();
-
-        setWillNotDraw(true);
-    }
-
-    @Override
-    protected boolean fitSystemWindows(Rect insets) {
-        mInsets = new Rect(insets);
-        setWillNotDraw(mInsetForeground == null);
-        ViewCompat.postInvalidateOnAnimation(this);
-        if (mOnInsetsCallback != null) {
-            mOnInsetsCallback.onInsetsChanged(insets);
-        }
-        return true; // consume insets
-    }
-
-    @Override
-    public void draw(Canvas canvas) {
-        super.draw(canvas);
-
-        int width = getWidth();
-        int height = getHeight();
-        if (mInsets != null && mInsetForeground != null) {
-            int sc = canvas.save();
-            canvas.translate(getScrollX(), getScrollY());
-
-            // Top
-            mTempRect.set(0, 0, width, mInsets.top);
-            mInsetForeground.setBounds(mTempRect);
-            mInsetForeground.draw(canvas);
-
-            // Bottom
-            mTempRect.set(0, height - mInsets.bottom, width, height);
-            mInsetForeground.setBounds(mTempRect);
-            mInsetForeground.draw(canvas);
-
-            // Left
-            mTempRect.set(0, mInsets.top, mInsets.left, height - mInsets.bottom);
-            mInsetForeground.setBounds(mTempRect);
-            mInsetForeground.draw(canvas);
-
-            // Right
-            mTempRect.set(width - mInsets.right, mInsets.top, width, height - mInsets.bottom);
-            mInsetForeground.setBounds(mTempRect);
-            mInsetForeground.draw(canvas);
-
-            canvas.restoreToCount(sc);
-        }
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (mInsetForeground != null) {
-            mInsetForeground.setCallback(this);
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        if (mInsetForeground != null) {
-            mInsetForeground.setCallback(null);
-        }
-    }
-
-    /**
-     * Allows the calling container to specify a callback for custom processing when insets change (i.e. when
-     * {@link #fitSystemWindows(android.graphics.Rect)} is called. This is useful for setting padding on UI elements based on
-     * UI chrome insets (e.g. a Google Map or a ListView). When using with ListView or GridView, remember to set
-     * clipToPadding to false.
-     */
-    public void setOnInsetsCallback(OnInsetsCallback onInsetsCallback) {
-        mOnInsetsCallback = onInsetsCallback;
-    }
-
-    public static interface OnInsetsCallback {
-        public void onInsetsChanged(Rect insets);
-    }
-}
\ No newline at end of file
diff --git a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardAction.java b/src/com/cyanogenmod/setupwizard/wizardmanager/WizardAction.java
deleted file mode 100644
index 903d58f..0000000
--- a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardAction.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.wizardmanager;
-
-import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.content.Intent;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.Log;
-
-import com.android.internal.util.XmlUtils;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.IOException;
-import java.net.URISyntaxException;
-
-public class WizardAction implements Parcelable {
-
-    private static final String TAG = "WizardAction";
-
-    private final String mId;
-    private final String mUri;
-    private final WizardTransitions mTransitions;
-
-    public WizardAction(String id, String uri, WizardTransitions transitions) {
-        if (transitions == null) {
-            throw new IllegalArgumentException("WizardTransitions cannot be null");
-        }
-        mId = id;
-        mUri = uri;
-        mTransitions = transitions;
-    }
-
-    public String getId() {
-        return mId;
-    }
-
-    public String getUri() {
-        return mUri;
-    }
-
-    public Intent getIntent() {
-        Intent intent = null;
-        try {
-            intent = Intent.parseUri(mUri, FLAG_GRANT_READ_URI_PERMISSION);
-        } catch(URISyntaxException e) {
-            Log.e(TAG, "Bad URI: " + mUri);
-        }
-        return intent;
-    }
-
-    public String getNextAction(int resultCode) {
-        return mTransitions.getAction(resultCode);
-    }
-
-    @Override
-    public String toString() {
-        return "WizardAction{" +
-                "mId='" + mId + '\'' +
-                ", mUri='" + mUri + '\'' +
-                ", mTransitions=" + mTransitions +
-                '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof WizardAction)) return false;
-
-        WizardAction that = (WizardAction) o;
-
-        if (mId != null ? !mId.equals(that.mId) : that.mId != null) return false;
-        if (mUri != null ? !mUri.equals(that.mUri) : that.mUri != null) return false;
-        return mTransitions != null ?
-                mTransitions.equals(that.mTransitions) :
-                that.mTransitions == null;
-
-    }
-
-    @Override
-    public int hashCode() {
-        int result = mId != null ? mId.hashCode() : 0;
-        result = 31 * result + (mUri != null ? mUri.hashCode() : 0);
-        result = 31 * result + (mTransitions != null ? mTransitions.hashCode() : 0);
-        return result;
-    }
-
-    public int describeContents() {
-        return 0;
-    }
-
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeString(mUri);
-        dest.writeString(mId);
-        dest.writeParcelable(mTransitions, flags);
-    }
-
-    public static final Creator<WizardAction> CREATOR = new Creator<WizardAction>() {
-        public WizardAction createFromParcel(Parcel source) {
-            return new WizardAction(source.readString(),
-                    source.readString(),
-                    source.readParcelable(WizardTransitions.class.getClassLoader()));
-        }
-
-        public WizardAction[] newArray(int size) {
-            return new WizardAction[size];
-        }
-    };
-
-    private static void parseResult(WizardTransitions transitions, XmlPullParser parser) {
-        String resultCode = parser.getAttributeValue(WizardScript.WIZARD_SCRIPT_NAMESPACE,
-                WizardScript.ATTR_RESULT_CODE);
-        String action = parser.getAttributeValue(WizardScript.WIZARD_SCRIPT_NAMESPACE,
-                WizardScript.ATTR_ACTION);
-        if (LOGV) {
-            Log.v(TAG, "parseResult{" +
-                    "resultCode='" + resultCode + '\'' +
-                    ", action=" + action +
-                    '}');
-        }
-        if (resultCode == null) {
-            transitions.setDefaultAction(action);
-        } else {
-            transitions.put(Integer.valueOf(resultCode).intValue(), action);
-        }
-    }
-
-    public static WizardAction parseWizardAction(XmlPullParser parser) throws XmlPullParserException,
-            IOException {
-        String id = parser.getAttributeValue(null, WizardScript.ATTR_ID);
-        String uri = parser.getAttributeValue(WizardScript.WIZARD_SCRIPT_NAMESPACE,
-                WizardScript.ATTR_URI);
-        WizardTransitions transitions = new WizardTransitions();
-        if (id == null) {
-            throw new XmlPullParserException("WizardAction must define an id");
-        }
-
-        if (uri == null) {
-            throw new XmlPullParserException("WizardAction must define an intent URI");
-        }
-        if (LOGV) {
-            Log.v(TAG, "parseWizardAction{" +
-                    "id='" + id + '\'' +
-                    ", uri=" + uri +
-                    '}');
-        }
-        int type;
-        final int depth = parser.getDepth();
-        while (((type = parser.next()) != XmlPullParser.END_TAG ||
-                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
-            if (!(type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT)) {
-                if (parser.getName().equals(WizardScript.TAG_RESULT)) {
-                    parseResult(transitions, parser);
-                } else {
-                    XmlUtils.skipCurrentTag(parser);
-                }
-            }
-        }
-
-        return new WizardAction(id, uri, transitions);
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardManager.java b/src/com/cyanogenmod/setupwizard/wizardmanager/WizardManager.java
deleted file mode 100644
index a3363cd..0000000
--- a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardManager.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.wizardmanager;
-
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_LOAD;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_NEXT;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ACTION_ID;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_FIRST_RUN;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_RESULT_CODE;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import com.android.setupwizardlib.util.ResultCodes;
-import com.android.setupwizardlib.util.WizardManagerHelper;
-
-import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
-
-import android.annotation.Nullable;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.util.Log;
-
-import java.util.HashMap;
-
-
-public class WizardManager extends Activity {
-
-    private static final String TAG = WizardManager.class.getSimpleName();
-
-    private static HashMap<String, WizardScript> sWizardScripts = new HashMap();
-
-
-    @Override
-    protected void onCreate(@Nullable Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (LOGV) {
-            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
-        }
-        Intent intent = this.getIntent();
-        if (intent != null) {
-            String action = intent.getAction();
-            int resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, 0);
-            String scriptUri = intent.getStringExtra(EXTRA_SCRIPT_URI);
-            String actionId = intent.getStringExtra(EXTRA_ACTION_ID);
-            if (LOGV) {
-                Log.v(TAG, "  action=" + action + " resultCode=" + resultCode + " scriptUri="
-                        + scriptUri + " actionId=" + actionId + " extras=" + intent.getExtras());
-            }
-
-            if (ACTION_LOAD.equals(action)) {
-                load(scriptUri, intent);
-                finish();
-                return;
-            }
-
-            if (ACTION_NEXT.equals(action)) {
-                next(scriptUri, actionId, resultCode, intent);
-                finish();
-                return;
-            }
-
-            Log.e(TAG, "ERROR: Unknown action");
-        } else {
-            Log.e(TAG, "ERROR: Intent not available");
-        }
-        finish();
-    }
-
-    private void addExtras(Intent intent) {
-        intent.putExtra(WizardManagerHelper.EXTRA_USE_IMMERSIVE_MODE, true);
-        intent.putExtra(EXTRA_FIRST_RUN, true);
-        intent.putExtra(WizardManagerHelper.EXTRA_THEME, WizardManagerHelper.THEME_MATERIAL_LIGHT);
-    }
-
-    private void doAction(String scriptUri, WizardAction action, Intent extras) {
-        Intent intent = action.getIntent();
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-        if(LOGV) {
-            Log.v(TAG, "doAction scriptUri=" + scriptUri + " extras=" + extras
-                    + " intent=" + intent + " extras2=" + intent.getExtras() + " action=" + action);
-        }
-
-        addExtras(intent);
-        if(extras != null) {
-            intent.putExtras(extras);
-        }
-
-        intent.putExtra(EXTRA_SCRIPT_URI, scriptUri);
-        intent.putExtra(EXTRA_ACTION_ID, action.getId());
-        startActivity(intent);
-    }
-
-    private void load(String scriptUri, Intent extras) {
-        WizardScript wizardScript = getWizardScript(this, scriptUri);
-        WizardAction wizardAction;
-        for(wizardAction = wizardScript.getFirstAction();
-            wizardAction != null;
-            wizardAction = wizardScript.getNextAction(wizardAction.getId(),
-                    ResultCodes.RESULT_ACTIVITY_NOT_FOUND)) {
-            if (isActionAvailable(this, wizardAction)) {
-                break;
-            }
-
-            if(LOGV) {
-                Log.v(TAG, "load action not available " + wizardAction);
-            }
-        }
-
-        if (wizardAction != null) {
-            doAction(scriptUri, wizardAction, extras);
-        } else {
-            Log.e(TAG, "load could not resolve first action scriptUri=" +
-                    scriptUri + " actionId=" + wizardScript.getFirstActionId());
-            exit(scriptUri);
-        }
-    }
-
-    private void next(String scriptUri, String actionId, int resultCode, Intent extras) {
-        if(LOGV) {
-            Log.v(TAG, "next actionId=" + actionId + " resultCode=" + resultCode);
-        }
-        WizardAction wizardAction = checkNextAction(this, scriptUri,
-                actionId, resultCode);
-        if (wizardAction != null) {
-            doAction(scriptUri, wizardAction, extras);
-        }  else {
-            exit(scriptUri);
-        }
-    }
-
-    private void exit(String scriptUri) {
-        if(LOGV) {
-            Log.v(TAG, "exit scriptUri=" + scriptUri);
-        }
-        WizardManager.sWizardScripts.remove(scriptUri);
-        SetupWizardUtils.disableComponent(this, WizardManager.class);
-    }
-
-    private static WizardAction checkNextAction(Context context, String scriptUri, String actionId,
-            int resultCode) {
-        if(LOGV) {
-            Log.v(TAG, "checkNextAction scriptUri=" + scriptUri + " actionId="
-                    + actionId + " resultCode=" + resultCode);
-        }
-
-        WizardScript wizardScript = getWizardScript(context, scriptUri);
-        WizardAction wizardAction;
-        for ( wizardAction = wizardScript.getNextAction(actionId, resultCode);
-             wizardAction != null;
-             wizardAction = wizardScript.getNextAction(wizardAction.getId(),
-                     ResultCodes.RESULT_ACTIVITY_NOT_FOUND)) {
-            if (WizardManager.isActionAvailable(context, wizardAction)) {
-                break;
-            }
-
-            if(LOGV) {
-                Log.v(TAG, "checkNextAction action not available " + wizardAction);
-            }
-        }
-
-        if (LOGV) {
-            Log.v(TAG, "checkNextAction action=" + wizardAction);
-        }
-
-        return wizardAction;
-    }
-
-    private static boolean isActionAvailable(Context context, WizardAction action) {
-        return isIntentAvailable(context, action.getIntent());
-    }
-
-    private static boolean isIntentAvailable(Context context, Intent intent) {
-        if (context.getPackageManager().queryIntentActivities(intent,
-                PackageManager.MATCH_DEFAULT_ONLY).size() > 0) {
-            return true;
-        }
-        return false;
-    }
-
-    private static WizardScript getWizardScript(Context context, String scriptUri) {
-        WizardScript wizardScript = sWizardScripts.get(scriptUri);
-        if (wizardScript == null) {
-            wizardScript = WizardScript.loadFromUri(context, scriptUri);
-            sWizardScripts.put(scriptUri, wizardScript);
-        }
-        return wizardScript;
-    }
-
-}
diff --git a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardScript.java b/src/com/cyanogenmod/setupwizard/wizardmanager/WizardScript.java
deleted file mode 100644
index 9e93618..0000000
--- a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardScript.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.wizardmanager;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import com.android.internal.util.XmlUtils;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-
-import android.app.Activity;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.net.Uri;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.Log;
-import android.util.Xml;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-public class WizardScript implements Parcelable {
-
-    private static final String TAG = "WizardScript";
-
-    static final String WIZARD_SCRIPT_NAMESPACE =
-            "http://schemas.android.com/apk/res/com.google.android.setupwizard";
-
-    public static final String TAG_WIZARD_SCRIPT = "WizardScript";
-    public static final String TAG_WIZARD_ACTION = "WizardAction";
-    public static final String TAG_RESULT = "result";
-    public static final String ATTR_ID = "id";
-    public static final String ATTR_URI = "uri";
-    public static final String ATTR_ACTION = "action";
-    public static final String ATTR_FIRST_ACTION = "firstAction";
-    public static final String ATTR_RESULT_CODE = "resultCode";
-
-    private final Map<String, WizardAction> mActions;
-    private final String mFirstActionId;
-
-    public WizardScript(Map<String, WizardAction> actions, String firstActionId) {
-        mActions = Collections.unmodifiableMap(actions);
-        mFirstActionId = firstActionId;
-    }
-
-    public WizardAction getAction(String actionId) {
-        return mActions.get(actionId);
-    }
-
-    public WizardAction getFirstAction() {
-        return getAction(mFirstActionId);
-    }
-
-    public String getFirstActionId() {
-        return mFirstActionId;
-    }
-
-    public WizardAction getNextAction(String currentActionId, int resultCode) {
-        WizardAction wizardAction = null;
-        String nextActionId = getNextActionId(currentActionId, resultCode);
-        if (nextActionId != null) {
-            wizardAction = getAction(nextActionId);
-        }
-        return wizardAction;
-    }
-
-    public String getNextActionId(String currentActionId, int resultCode) {
-        String nextActionId = null;
-        if(resultCode != Activity.RESULT_CANCELED) {
-            WizardAction wizardAction = mActions.get(currentActionId);
-            if (LOGV) {
-                StringBuilder currentAction =
-                        new StringBuilder().append("getNextActionId(").append(currentActionId)
-                        .append(",").append(resultCode).append(")").append(" current uri=");
-                String uri = wizardAction == null ? "n/a" : wizardAction.getUri();
-                Log.v(TAG, currentAction.append(uri).toString());
-            }
-            nextActionId = wizardAction.getNextAction(resultCode);
-        } else {
-            if (LOGV) {
-                Log.v(TAG, "getNextActionId(" + currentActionId + "," + resultCode
-                        + ")" + " RESULT_CANCELED not expected; ignored");
-            }
-        }
-        return nextActionId;
-    }
-
-    public int describeContents() {
-        return 0;
-    }
-
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeString(this.mFirstActionId);
-        dest.writeTypedList(new ArrayList(this.mActions.values()));
-    }
-
-    public static final Creator<WizardScript> CREATOR = new Creator<WizardScript>() {
-        public WizardScript createFromParcel(Parcel source) {
-            String firstActionId = source.readString();
-            HashMap<String, WizardAction> actions = new HashMap();
-            ArrayList<WizardAction> actionList = new ArrayList();
-            source.readTypedList(actionList, WizardAction.CREATOR);
-            for (WizardAction action : actionList) {
-                actions.put(action.getId(), action);
-            }
-            return new WizardScript(actions, firstActionId);
-        }
-
-        public WizardScript[] newArray(int size) {
-            return new WizardScript[size];
-        }
-    };
-
-    public static WizardScript loadFromUri(Context context, String uriString) {
-        XmlPullParser xmlPullParser;
-        WizardScript wizardScript = null;
-        try {
-            ContentResolver.OpenResourceIdResult openResourceIdResult =
-                    context.getContentResolver().getResourceId(Uri
-                    .parse(uriString));
-            if("xml".equals(openResourceIdResult.r.getResourceTypeName(openResourceIdResult.id))) {
-                xmlPullParser =
-                        openResourceIdResult.r.getXml(openResourceIdResult.id);
-            } else {
-                InputStream inputStream =
-                        openResourceIdResult.r.openRawResource(openResourceIdResult.id);
-                xmlPullParser = Xml.newPullParser();
-                xmlPullParser.setInput(inputStream, null);
-            }
-
-            int next;
-            do {
-                next = xmlPullParser.next();
-                if (next == XmlPullParser.END_DOCUMENT) {
-                    break;
-                }
-            }
-            while (next != XmlPullParser.START_TAG);
-
-            return parseWizardScript(xmlPullParser);
-        } catch (XmlPullParserException e) {
-            Log.e(TAG, "Ill-formatted wizard_script: " + uriString);
-            Log.e(TAG, e.getMessage());
-            return wizardScript;
-        } catch(FileNotFoundException fnfe) {
-            Log.e(TAG, "Cannot find file: " + uriString);
-            Log.e(TAG, fnfe.getMessage());
-            return wizardScript;
-        } catch(IOException ioe) {
-            Log.e(TAG, "Unable to read wizard_script: " + uriString);
-            Log.e(TAG, ioe.getMessage());
-            return wizardScript;
-        }
-    }
-
-    private static WizardScript parseWizardScript(XmlPullParser parser)
-            throws XmlPullParserException, IOException {
-        String startTag = parser.getName();
-        if(!TAG_WIZARD_SCRIPT.equals(startTag)) {
-            throw new XmlPullParserException("XML document must start with " +
-                    "<WizardScript> tag; found "
-                    + startTag + " at " + parser.getPositionDescription());
-        }
-
-        String firstAction = parser.getAttributeValue(WIZARD_SCRIPT_NAMESPACE, ATTR_FIRST_ACTION);
-        if(firstAction == null) {
-            throw new XmlPullParserException("WizardScript must define a firstAction");
-        }
-
-        HashMap wizardActions = new HashMap();
-        int type;
-        final int depth = parser.getDepth();
-        while (((type = parser.next()) != XmlPullParser.END_TAG ||
-                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
-            final int next = parser.next();
-            if (next != XmlPullParser.END_TAG || next != XmlPullParser.TEXT) {
-                if (TAG_WIZARD_ACTION.equals(parser.getName())) {
-                    WizardAction action = WizardAction.parseWizardAction(parser);
-                    if (action != null) {
-                        wizardActions.put(action.getId(), action);
-                    }
-                } else {
-                    XmlUtils.skipCurrentTag(parser);
-                }
-            }
-        }
-
-        return new WizardScript(wizardActions, firstAction);
-    }
-}
diff --git a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardTransitions.java b/src/com/cyanogenmod/setupwizard/wizardmanager/WizardTransitions.java
deleted file mode 100644
index c7b826c..0000000
--- a/src/com/cyanogenmod/setupwizard/wizardmanager/WizardTransitions.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2016 The CyanogenMod Project
- * Copyright (C) 2017 The LineageOS Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.wizardmanager;
-
-import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.cyanogenmod.setupwizard.SetupWizardApp;
-
-public class WizardTransitions extends SparseArray<String> implements Parcelable {
-
-    private static final String TAG = "WizardTransitions";
-
-    private String mDefaultAction;
-
-    public static final Creator<WizardTransitions> CREATOR = new Creator<WizardTransitions>() {
-        public WizardTransitions createFromParcel(Parcel source) {
-            WizardTransitions transitions = new WizardTransitions(source);
-            SparseArray<String> actions = source.readSparseArray(null);
-            for (int i = 0; i < actions.size(); i++) {
-                transitions.put(actions.keyAt(i), actions.valueAt(i));
-            }
-            return transitions;
-        }
-
-        public WizardTransitions[] newArray(int size) {
-            return new WizardTransitions[size];
-        }
-    };
-
-    public WizardTransitions() {}
-
-    public void setDefaultAction(String action) {
-        mDefaultAction = action;
-    }
-
-    public String getAction(int resultCode) {
-        return get(resultCode, mDefaultAction);
-    }
-
-    @Override
-    public void put(int key, String value) {
-        if (LOGV) {
-            Log.v(TAG, "put{" +
-                    "key='" + key + '\'' +
-                    ", value=" + value +
-                    '}');
-        }
-        super.put(key, value);
-    }
-
-    public String toString() {
-        return super.toString() + " mDefaultAction: " + mDefaultAction;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        WizardTransitions that = (WizardTransitions) o;
-        return mDefaultAction != null ? mDefaultAction.equals(that.mDefaultAction) : that.mDefaultAction == null;
-
-    }
-
-    public int hashCode() {
-        return  super.hashCode() + mDefaultAction.hashCode();
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-
-    @Override
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeString(mDefaultAction);
-        int size = size();
-        SparseArray sparseArray = new SparseArray<>(size);
-        for (int i = 0; i < size; i++) {
-            sparseArray.put(keyAt(i), valueAt(i));
-        }
-        dest.writeSparseArray(sparseArray);
-    }
-
-    protected WizardTransitions(Parcel in) {
-        mDefaultAction = in.readString();
-    }
-
-
-}
diff --git a/src/org/lineageos/setupwizard/BaseSetupWizardActivity.java b/src/org/lineageos/setupwizard/BaseSetupWizardActivity.java
new file mode 100644
index 0000000..56ee309
--- /dev/null
+++ b/src/org/lineageos/setupwizard/BaseSetupWizardActivity.java
@@ -0,0 +1,667 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.android.setupwizardlib.util.ResultCodes.RESULT_ACTIVITY_NOT_FOUND;
+import static com.android.setupwizardlib.util.ResultCodes.RESULT_RETRY;
+import static com.android.setupwizardlib.util.ResultCodes.RESULT_SKIP;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_EMERGENCY_DIAL;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_NEXT;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ACTION_ID;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_FIRST_RUN;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_HAS_MULTIPLE_USERS;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_RESULT_CODE;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_USE_IMMERSIVE;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.util.Log;
+import android.view.View;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.android.setupwizard.navigationbar.SetupWizardNavBar;
+import com.android.setupwizard.navigationbar.SetupWizardNavBar.NavigationBarListener;
+import com.android.setupwizardlib.util.SystemBarHelper;
+import com.android.setupwizardlib.util.WizardManagerHelper;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+import java.util.List;
+
+public abstract class BaseSetupWizardActivity extends Activity implements NavigationBarListener {
+
+    public static final String TAG = BaseSetupWizardActivity.class.getSimpleName();
+
+    protected static final int TRANSITION_ID_NONE = -1;
+    protected static final int TRANSITION_ID_DEFAULT = 1;
+    protected static final int TRANSITION_ID_SLIDE = 2;
+    protected static final int TRANSITION_ID_FADE = 3;
+
+    protected static final int NEXT_REQUEST = 10000;
+    protected static final int EMERGENCY_DIAL_ACTIVITY_REQUEST = 10038;
+    protected static final int WIFI_ACTIVITY_REQUEST = 10004;
+    protected static final int BLUETOOTH_ACTIVITY_REQUEST = 10100;
+    protected static final int FINGERPRINT_ACTIVITY_REQUEST = 10101;
+    protected static final int SCREENLOCK_ACTIVITY_REQUEST = 10102;
+
+    private SetupWizardNavBar mNavigationBar;
+
+    protected boolean mIsActivityVisible = false;
+    protected boolean mIsExiting = false;
+    private boolean mIsFirstRun = true;
+    protected boolean mIsGoingBack = false;
+    private boolean mIsPrimaryUser;
+    private int mResultCode = 0;
+    private Intent mResultData;
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        if (LOGV) {
+            logActivityState("onCreate savedInstanceState=" + savedInstanceState);
+        }
+        super.onCreate(savedInstanceState);
+        mIsPrimaryUser = UserHandle.myUserId() == 0;
+        initLayout();
+    }
+
+    @Override
+    protected void onStart() {
+        if (LOGV) {
+            logActivityState("onStart");
+        }
+        super.onStart();
+        exitIfSetupComplete();
+    }
+
+    @Override
+    protected void onRestart() {
+        if (LOGV) {
+            logActivityState("onRestart");
+        }
+        super.onRestart();
+    }
+
+    @Override
+    protected void onResume() {
+        if (LOGV) {
+            logActivityState("onResume");
+        }
+        super.onResume();
+        if (mIsGoingBack) {
+            if (!mIsExiting) {
+                applyBackwardTransition(getTransition());
+            }
+        } else if (!mIsExiting) {
+            applyForwardTransition(getTransition());
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        if (LOGV) {
+            logActivityState("onPause");
+        }
+        super.onPause();
+    }
+
+    @Override
+    protected void onStop() {
+        if (LOGV) {
+            logActivityState("onStop");
+        }
+        super.onStop();
+    }
+
+    @Override
+    protected void onDestroy() {
+        if (LOGV) {
+            logActivityState("onDestroy");
+        }
+        super.onDestroy();
+    }
+
+    @Override
+    public void onAttachedToWindow() {
+        if (LOGV) {
+            logActivityState("onAttachedToWindow");
+        }
+        mIsActivityVisible = true;
+        super.onAttachedToWindow();
+    }
+
+    @Override
+    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
+        if (LOGV) {
+            Log.v(TAG, "onRestoreInstanceState(" + savedInstanceState + ")");
+        }
+        super.onRestoreInstanceState(savedInstanceState);
+        int currentId = savedInstanceState.getInt("currentFocus", -1);
+        if (currentId != -1) {
+            View view = findViewById(currentId);
+            if (view != null) {
+                view.requestFocus();
+            }
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        super.onSaveInstanceState(outState);
+        View current = getCurrentFocus();
+        outState.putInt("currentFocus", current != null ? current.getId() : -1);
+        if (LOGV) {
+            Log.v(TAG, "onSaveInstanceState(" + outState + ")");
+        }
+    }
+
+    @Override
+    public void onNavigationBarCreated(SetupWizardNavBar bar) {
+        mNavigationBar = bar;
+        bar.setUseImmersiveMode(true);
+        bar.getView().addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
+            @Override
+            public void onLayoutChange(View view, int left, int top, int right, int bottom,
+                                       int oldLeft, int oldTop, int oldRight, int oldBottom) {
+                view.requestApplyInsets();
+            }
+        });
+    }
+
+    protected void setBackDrawable(Drawable drawable) {
+        if (mNavigationBar != null) {
+            mNavigationBar.getBackButton().setCompoundDrawables(drawable, null, null, null);
+        }
+    }
+
+    protected void setNextDrawable(Drawable drawable) {
+        if (mNavigationBar != null) {
+            mNavigationBar.getBackButton().setCompoundDrawables(null, null, drawable, null);
+        }
+    }
+
+    public void setBackAllowed(boolean allowed) {
+        SystemBarHelper.setBackButtonVisible(getWindow(), allowed);
+        if (mNavigationBar != null) {
+            Button backButton = mNavigationBar.getBackButton();
+            backButton.setEnabled(allowed);
+        }
+    }
+
+    protected boolean isBackAllowed() {
+        if (mNavigationBar != null) {
+            mNavigationBar.getBackButton().isEnabled();
+        }
+        return false;
+    }
+
+    public void setNextAllowed(boolean allowed) {
+        if (mNavigationBar != null) {
+            mNavigationBar.getNextButton().setEnabled(allowed);
+        }
+    }
+
+    protected boolean isNextAllowed() {
+        if (mNavigationBar != null) {
+            mNavigationBar.getNextButton().isEnabled();
+        }
+        return false;
+    }
+
+    protected void onNextPressed() {
+        nextAction(NEXT_REQUEST);
+    }
+
+    protected void setNextText(int resId) {
+        if (mNavigationBar != null) {
+            mNavigationBar.getNextButton().setText(resId);
+        }
+    }
+
+    protected void setBackText(int resId) {
+        if (mNavigationBar != null) {
+            mNavigationBar.getBackButton().setText(resId);
+        }
+    }
+
+    protected void hideNextButton() {
+        if (mNavigationBar != null) {
+            Animation fadeOut = AnimationUtils.loadAnimation(this, android.R.anim.fade_out);
+            final Button next = mNavigationBar.getNextButton();
+            next.startAnimation(fadeOut);
+            next.setVisibility(View.INVISIBLE);
+        }
+    }
+
+    protected Intent getResultData() {
+        return null;
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (LOGV) {
+            Log.v(TAG, "onBackPressed()");
+        }
+        setResultCode(RESULT_CANCELED, getResultData());
+        super.onBackPressed();
+    }
+
+    public void onNavigateBack() {
+        onBackPressed();
+    }
+
+    public void onNavigateNext() {
+        onNextPressed();
+    }
+
+    protected void startEmergencyDialer() {
+        try {
+            startFirstRunActivityForResult(new Intent(ACTION_EMERGENCY_DIAL),
+                    EMERGENCY_DIAL_ACTIVITY_REQUEST);
+            applyForwardTransition(TRANSITION_ID_DEFAULT);
+        } catch (ActivityNotFoundException e) {
+            Log.e(TAG, "Can't find the emergency dialer: com.android.phone.EmergencyDialer.DIAL");
+        }
+    }
+
+    protected void onSetupStart() {
+        SetupWizardUtils.disableCaptivePortalDetection(getApplicationContext());
+        SetupWizardUtils.disableStatusBar(getApplicationContext());
+        SystemBarHelper.hideSystemBars(getWindow());
+        tryEnablingWifi();
+    }
+
+
+    protected void exitIfSetupComplete() {
+        if (WizardManagerHelper.isUserSetupComplete(this)) {
+            Log.i(TAG, "Starting activity with USER_SETUP_COMPLETE=true");
+            startSetupWizardExitActivity();
+            setResult(RESULT_CANCELED, null);
+            finishAllAppTasks();
+        }
+    }
+
+    protected void finishAllAppTasks() {
+        List<ActivityManager.AppTask> appTasks =
+                getSystemService(ActivityManager.class).getAppTasks();
+
+        for (ActivityManager.AppTask task : appTasks) {
+            if (LOGV) {
+                Log.v(TAG, "Finishing task=" + task.toString());
+            }
+            task.finishAndRemoveTask();
+        }
+        finish();
+    }
+
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (LOGV) {
+            Log.v(TAG, "onActivityResult(" + getRequestName(requestCode) + ", " +
+                    getResultName(requestCode, resultCode) + ")");
+        }
+        mIsGoingBack = true;
+        if (requestCode != NEXT_REQUEST || resultCode != RESULT_CANCELED) {
+            if (requestCode == EMERGENCY_DIAL_ACTIVITY_REQUEST) {
+                applyBackwardTransition(TRANSITION_ID_DEFAULT);
+                return;
+            }
+            if (resultCode == RESULT_CANCELED) {
+                finish();
+            } else {
+                nextAction(resultCode);
+            }
+        }
+    }
+
+    public void finish() {
+        if (LOGV) {
+            Log.v(TAG, "finish");
+        }
+        super.finish();
+        if (isResumed() && mResultCode == RESULT_CANCELED) {
+            applyBackwardTransition(getTransition());
+        }
+        mIsExiting = true;
+    }
+
+    protected void finishAction() {
+        finishAction(RESULT_CANCELED);
+    }
+
+    protected void finishAction(int resultCode) {
+        finishAction(resultCode, null);
+    }
+
+    protected void finishAction(int resultCode, Intent data) {
+        if (resultCode != 0) {
+            nextAction(resultCode, data);
+        }
+        finish();
+    }
+
+    protected void setResultCode(int resultCode) {
+        setResultCode(resultCode, getResultData());
+    }
+
+    protected void setResultCode(int resultCode, Intent data) {
+        if (LOGV) {
+            Log.v(TAG, "setResultCode result=" + getResultName(0, resultCode) + " data=" + data);
+        }
+        mResultCode = resultCode;
+        mResultData = data;
+        setResult(resultCode, data);
+    }
+
+    protected void nextAction(int resultCode) {
+        nextAction(resultCode, null);
+    }
+
+    protected void nextAction(int resultCode, Intent data) {
+        if (LOGV) {
+            Log.v(TAG, "nextAction resultCode=" + resultCode +
+                    " data=" + data + " this=" + this);
+        }
+        if (resultCode == 0) {
+            throw new IllegalArgumentException("Cannot call nextAction with RESULT_CANCELED");
+        }
+        setResultCode(resultCode, data);
+        sendActionResults();
+    }
+
+    public void startActivity(Intent intent) {
+        super.startActivity(intent);
+        if (isResumed() && mIsActivityVisible) {
+            applyForwardTransition(getTransition());
+        }
+        mIsExiting = true;
+    }
+
+    public void startActivityForResult(Intent intent, int requestCode) {
+        super.startActivityForResult(intent, requestCode);
+        if (isResumed() && mIsActivityVisible) {
+            applyForwardTransition(getTransition());
+        }
+        mIsExiting = true;
+    }
+
+    protected void sendActionResults() {
+        if (LOGV) {
+            Log.v(TAG, "sendActionResults resultCode=" + mResultCode + " data=" + mResultData);
+        }
+        Intent intent = new Intent(ACTION_NEXT);
+        intent.putExtra(EXTRA_SCRIPT_URI, getIntent().getStringExtra(EXTRA_SCRIPT_URI));
+        intent.putExtra(EXTRA_ACTION_ID, getIntent().getStringExtra(EXTRA_ACTION_ID));
+        intent.putExtra(EXTRA_RESULT_CODE, mResultCode);
+        if (!(mResultData == null || mResultData.getExtras() == null)) {
+            intent.putExtras(mResultData.getExtras());
+        }
+        startActivityForResult(intent, NEXT_REQUEST);
+    }
+
+    protected void applyForwardTransition(int transitionId) {
+        if (transitionId == TRANSITION_ID_SLIDE) {
+            overridePendingTransition(R.anim.suw_slide_next_in, R.anim.suw_slide_next_out);
+        } else if (transitionId == TRANSITION_ID_FADE) {
+            overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
+        } else if (transitionId == TRANSITION_ID_DEFAULT) {
+            TypedArray typedArray = obtainStyledAttributes(android.R.style.Animation_Activity,
+                    new int[]{android.R.attr.activityOpenEnterAnimation,
+                            android.R.attr.activityOpenExitAnimation});
+            overridePendingTransition(typedArray.getResourceId(0, 0),
+                    typedArray.getResourceId(1, 0));
+            typedArray.recycle();
+        } else if (transitionId == TRANSITION_ID_NONE) {
+            overridePendingTransition(0, 0);
+        }
+    }
+
+    protected void applyBackwardTransition(int transitionId) {
+        if (transitionId == TRANSITION_ID_SLIDE) {
+            overridePendingTransition(R.anim.suw_slide_back_in, R.anim.suw_slide_back_out);
+        } else if (transitionId == TRANSITION_ID_FADE) {
+            overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
+        } else if (transitionId == TRANSITION_ID_DEFAULT) {
+            TypedArray typedArray = obtainStyledAttributes(android.R.style.Animation_Activity,
+                    new int[]{android.R.attr.activityCloseEnterAnimation,
+                    android.R.attr.activityCloseExitAnimation});
+            overridePendingTransition(typedArray.getResourceId(0, 0),
+                    typedArray.getResourceId(1, 0));
+            typedArray.recycle();
+        } else if (transitionId == TRANSITION_ID_NONE) {
+            overridePendingTransition(0, 0);
+        }
+    }
+
+    protected void hideBackButton() {
+        if (mNavigationBar != null) {
+            Animation fadeOut = AnimationUtils.loadAnimation(this, android.R.anim.fade_out);
+            final Button back = mNavigationBar.getBackButton();
+            back.startAnimation(fadeOut);
+            back.setVisibility(View.INVISIBLE);
+        }
+    }
+
+    protected int getTransition() {
+        return TRANSITION_ID_DEFAULT;
+    }
+
+    protected boolean tryEnablingWifi() {
+        WifiManager wifiManager = getSystemService(WifiManager.class);
+        if (wifiManager != null && !wifiManager.isWifiEnabled()) {
+            return wifiManager.setWifiEnabled(true);
+        }
+        return false;
+    }
+
+    private void startSetupWizardExitActivity() {
+        if (LOGV) {
+            Log.v(TAG, "startSetupWizardExitActivity()");
+        }
+        startFirstRunActivity(new Intent(this, SetupWizardExitActivity.class));
+    }
+
+    protected void startFirstRunActivity(Intent intent) {
+        if (LOGV) {
+            Log.v(TAG, "starting activity " + intent);
+        }
+        intent.putExtra(EXTRA_FIRST_RUN, isFirstRun());
+        intent.putExtra(EXTRA_HAS_MULTIPLE_USERS, hasMultipleUsers());
+        intent.putExtra(EXTRA_USE_IMMERSIVE, true);
+        startActivity(intent);
+    }
+
+    protected void startFirstRunActivityForResult(Intent intent, int requestCode) {
+        if (LOGV) {
+            Log.v(TAG, "startFirstRunActivityForResult requestCode=" + requestCode);
+        }
+        intent.putExtra(EXTRA_FIRST_RUN, isFirstRun());
+        intent.putExtra(EXTRA_HAS_MULTIPLE_USERS, hasMultipleUsers());
+        intent.putExtra(EXTRA_USE_IMMERSIVE, true);
+        startActivityForResult(intent, requestCode);
+    }
+
+
+    protected boolean isFirstRun() {
+        return mIsFirstRun;
+    }
+
+    protected boolean isPrimaryUser() {
+        return mIsPrimaryUser;
+    }
+
+    public boolean hasMultipleUsers() {
+        return ((UserManager) getSystemService(USER_SERVICE)).getUsers().size() > 1;
+    }
+
+    protected void logActivityState(String prefix) {
+        Log.v(TAG, prefix + " isResumed=" + isResumed() + " isFinishing=" +
+                isFinishing() + " isDestroyed=" + isDestroyed());
+    }
+
+    protected static String getRequestName(int requestCode) {
+        StringBuilder sb = new StringBuilder();
+        switch (requestCode) {
+            case NEXT_REQUEST:
+                sb.append("NEXT_REQUEST");
+                break;
+            case EMERGENCY_DIAL_ACTIVITY_REQUEST:
+                sb.append("EMERGENCY_DIAL_ACTIVITY_REQUEST");
+                break;
+            case WIFI_ACTIVITY_REQUEST:
+                sb.append("WIFI_ACTIVITY_REQUEST");
+                break;
+            case BLUETOOTH_ACTIVITY_REQUEST:
+                sb.append("BLUETOOTH_ACTIVITY_REQUEST");
+                break;
+            case FINGERPRINT_ACTIVITY_REQUEST:
+                sb.append("FINGERPRINT_ACTIVITY_REQUEST");
+                break;
+            case SCREENLOCK_ACTIVITY_REQUEST:
+                sb.append("SCREENLOCK_ACTIVITY_REQUEST");
+                break;
+        }
+        sb.append("(").append(requestCode).append(")");
+        return sb.toString();
+    }
+
+    protected static String getResultName(int requestCode, int resultCode) {
+        StringBuilder sb = new StringBuilder();
+        switch (requestCode) {
+            case WIFI_ACTIVITY_REQUEST:
+                switch (resultCode) {
+                    case RESULT_OK:
+                        sb.append("RESULT_OK");
+                        break;
+                    case RESULT_CANCELED:
+                        sb.append("RESULT_CANCELED");
+                        break;
+                    case RESULT_SKIP:
+                        sb.append("RESULT_WIFI_SKIP");
+                        break;
+                    default:
+                        break;
+                }
+            case BLUETOOTH_ACTIVITY_REQUEST:
+                switch (resultCode) {
+                    case RESULT_OK:
+                        sb.append("RESULT_OK");
+                        break;
+                    case RESULT_CANCELED:
+                        sb.append("RESULT_CANCELED");
+                        break;
+                    case RESULT_SKIP:
+                        sb.append("RESULT_BLUETOOTH_SKIP");
+                        break;
+                    default:
+                        break;
+                }
+            case FINGERPRINT_ACTIVITY_REQUEST:
+                switch (resultCode) {
+                    case RESULT_OK:
+                        sb.append("RESULT_OK");
+                        break;
+                    case RESULT_CANCELED:
+                        sb.append("RESULT_CANCELED");
+                        break;
+                    case RESULT_SKIP:
+                        sb.append("RESULT_FINGERPRINT_SKIP");
+                        break;
+                    default:
+                        break;
+                }
+            case SCREENLOCK_ACTIVITY_REQUEST:
+                switch (resultCode) {
+                    case RESULT_OK:
+                        sb.append("RESULT_OK");
+                        break;
+                    case RESULT_CANCELED:
+                        sb.append("RESULT_CANCELED");
+                        break;
+                    case RESULT_SKIP:
+                        sb.append("RESULT_SCREENLOCK_SKIP");
+                        break;
+                    default:
+                        break;
+                }
+            default:
+                switch (resultCode) {
+                    case RESULT_OK:
+                        sb.append("RESULT_OK");
+                        break;
+                    case RESULT_CANCELED:
+                        sb.append("RESULT_CANCELED");
+                        break;
+                    case RESULT_SKIP:
+                        sb.append("RESULT_SKIP");
+                        break;
+                    case RESULT_RETRY:
+                        sb.append("RESULT_RETRY");
+                        break;
+                    case RESULT_ACTIVITY_NOT_FOUND:
+                        sb.append("RESULT_ACTIVITY_NOT_FOUND");
+                        break;
+                }
+                break;
+        }
+        sb.append("(").append(resultCode).append(")");
+        return sb.toString();
+    }
+
+    private void initLayout() {
+        if (getLayoutResId() != -1) {
+            setContentView(getLayoutResId());
+        }
+        if (getTitleResId() != -1) {
+            TextView title = (TextView) findViewById(android.R.id.title);
+            title.setText(getTitleResId());
+        }
+        if (getIconResId() != -1) {
+            ImageView icon = (ImageView) findViewById(R.id.header_icon);
+            icon.setImageResource(getIconResId());
+            icon.setVisibility(View.VISIBLE);
+        }
+    }
+
+    protected int getLayoutResId() {
+        return -1;
+    }
+
+    protected int getTitleResId() {
+        return -1;
+    }
+
+    protected int getIconResId() {
+        return -1;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/BluetoothSetupActivity.java b/src/org/lineageos/setupwizard/BluetoothSetupActivity.java
new file mode 100644
index 0000000..a8b8d88
--- /dev/null
+++ b/src/org/lineageos/setupwizard/BluetoothSetupActivity.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_BLUETOOTH;
+
+import android.content.Intent;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+public class BluetoothSetupActivity extends SubBaseActivity {
+
+    public static final String TAG = BluetoothSetupActivity.class.getSimpleName();
+
+    private static final String ACTION_CONNECT_INPUT =
+            "com.google.android.intent.action.CONNECT_INPUT";
+
+    private static final String INTENT_EXTRA_NO_INPUT_MODE = "no_input_mode";
+
+    @Override
+    protected void onStartSubactivity() {
+        try {
+            Intent intent = new Intent();
+            intent.setComponent(SetupWizardUtils.mTvAddAccessorySettingsActivity);
+            intent.setAction(ACTION_CONNECT_INPUT);
+            intent.putExtra(INTENT_EXTRA_NO_INPUT_MODE, true);
+            startActivityForResult(intent, REQUEST_CODE_SETUP_BLUETOOTH);
+        } catch (Exception e) {
+            Log.e(TAG, "Error starting bluetooth setup", e);
+            nextAction(RESULT_OK);
+            SetupWizardUtils.disableComponent(this, BluetoothSetupActivity.class);
+            finish();
+        }
+    }
+
+    @Override
+    protected int getSubactivityNextTransition() {
+        nextAction(RESULT_OK);
+        return TRANSITION_ID_SLIDE;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/CaptivePortalSetupActivity.java b/src/org/lineageos/setupwizard/CaptivePortalSetupActivity.java
new file mode 100644
index 0000000..1b7cc07
--- /dev/null
+++ b/src/org/lineageos/setupwizard/CaptivePortalSetupActivity.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_CAPTIVE_PORTAL;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.CaptivePortal;
+import android.net.ConnectivityManager;
+import android.net.ICaptivePortal;
+import android.os.AsyncTask;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Random;
+
+public class CaptivePortalSetupActivity extends SubBaseActivity {
+
+    public static final String TAG = CaptivePortalSetupActivity.class.getSimpleName();
+
+    private static final String DEFAULT_SERVER = "clients3.google.com";
+    private static final int CAPTIVE_PORTAL_SOCKET_TIMEOUT_MS = 10000;
+
+    private URL mCaptivePortalUrl;
+
+    @Override
+    protected void onStartSubactivity() {
+        String server = Settings.Global.getString(getContentResolver(), "captive_portal_server");
+        if (server == null) server = DEFAULT_SERVER;
+        try {
+            mCaptivePortalUrl = new URL("http://" + server + "/generate_204");
+        } catch (MalformedURLException e) {
+            Log.e(TAG, "Not a valid url" + e);
+        }
+        CheckForCaptivePortalTask
+                .checkForCaptivePortal(mCaptivePortalUrl, this, true);
+    }
+
+    @Override
+    protected int getSubactivityNextTransition() {
+        return TRANSITION_ID_FADE;
+    }
+
+    private static class CheckForCaptivePortalTask extends AsyncTask<Void, Void, Boolean> {
+
+        private final URL captivePortalUrl;
+        private final CaptivePortalSetupActivity captivePortalSetupActivity;
+        private static CheckForCaptivePortalTask sTask = null;
+        private String responseToken;
+
+        public CheckForCaptivePortalTask(URL captivePortalUrl,
+                CaptivePortalSetupActivity captivePortalSetupActivity) {
+            this.captivePortalUrl = captivePortalUrl;
+            this.captivePortalSetupActivity = captivePortalSetupActivity;
+        }
+
+        public static void checkForCaptivePortal(URL captivePortalUrl,
+                CaptivePortalSetupActivity captivePortalSetupActivity, boolean cancelAndRecreateIfRunning) {
+            if (sTask == null || sTask.getStatus() == Status.FINISHED) {
+                sTask = new CheckForCaptivePortalTask(captivePortalUrl, captivePortalSetupActivity);
+                sTask.execute();
+
+            } else if (cancelAndRecreateIfRunning) {
+                sTask.cancel(true);
+                sTask = new CheckForCaptivePortalTask(captivePortalUrl, captivePortalSetupActivity);
+                sTask.execute();
+            }
+        }
+
+        @Override
+        protected Boolean doInBackground(Void... params) {
+            if (captivePortalUrl == null) return false;
+            HttpURLConnection urlConnection = null;
+            try {
+                urlConnection = (HttpURLConnection) captivePortalUrl.openConnection();
+                urlConnection.setInstanceFollowRedirects(false);
+                urlConnection.setConnectTimeout(CAPTIVE_PORTAL_SOCKET_TIMEOUT_MS);
+                urlConnection.setReadTimeout(CAPTIVE_PORTAL_SOCKET_TIMEOUT_MS);
+                urlConnection.setUseCaches(false);
+                urlConnection.getInputStream();
+                // We got a valid response, but not from the real google
+                final int responseCode = urlConnection.getResponseCode();
+                if (responseCode == 408 || responseCode == 504) {
+                    // If we timeout here, we'll try and go through captive portal login
+                    return true;
+                }
+                return urlConnection.getResponseCode() != 204;
+            } catch (IOException e) {
+                Log.e(TAG, "Captive portal check - probably not a portal: exception "
+                        + e);
+                return false;
+            } finally {
+                if (urlConnection != null) {
+                    urlConnection.disconnect();
+                }
+            }
+        }
+
+        @Override
+        protected void onPostExecute(Boolean isPortal) {
+            if (isPortal) {
+                final Context context = captivePortalSetupActivity.getApplicationContext();
+                responseToken = String.valueOf(new Random().nextLong());
+                final Intent intent = new Intent(
+                        ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
+                intent.putExtra(Intent.EXTRA_TEXT, responseToken);
+                intent.putExtra(ConnectivityManager.EXTRA_NETWORK,
+                        ConnectivityManager.from(context)
+                                .getNetworkForType(ConnectivityManager.TYPE_WIFI));
+                intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL,
+                        new CaptivePortal(new ICaptivePortal.Stub() {
+                            @Override
+                            public void appResponse(int response) {}
+                        }));
+                intent.putExtra("status_bar_color",
+                        context.getResources().getColor(R.color.primary_dark));
+                intent.putExtra("action_bar_color", context.getResources().getColor(
+                        R.color.primary_dark));
+                intent.putExtra("progress_bar_color", context.getResources().getColor(
+                        R.color.accent));
+                captivePortalSetupActivity.startSubactivity(intent, REQUEST_CODE_SETUP_CAPTIVE_PORTAL);
+            } else {
+                captivePortalSetupActivity.finishAction(RESULT_OK);
+                captivePortalSetupActivity.finish();
+            }
+        }
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/ChooseDataSimActivity.java b/src/org/lineageos/setupwizard/ChooseDataSimActivity.java
new file mode 100644
index 0000000..725ade9
--- /dev/null
+++ b/src/org/lineageos/setupwizard/ChooseDataSimActivity.java
@@ -0,0 +1,498 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.os.Bundle;
+import android.os.Handler;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseArray;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.AnimationUtils;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import com.cyanogenmod.setupwizard.util.PhoneMonitor;
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+import java.util.List;
+
+public class ChooseDataSimActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = ChooseDataSimActivity.class.getSimpleName();
+
+    private ViewGroup mPageView;
+    private ProgressBar mProgressBar;
+    private SparseArray<TextView> mNameViews;
+    private SparseArray<ImageView> mSignalViews;
+    private SparseArray<CheckBox> mCheckBoxes;
+    private SparseArray<View> mRows;
+
+    private SparseArray<SubscriptionInfo> mSubInfoRecords;
+    private SparseArray<SignalStrength> mSignalStrengths;
+    private SparseArray<ServiceState> mServiceStates;
+
+    private boolean mIsAttached = false;
+    private boolean mRadioReady = false;
+
+    private PhoneMonitor mPhoneMonitor;
+
+    private boolean mDisabledForSwitch = false;
+
+    private final Handler mHandler = new Handler();
+
+    private final Runnable mRadioReadyRunnable = new Runnable() {
+        @Override
+        public void run() {
+            // If we timeout out waiting for the radio, Oh well.
+            if (!mRadioReady) {
+                mRadioReady = true;
+                checkForRadioReady();
+            }
+        }
+    };
+
+    private View.OnClickListener mSetDataSimClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            SubscriptionInfo subInfoRecord = (SubscriptionInfo)view.getTag();
+            if (subInfoRecord != null) {
+                changeDataSub(subInfoRecord);
+            }
+        }
+    };
+
+    private PhoneMonitor.SubscriptionStateListener mSubscriptionStateListener =
+            new PhoneMonitor.SubscriptionStateListener() {
+                @Override
+                public void onServiceStateChanged(int subId, ServiceState serviceState) {
+                    if (LOGV) {
+                        Log.v(TAG, "onServiceStateChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", serviceState=" + serviceState.toString() +
+                                '}');
+                    }
+                    SubscriptionInfo subInfoRecord =
+                            mPhoneMonitor.getActiveSubscriptionInfo(subId);
+                    mRadioReady = SetupWizardUtils.isRadioReady(
+                            ChooseDataSimActivity.this, serviceState);
+                    checkForRadioReady();
+                    mServiceStates.put(subInfoRecord.getSimSlotIndex(), serviceState);
+                    updateSignalStrength(subInfoRecord);
+                }
+
+                @Override
+                public void onDataConnectionStateChanged(int subId, int state, int networkType) {
+                    if (LOGV) {
+                        Log.v(TAG, "onDataConnectionStateChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", state=" + state +
+                                '}');
+                    }
+                    onDefaultDataSubscriptionChanged(subId);
+                }
+
+                @Override
+                public void onDefaultDataSubscriptionChanged(int subId) {
+                    if (LOGV) {
+                        Log.v(TAG, "onDefaultDataSubscriptionChanged{" +
+                                "subId='" + subId + '\'' +
+                                '}');
+                    }
+                    final int currentDataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
+                    if (currentDataSubId != subId) {
+                        updateCurrentDataSub();
+                        hideProgress();
+                        enableViews(true);
+                    }
+                    checkSimChangingState(currentDataSubId, subId);
+                }
+
+                @Override
+                public void onDefaultDataSubscriptionChangeRequested(int currentSubId,
+                        int newSubId) {
+                    if (LOGV) {
+                        Log.v(TAG, "onDefaultDataSubscriptionChangeRequested{" +
+                                "currentSubId='" + currentSubId + '\'' +
+                                ", newSubId=" + newSubId +
+                                '}');
+                    }
+                    checkSimChangingState(currentSubId, newSubId);
+                }
+
+                @Override
+                public void onSignalStrengthsChanged(int subId, SignalStrength signalStrength) {
+                    if (LOGV) {
+                        Log.v(TAG, "onSignalStrengthsChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", signalStrength=" + signalStrength.toString() +
+                                '}');
+                    }
+                    SubscriptionInfo subInfoRecord =
+                            mPhoneMonitor.getActiveSubscriptionInfo(subId);
+                    mSignalStrengths.put(subInfoRecord.getSimSlotIndex(), signalStrength);
+                    updateSignalStrength(subInfoRecord);
+                }
+
+                @Override
+                public void onSimStateChanged(int subId, int simState) {
+                    if (LOGV) {
+                        Log.v(TAG, "onSimStateChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", simState=" + simState +
+                                '}');
+                    }
+                    updateSignalStrengths();
+                    updateCurrentDataSub();
+                }
+            };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setNextText(R.string.next);
+        mPhoneMonitor = PhoneMonitor.getInstance();
+        mPageView = (ViewGroup) findViewById(R.id.page_view);
+        mProgressBar = (ProgressBar) findViewById(R.id.progress);
+        List<SubscriptionInfo> subInfoRecords = mPhoneMonitor.getActiveSubscriptionInfoList();
+        int simCount =
+                subInfoRecords != null ? subInfoRecords.size() : 0;
+        mSubInfoRecords = new SparseArray<>(simCount);
+        for (SubscriptionInfo subInfoRecord : subInfoRecords) {
+            mSubInfoRecords.put(subInfoRecord.getSimSlotIndex(), subInfoRecord);
+            updateSignalStrength(subInfoRecord);
+        }
+        mNameViews = new SparseArray<>(simCount);
+        mSignalViews = new SparseArray<>(simCount);
+        mCheckBoxes = new SparseArray<>(simCount);
+        mRows = new SparseArray<>(simCount);
+        mServiceStates = new SparseArray<>(simCount);
+        mSignalStrengths = new SparseArray<>(simCount);
+        LayoutInflater inflater = LayoutInflater.from(this);
+        for (int i = 0; i < simCount; i++) {
+            View simRow = inflater.inflate(R.layout.data_sim_row, null);
+            mPageView.addView(simRow);
+            SubscriptionInfo subInfoRecord = mSubInfoRecords.valueAt(i);
+            simRow.setTag(subInfoRecord);
+            simRow.setOnClickListener(mSetDataSimClickListener);
+            int slot = subInfoRecord.getSimSlotIndex();
+            mNameViews.put(slot, (TextView) simRow.findViewById(R.id.sim_title));
+            mSignalViews.put(slot, (ImageView) simRow.findViewById(R.id.signal));
+            mCheckBoxes.put(slot, (CheckBox) simRow.findViewById(R.id.enable_check));
+            mRows.put(slot, simRow);
+            mPageView.addView(inflater.inflate(R.layout.divider, null));
+        }
+        updateSignalStrengths();
+        updateCurrentDataSub();
+
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mIsAttached = false;
+        mPhoneMonitor.removeListener(mSubscriptionStateListener);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mIsAttached = true;
+        mPhoneMonitor.addListener(mSubscriptionStateListener);
+        mRadioReady = SetupWizardUtils.isRadioReady(this, null);
+        updateSignalStrengths();
+        updateCurrentDataSub();
+        checkForRadioReady();
+        if (mRadioReady) {
+            final int currentDataSub = SubscriptionManager.getDefaultDataSubscriptionId();
+            checkSimChangingState(currentDataSub, currentDataSub);
+        }
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    private void checkForRadioReady() {
+        if (mRadioReady) {
+            mHandler.removeCallbacks(mRadioReadyRunnable);
+            showPage();
+            final int currentDataSub = SubscriptionManager.getDefaultDataSubscriptionId();
+            checkSimChangingState(currentDataSub, currentDataSub);
+            return;
+        } else {
+            enableViews(false);
+            showProgress();
+            if (!mHandler.hasCallbacks(mRadioReadyRunnable)) {
+                mHandler.postDelayed(mRadioReadyRunnable, SetupWizardApp.RADIO_READY_TIMEOUT);
+            }
+        }
+    }
+
+    private void showPage() {
+        mPageView.setVisibility(View.VISIBLE);
+        if (!mPageView.isShown()) {
+            mPageView.startAnimation(
+                    AnimationUtils.loadAnimation(this, R.anim.translucent_enter));
+        }
+    }
+
+    private void showProgress() {
+        if (!mProgressBar.isShown()) {
+            mProgressBar.setVisibility(View.VISIBLE);
+            mProgressBar.startAnimation(
+                    AnimationUtils.loadAnimation(this, R.anim.translucent_enter));
+        }
+    }
+
+    private void hideProgress() {
+        if (mProgressBar.isShown()) {
+            mProgressBar.startAnimation(
+                    AnimationUtils.loadAnimation(this, R.anim.translucent_exit));
+            mProgressBar.setVisibility(View.INVISIBLE);
+        }
+    }
+
+    private void updateSignalStrengths() {
+        if (mIsAttached) {
+            for (int i = 0; i < mSubInfoRecords.size(); i++) {
+                updateSignalStrength(mSubInfoRecords.valueAt(i));
+            }
+        }
+    }
+
+    private void changeDataSub(SubscriptionInfo subInfoRecord) {
+        final int currentDataSub = SubscriptionManager.getDefaultDataSubscriptionId();
+        final int requestedDataSub = subInfoRecord.getSubscriptionId();
+        if (LOGV) {
+            Log.v(TAG, "changeDataSub{" +
+                    "currentDataSub='" + currentDataSub + '\'' +
+                    ", requestedDataSub=" + requestedDataSub +
+                    '}');
+        }
+        if (currentDataSub != requestedDataSub) {
+            mPhoneMonitor.changeDataSub(requestedDataSub);
+            setDataSubChecked(subInfoRecord);
+            checkSimChangingState(currentDataSub, requestedDataSub);
+        }
+    }
+
+    private void checkSimChangingState(int currentDataSubId, int changingToDataSubId) {
+        if (LOGV) {
+            Log.v(TAG, "checkSimChangingState{" +
+                    "currentDataSubId='" + currentDataSubId + '\'' +
+                    "changingToDataSubId='" + changingToDataSubId + '\'' +
+                    "mIsAttached='" + mIsAttached + '\'' +
+                    ", mRadioReady=" + mRadioReady +
+                    '}');
+        }
+        if (mIsAttached && mRadioReady) {
+            if (currentDataSubId != changingToDataSubId) {
+                showProgress();
+                enableViews(false);
+            } else {
+                hideProgress();
+                enableViews(true);
+            }
+        }
+    }
+
+    private void setDataSubChecked(SubscriptionInfo subInfoRecord) {
+        if (mIsAttached) {
+            for (int i = 0; i < mCheckBoxes.size(); i++) {
+                int key = mCheckBoxes.keyAt(i);
+                if (subInfoRecord.getSimSlotIndex() == key) {
+                    mCheckBoxes.get(key).setChecked(true);
+                } else {
+                    mCheckBoxes.get(key).setChecked(false);
+                }
+            }
+        }
+    }
+
+    private void updateCurrentDataSub() {
+        if (mIsAttached) {
+            for (int i = 0; i < mSubInfoRecords.size(); i++) {
+                SubscriptionInfo subInfoRecord = mSubInfoRecords.valueAt(i);
+                int slot = subInfoRecord.getSimSlotIndex();
+                mCheckBoxes.get(slot).setChecked(SubscriptionManager.getDefaultDataSubscriptionId()
+                        == subInfoRecord.getSubscriptionId());
+                if (LOGV) {
+                    Log.v(TAG, "updateCurrentDataSub{" +
+                            "currentDataSubId='" + SubscriptionManager
+                            .getDefaultDataSubscriptionId() + '\'' +
+                            "subInfoRecord.getSubscriptionId()='" +
+                            subInfoRecord.getSubscriptionId() +
+                            '}');
+                }
+            }
+        }
+    }
+
+    private void enableViews(boolean enabled) {
+        mDisabledForSwitch = !enabled;
+        enableRows(enabled);
+        setNextAllowed(enabled);
+    }
+
+    private void enableRows(boolean enabled) {
+        for (int i = 0; i < mRows.size(); i++) {
+            final View v =  mRows.get(mRows.keyAt(i));
+            v.setEnabled(enabled);
+            final SubscriptionInfo subInfoRecord = (SubscriptionInfo)v.getTag();
+            if (subInfoRecord != null) {
+                updateCarrierText(subInfoRecord);
+            }
+        }
+    }
+
+    private void updateCarrierText(SubscriptionInfo subInfoRecord) {
+        if (mIsAttached) {
+            String name = mPhoneMonitor.getSimOperatorName(subInfoRecord.getSubscriptionId());
+            if (TextUtils.isEmpty(name)) {
+                name = mPhoneMonitor.getNetworkOperatorName(subInfoRecord.getSubscriptionId());
+            }
+            ServiceState serviceState = mServiceStates.get(subInfoRecord.getSimSlotIndex());
+            final int slot = subInfoRecord.getSimSlotIndex();
+            final View v = mRows.get(slot);
+            if (TextUtils.isEmpty(name)) {
+                if (serviceState != null && serviceState.isEmergencyOnly()) {
+                    name = getString(R.string.setup_mobile_data_emergency_only);
+                } else {
+                    name = getString(R.string.setup_mobile_data_no_service);
+                }
+                if (v != null) {
+                    v.setEnabled(false);
+                }
+            } else {
+                if (v != null && !mDisabledForSwitch) {
+                    v.setEnabled(true);
+                }
+            }
+            String formattedName =
+                    getString(R.string.data_sim_name,
+                            slot + 1, name);
+            mNameViews.get(slot).setText(formattedName);
+        }
+    }
+
+    private void updateSignalStrength(SubscriptionInfo subInfoRecord) {
+        if (mIsAttached) {
+            ImageView signalView = mSignalViews.get(subInfoRecord.getSimSlotIndex());
+            SignalStrength signalStrength = mSignalStrengths.get(subInfoRecord.getSimSlotIndex());
+            if (LOGV) {
+                Log.v(TAG, "updateSignalStrength{" +
+                        "signalStrength='" + signalStrength + '\'' +
+                        "signalStrengthLevel='" + ((signalStrength != null) ?
+                        signalStrength.getLevel() : "null") + '\'' +
+                        ", subInfoRecord.getSimSlotIndex() =" + subInfoRecord.getSimSlotIndex()  +
+                        '}');
+            }
+            if (!hasService(subInfoRecord)) {
+                signalView.setImageResource(R.drawable.ic_signal_no_signal);
+            } else {
+                if (signalStrength != null) {
+                    int resId;
+                    switch (signalStrength.getLevel()) {
+                        case 4:
+                            resId = R.drawable.ic_signal_4;
+                            break;
+                        case 3:
+                            resId = R.drawable.ic_signal_3;
+                            break;
+                        case 2:
+                            resId = R.drawable.ic_signal_2;
+                            break;
+                        case 1:
+                            resId = R.drawable.ic_signal_1;
+                            break;
+                        default:
+                            resId = R.drawable.ic_signal_0;
+                            break;
+                    }
+                    signalView.setImageResource(resId);
+                }
+            }
+            updateCarrierText(subInfoRecord);
+        }
+    }
+
+    private boolean hasService(SubscriptionInfo subInfoRecord) {
+        boolean retVal;
+        ServiceState serviceState = mServiceStates.get(subInfoRecord.getSimSlotIndex());
+        if (serviceState == null) {
+            serviceState  = mPhoneMonitor
+                    .getServiceStateForSubscriber(subInfoRecord.getSubscriptionId());
+            mServiceStates.put(subInfoRecord.getSimSlotIndex(), serviceState);
+        }
+        if (serviceState != null) {
+            if (LOGV) {
+                Log.v(TAG, "hasService{" +
+                        "serviceState.getVoiceRegState()='" + serviceState.getVoiceRegState() + '\'' +
+                        "serviceState.getVoiceRegState()='" + serviceState.getVoiceRegState() + '\'' +
+                        ", subInfoRecord.getSimSlotIndex() =" + subInfoRecord.getSimSlotIndex()  +
+                        '}');
+            }
+            // Consider the device to be in service if either voice or data service is available.
+            // Some SIM cards are marketed as data-only and do not support voice service, and on
+            // these SIM cards, we want to show signal bars for data service as well as the "no
+            // service" or "emergency calls only" text that indicates that voice is not available.
+            switch(serviceState.getVoiceRegState()) {
+                case ServiceState.STATE_POWER_OFF:
+                    retVal = false;
+                    break;
+                case ServiceState.STATE_OUT_OF_SERVICE:
+                case ServiceState.STATE_EMERGENCY_ONLY:
+                    retVal = serviceState.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+                    break;
+                default:
+                    retVal = true;
+            }
+        } else {
+            retVal = false;
+        }
+        return retVal;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.choose_data_sim_page;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_choose_data_sim;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_sim;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/DateTimeActivity.java b/src/org/lineageos/setupwizard/DateTimeActivity.java
new file mode 100644
index 0000000..c9f65b4
--- /dev/null
+++ b/src/org/lineageos/setupwizard/DateTimeActivity.java
@@ -0,0 +1,444 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import android.app.AlarmManager;
+import android.app.DatePickerDialog;
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.app.TimePickerDialog;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.XmlResourceParser;
+import android.os.Bundle;
+import android.os.Handler;
+import android.text.format.DateFormat;
+import android.util.Log;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.DatePicker;
+import android.widget.ImageView;
+import android.widget.SimpleAdapter;
+import android.widget.Spinner;
+import android.widget.TextView;
+import android.widget.TimePicker;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.TimeZone;
+
+public class DateTimeActivity extends BaseSetupWizardActivity implements
+        TimePickerDialog.OnTimeSetListener, DatePickerDialog.OnDateSetListener {
+
+    public static final String TAG = DateTimeActivity.class.getSimpleName();
+
+    private static final String KEY_ID = "id";  // value: String
+    private static final String KEY_DISPLAYNAME = "name";  // value: String
+    private static final String KEY_GMT = "gmt";  // value: String
+    private static final String KEY_OFFSET = "offset";  // value: int (Integer)
+    private static final String XMLTAG_TIMEZONE = "timezone";
+
+    private static final int HOURS_1 = 60 * 60000;
+
+    private TimeZone mCurrentTimeZone;
+    private View mDateView;
+    private View mTimeView;
+    private TextView mDateTextView;
+    private TextView mTimeTextView;
+
+
+    private final Handler mHandler = new Handler();
+
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+                updateTimeAndDateDisplay();
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setNextText(R.string.next);
+
+        final Spinner spinner = (Spinner) findViewById(R.id.timezone_list);
+        final SimpleAdapter adapter = constructTimezoneAdapter(this, false);
+        mCurrentTimeZone = TimeZone.getDefault();
+        mDateView = findViewById(R.id.date_item);
+        mDateView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                showDatePicker();
+            }
+        });
+        mTimeView = findViewById(R.id.time_item);
+        mTimeView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                showTimePicker();
+            }
+        });
+        mDateTextView = (TextView)findViewById(R.id.date_text);
+        mTimeTextView = (TextView)findViewById(R.id.time_text);
+        // Pre-select current/default timezone
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                int tzIndex = getTimeZoneIndex(adapter, mCurrentTimeZone);
+                spinner.setAdapter(adapter);
+                if (tzIndex != -1) {
+                    spinner.setSelection(tzIndex);
+                }
+                spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+                    @Override
+                    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long id) {
+                        final Map<?, ?> map = (Map<?, ?>) adapterView.getItemAtPosition(position);
+                        final String tzId = (String) map.get(KEY_ID);
+                        if (mCurrentTimeZone != null && !mCurrentTimeZone.getID().equals(tzId)) {
+                            // Update the system timezone value
+                            final AlarmManager alarm = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
+                            alarm.setTimeZone(tzId);
+                            mCurrentTimeZone = TimeZone.getTimeZone(tzId);
+                        }
+
+                    }
+
+                    @Override
+                    public void onNothingSelected(AdapterView<?> adapterView) {
+                    }
+                });
+            }
+        });
+        // Pre-select current/default date if epoch
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                final Calendar calendar = Calendar.getInstance();
+                final boolean isEpoch = calendar.get(Calendar.YEAR) == 1970;
+                if (isEpoch) {
+                    // If epoch, set date to build date
+                    long timestamp = SetupWizardUtils.getBuildDateTimestamp();
+                    if (timestamp > 0) {
+                        calendar.setTimeInMillis(timestamp * 1000);
+                        setDate(DateTimeActivity.this, calendar.get(Calendar.YEAR),
+                                calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
+                    } else {
+                        // no build date available, use a sane default
+                        setDate(DateTimeActivity.this, 2017, Calendar.JANUARY, 1);
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        // Register for time ticks and other reasons for time change
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_TIME_TICK);
+        filter.addAction(Intent.ACTION_TIME_CHANGED);
+        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+        registerReceiver(mIntentReceiver, filter, null, null);
+
+        updateTimeAndDateDisplay();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        unregisterReceiver(mIntentReceiver);
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.setup_datetime_page;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_datetime;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_datetime;
+    }
+
+    @Override
+    public void onDateSet(DatePicker view, int year, int month, int day) {
+            setDate(this, year, month, day);
+            updateTimeAndDateDisplay();
+    }
+
+    @Override
+    public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
+            setTime(this, hourOfDay, minute);
+            updateTimeAndDateDisplay();
+    }
+
+    private void showDatePicker() {
+        DatePickerFragment datePickerFragment = DatePickerFragment.newInstance();
+        datePickerFragment.show(getFragmentManager(), DatePickerFragment.TAG);
+    }
+
+    private void showTimePicker() {
+        TimePickerFragment timePickerFragment = TimePickerFragment.newInstance();
+        timePickerFragment.show(getFragmentManager(), TimePickerFragment.TAG);
+    }
+
+    private void updateTimeAndDateDisplay() {
+        java.text.DateFormat shortDateFormat = DateFormat.getDateFormat(this);
+        final Calendar now = Calendar.getInstance();
+        mTimeTextView.setText(DateFormat.getTimeFormat(this).format(now.getTime()));
+        mDateTextView.setText(shortDateFormat.format(now.getTime()));
+    }
+
+    private static SimpleAdapter constructTimezoneAdapter(Context context,
+            boolean sortedByName) {
+        final String[] from = new String[] {KEY_DISPLAYNAME, KEY_GMT};
+        final int[] to = new int[] {android.R.id.text1, android.R.id.text2};
+
+        final String sortKey = (sortedByName ? KEY_DISPLAYNAME : KEY_OFFSET);
+        final TimeZoneComparator comparator = new TimeZoneComparator(sortKey);
+        final List<HashMap<String, Object>> sortedList = getZones(context);
+        Collections.sort(sortedList, comparator);
+        final SimpleAdapter adapter = new SimpleAdapter(context,
+                sortedList,
+                R.layout.date_time_setup_custom_list_item_2,
+                from,
+                to);
+
+        return adapter;
+    }
+
+    private static List<HashMap<String, Object>> getZones(Context context) {
+        final List<HashMap<String, Object>> myData = new ArrayList();
+        final long date = Calendar.getInstance().getTimeInMillis();
+        try {
+            XmlResourceParser xrp = context.getResources().getXml(R.xml.timezones);
+            while (xrp.next() != XmlResourceParser.START_TAG)
+                continue;
+            xrp.next();
+            while (xrp.getEventType() != XmlResourceParser.END_TAG) {
+                while (xrp.getEventType() != XmlResourceParser.START_TAG) {
+                    if (xrp.getEventType() == XmlResourceParser.END_DOCUMENT) {
+                        return myData;
+                    }
+                    xrp.next();
+                }
+                if (xrp.getName().equals(XMLTAG_TIMEZONE)) {
+                    String id = xrp.getAttributeValue(0);
+                    String displayName = xrp.nextText();
+                    addItem(myData, id, displayName, date);
+                }
+                while (xrp.getEventType() != XmlResourceParser.END_TAG) {
+                    xrp.next();
+                }
+                xrp.next();
+            }
+            xrp.close();
+        } catch (XmlPullParserException xppe) {
+            Log.e(TAG, "Ill-formatted timezones.xml file");
+        } catch (java.io.IOException ioe) {
+            Log.e(TAG, "Unable to read timezones.xml file");
+        }
+
+        return myData;
+    }
+
+    private static void addItem(
+            List<HashMap<String, Object>> myData, String id, String displayName, long date) {
+        final HashMap<String, Object> map = new HashMap();
+        map.put(KEY_ID, id);
+        map.put(KEY_DISPLAYNAME, displayName);
+        final TimeZone tz = TimeZone.getTimeZone(id);
+        final int offset = tz.getOffset(date);
+        final int p = Math.abs(offset);
+        final StringBuilder name = new StringBuilder();
+        name.append("GMT");
+
+        if (offset < 0) {
+            name.append('-');
+        } else {
+            name.append('+');
+        }
+
+        name.append(p / (HOURS_1));
+        name.append(':');
+
+        int min = p / 60000;
+        min %= 60;
+
+        if (min < 10) {
+            name.append('0');
+        }
+        name.append(min);
+
+        map.put(KEY_GMT, name.toString());
+        map.put(KEY_OFFSET, offset);
+
+        myData.add(map);
+    }
+
+    private static int getTimeZoneIndex(SimpleAdapter adapter, TimeZone tz) {
+        final String defaultId = tz.getID();
+        final int listSize = adapter.getCount();
+        for (int i = 0; i < listSize; i++) {
+            // Using HashMap<String, Object> induces unnecessary warning.
+            final HashMap<?,?> map = (HashMap<?,?>)adapter.getItem(i);
+            final String id = (String)map.get(KEY_ID);
+            if (defaultId.equals(id)) {
+                // If current timezone is in this list, move focus to it
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    private static void setDate(Context context, int year, int month, int day) {
+        Calendar c = Calendar.getInstance();
+
+        c.set(Calendar.YEAR, year);
+        c.set(Calendar.MONTH, month);
+        c.set(Calendar.DAY_OF_MONTH, day);
+        long when = c.getTimeInMillis();
+
+        if (when / 1000 < Integer.MAX_VALUE) {
+            ((AlarmManager) context.getSystemService(Context.ALARM_SERVICE)).setTime(when);
+        }
+    }
+
+    private static void setTime(Context context, int hourOfDay, int minute) {
+        Calendar c = Calendar.getInstance();
+
+        c.set(Calendar.HOUR_OF_DAY, hourOfDay);
+        c.set(Calendar.MINUTE, minute);
+        c.set(Calendar.SECOND, 0);
+        c.set(Calendar.MILLISECOND, 0);
+        long when = c.getTimeInMillis();
+
+        if (when / 1000 < Integer.MAX_VALUE) {
+            ((AlarmManager) context.getSystemService(Context.ALARM_SERVICE)).setTime(when);
+        }
+    }
+
+    private static class TimeZoneComparator implements Comparator<HashMap<?, ?>> {
+        private String mSortingKey;
+
+        public TimeZoneComparator(String sortingKey) {
+            mSortingKey = sortingKey;
+        }
+
+        public void setSortingKey(String sortingKey) {
+            mSortingKey = sortingKey;
+        }
+
+        public int compare(HashMap<?, ?> map1, HashMap<?, ?> map2) {
+            Object value1 = map1.get(mSortingKey);
+            Object value2 = map2.get(mSortingKey);
+
+            /*
+             * This should never happen, but just in-case, put non-comparable
+             * items at the end.
+             */
+            if (!isComparable(value1)) {
+                return isComparable(value2) ? 1 : 0;
+            } else if (!isComparable(value2)) {
+                return -1;
+            }
+
+            return ((Comparable) value1).compareTo(value2);
+        }
+
+        private boolean isComparable(Object value) {
+            return (value != null) && (value instanceof Comparable);
+        }
+    }
+
+    public static class TimePickerFragment extends DialogFragment
+            implements TimePickerDialog.OnTimeSetListener {
+
+        private static String TAG = TimePickerFragment.class.getSimpleName();
+
+        public static TimePickerFragment newInstance() {
+            TimePickerFragment frag = new TimePickerFragment();
+            return frag;
+        }
+
+        @Override
+        public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
+            ((DateTimeActivity)getActivity()).onTimeSet(view, hourOfDay, minute);
+        }
+
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            final Calendar calendar = Calendar.getInstance();
+            return new TimePickerDialog(
+                    getActivity(),
+                    this,
+                    calendar.get(Calendar.HOUR_OF_DAY),
+                    calendar.get(Calendar.MINUTE),
+                    DateFormat.is24HourFormat(getActivity()));
+        }
+
+    }
+
+    public static class DatePickerFragment extends DialogFragment
+            implements DatePickerDialog.OnDateSetListener {
+
+        private static String TAG = DatePickerFragment.class.getSimpleName();
+
+        public static DatePickerFragment newInstance() {
+            DatePickerFragment frag = new DatePickerFragment();
+            return frag;
+        }
+
+        @Override
+        public void onDateSet(DatePicker view, int year, int month, int day) {
+            ((DateTimeActivity)getActivity()).onDateSet(view, year, month, day);
+        }
+
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            final Calendar calendar = Calendar.getInstance();
+            return new DatePickerDialog(
+                    getActivity(),
+                    this,
+                    calendar.get(Calendar.YEAR),
+                    calendar.get(Calendar.MONTH),
+                    calendar.get(Calendar.DAY_OF_MONTH));
+        }
+    }
+}
diff --git a/src/org/lineageos/setupwizard/FingerprintActivity.java b/src/org/lineageos/setupwizard/FingerprintActivity.java
new file mode 100644
index 0000000..b7c678b
--- /dev/null
+++ b/src/org/lineageos/setupwizard/FingerprintActivity.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_SETUP_FINGERPRINT;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ALLOW_SKIP;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_AUTO_FINISH;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_DETAILS;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_FIRST_RUN;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_MATERIAL_LIGHT;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_THEME;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_TITLE;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_USE_IMMERSIVE;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_FINGERPRINT;
+
+import android.content.Intent;
+import android.view.View;
+
+public class FingerprintActivity extends SubBaseActivity {
+
+    public static final String TAG = FingerprintActivity.class.getSimpleName();
+
+    @Override
+    protected void onStartSubactivity() {
+        setNextAllowed(true);
+        findViewById(R.id.setup_fingerprint).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                launchFingerprintSetup();
+            }
+        });
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.setup_fingerprint;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.fingerprint_setup_title;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_fingerprint;
+    }
+
+    private void launchFingerprintSetup() {
+        Intent intent = new Intent(ACTION_SETUP_FINGERPRINT);
+        intent.putExtra(EXTRA_FIRST_RUN, true);
+        intent.putExtra(EXTRA_ALLOW_SKIP, true);
+        intent.putExtra(EXTRA_USE_IMMERSIVE, true);
+        intent.putExtra(EXTRA_THEME, EXTRA_MATERIAL_LIGHT);
+        intent.putExtra(EXTRA_AUTO_FINISH, false);
+            /*intent.putExtra(LockPatternUtils.LOCKSCREEN_FINGERPRINT_FALLBACK, true);*/
+        intent.putExtra(EXTRA_TITLE,
+                getString(R.string.settings_fingerprint_setup_title));
+        intent.putExtra(EXTRA_DETAILS,
+                getString(R.string.settings_fingerprint_setup_details));
+        startSubactivity(intent, REQUEST_CODE_SETUP_FINGERPRINT);
+    }
+
+    @Override
+    protected int getSubactivityNextTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/FinishActivity.java b/src/org/lineageos/setupwizard/FinishActivity.java
new file mode 100644
index 0000000..b2ae9a6
--- /dev/null
+++ b/src/org/lineageos/setupwizard/FinishActivity.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.DISABLE_NAV_KEYS;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_APPLY_DEFAULT_THEME;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_BUTTON_BACKLIGHT;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_PRIVACY_GUARD;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_SEND_METRICS;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.animation.Animator;
+import android.app.Activity;
+import android.app.WallpaperManager;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.ActivityInfo;
+import android.graphics.Bitmap;
+import android.graphics.Point;
+import android.os.Bundle;
+import android.os.Handler;
+import android.preference.PreferenceManager;
+import android.view.View;
+import android.view.ViewAnimationUtils;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+
+import com.android.setupwizardlib.util.WizardManagerHelper;
+
+import com.cyanogenmod.setupwizard.util.EnableAccessibilityController;
+
+import lineageos.hardware.LineageHardwareManager;
+import lineageos.providers.LineageSettings;
+
+public class FinishActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = FinishActivity.class.getSimpleName();
+
+    private ImageView mReveal;
+
+    private EnableAccessibilityController mEnableAccessibilityController;
+
+    private SetupWizardApp mSetupWizardApp;
+
+    private final Handler mHandler = new Handler();
+
+    private volatile boolean mIsFinishing = false;
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (LOGV) {
+            logActivityState("onCreate savedInstanceState=" + savedInstanceState);
+        }
+        mSetupWizardApp = (SetupWizardApp) getApplication();
+        mReveal = (ImageView) findViewById(R.id.reveal);
+        mEnableAccessibilityController =
+                EnableAccessibilityController.getInstance(getApplicationContext());
+        setNextText(R.string.start);
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.finish_activity;
+    }
+
+    @Override
+    public void finish() {
+        super.finish();
+        overridePendingTransition(R.anim.translucent_enter, R.anim.translucent_exit);
+    }
+
+    @Override
+    public void onNavigateNext() {
+        applyForwardTransition(TRANSITION_ID_NONE);
+        startFinishSequence();
+    }
+
+    private void finishSetup() {
+        if (!mIsFinishing) {
+            mIsFinishing = true;
+            setupRevealImage();
+        }
+    }
+
+    private void startFinishSequence() {
+        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);
+        hideBackButton();
+        hideNextButton();
+        finishSetup();
+    }
+
+    private void setupRevealImage() {
+        final Point p = new Point();
+        getWindowManager().getDefaultDisplay().getRealSize(p);
+        final WallpaperManager wallpaperManager =
+                WallpaperManager.getInstance(this);
+        wallpaperManager.forgetLoadedWallpaper();
+        final Bitmap wallpaper = wallpaperManager.getBitmap();
+        Bitmap cropped = null;
+        if (wallpaper != null) {
+            cropped = Bitmap.createBitmap(wallpaper, 0,
+                    0, Math.min(p.x, wallpaper.getWidth()),
+                    Math.min(p.y, wallpaper.getHeight()));
+        }
+        if (cropped != null) {
+            mReveal.setScaleType(ImageView.ScaleType.CENTER_CROP);
+            mReveal.setImageBitmap(cropped);
+        } else {
+            mReveal.setBackground(wallpaperManager
+                    .getBuiltInDrawable(p.x, p.y, false, 0, 0));
+        }
+        animateOut();
+    }
+
+    private void animateOut() {
+        int cx = (mReveal.getLeft() + mReveal.getRight()) / 2;
+        int cy = (mReveal.getTop() + mReveal.getBottom()) / 2;
+        int finalRadius = Math.max(mReveal.getWidth(), mReveal.getHeight());
+        Animator anim =
+                ViewAnimationUtils.createCircularReveal(mReveal, cx, cy, 0, finalRadius);
+        anim.setDuration(900);
+        anim.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                mReveal.setVisibility(View.VISIBLE);
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                mHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        completeSetup();
+                    }
+                });
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {}
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {}
+        });
+        anim.start();
+    }
+
+    private void completeSetup() {
+        if (mEnableAccessibilityController != null) {
+            mEnableAccessibilityController.onDestroy();
+        }
+        handlePrivacyGuard(mSetupWizardApp);
+        handleEnableMetrics(mSetupWizardApp);
+        handleNavKeys(mSetupWizardApp);
+        final WallpaperManager wallpaperManager =
+                WallpaperManager.getInstance(mSetupWizardApp);
+        wallpaperManager.forgetLoadedWallpaper();
+        finishAllAppTasks();
+        Intent intent = WizardManagerHelper.getNextIntent(getIntent(),
+                Activity.RESULT_OK);
+        startActivityForResult(intent, NEXT_REQUEST);
+    }
+
+    private static void handleEnableMetrics(SetupWizardApp setupWizardApp) {
+        Bundle privacyData = setupWizardApp.getSettingsBundle();
+        if (privacyData != null
+                && privacyData.containsKey(KEY_SEND_METRICS)) {
+            LineageSettings.Secure.putInt(setupWizardApp.getContentResolver(),
+                    LineageSettings.Secure.STATS_COLLECTION, privacyData.getBoolean(KEY_SEND_METRICS)
+                            ? 1 : 0);
+        }
+    }
+
+    private static void handlePrivacyGuard(SetupWizardApp setupWizardApp) {
+        Bundle mPrivacyData = setupWizardApp.getSettingsBundle();
+        if (mPrivacyData != null && mPrivacyData.containsKey(KEY_PRIVACY_GUARD)) {
+            LineageSettings.Secure.putInt(setupWizardApp.getContentResolver(),
+                    LineageSettings.Secure.PRIVACY_GUARD_DEFAULT,
+                    mPrivacyData.getBoolean(KEY_PRIVACY_GUARD) ? 1 : 0);
+        }
+    }
+
+    private static void handleNavKeys(SetupWizardApp setupWizardApp) {
+        if (setupWizardApp.getSettingsBundle().containsKey(DISABLE_NAV_KEYS)) {
+            writeDisableNavkeysOption(setupWizardApp,
+                    setupWizardApp.getSettingsBundle().getBoolean(DISABLE_NAV_KEYS));
+        }
+    }
+
+    private static void writeDisableNavkeysOption(Context context, boolean enabled) {
+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
+
+        LineageSettings.Global.putInt(context.getContentResolver(),
+                LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, enabled ? 1 : 0);
+        LineageHardwareManager hardware = LineageHardwareManager.getInstance(context);
+        hardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, enabled);
+
+        /* Save/restore button timeouts to disable them in softkey mode */
+        if (enabled) {
+            LineageSettings.Secure.putInt(context.getContentResolver(),
+                    LineageSettings.Secure.BUTTON_BRIGHTNESS, 0);
+        } else {
+            int currentBrightness = LineageSettings.Secure.getInt(context.getContentResolver(),
+                    LineageSettings.Secure.BUTTON_BRIGHTNESS, 100);
+            int oldBright = prefs.getInt(KEY_BUTTON_BACKLIGHT,
+                    currentBrightness);
+            LineageSettings.Secure.putInt(context.getContentResolver(),
+                    LineageSettings.Secure.BUTTON_BRIGHTNESS, oldBright);
+        }
+    }
+}
diff --git a/src/org/lineageos/setupwizard/LineageSettingsActivity.java b/src/org/lineageos/setupwizard/LineageSettingsActivity.java
new file mode 100644
index 0000000..6ebdb77
--- /dev/null
+++ b/src/org/lineageos/setupwizard/LineageSettingsActivity.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.DISABLE_NAV_KEYS;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_APPLY_DEFAULT_THEME;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_PRIVACY_GUARD;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_SEND_METRICS;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.method.LinkMovementMethod;
+import android.text.style.ClickableSpan;
+import android.util.Log;
+import android.view.IWindowManager;
+import android.view.View;
+import android.view.WindowManagerGlobal;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.android.setupwizardlib.util.WizardManagerHelper;
+
+import com.cyanogenmod.setupwizard.R;
+
+import lineageos.hardware.LineageHardwareManager;
+import lineageos.providers.LineageSettings;
+
+public class LineageSettingsActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = LineageSettingsActivity.class.getSimpleName();
+
+    public static final String PRIVACY_POLICY_URI = "http://lineageos.org/legal";
+
+    private SetupWizardApp mSetupWizardApp;
+
+    private View mMetricsRow;
+    private View mNavKeysRow;
+    private View mPrivacyGuardRow;
+    private CheckBox mMetrics;
+    private CheckBox mNavKeys;
+    private CheckBox mPrivacyGuard;
+
+    private boolean mHideNavKeysRow = false;
+
+    private View.OnClickListener mMetricsClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            boolean checked = !mMetrics.isChecked();
+            mMetrics.setChecked(checked);
+            mSetupWizardApp.getSettingsBundle().putBoolean(KEY_SEND_METRICS, checked);
+        }
+    };
+
+    private View.OnClickListener mNavKeysClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            boolean checked = !mNavKeys.isChecked();
+            mNavKeys.setChecked(checked);
+            mSetupWizardApp.getSettingsBundle().putBoolean(DISABLE_NAV_KEYS, checked);
+        }
+    };
+
+    private View.OnClickListener mPrivacyGuardClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            boolean checked = !mPrivacyGuard.isChecked();
+            mPrivacyGuard.setChecked(checked);
+            mSetupWizardApp.getSettingsBundle().putBoolean(KEY_PRIVACY_GUARD, checked);
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mSetupWizardApp = (SetupWizardApp) getApplication();
+        setNextText(R.string.next);
+        String privacy_policy = getString(R.string.services_privacy_policy);
+        String policySummary = getString(R.string.services_explanation, privacy_policy);
+        SpannableString ss = new SpannableString(policySummary);
+        ClickableSpan clickableSpan = new ClickableSpan() {
+            @Override
+            public void onClick(View textView) {
+                // At this point of the setup, the device has already been unlocked (if frp
+                // had been enabled), so there should be no issues regarding security
+                final Intent intent = new Intent(Intent.ACTION_VIEW,
+                        Uri.parse(PRIVACY_POLICY_URI));
+                try {
+                    startActivity(intent);
+                } catch (Exception e) {
+                    Log.e(TAG, "Unable to start activity " + intent.toString(), e);
+                }
+            }
+        };
+        ss.setSpan(clickableSpan,
+                policySummary.length() - privacy_policy.length() - 1,
+                policySummary.length() - 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        TextView privacyPolicy = (TextView) findViewById(R.id.privacy_policy);
+        privacyPolicy.setMovementMethod(LinkMovementMethod.getInstance());
+        privacyPolicy.setText(ss);
+
+        mMetricsRow = findViewById(R.id.metrics);
+        mMetricsRow.setOnClickListener(mMetricsClickListener);
+        String metricsHelpImproveCM =
+                getString(R.string.services_help_improve_cm, getString(R.string.os_name));
+        String metricsSummary = getString(R.string.services_metrics_label,
+                metricsHelpImproveCM, getString(R.string.os_name));
+        final SpannableStringBuilder metricsSpan = new SpannableStringBuilder(metricsSummary);
+        metricsSpan.setSpan(new android.text.style.StyleSpan(android.graphics.Typeface.BOLD),
+                0, metricsHelpImproveCM.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+        TextView metrics = (TextView) findViewById(R.id.enable_metrics_summary);
+        metrics.setText(metricsSpan);
+        mMetrics = (CheckBox) findViewById(R.id.enable_metrics_checkbox);
+
+        mNavKeysRow = findViewById(R.id.nav_keys);
+        mNavKeysRow.setOnClickListener(mNavKeysClickListener);
+        mNavKeys = (CheckBox) findViewById(R.id.nav_keys_checkbox);
+        boolean needsNavBar = true;
+        try {
+            IWindowManager windowManager = WindowManagerGlobal.getWindowManagerService();
+            needsNavBar = windowManager.needsNavigationBar();
+        } catch (RemoteException e) {
+        }
+        mHideNavKeysRow = hideKeyDisabler(this);
+        if (mHideNavKeysRow || needsNavBar) {
+            mNavKeysRow.setVisibility(View.GONE);
+        } else {
+            boolean navKeysDisabled = isKeyDisablerActive(this);
+            mNavKeys.setChecked(navKeysDisabled);
+        }
+
+        mPrivacyGuardRow = findViewById(R.id.privacy_guard);
+        mPrivacyGuardRow.setOnClickListener(mPrivacyGuardClickListener);
+        mPrivacyGuard = (CheckBox) findViewById(R.id.privacy_guard_checkbox);
+        mPrivacyGuard.setChecked(LineageSettings.Secure.getInt(getContentResolver(),
+                LineageSettings.Secure.PRIVACY_GUARD_DEFAULT, 0) == 1);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        updateDisableNavkeysOption();
+        updateMetricsOption();
+        updatePrivacyGuardOption();
+    }
+
+    @Override
+    public void onNavigateBack() {
+        onBackPressed();
+    }
+
+    @Override
+    public void onNavigateNext() {
+        Intent intent = WizardManagerHelper.getNextIntent(getIntent(), Activity.RESULT_OK);
+        startActivityForResult(intent, 1);
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.setup_lineage_settings;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_services;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_features;
+    }
+
+    private void updateMetricsOption() {
+        final Bundle myPageBundle = mSetupWizardApp.getSettingsBundle();
+        boolean metricsChecked =
+                !myPageBundle.containsKey(KEY_SEND_METRICS) || myPageBundle
+                        .getBoolean(KEY_SEND_METRICS);
+        mMetrics.setChecked(metricsChecked);
+        myPageBundle.putBoolean(KEY_SEND_METRICS, metricsChecked);
+    }
+
+    private void updateDisableNavkeysOption() {
+        if (!mHideNavKeysRow) {
+            final Bundle myPageBundle = mSetupWizardApp.getSettingsBundle();
+            boolean enabled = LineageSettings.Secure.getInt(getContentResolver(),
+                    LineageSettings.Secure.DEV_FORCE_SHOW_NAVBAR, 0) != 0;
+            boolean checked = myPageBundle.containsKey(DISABLE_NAV_KEYS) ?
+                    myPageBundle.getBoolean(DISABLE_NAV_KEYS) :
+                    enabled;
+            mNavKeys.setChecked(checked);
+            myPageBundle.putBoolean(DISABLE_NAV_KEYS, checked);
+        }
+    }
+
+    private void updatePrivacyGuardOption() {
+        final Bundle bundle = mSetupWizardApp.getSettingsBundle();
+        boolean enabled = LineageSettings.Secure.getInt(getContentResolver(),
+                LineageSettings.Secure.PRIVACY_GUARD_DEFAULT, 0) != 0;
+        boolean checked = bundle.containsKey(KEY_PRIVACY_GUARD) ?
+                bundle.getBoolean(KEY_PRIVACY_GUARD) :
+                enabled;
+        mPrivacyGuard.setChecked(checked);
+        bundle.putBoolean(KEY_PRIVACY_GUARD, checked);
+    }
+
+    private static boolean hideKeyDisabler(Context context) {
+        final LineageHardwareManager hardware = LineageHardwareManager.getInstance(context);
+        return !hardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE);
+    }
+
+    private static boolean isKeyDisablerActive(Context context) {
+        final LineageHardwareManager hardware = LineageHardwareManager.getInstance(context);
+        return hardware.get(LineageHardwareManager.FEATURE_KEY_DISABLE);
+    }
+}
diff --git a/src/org/lineageos/setupwizard/LocaleActivity.java b/src/org/lineageos/setupwizard/LocaleActivity.java
new file mode 100644
index 0000000..b622d7a
--- /dev/null
+++ b/src/org/lineageos/setupwizard/LocaleActivity.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Handler;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.view.View;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.NumberPicker;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.android.internal.telephony.MccTable;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.setupwizardlib.util.WizardManagerHelper;
+
+import com.cyanogenmod.setupwizard.R;
+import com.cyanogenmod.setupwizard.widget.LocalePicker;
+
+import java.util.List;
+import java.util.Locale;
+
+public class LocaleActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = LocaleActivity.class.getSimpleName();
+
+    private ArrayAdapter<com.android.internal.app.LocalePicker.LocaleInfo> mLocaleAdapter;
+    private Locale mCurrentLocale;
+    private int[] mAdapterIndices;
+    private LocalePicker mLanguagePicker;
+    private FetchUpdateSimLocaleTask mFetchUpdateSimLocaleTask;
+    private final Handler mHandler = new Handler();
+    private boolean mPendingLocaleUpdate;
+    private boolean mPaused = true;
+
+    private final Runnable mUpdateLocale = new Runnable() {
+        public void run() {
+            if (mCurrentLocale != null) {
+                mLanguagePicker.setEnabled(false);
+                com.android.internal.app.LocalePicker.updateLocale(mCurrentLocale);
+            }
+        }
+    };
+
+    private final BroadcastReceiver mSimChangedReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                fetchAndUpdateSimLocale();
+            }
+        }
+    };
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setNextText(R.string.next);
+        mLanguagePicker = (LocalePicker) findViewById(R.id.locale_list);
+        loadLanguages();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mPaused = true;
+        unregisterReceiver(mSimChangedReceiver);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mPaused = false;
+        registerReceiver(mSimChangedReceiver,
+                new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
+        if (mLanguagePicker != null) {
+            mLanguagePicker.setEnabled(true);
+        }
+        if (mPendingLocaleUpdate) {
+            mPendingLocaleUpdate = false;
+            fetchAndUpdateSimLocale();
+        }
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.setup_locale;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_locale;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_locale;
+    }
+
+    private void loadLanguages() {
+        mLocaleAdapter = com.android.internal.app.LocalePicker.constructAdapter(this,
+                R.layout.locale_picker_item, R.id.locale);
+        mCurrentLocale = Locale.getDefault();
+        fetchAndUpdateSimLocale();
+        mAdapterIndices = new int[mLocaleAdapter.getCount()];
+        int currentLocaleIndex = 0;
+        String [] labels = new String[mLocaleAdapter.getCount()];
+        for (int i=0; i<mAdapterIndices.length; i++) {
+            com.android.internal.app.LocalePicker.LocaleInfo localLocaleInfo =
+                    mLocaleAdapter.getItem(i);
+            Locale localLocale = localLocaleInfo.getLocale();
+            if (localLocale.equals(mCurrentLocale)) {
+                currentLocaleIndex = i;
+            }
+            mAdapterIndices[i] = i;
+            labels[i] = localLocaleInfo.getLabel();
+        }
+        mLanguagePicker.setDisplayedValues(labels);
+        mLanguagePicker.setMaxValue(labels.length - 1);
+        mLanguagePicker.setValue(currentLocaleIndex);
+        mLanguagePicker.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);
+        mLanguagePicker.setOnValueChangedListener(new LocalePicker.OnValueChangeListener() {
+            public void onValueChange(LocalePicker picker, int oldVal, int newVal) {
+                setLocaleFromPicker();
+            }
+        });
+        mLanguagePicker.setOnScrollListener(new LocalePicker.OnScrollListener() {
+            @Override
+            public void onScrollStateChange(LocalePicker view, int scrollState) {
+                if (scrollState == SCROLL_STATE_TOUCH_SCROLL) {
+                    ((SetupWizardApp)getApplication()).setIgnoreSimLocale(true);
+                }
+            }
+        });
+    }
+
+    private void setLocaleFromPicker() {
+        ((SetupWizardApp)getApplication()).setIgnoreSimLocale(true);
+        int i = mAdapterIndices[mLanguagePicker.getValue()];
+        final com.android.internal.app.LocalePicker.LocaleInfo localLocaleInfo = mLocaleAdapter.getItem(i);
+        onLocaleChanged(localLocaleInfo.getLocale());
+    }
+
+    private void onLocaleChanged(Locale paramLocale) {
+        mLanguagePicker.setEnabled(true);
+        Resources localResources = getResources();
+        Configuration localConfiguration1 = localResources.getConfiguration();
+        Configuration localConfiguration2 = new Configuration();
+        localConfiguration2.locale = paramLocale;
+        localResources.updateConfiguration(localConfiguration2, null);
+        localResources.updateConfiguration(localConfiguration1, null);
+        mHandler.removeCallbacks(mUpdateLocale);
+        mCurrentLocale = paramLocale;
+        mHandler.postDelayed(mUpdateLocale, 1000);
+    }
+
+    private void fetchAndUpdateSimLocale() {
+        if (((SetupWizardApp)getApplication()).ignoreSimLocale() || isDestroyed()) {
+            return;
+        }
+        if (mPaused) {
+            mPendingLocaleUpdate = true;
+            return;
+        }
+        if (mFetchUpdateSimLocaleTask != null) {
+            mFetchUpdateSimLocaleTask.cancel(true);
+        }
+        mFetchUpdateSimLocaleTask = new FetchUpdateSimLocaleTask();
+        mFetchUpdateSimLocaleTask.execute();
+    }
+
+    private class FetchUpdateSimLocaleTask extends AsyncTask<Void, Void, Locale> {
+        @Override
+        protected Locale doInBackground(Void... params) {
+            Locale locale = null;
+            Activity activity = LocaleActivity.this;
+            if (!activity.isFinishing() || !activity.isDestroyed()) {
+                // If the sim is currently pin locked, return
+                TelephonyManager telephonyManager = (TelephonyManager)
+                        activity.getSystemService(Context.TELEPHONY_SERVICE);
+                int state = telephonyManager.getSimState();
+                if(state == TelephonyManager.SIM_STATE_PIN_REQUIRED ||
+                        state == TelephonyManager.SIM_STATE_PUK_REQUIRED) {
+                    return null;
+                }
+
+                final SubscriptionManager subscriptionManager =
+                        SubscriptionManager.from(activity);
+                List<SubscriptionInfo> activeSubs =
+                        subscriptionManager.getActiveSubscriptionInfoList();
+                if (activeSubs == null || activeSubs.isEmpty()) {
+                    return null;
+                }
+
+                // Fetch locale for active sim's MCC
+                int mcc = activeSubs.get(0).getMcc();
+                locale = MccTable.getLocaleFromMcc(activity, mcc, null);
+
+                // If that fails, fall back to preferred languages reported
+                // by the sim
+                if (locale == null) {
+                    String localeString = telephonyManager.getLocaleFromDefaultSim();
+                    if (localeString != null) {
+                        locale = Locale.forLanguageTag(localeString);
+
+                    }
+                }
+            }
+            return locale;
+        }
+
+        @Override
+        protected void onPostExecute(Locale simLocale) {
+            if (simLocale != null && !simLocale.equals(mCurrentLocale)) {
+                if (!((SetupWizardApp)getApplication()).ignoreSimLocale() && !isDestroyed()) {
+                    String label = getString(R.string.sim_locale_changed,
+                            simLocale.getDisplayName());
+                    Toast.makeText(LocaleActivity.this, label, Toast.LENGTH_SHORT).show();
+                    onLocaleChanged(simLocale);
+                    ((SetupWizardApp)getApplication()).setIgnoreSimLocale(true);
+                }
+            }
+        }
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/LocationSettingsActivity.java b/src/org/lineageos/setupwizard/LocationSettingsActivity.java
new file mode 100644
index 0000000..039c3a0
--- /dev/null
+++ b/src/org/lineageos/setupwizard/LocationSettingsActivity.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.os.Bundle;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.TextView;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+public class LocationSettingsActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG =
+            LocationSettingsActivity.class.getSimpleName().substring(0, 22);
+
+    private View mLocationRow;
+    private View mBatteryRow;
+    private View mNetworkRow;
+    private CheckBox mNetwork;
+    private CheckBox mBattery;
+    private CheckBox mLocationAccess;
+
+    private ContentResolver mContentResolver;
+
+
+    /** Broadcast intent action when the location mode is about to change. */
+    private static final String MODE_CHANGING_ACTION =
+            "com.android.settings.location.MODE_CHANGING";
+    private static final String CURRENT_MODE_KEY = "CURRENT_MODE";
+    private static final String NEW_MODE_KEY = "NEW_MODE";
+
+    private int mCurrentMode = Settings.Secure.LOCATION_MODE_OFF;
+
+    private View.OnClickListener mLocationClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            onToggleLocationAccess(!mLocationAccess.isChecked());
+        }
+    };
+
+    private View.OnClickListener mBatteryClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            onToggleBatterySaving(!mBattery.isChecked());
+        }
+    };
+
+    private View.OnClickListener mNetworkClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            onToggleNetwork(!mNetwork.isChecked());
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setNextText(R.string.next);
+
+        mContentResolver = getContentResolver();
+        TextView summaryView = (TextView) findViewById(android.R.id.summary);
+        summaryView.setText(R.string.location_services_summary);
+        mLocationRow = findViewById(R.id.location);
+        mLocationRow.setOnClickListener(mLocationClickListener);
+        mLocationAccess = (CheckBox) findViewById(R.id.location_checkbox);
+        mBatteryRow = findViewById(R.id.battery_saving);
+        mBatteryRow.setOnClickListener(mBatteryClickListener);
+        mBattery = (CheckBox) findViewById(R.id.battery_saving_checkbox);
+        mNetworkRow = findViewById(R.id.network);
+        mNetworkRow.setOnClickListener(mNetworkClickListener);
+        mNetwork = (CheckBox) findViewById(R.id.network_checkbox);
+        TextView networkSummary = (TextView) findViewById(R.id.network_summary);
+        final boolean hasTelephony = SetupWizardUtils.hasTelephony(this);
+        if (hasTelephony) {
+            networkSummary.setText(R.string.location_network_telephony);
+        } else {
+            networkSummary.setText(R.string.location_network);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        refreshLocationMode();
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.location_settings;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_location;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_location;
+    }
+
+    private void setLocationMode(int mode) {
+        Intent intent = new Intent(MODE_CHANGING_ACTION);
+        intent.putExtra(CURRENT_MODE_KEY, mCurrentMode);
+        intent.putExtra(NEW_MODE_KEY, mode);
+        sendBroadcast(intent, android.Manifest.permission.WRITE_SECURE_SETTINGS);
+        Settings.Secure.putInt(mContentResolver, Settings.Secure.LOCATION_MODE, mode);
+        refreshLocationMode();
+    }
+
+    private void refreshLocationMode() {
+        int mode = Settings.Secure.getInt(mContentResolver, Settings.Secure.LOCATION_MODE,
+                Settings.Secure.LOCATION_MODE_OFF);
+
+        if (mCurrentMode != mode) {
+            mCurrentMode = mode;
+            if (Log.isLoggable(TAG, Log.INFO)) {
+                Log.i(TAG, "Location mode has been changed");
+            }
+            updateLocationToggles(mode);
+        }
+    }
+
+    private void updateLocationToggles(int mode) {
+        switch (mode) {
+            case Settings.Secure.LOCATION_MODE_OFF:
+                mLocationAccess.setChecked(false);
+                mBattery.setChecked(false);
+                mBattery.setEnabled(false);
+                mBatteryRow.setEnabled(false);
+                mNetwork.setChecked(false);
+                mNetwork.setEnabled(false);
+                mNetworkRow.setEnabled(false);
+                break;
+            case Settings.Secure.LOCATION_MODE_SENSORS_ONLY:
+                mLocationAccess.setChecked(true);
+                mBattery.setChecked(false);
+                mBattery.setEnabled(true);
+                mBatteryRow.setEnabled(true);
+                mNetwork.setChecked(false);
+                mNetwork.setEnabled(true);
+                mNetworkRow.setEnabled(true);
+                break;
+            case Settings.Secure.LOCATION_MODE_BATTERY_SAVING:
+                mLocationAccess.setChecked(true);
+                mBattery.setChecked(true);
+                mNetwork.setChecked(false);
+                mNetwork.setEnabled(false);
+                mNetworkRow.setEnabled(false);
+                break;
+            case Settings.Secure.LOCATION_MODE_HIGH_ACCURACY:
+                mLocationAccess.setChecked(true);
+                mNetwork.setChecked(true);
+                mBattery.setChecked(false);
+                mBattery.setEnabled(false);
+                mBatteryRow.setEnabled(false);
+                break;
+            default:
+                mLocationAccess.setChecked(false);
+                mBattery.setChecked(false);
+                mBattery.setEnabled(false);
+                mBatteryRow.setEnabled(false);
+                mNetwork.setChecked(false);
+                mNetwork.setEnabled(false);
+                mNetworkRow.setEnabled(false);
+                break;
+        }
+    }
+
+    private void onToggleLocationAccess(boolean checked) {
+        if (checked) {
+            setLocationMode(Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
+        } else {
+            setLocationMode(Settings.Secure.LOCATION_MODE_OFF);
+        }
+    }
+
+    private void onToggleBatterySaving(boolean checked) {
+        if (checked) {
+            setLocationMode(Settings.Secure.LOCATION_MODE_BATTERY_SAVING);
+        } else {
+            setLocationMode(Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
+        }
+    }
+
+    private void onToggleNetwork(boolean checked) {
+        if (checked) {
+            setLocationMode(Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);
+        } else {
+            setLocationMode(Settings.Secure.LOCATION_MODE_SENSORS_ONLY);
+        }
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/MobileDataActivity.java b/src/org/lineageos/setupwizard/MobileDataActivity.java
new file mode 100644
index 0000000..cb7bf18
--- /dev/null
+++ b/src/org/lineageos/setupwizard/MobileDataActivity.java
@@ -0,0 +1,334 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.os.Bundle;
+import android.os.Handler;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import com.cyanogenmod.setupwizard.util.NetworkMonitor;
+import com.cyanogenmod.setupwizard.util.PhoneMonitor;
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+public class MobileDataActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = MobileDataActivity.class.getSimpleName();
+
+    private static final int DC_READY_TIMEOUT = 20 * 1000;
+
+    private ProgressBar mProgressBar;
+    private View mEnableDataRow;
+    private Switch mEnableMobileData;
+    private ImageView mSignalView;
+    private TextView mNameView;
+
+    private TelephonyManager mPhone;
+    private SignalStrength mSignalStrength;
+    private ServiceState mServiceState;
+    private PhoneMonitor mPhoneMonitor;
+    private NetworkMonitor mNetworkMonitor;
+
+    private boolean mIsAttached = false;
+
+    private final Handler mHandler = new Handler();
+
+    private final Runnable mRadioReadyRunnable = new Runnable() {
+        @Override
+        public void run() {
+            hideWaitForRadio();
+        }
+    };
+
+    private final Runnable mDataConnectionReadyRunnable = new Runnable() {
+        @Override
+        public void run() {
+            onDataStateReady();
+        }
+    };
+
+    private PhoneMonitor.SubscriptionStateListener mSubscriptionStateListener =
+            new PhoneMonitor.SubscriptionStateListener() {
+                @Override
+                public void onServiceStateChanged(int subId, ServiceState serviceState) {
+                    if (LOGV) {
+                        Log.v(TAG, "onServiceStateChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", serviceState=" + serviceState.toString() +
+                                '}');
+                    }
+                    if (SetupWizardUtils.isRadioReady(MobileDataActivity.this, serviceState)) {
+                        hideWaitForRadio();
+                    }
+                    mServiceState = serviceState;
+                    updateSignalStrength();
+                }
+
+                @Override
+                public void onDataConnectionStateChanged(int subId, int state, int networkType) {
+                    if (LOGV) {
+                        Log.v(TAG, "onDataConnectionStateChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", state=" + state +
+                                '}');
+                    }
+                    if (state == TelephonyManager.DATA_CONNECTED) {
+                        onDataStateReady();
+                    }
+                }
+
+                @Override
+                public void onDefaultDataSubscriptionChanged(int subId) {}
+
+                @Override
+                public void onDefaultDataSubscriptionChangeRequested(int currentSubId,
+                        int newSubId) {}
+
+                @Override
+                public void onSignalStrengthsChanged(int subId, SignalStrength signalStrength) {
+                    if (LOGV) {
+                        Log.v(TAG, "onSignalStrengthsChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", signalStrength=" + signalStrength.toString() +
+                                '}');
+                    }
+                    mSignalStrength = signalStrength;
+                    updateSignalStrength();
+                }
+
+                @Override
+                public void onSimStateChanged(int subId, int simState) {
+                    if (LOGV) {
+                        Log.v(TAG, "onSimStateChanged{" +
+                                "subId='" + subId + '\'' +
+                                ", simState=" + simState +
+                                '}');
+                    }
+                }
+            };
+
+    private View.OnClickListener mEnableDataClickListener = new View.OnClickListener() {
+        @Override
+        public void onClick(View view) {
+            boolean checked = !mEnableMobileData.isChecked();
+            SetupWizardUtils.setMobileDataEnabled(MobileDataActivity.this, checked);
+            mEnableMobileData.setChecked(checked);
+            if (checked && !mNetworkMonitor.isWifiConnected()) {
+                waitForData();
+            } else {
+                onDataStateReady();
+            }
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPhoneMonitor = PhoneMonitor.getInstance();
+        mNetworkMonitor = NetworkMonitor.getInstance();
+        setNextText(R.string.next);
+
+        mProgressBar = (ProgressBar) findViewById(R.id.progress);
+        mEnableDataRow = findViewById(R.id.data);
+        mEnableDataRow.setOnClickListener(mEnableDataClickListener);
+        mEnableMobileData = (Switch) findViewById(R.id.data_switch);
+        mSignalView =  (ImageView) findViewById(R.id.signal);
+        mNameView =  (TextView) findViewById(R.id.enable_data_title);
+        updateDataConnectionStatus();
+        updateSignalStrength();
+
+    }
+
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mIsAttached = true;
+        mPhone = getSystemService(TelephonyManager.class);
+        mPhoneMonitor.addListener(mSubscriptionStateListener);
+        updateDataConnectionStatus();
+        updateSignalStrength();
+        if (SetupWizardUtils.isRadioReady(this, null)) {
+            hideWaitForRadio();
+        } else {
+            mHandler.postDelayed(mRadioReadyRunnable, SetupWizardApp.RADIO_READY_TIMEOUT);
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mIsAttached = false;
+        mPhoneMonitor.removeListener(mSubscriptionStateListener);
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    private void hideWaitForRadio() {
+        if (mProgressBar.isShown()) {
+            mHandler.removeCallbacks(mRadioReadyRunnable);
+            // Something else, like data enablement, may have grabbed
+            // the "hold" status. Kill it only if "Next" is active
+            if (isNextAllowed()) {
+                mProgressBar.setVisibility(View.INVISIBLE);
+            }
+        }
+    }
+
+    private void waitForData() {
+        if (!mProgressBar.isShown()) {
+            mProgressBar.setVisibility(View.VISIBLE);
+            mProgressBar.startAnimation(
+                    AnimationUtils.loadAnimation(this, R.anim.translucent_enter));
+            mEnableDataRow.setEnabled(false);
+            setNextAllowed(false);
+            mHandler.postDelayed(mDataConnectionReadyRunnable, DC_READY_TIMEOUT);
+        }
+    }
+
+    private void onDataStateReady() {
+        mHandler.removeCallbacks(mDataConnectionReadyRunnable);
+        if ((mProgressBar.isShown()) ||
+                !isNextAllowed()) {
+            mProgressBar.startAnimation(
+                    AnimationUtils.loadAnimation(this, R.anim.translucent_exit));
+            mProgressBar.setVisibility(View.INVISIBLE);
+            mEnableDataRow.setEnabled(true);
+            setNextAllowed(true);
+        }
+    }
+
+    private void updateCarrierText() {
+        if (mIsAttached) {
+            String name = mPhone.getSimOperatorName(SubscriptionManager.getDefaultSubscriptionId());
+            if (TextUtils.isEmpty(name)) {
+                name = mPhone.getNetworkOperatorName(SubscriptionManager.getDefaultSubscriptionId());
+            }
+            if (TextUtils.isEmpty(name)) {
+                if (mServiceState != null && mServiceState.isEmergencyOnly()) {
+                    name = getString(R.string.setup_mobile_data_emergency_only);
+                } else {
+                    name = getString(R.string.setup_mobile_data_no_service);
+                }
+            }
+            mNameView.setText(name);
+        }
+    }
+
+    private void updateSignalStrength() {
+        if (mIsAttached) {
+            if (LOGV) {
+                Log.v(TAG, "updateSignalStrength{" +
+                        "signalStrength='" + mSignalStrength + '\'' +
+                        "signalStrengthLevel='" + ((mSignalStrength != null) ?
+                        mSignalStrength.getLevel() : "null") + '\'' +
+                        '}');
+            }
+            if (!hasService()) {
+                mSignalView.setImageResource(R.drawable.ic_signal_no_signal);
+            } else {
+                if (mSignalStrength != null) {
+                    int resId;
+                    switch (mSignalStrength.getLevel()) {
+                        case 4:
+                            resId = R.drawable.ic_signal_4;
+                            break;
+                        case 3:
+                            resId = R.drawable.ic_signal_3;
+                            break;
+                        case 2:
+                            resId = R.drawable.ic_signal_2;
+                            break;
+                        case 1:
+                            resId = R.drawable.ic_signal_1;
+                            break;
+                        default:
+                            resId = R.drawable.ic_signal_0;
+                            break;
+                    }
+                    mSignalView.setImageResource(resId);
+                }
+            }
+            updateCarrierText();
+        }
+    }
+
+    private void updateDataConnectionStatus() {
+        mEnableMobileData.setChecked(SetupWizardUtils.isMobileDataEnabled(this));
+    }
+
+    private boolean hasService() {
+        boolean retVal;
+        if (mServiceState == null) {
+            mServiceState  =  TelephonyManager.from(this)
+                    .getServiceStateForSubscriber(SubscriptionManager.getDefaultSubscriptionId());
+        }
+        if (mServiceState != null) {
+            // Consider the device to be in service if either voice or data service is available.
+            // Some SIM cards are marketed as data-only and do not support voice service, and on
+            // these SIM cards, we want to show signal bars for data service as well as the "no
+            // service" or "emergency calls only" text that indicates that voice is not available.
+            switch(mServiceState.getVoiceRegState()) {
+                case ServiceState.STATE_POWER_OFF:
+                    retVal = false;
+                    break;
+                case ServiceState.STATE_OUT_OF_SERVICE:
+                case ServiceState.STATE_EMERGENCY_ONLY:
+                    retVal = mServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE;
+                    break;
+                default:
+                    retVal = true;
+            }
+        } else {
+            retVal = false;
+        }
+        return retVal;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.mobile_data_settings;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_mobile_data;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_mobile_data;
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/PartnerReceiver.java b/src/org/lineageos/setupwizard/PartnerReceiver.java
new file mode 100644
index 0000000..7a85961
--- /dev/null
+++ b/src/org/lineageos/setupwizard/PartnerReceiver.java
@@ -0,0 +1,29 @@
+package com.cyanogenmod.setupwizard;
+
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class PartnerReceiver extends BroadcastReceiver {
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // Do nothing
+    }
+}
diff --git a/src/org/lineageos/setupwizard/ScreenLockActivity.java b/src/org/lineageos/setupwizard/ScreenLockActivity.java
new file mode 100644
index 0000000..7b53f7d
--- /dev/null
+++ b/src/org/lineageos/setupwizard/ScreenLockActivity.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_SETUP_LOCKSCREEN;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_DETAILS;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_TITLE;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_LOCKSCREEN;
+
+import android.content.Intent;
+import android.view.View;
+
+public class ScreenLockActivity extends SubBaseActivity {
+
+    public static final String TAG = ScreenLockActivity.class.getSimpleName();
+
+    @Override
+    protected void onStartSubactivity() {
+        setNextAllowed(true);
+        findViewById(R.id.setup_lockscreen).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                launchLockscreenSetup();
+            }
+        });
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.setup_lockscreen;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.lockscreen_setup_title;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_lock_screen;
+    }
+
+    private void launchLockscreenSetup() {
+        Intent intent = new Intent(ACTION_SETUP_LOCKSCREEN);
+        intent.putExtra(EXTRA_TITLE,
+                getString(R.string.settings_lockscreen_setup_title));
+        intent.putExtra(EXTRA_DETAILS,
+                getString(R.string.settings_lockscreen_setup_details));
+        intent.putExtra(SetupWizardApp.EXTRA_ALLOW_SKIP, true);
+        startSubactivity(intent, REQUEST_CODE_SETUP_LOCKSCREEN);
+    }
+
+    @Override
+    protected int getSubactivityNextTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/SetupWizardActivity.java b/src/org/lineageos/setupwizard/SetupWizardActivity.java
new file mode 100644
index 0000000..244f666
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SetupWizardActivity.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_LOAD;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.annotation.Nullable;
+import android.content.Intent;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+import com.cyanogenmod.setupwizard.wizardmanager.WizardManager;
+
+public class SetupWizardActivity extends BaseSetupWizardActivity {
+    private static final String TAG = SetupWizardActivity.class.getSimpleName();
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (LOGV) {
+            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
+        }
+        if (SetupWizardUtils.hasGMS(this)) {
+            if (LOGV) {
+                Log.v(TAG, "Has GMS disabling local wizard manager");
+            }
+            SetupWizardUtils.disableComponentsForGMS(this);
+            finish();
+        } else {
+            onSetupStart();
+            SetupWizardUtils.resetComponent(this, WizardManager.class);
+            Intent intent = new Intent(ACTION_LOAD);
+            if (isPrimaryUser()) {
+                intent.putExtra(EXTRA_SCRIPT_URI, getString(R.string.cm_wizard_script_uri));
+            } else {
+                intent.putExtra(EXTRA_SCRIPT_URI, getString(R.string.cm_wizard_script_user_uri));
+            }
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | FLAG_GRANT_READ_URI_PERMISSION);
+            startActivity(intent);
+            finish();
+        }
+    }
+}
diff --git a/src/org/lineageos/setupwizard/SetupWizardApp.java b/src/org/lineageos/setupwizard/SetupWizardApp.java
new file mode 100644
index 0000000..fa5fc6f
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SetupWizardApp.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2013 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+
+import android.app.Application;
+import android.os.Bundle;
+import android.os.Handler;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.util.NetworkMonitor;
+import com.cyanogenmod.setupwizard.util.PhoneMonitor;
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+import com.cyanogenmod.setupwizard.wizardmanager.WizardManager;
+
+public class SetupWizardApp extends Application {
+
+    public static final String TAG = SetupWizardApp.class.getSimpleName();
+    // Leave this off for release
+    public static final boolean DEBUG = false;
+    /* Verbose Logging */
+    public static final boolean LOGV = Log.isLoggable(TAG, Log.VERBOSE);
+
+    public static final String ACTION_FINISHED = "com.cyanogenmod.setupwizard.SETUP_FINISHED";
+    public static final String ACTION_SETUP_WIFI = "android.net.wifi.PICK_WIFI_NETWORK";
+    public static final String ACTION_SETUP_FINGERPRINT = "android.settings.FINGERPRINT_SETUP";
+    public static final String ACTION_SETUP_LOCKSCREEN = "com.android.settings.SETUP_LOCK_SCREEN";
+    public static final String ACTION_EMERGENCY_DIAL = "com.android.phone.EmergencyDialer.DIAL";
+    public static final String ACTION_NEXT = "com.android.wizard.NEXT";
+    public static final String ACTION_LOAD = "com.android.wizard.LOAD";
+
+
+    public static final String EXTRA_FIRST_RUN = "firstRun";
+    public static final String EXTRA_ALLOW_SKIP = "allowSkip";
+    public static final String EXTRA_AUTO_FINISH = "wifi_auto_finish_on_connect";
+    public static final String EXTRA_USE_IMMERSIVE = "useImmersiveMode";
+    public static final String EXTRA_HAS_MULTIPLE_USERS = "hasMultipleUsers";
+    public static final String EXTRA_THEME = "theme";
+    public static final String EXTRA_MATERIAL_LIGHT = "material_light";
+    public static final String EXTRA_TITLE = "title";
+    public static final String EXTRA_DETAILS = "details";
+    public static final String EXTRA_SCRIPT_URI = "scriptUri";
+    public static final String EXTRA_ACTION_ID = "actionId";
+    public static final String EXTRA_RESULT_CODE = "com.android.setupwizard.ResultCode";
+    public static final String EXTRA_PREFS_SHOW_BUTTON_BAR = "extra_prefs_show_button_bar";
+    public static final String EXTRA_PREFS_SET_BACK_TEXT = "extra_prefs_set_back_text";
+
+    public static final String KEY_DETECT_CAPTIVE_PORTAL = "captive_portal_detection_enabled";
+    public static final String KEY_SEND_METRICS = "send_metrics";
+    public static final String DISABLE_NAV_KEYS = "disable_nav_keys";
+    public static final String KEY_APPLY_DEFAULT_THEME = "apply_default_theme";
+    public static final String KEY_BUTTON_BACKLIGHT = "pre_navbar_button_backlight";
+    public static final String KEY_PRIVACY_GUARD = "privacy_guard_default";
+
+    private static final String[] THEME_PACKAGES = {
+            "org.cyanogenmod.theme.chooser",
+            "org.cyanogenmod.theme.chooser2",
+            "com.cyngn.theme.chooser",
+            "com.cyngn.themestore"
+    };
+
+    public static final int REQUEST_CODE_SETUP_WIFI = 0;
+    public static final int REQUEST_CODE_SETUP_CAPTIVE_PORTAL= 4;
+    public static final int REQUEST_CODE_SETUP_BLUETOOTH= 5;
+    public static final int REQUEST_CODE_SETUP_FINGERPRINT = 7;
+    public static final int REQUEST_CODE_SETUP_LOCKSCREEN = 9;
+
+    public static final int RADIO_READY_TIMEOUT = 10 * 1000;
+
+    private boolean mIsRadioReady = false;
+    private boolean mIgnoreSimLocale = false;
+
+    private final Bundle mSettingsBundle = new Bundle();
+    private final Handler mHandler = new Handler();
+
+    private final Runnable mRadioTimeoutRunnable = new Runnable() {
+        @Override
+        public void run() {
+            mIsRadioReady = true;
+        }
+    };
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        if (LOGV) {
+            Log.v(TAG, "onCreate()");
+        }
+        NetworkMonitor.initInstance(this);
+        PhoneMonitor.initInstance(this);
+        SetupWizardUtils.disableComponentsForMissingFeatures(this);
+        mHandler.postDelayed(mRadioTimeoutRunnable, SetupWizardApp.RADIO_READY_TIMEOUT);
+    }
+
+    public boolean isRadioReady() {
+        return mIsRadioReady;
+    }
+
+    public void setRadioReady(boolean radioReady) {
+        if (!mIsRadioReady && radioReady) {
+            mHandler.removeCallbacks(mRadioTimeoutRunnable);
+        }
+        mIsRadioReady = radioReady;
+    }
+
+    public boolean ignoreSimLocale() {
+        return mIgnoreSimLocale;
+    }
+
+    public void setIgnoreSimLocale(boolean ignoreSimLocale) {
+        mIgnoreSimLocale = ignoreSimLocale;
+    }
+
+    public Bundle getSettingsBundle() {
+        return mSettingsBundle;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/SetupWizardExitActivity.java b/src/org/lineageos/setupwizard/SetupWizardExitActivity.java
new file mode 100644
index 0000000..321a426
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SetupWizardExitActivity.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK;
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.annotation.Nullable;
+import android.content.Intent;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.android.setupwizardlib.util.SystemBarHelper;
+
+import com.cyanogenmod.setupwizard.util.PhoneMonitor;
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+public class SetupWizardExitActivity extends BaseSetupWizardActivity {
+
+    private static final String TAG = SetupWizardExitActivity.class.getSimpleName();
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (LOGV) {
+            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
+        }
+        SystemBarHelper.showSystemBars(getWindow(), this);
+        SetupWizardUtils.enableStatusBar(this);
+        SetupWizardUtils.enableCaptivePortalDetection(this);
+        PhoneMonitor.onSetupFinished();
+        launchHome();
+        finish();
+        applyForwardTransition(TRANSITION_ID_FADE);
+        Intent i = new Intent();
+        i.setClassName(getPackageName(), SetupWizardExitService.class.getName());
+        startService(i);
+    }
+
+    private void launchHome() {
+        startActivity(new Intent("android.intent.action.MAIN")
+                .addCategory("android.intent.category.HOME")
+                .addFlags(FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK));
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/SetupWizardExitService.java b/src/org/lineageos/setupwizard/SetupWizardExitService.java
new file mode 100644
index 0000000..c3243b9
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SetupWizardExitService.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.annotation.Nullable;
+import android.app.IntentService;
+import android.content.Intent;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+public class SetupWizardExitService extends IntentService {
+
+    private static final String TAG = "SUWExitService";
+
+    public SetupWizardExitService() {
+        super(TAG);
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable Intent intent) {
+        if (LOGV) {
+            Log.v(TAG, "onHandleIntent intent=" + intent.toString());
+        }
+        SetupWizardUtils.finishSetupWizard(this);
+    }
+}
diff --git a/src/org/lineageos/setupwizard/SetupWizardTestActivity.java b/src/org/lineageos/setupwizard/SetupWizardTestActivity.java
new file mode 100644
index 0000000..5f978b7
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SetupWizardTestActivity.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static android.content.pm.PackageManager.GET_ACTIVITIES;
+import static android.content.pm.PackageManager.GET_RECEIVERS;
+import static android.content.pm.PackageManager.GET_SERVICES;
+import static android.content.pm.PackageManager.MATCH_DISABLED_COMPONENTS;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.provider.Settings;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+import java.util.List;
+
+public class SetupWizardTestActivity extends Activity {
+
+    private static final String TAG = SetupWizardTestActivity.class.getSimpleName();
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (LOGV) {
+            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
+        }
+        if (SetupWizardUtils.isOwner()) {
+            Settings.Global.putInt(getContentResolver(), "device_provisioned", 0);
+        }
+        Settings.Secure.putInt(getContentResolver(), "user_setup_complete", 0);
+        SetupWizardUtils.resetComponentSets(this, GET_ACTIVITIES |
+                GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
+        forgetAllWifi();
+        Intent setupIntent = new Intent("android.intent.action.MAIN")
+                .addCategory("android.intent.category.HOME")
+                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        SetupWizardUtils.disableComponentsForMissingFeatures(this);
+        startActivity(setupIntent);
+        finish();
+    }
+
+    private void forgetAllWifi() {
+        WifiManager wm = getSystemService(WifiManager.class);
+        if (wm != null) {
+            List<WifiConfiguration> configs = wm.getConfiguredNetworks();
+            if (configs != null) {
+                for (WifiConfiguration config : configs) {
+                    wm.forget(config.networkId, null);
+                }
+            }
+        }
+    }
+}
diff --git a/src/org/lineageos/setupwizard/SimMissingActivity.java b/src/org/lineageos/setupwizard/SimMissingActivity.java
new file mode 100644
index 0000000..7369f7d
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SimMissingActivity.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import android.os.Bundle;
+import android.widget.ImageView;
+
+import com.android.setupwizardlib.util.ResultCodes;
+
+import com.cyanogenmod.setupwizard.util.PhoneMonitor;
+
+public class SimMissingActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = SimMissingActivity.class.getSimpleName();
+
+    private static final int SIM_DEFAULT = 0;
+    private static final int SIM_SIDE = 1;
+    private static final int SIM_BACK = 2;
+
+    private PhoneMonitor mPhoneMonitor;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPhoneMonitor = PhoneMonitor.getInstance();
+        if (!mPhoneMonitor.simMissing()) {
+            finishAction(RESULT_OK);
+        }
+        setNextText(R.string.skip);
+        final int simLocation = getResources().getInteger(
+                R.integer.sim_image_type);
+        ImageView simLogo = ((ImageView)findViewById(R.id.sim_slot_image));
+        switch (simLocation) {
+            case SIM_SIDE:
+                simLogo.setImageResource(R.drawable.sim_side);
+                break;
+            case SIM_BACK:
+                simLogo.setImageResource(R.drawable.sim_back);
+                break;
+            default:
+                simLogo.setImageResource(R.drawable.sim);
+                simLogo.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
+        }
+    }
+
+    @Override
+    public void onNavigateNext() {
+        if (mPhoneMonitor.simMissing()) {
+            nextAction(ResultCodes.RESULT_SKIP);
+        } else {
+            super.onNavigateNext();
+        }
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.sim_missing_page;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.setup_sim_missing;
+    }
+
+    @Override
+    protected int getIconResId() {
+        return R.drawable.ic_sim;
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/SubBaseActivity.java b/src/org/lineageos/setupwizard/SubBaseActivity.java
new file mode 100644
index 0000000..ae44a69
--- /dev/null
+++ b/src/org/lineageos/setupwizard/SubBaseActivity.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+
+import static android.content.Intent.FLAG_ACTIVITY_FORWARD_RESULT;
+
+import static com.android.setupwizardlib.util.ResultCodes.RESULT_ACTIVITY_NOT_FOUND;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ACTION_ID;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.annotation.NonNull;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.TextView;
+
+public abstract class SubBaseActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = SubBaseActivity.class.getSimpleName();
+
+    private boolean mIsSubactivityNotFound = false;
+    private int mRequestCode;
+
+    protected abstract void onStartSubactivity();
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        if (LOGV) {
+            Log.d(TAG, "onCreate savedInstanceState=" + savedInstanceState);
+        }
+        super.onCreate(savedInstanceState);
+        setNextText(R.string.skip);
+        setNextAllowed(false);
+        if (savedInstanceState == null) {
+            onStartSubactivity();
+        }
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        mIsActivityVisible = true;
+    }
+
+    @Override
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        outState.putInt("request_code", mRequestCode);
+        super.onSaveInstanceState(outState);
+    }
+
+    @Override
+    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+        mRequestCode = savedInstanceState.getInt("request_code");
+    }
+
+    protected void startSubactivity(Intent subactivityIntent, int requestCode) {
+        mRequestCode = requestCode;
+        Intent intent = getIntent();
+        if (intent.hasExtra(EXTRA_SCRIPT_URI)) {
+            subactivityIntent.putExtra(EXTRA_SCRIPT_URI, intent.getStringExtra(EXTRA_SCRIPT_URI));
+            subactivityIntent.putExtra(EXTRA_ACTION_ID, intent.getStringExtra(EXTRA_ACTION_ID));
+        }
+        boolean activityForwardsResult =
+                (subactivityIntent.getFlags() & FLAG_ACTIVITY_FORWARD_RESULT) != 0;
+        if (activityForwardsResult) {
+            try {
+                startFirstRunActivity(subactivityIntent);
+                setResultCode(RESULT_OK);
+                finish();
+            } catch (ActivityNotFoundException e) {
+                Log.w(TAG, "activity not found; start next screen and finish; intent="
+                        + intent);
+                mIsSubactivityNotFound = true;
+                nextAction(RESULT_ACTIVITY_NOT_FOUND);
+                finish();
+                return;
+            }
+        }
+        startFirstRunActivityForResult(subactivityIntent, requestCode);
+        mIsSubactivityNotFound = false;
+        applyForwardTransition(getSubactivityPreviousTransition());
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Bundle extras = null;
+        if (LOGV) {
+            Log.v(TAG, "onActivityResult(" + getRequestName(requestCode) +
+                    ", " + getResultName(requestCode, resultCode));
+        }
+        if (requestCode == mRequestCode) {
+            StringBuilder append = new StringBuilder().append("subactivity result {")
+                    .append(getRequestName(requestCode)).append(", ")
+                    .append(getResultName(mRequestCode, resultCode)).append(", ");
+            if (data != null) {
+                extras = data.getExtras();
+            }
+            Log.i(TAG, append.append(extras).append("}").toString());
+            onSubactivityResult(requestCode, resultCode, data);
+        } else if (resultCode == RESULT_CANCELED) {
+            onStartSubactivity();
+            mIsGoingBack = true;
+            applyBackwardTransition(getSubactivityNextTransition());
+        } else {
+            super.onActivityResult(requestCode, resultCode, data);
+        }
+    }
+
+    protected void onSubactivityResult(int requestCode, int resultCode, Intent data) {
+        if (LOGV) {
+            StringBuilder append = new StringBuilder().append("onSubactivityResult(")
+                    .append(getRequestName(requestCode)).append(", ")
+                    .append(getResultName(requestCode, resultCode)).append(", ");
+            Bundle extras = null;
+            if (data != null) {
+                extras = data.getExtras();
+            }
+            Log.v(TAG, append.append(extras).append(")").toString());
+        }
+        if (resultCode != RESULT_CANCELED) {
+            applyForwardTransition(getSubactivityNextTransition());
+            nextAction(resultCode, data);
+        } else if (mIsSubactivityNotFound) {
+            nextAction(RESULT_ACTIVITY_NOT_FOUND);
+            finish();
+        } else {
+            applyBackwardTransition(getSubactivityPreviousTransition());
+            finishAction(RESULT_CANCELED, data);
+        }
+    }
+
+    protected int getSubactivityPreviousTransition() {
+        return TRANSITION_ID_DEFAULT;
+    }
+
+    protected int getSubactivityNextTransition() {
+        return TRANSITION_ID_DEFAULT;
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_FADE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.setup_loading_page;
+    }
+
+    @Override
+    protected int getTitleResId() {
+        return R.string.loading;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/WelcomeActivity.java b/src/org/lineageos/setupwizard/WelcomeActivity.java
new file mode 100644
index 0000000..061cfbe
--- /dev/null
+++ b/src/org/lineageos/setupwizard/WelcomeActivity.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import android.os.Bundle;
+import android.view.MotionEvent;
+import android.view.View;
+
+import com.cyanogenmod.setupwizard.util.EnableAccessibilityController;
+
+public class WelcomeActivity extends BaseSetupWizardActivity {
+
+    public static final String TAG = WelcomeActivity.class.getSimpleName();
+
+    private View mRootView;
+    private EnableAccessibilityController mEnableAccessibilityController;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mRootView = findViewById(R.id.root);
+        setNextText(R.string.next);
+        setBackText(R.string.emergency_call);
+        setBackDrawable(null);
+        mEnableAccessibilityController =
+                EnableAccessibilityController.getInstance(getApplicationContext());
+        mRootView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                return mEnableAccessibilityController.onTouchEvent(event);
+            }
+        });
+    }
+
+    @Override
+    public void onBackPressed() {}
+
+    @Override
+    public void onNavigateBack() {
+        startEmergencyDialer();
+    }
+
+    @Override
+    protected int getTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+    @Override
+    protected int getLayoutResId() {
+        return R.layout.welcome_activity;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/WifiSetupActivity.java b/src/org/lineageos/setupwizard/WifiSetupActivity.java
new file mode 100644
index 0000000..ec49dd3
--- /dev/null
+++ b/src/org/lineageos/setupwizard/WifiSetupActivity.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_SETUP_WIFI;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_MATERIAL_LIGHT;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.REQUEST_CODE_SETUP_WIFI;
+
+import android.content.Intent;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+public class WifiSetupActivity extends SubBaseActivity {
+
+    public static final String TAG = WifiSetupActivity.class.getSimpleName();
+
+
+    @Override
+    protected void onStartSubactivity() {
+        tryEnablingWifi();
+        Intent intent = new Intent(ACTION_SETUP_WIFI);
+        if (SetupWizardUtils.hasLeanback(this)) {
+            intent.setComponent(SetupWizardUtils.mTvwifisettingsActivity);
+        }
+        intent.putExtra(SetupWizardApp.EXTRA_PREFS_SHOW_BUTTON_BAR, true);
+        intent.putExtra(SetupWizardApp.EXTRA_PREFS_SET_BACK_TEXT , false);
+        startSubactivity(intent, REQUEST_CODE_SETUP_WIFI);
+    }
+
+    @Override
+    protected int getSubactivityNextTransition() {
+        return TRANSITION_ID_SLIDE;
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/util/EnableAccessibilityController.java b/src/org/lineageos/setupwizard/util/EnableAccessibilityController.java
new file mode 100644
index 0000000..17eb782
--- /dev/null
+++ b/src/org/lineageos/setupwizard/util/EnableAccessibilityController.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.cyanogenmod.setupwizard.util;
+
+import android.accessibilityservice.AccessibilityServiceInfo;
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.pm.ServiceInfo;
+import android.media.AudioManager;
+import android.media.Ringtone;
+import android.media.RingtoneManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.speech.tts.TextToSpeech;
+import android.util.MathUtils;
+import android.view.IWindowManager;
+import android.view.MotionEvent;
+import android.view.accessibility.AccessibilityManager;
+import android.view.accessibility.IAccessibilityManager;
+
+import com.android.internal.R;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class EnableAccessibilityController {
+
+    private static final int SPEAK_WARNING_DELAY_MILLIS = 5000;
+    private static final int ENABLE_ACCESSIBILITY_DELAY_MILLIS = 12000;
+
+    public static final int MESSAGE_SPEAK_WARNING = 1;
+    public static final int MESSAGE_SPEAK_ENABLE_CANCELED = 2;
+    public static final int MESSAGE_ENABLE_ACCESSIBILITY = 3;
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message message) {
+            switch (message.what) {
+                case MESSAGE_SPEAK_WARNING: {
+                    // TODO: Fix these or remove these
+                    //String text = mContext.getString(R.string.continue_to_enable_accessibility);
+                    //mTts.speak(text, TextToSpeech.QUEUE_FLUSH, null);
+                } break;
+                case MESSAGE_SPEAK_ENABLE_CANCELED: {
+                    //String text = mContext.getString(R.string.enable_accessibility_canceled);
+                    //mTts.speak(text, TextToSpeech.QUEUE_FLUSH, null);
+                } break;
+                case MESSAGE_ENABLE_ACCESSIBILITY: {
+                    enableAccessibility();
+                    //mTone.play();
+                    //mTts.speak(mContext.getString(R.string.accessibility_enabled),
+                    //        TextToSpeech.QUEUE_FLUSH, null);
+                } break;
+            }
+        }
+    };
+
+    private final IWindowManager mWindowManager = IWindowManager.Stub.asInterface(
+            ServiceManager.getService("window"));
+
+    private final IAccessibilityManager mAccessibilityManager = IAccessibilityManager
+            .Stub.asInterface(ServiceManager.getService("accessibility"));
+
+
+    private final Context mContext;
+    private final UserManager mUserManager;
+    private final TextToSpeech mTts;
+    private final Ringtone mTone;
+
+    private final float mTouchSlop;
+
+    private boolean mDestroyed;
+
+    private float mFirstPointerDownX;
+    private float mFirstPointerDownY;
+    private float mSecondPointerDownX;
+    private float mSecondPointerDownY;
+
+    private static EnableAccessibilityController sInstance;
+
+    private EnableAccessibilityController(Context context) {
+        mContext = context;
+        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
+        mTts = new TextToSpeech(context, new TextToSpeech.OnInitListener() {
+            @Override
+            public void onInit(int status) {
+                if (mDestroyed) {
+                    mTts.shutdown();
+                }
+            }
+        });
+        mTone = RingtoneManager.getRingtone(context, Settings.System.DEFAULT_NOTIFICATION_URI);
+        mTone.setStreamType(AudioManager.STREAM_MUSIC);
+        mTouchSlop = context.getResources().getDimensionPixelSize(
+                R.dimen.accessibility_touch_slop);
+    }
+
+    public static EnableAccessibilityController getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new EnableAccessibilityController(context);
+        }
+        return sInstance;
+    }
+
+    public static boolean canEnableAccessibilityViaGesture(Context context) {
+        AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(context);
+        // Accessibility is enabled and there is an enabled speaking
+        // accessibility service, then we have nothing to do.
+        if (accessibilityManager.isEnabled()
+                && !accessibilityManager.getEnabledAccessibilityServiceList(
+                AccessibilityServiceInfo.FEEDBACK_SPOKEN).isEmpty()) {
+            return false;
+        }
+
+        // If there is a speaking service
+        // installed we are good to go, otherwise there is nothing to do.
+        return getInstalledSpeakingAccessibilityServices(context).isEmpty();
+    }
+
+    private static List<AccessibilityServiceInfo> getInstalledSpeakingAccessibilityServices(
+            Context context) {
+        List<AccessibilityServiceInfo> services = new ArrayList<AccessibilityServiceInfo>();
+        services.addAll(AccessibilityManager.getInstance(context)
+                .getInstalledAccessibilityServiceList());
+        Iterator<AccessibilityServiceInfo> iterator = services.iterator();
+        while (iterator.hasNext()) {
+            AccessibilityServiceInfo service = iterator.next();
+            if ((service.feedbackType & AccessibilityServiceInfo.FEEDBACK_SPOKEN) == 0) {
+                iterator.remove();
+            }
+        }
+        return services;
+    }
+
+    public void onDestroy() {
+        mDestroyed = true;
+    }
+
+    public boolean onTouchEvent(MotionEvent event) {
+        final int pointerCount = event.getPointerCount();
+        final int action = event.getActionMasked();
+
+        if (pointerCount != 2) {
+            cancel();
+            return true;
+        }
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+            case MotionEvent.ACTION_POINTER_DOWN: {
+                mFirstPointerDownX = event.getX(0);
+                mFirstPointerDownY = event.getY(0);
+                mSecondPointerDownX = event.getX(1);
+                mSecondPointerDownY = event.getY(1);
+                mHandler.sendEmptyMessageDelayed(MESSAGE_SPEAK_WARNING,
+                        SPEAK_WARNING_DELAY_MILLIS);
+                mHandler.sendEmptyMessageDelayed(MESSAGE_ENABLE_ACCESSIBILITY,
+                        ENABLE_ACCESSIBILITY_DELAY_MILLIS);
+            }
+            break;
+            case MotionEvent.ACTION_MOVE: {
+                final float firstPointerMove = MathUtils.dist(event.getX(0),
+                        event.getY(0), mFirstPointerDownX, mFirstPointerDownY);
+                if (Math.abs(firstPointerMove) > mTouchSlop) {
+                    cancel();
+                }
+                final float secondPointerMove = MathUtils.dist(event.getX(1),
+                        event.getY(1), mSecondPointerDownX, mSecondPointerDownY);
+                if (Math.abs(secondPointerMove) > mTouchSlop) {
+                    cancel();
+                }
+            }
+            break;
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_POINTER_UP:
+            case MotionEvent.ACTION_CANCEL: {
+                cancel();
+            }
+            break;
+        }
+        return true;
+    }
+
+    private void cancel() {
+        if (mHandler.hasMessages(MESSAGE_SPEAK_WARNING)) {
+            mHandler.removeMessages(MESSAGE_SPEAK_WARNING);
+        } else if (mHandler.hasMessages(MESSAGE_ENABLE_ACCESSIBILITY)) {
+            mHandler.sendEmptyMessage(MESSAGE_SPEAK_ENABLE_CANCELED);
+        }
+        mHandler.removeMessages(MESSAGE_ENABLE_ACCESSIBILITY);
+    }
+
+    private void enableAccessibility() {
+        List<AccessibilityServiceInfo> services = getInstalledSpeakingAccessibilityServices(
+                mContext);
+        if (services.isEmpty()) {
+            return;
+        }
+        boolean keyguardLocked = false;
+        try {
+            keyguardLocked = mWindowManager.isKeyguardLocked();
+        } catch (RemoteException re) {
+            /* ignore */
+        }
+
+        final boolean hasMoreThanOneUser = mUserManager.getUsers().size() > 1;
+
+        AccessibilityServiceInfo service = services.get(0);
+        boolean enableTouchExploration = (service.flags
+                & AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0;
+        // Try to find a service supporting explore by touch.
+        if (!enableTouchExploration) {
+            final int serviceCount = services.size();
+            for (int i = 1; i < serviceCount; i++) {
+                AccessibilityServiceInfo candidate = services.get(i);
+                if ((candidate.flags & AccessibilityServiceInfo
+                        .FLAG_REQUEST_TOUCH_EXPLORATION_MODE) != 0) {
+                    enableTouchExploration = true;
+                    service = candidate;
+                    break;
+                }
+            }
+        }
+
+        ServiceInfo serviceInfo = service.getResolveInfo().serviceInfo;
+        ComponentName componentName = new ComponentName(serviceInfo.packageName, serviceInfo.name);
+        if (!keyguardLocked || !hasMoreThanOneUser) {
+            final int userId = ActivityManager.getCurrentUser();
+            String enabledServiceString = componentName.flattenToString();
+            ContentResolver resolver = mContext.getContentResolver();
+            // Enable one speaking accessibility service.
+            Settings.Secure.putStringForUser(resolver,
+                    Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,
+                    enabledServiceString, userId);
+            // Allow the services we just enabled to toggle touch exploration.
+            Settings.Secure.putStringForUser(resolver,
+                    Settings.Secure.TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
+                    enabledServiceString, userId);
+            // Enable touch exploration.
+            if (enableTouchExploration) {
+                Settings.Secure.putIntForUser(resolver, Settings.Secure.TOUCH_EXPLORATION_ENABLED,
+                        1, userId);
+            }
+            // Turn on accessibility mode last.
+            Settings.Secure.putIntForUser(resolver, Settings.Secure.ACCESSIBILITY_ENABLED,
+                    1, userId);
+        } else if (keyguardLocked) {
+            try {
+                mAccessibilityManager.temporaryEnableAccessibilityStateUntilKeyguardRemoved(
+                        componentName, enableTouchExploration);
+            } catch (RemoteException re) {
+                /* ignore */
+            }
+        }
+    }
+}
diff --git a/src/org/lineageos/setupwizard/util/NetworkMonitor.java b/src/org/lineageos/setupwizard/util/NetworkMonitor.java
new file mode 100644
index 0000000..0cc1d9e
--- /dev/null
+++ b/src/org/lineageos/setupwizard/util/NetworkMonitor.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.util;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.os.Handler;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.SetupWizardApp;
+
+public class NetworkMonitor {
+
+    public static final String TAG = NetworkMonitor.class.getSimpleName();
+
+    private static NetworkMonitor sInstance;
+
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (LOGV) {
+                Log.v(TAG, intent.toString());
+            }
+            NetworkMonitor.this.updateNetworkStatus(context);
+        }
+    };
+    private Context mContext = null;
+    private boolean mNetworkConnected = false;
+    private NetworkInfo mNetworkInfo = null;
+
+    public static void initInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new NetworkMonitor(context.getApplicationContext());
+        }
+    }
+
+    public static NetworkMonitor getInstance() {
+        return sInstance;
+    }
+
+    public NetworkMonitor(Context context) {
+        mContext = context;
+        if (LOGV) {
+            Log.v(TAG, "Starting NetworkMonitor");
+        }
+        IntentFilter filter = new IntentFilter();
+        filter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
+        context.registerReceiver(mBroadcastReceiver, filter);
+        new Handler().post(new Runnable() {
+            public void run() {
+                updateNetworkStatus(mContext);
+            }
+        });
+    }
+
+    public boolean isNetworkConnected() {
+        if (LOGV) {
+            Log.v(TAG, "isNetworkConnected() returns " + mNetworkConnected);
+        }
+        return mNetworkConnected;
+    }
+
+    public boolean isWifiConnected() {
+        boolean wifiConnected = (!mNetworkConnected || mNetworkInfo == null) ?
+                false :
+                mNetworkInfo.getType() == 1;
+        if (LOGV) {
+            Log.v(TAG, "isWifiConnected() returns " + wifiConnected);
+        }
+        return wifiConnected;
+    }
+
+    public boolean checkIsNetworkConnected() {
+        updateNetworkStatus(mContext);
+        return isNetworkConnected();
+    }
+
+    private void onNetworkConnected(NetworkInfo ni) {
+        if (LOGV) {
+            Log.v(TAG, "onNetworkConnected()");
+        }
+        mNetworkConnected = true;
+        mNetworkInfo = ni;
+    }
+
+    private void onNetworkDisconnected() {
+        if (LOGV) {
+            Log.v(TAG, "onNetworkDisconnected()");
+        }
+        mNetworkConnected = false;
+        mNetworkInfo = null;
+    }
+
+    private boolean updateNetworkStatus(Context context) {
+        ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
+        if (cm != null) {
+            NetworkInfo ni = cm.getActiveNetworkInfo();
+            boolean isConnected = ni != null ? ni.isConnected() : false;
+            if (isConnected && !mNetworkConnected) {
+                onNetworkConnected(ni);
+            } else if (!isConnected && mNetworkConnected) {
+                onNetworkDisconnected();
+            }
+        }
+        return mNetworkConnected;
+    }
+}
diff --git a/src/org/lineageos/setupwizard/util/PhoneMonitor.java b/src/org/lineageos/setupwizard/util/PhoneMonitor.java
new file mode 100644
index 0000000..ec8ba4c
--- /dev/null
+++ b/src/org/lineageos/setupwizard/util/PhoneMonitor.java
@@ -0,0 +1,487 @@
+/*
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.util;
+
+import static android.telephony.PhoneStateListener.LISTEN_DATA_CONNECTION_STATE;
+import static android.telephony.PhoneStateListener.LISTEN_NONE;
+import static android.telephony.PhoneStateListener.LISTEN_SERVICE_STATE;
+import static android.telephony.PhoneStateListener.LISTEN_SIGNAL_STRENGTHS;
+import static android.telephony.ServiceState.STATE_EMERGENCY_ONLY;
+import static android.telephony.ServiceState.STATE_IN_SERVICE;
+import static android.telephony.ServiceState.STATE_OUT_OF_SERVICE;
+import static android.telephony.ServiceState.STATE_POWER_OFF;
+import static android.telephony.TelephonyManager.DATA_CONNECTED;
+import static android.telephony.TelephonyManager.DATA_CONNECTING;
+import static android.telephony.TelephonyManager.DATA_DISCONNECTED;
+import static android.telephony.TelephonyManager.DATA_SUSPENDED;
+import static android.telephony.TelephonyManager.DATA_UNKNOWN;
+import static android.telephony.TelephonyManager.PHONE_TYPE_CDMA;
+import static android.telephony.TelephonyManager.PHONE_TYPE_GSM;
+import static android.telephony.TelephonyManager.PHONE_TYPE_NONE;
+import static android.telephony.TelephonyManager.PHONE_TYPE_SIP;
+import static android.telephony.TelephonyManager.SIM_STATE_ABSENT;
+import static android.telephony.TelephonyManager.SIM_STATE_CARD_IO_ERROR;
+import static android.telephony.TelephonyManager.SIM_STATE_NETWORK_LOCKED;
+import static android.telephony.TelephonyManager.SIM_STATE_PIN_REQUIRED;
+import static android.telephony.TelephonyManager.SIM_STATE_PUK_REQUIRED;
+import static android.telephony.TelephonyManager.SIM_STATE_READY;
+import static android.telephony.TelephonyManager.SIM_STATE_UNKNOWN;
+
+import static com.android.internal.telephony.PhoneConstants.LTE_ON_CDMA_TRUE;
+import static com.android.internal.telephony.PhoneConstants.LTE_ON_CDMA_UNKNOWN;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.SystemProperties;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+
+public class PhoneMonitor {
+
+    public static final String TAG = PhoneMonitor.class.getSimpleName();
+
+    private static PhoneMonitor sInstance;
+    private Context mContext;
+    private TelephonyManager mTelephony;
+    private SubscriptionManager mSubscriptionManager;
+    private ArrayList<SubscriptionStateListener> mListeners = new ArrayList<>();
+    private SparseArray<SubscriptionStateTracker> mTrackers = new SparseArray<>();
+
+    private int mChangingToDataSubId = -1;
+
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                final int sub = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1);
+                final int state = mTelephony.getSimState(sub);
+                simStateChanged(sub, state);
+            } else if (intent.getAction()
+                    .equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
+                ddsHasChanged(intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1));
+            }
+        }
+    };
+
+    private class SubscriptionStateTracker extends PhoneStateListener {
+
+        private ServiceState mServiceState;
+        private int mSubId = -1;
+
+        public SubscriptionStateTracker(int subId) {
+            super(subId);
+            mSubId = subId;
+        }
+
+        public void onServiceStateChanged(ServiceState serviceState) {
+            mServiceState = serviceState;
+            if (LOGV) {
+                logPhoneState("onServiceStateChanged state=\"" + serviceState + "\" ");
+            }
+            for (SubscriptionStateListener listener : mListeners) {
+                listener.onServiceStateChanged(mSubId, serviceState);
+            }
+        }
+
+        public void onDataConnectionStateChanged(int state, int networkType) {
+            for (SubscriptionStateListener listener : mListeners) {
+                listener.onDataConnectionStateChanged(mSubId, state, networkType);
+            }
+        }
+
+        public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+            for (SubscriptionStateListener listener : mListeners) {
+                listener.onSignalStrengthsChanged(mSubId, signalStrength);
+            }
+        }
+    }
+
+    private final OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
+            new OnSubscriptionsChangedListener() {
+        public void onSubscriptionsChanged() {
+            if (LOGV) {
+                Log.d(TAG, "Subscriptions changed");
+            }
+            super.onSubscriptionsChanged();
+            updatePhoneStateTrackers();
+        }
+    };
+
+    public static void initInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new PhoneMonitor(context.getApplicationContext());
+        }
+    }
+
+    public static void onSetupFinished() {
+        if (sInstance != null) {
+            sInstance.mContext.unregisterReceiver(sInstance.mIntentReceiver);
+        }
+    }
+
+    public static PhoneMonitor getInstance() {
+        return sInstance;
+    }
+
+    public PhoneMonitor(Context context) {
+        mContext = context;
+        if (LOGV) {
+            Log.v(TAG, "Starting PhoneMonitor");
+        }
+        mTelephony = mContext.getSystemService(TelephonyManager.class);
+        if (mTelephony != null) {
+            mSubscriptionManager = SubscriptionManager.from(mContext);
+            mSubscriptionManager.addOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
+            updatePhoneStateTrackers();
+        }
+        // Register for DDS changes
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        context.registerReceiver(mIntentReceiver, filter, null, null);
+    }
+
+    private void updatePhoneStateTrackers() {
+        int i = 0;
+        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
+        HashSet<Integer> subIdSet = new HashSet(Arrays.asList(subIds));
+        if (LOGV) {
+            Log.v(TAG, "Register PhoneStateListeners for " + subIdSet);
+        }
+        for (int i2 = 0; i2 < mTrackers.size(); i2++) {
+            if (!subIdSet.contains(Integer.valueOf(mTrackers.keyAt(i2)))) {
+                mTelephony.listen(mTrackers.valueAt(i2), LISTEN_NONE);
+                mTrackers.removeAt(i2);
+            }
+        }
+        int length = subIds.length;
+        while (i < length) {
+            int subId = subIds[i];
+            if (mTrackers.indexOfKey(subId) < 0) {
+                SubscriptionStateTracker tracker = new SubscriptionStateTracker(subId);
+                mTrackers.put(subId, tracker);
+                mTelephony.listen(tracker, LISTEN_SERVICE_STATE
+                        | LISTEN_SIGNAL_STRENGTHS
+                        | LISTEN_DATA_CONNECTION_STATE);
+            }
+            i++;
+        }
+    }
+
+    public void addListener(SubscriptionStateListener listener) {
+        mListeners.add(listener);
+    }
+
+    public void removeListener(SubscriptionStateListener listener) {
+        mListeners.remove(listener);
+    }
+
+    public SubscriptionInfo getActiveSubscriptionInfo(int subId) {
+        return mSubscriptionManager.getActiveSubscriptionInfo(subId);
+    }
+
+    public List<SubscriptionInfo> getActiveSubscriptionInfoList() {
+        return mSubscriptionManager.getActiveSubscriptionInfoList();
+    }
+
+    public String getSimOperatorName(int subId) {
+        return mTelephony.getSimOperatorName(subId);
+    }
+
+    public String getNetworkOperatorName(int subId) {
+        return mTelephony.getNetworkOperatorName(subId);
+    }
+
+    public ServiceState getServiceStateForSubscriber(int subId) {
+        return mTelephony.getServiceStateForSubscriber(subId);
+    }
+
+    public void changeDataSub(int subId) {
+        if (LOGV) {
+            Log.v(TAG, "changeDataSub{" +
+                    "subId='" + subId + '\'' +
+                    ", mChangingToDataSubId=" + mChangingToDataSubId +
+                    '}');
+        }
+        if (mChangingToDataSubId != subId) {
+            mSubscriptionManager.setDefaultDataSubId(subId);
+            for (SubscriptionStateListener subscriptionStateListener : mListeners) {
+                subscriptionStateListener
+                        .onDefaultDataSubscriptionChangeRequested(mChangingToDataSubId, subId);
+            }
+            mChangingToDataSubId = subId;
+        }
+    }
+
+    private void ddsHasChanged(int subId) {
+        if (subId > -1) {
+            for (SubscriptionStateListener subscriptionStateListener : mListeners) {
+                subscriptionStateListener.onDefaultDataSubscriptionChanged(subId);
+            }
+        }
+    }
+
+    private void simStateChanged(int subId, int simState) {
+        if (LOGV) {
+            Log.v(TAG,
+                    "simStateChanged(" + subId + ", " + simState + ")");
+        }
+        for (SubscriptionStateListener subscriptionStateListener : mListeners) {
+            subscriptionStateListener.onSimStateChanged(subId, simState);
+        }
+    }
+
+    public boolean simMissing() {
+        if (mTelephony == null) {
+            return false;
+        }
+        List<SubscriptionInfo> subs = mSubscriptionManager.getActiveSubscriptionInfoList();
+        if (subs != null) {
+            for (SubscriptionInfo sub : subs) {
+                int simState = mTelephony.getSimState(sub.getSimSlotIndex());
+                if (LOGV) {
+                    Log.v(TAG, "getSimState(" + sub.getSubscriptionId() + ") == " + simState);
+                }
+                int subId = sub.getSubscriptionId();
+                boolean isGsm = isGSM(subId);
+                boolean isLte = isLte(subId);
+                if ((isGsm || isLte) && simState != 1) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    // We only care that each slot has a sim
+    public boolean allSimsInserted() {
+        int simSlotCount = mTelephony.getSimCount();
+        for (int i = 0; i < simSlotCount; i++) {
+            int state = mTelephony.getSimState(i);
+            if (state == TelephonyManager.SIM_STATE_ABSENT) {
+                return false;
+            }
+        }
+        return simSlotCount == mSubscriptionManager.getActiveSubscriptionInfoCount();
+    }
+
+    public boolean isGSM(int subId) {
+        return mTelephony.getCurrentPhoneType(subId) == PHONE_TYPE_GSM;
+    }
+
+    public boolean isLte(int subId) {
+        return getLteOnCdmaMode(subId) == LTE_ON_CDMA_TRUE;
+    }
+
+    public int getLteOnCdmaMode(int subId) {
+        if (mTelephony == null || mTelephony.getLteOnCdmaMode(subId) == LTE_ON_CDMA_UNKNOWN) {
+            return SystemProperties.getInt("telephony.lteOnCdmaDevice", LTE_ON_CDMA_UNKNOWN);
+        }
+        return mTelephony.getLteOnCdmaMode(subId);
+    }
+
+    private void logPhoneState(String prefix) {
+        if (LOGV) {
+            Log.v(TAG, prefix + getPhoneState());
+        }
+    }
+
+    private String getPhoneTypeName() {
+        return getPhoneTypeName(mTelephony != null ? mTelephony.getCurrentPhoneType() : -1);
+    }
+
+    private int getMcc() {
+        return mContext.getResources().getConfiguration().mcc;
+    }
+
+    private int getMnc() {
+        return mContext.getResources().getConfiguration().mnc;
+    }
+
+    private String getPhoneTypeName(int phoneType) {
+        StringBuilder sb = new StringBuilder();
+        switch (phoneType) {
+            case PHONE_TYPE_NONE:
+                sb.append("PHONE_TYPE_NONE");
+                break;
+            case PHONE_TYPE_GSM:
+                sb.append("PHONE_TYPE_GSM");
+                break;
+            case PHONE_TYPE_CDMA:
+                sb.append("PHONE_TYPE_CDMA");
+                break;
+            case PHONE_TYPE_SIP:
+                sb.append("PHONE_TYPE_SIP");
+                break;
+        }
+        sb.append("(").append(phoneType).append(")");
+        return sb.toString();
+    }
+
+    private String getNetworkTypeName() {
+        return mTelephony != null ? mTelephony.getNetworkTypeName() : "";
+    }
+
+    private String getSubscriptionSimStateName(int subId) {
+        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
+        if (subInfo == null) {
+            return "SIM_STATE_UNKNOWN";
+        }
+        return mTelephony != null ?
+                getSimStateName(mTelephony.getSimState(subInfo.getSimSlotIndex())) : "";
+    }
+
+    private String getDataStateName() {
+        return mTelephony != null ? getDataStateName(mTelephony.getDataState()) : "";
+    }
+
+    private String getDataStateName(int dataState) {
+        StringBuilder sb = new StringBuilder();
+        switch (dataState) {
+            case DATA_UNKNOWN:
+                sb.append("DATA_UNKNOWN");
+                break;
+            case DATA_DISCONNECTED:
+                sb.append("DATA_DISCONNECTED");
+                break;
+            case DATA_CONNECTING:
+                sb.append("DATA_CONNECTING");
+                break;
+            case DATA_CONNECTED:
+                sb.append("DATA_CONNECTED");
+                break;
+            case DATA_SUSPENDED:
+                sb.append("DATA_SUSPENDED");
+                break;
+        }
+        sb.append("(").append(dataState).append(")");
+        return sb.toString();
+    }
+
+    private String getSimStateName(int simState) {
+        StringBuilder sb = new StringBuilder();
+        switch (simState) {
+            case SIM_STATE_UNKNOWN:
+                sb.append("SIM_STATE_UNKNOWN");
+                break;
+            case SIM_STATE_ABSENT:
+                sb.append("SIM_STATE_ABSENT");
+                break;
+            case SIM_STATE_PIN_REQUIRED:
+                sb.append("SIM_STATE_PIN_REQUIRED");
+                break;
+            case SIM_STATE_PUK_REQUIRED:
+                sb.append("SIM_STATE_PUK_REQUIRED");
+                break;
+            case SIM_STATE_NETWORK_LOCKED:
+                sb.append("SIM_STATE_NETWORK_LOCKED");
+                break;
+            case SIM_STATE_READY:
+                sb.append("SIM_STATE_READY");
+                break;
+            case SIM_STATE_CARD_IO_ERROR:
+                sb.append("SIM_STATE_CARD_IO_ERROR");
+                break;
+        }
+        sb.append("(").append(simState).append(")");
+        return sb.toString();
+    }
+
+    private String getVoiceServiceStateName(int subId) {
+        return getServiceStateName(getVoiceRegState(subId));
+    }
+
+    private String getDataServiceStateName(int subId) {
+        return getServiceStateName(getDataRegState(subId));
+    }
+
+    private int getVoiceRegState(int subId) {
+        SubscriptionStateTracker tracker = mTrackers.get(subId);
+        ServiceState serviceState = tracker != null ? tracker.mServiceState : null;
+        return serviceState != null ? serviceState.getVoiceRegState() : -1;
+    }
+
+    private int getDataRegState(int subId) {
+        SubscriptionStateTracker tracker = mTrackers.get(subId);
+        ServiceState serviceState = tracker != null ? tracker.mServiceState : null;
+        return serviceState != null ? serviceState.getDataRegState() : -1;
+    }
+
+    private String getServiceStateName(int serviceState) {
+        StringBuilder sb = new StringBuilder();
+        switch (serviceState) {
+            case STATE_IN_SERVICE:
+                sb.append("STATE_IN_SERVICE");
+                break;
+            case STATE_OUT_OF_SERVICE:
+                sb.append("STATE_OUT_OF_SERVICE");
+                break;
+            case STATE_EMERGENCY_ONLY:
+                sb.append("STATE_EMERGENCY_ONLY");
+                break;
+            case STATE_POWER_OFF:
+                sb.append("STATE_POWER_OFF");
+                break;
+        }
+        sb.append("(").append(serviceState).append(")");
+        return sb.toString();
+    }
+
+    private String getPhoneState() {
+        StringBuilder states = new StringBuilder();
+        for (int subId : mSubscriptionManager.getActiveSubscriptionIdList()) {
+            states.append(" ").append(getPhoneState(subId));
+        }
+        return getPhoneTypeName() + " \"" + getNetworkTypeName() + "\"" + " mcc" + getMcc() +
+                "mnc" + getMnc() + " " + getDataStateName() + " " + states.toString();
+    }
+
+    private String getPhoneState(int subId) {
+        return "{ " + getSubscriptionSimStateName(subId) + " Voice:"
+                + getVoiceServiceStateName(subId)
+                + " Data:" + getDataServiceStateName(subId) + "  }";
+    }
+
+    public interface SubscriptionStateListener {
+        void onServiceStateChanged(int subId, ServiceState serviceState);
+        void onDataConnectionStateChanged(int subId, int state, int networkType);
+        void onDefaultDataSubscriptionChanged(int subId);
+        void onDefaultDataSubscriptionChangeRequested(int currentSubId, int newSubId);
+        void onSignalStrengthsChanged(int subId, SignalStrength signalStrength);
+        void onSimStateChanged(int subId, int simState);
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/util/SetupWizardUtils.java b/src/org/lineageos/setupwizard/util/SetupWizardUtils.java
new file mode 100644
index 0000000..c1269ca
--- /dev/null
+++ b/src/org/lineageos/setupwizard/util/SetupWizardUtils.java
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2013 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.util;
+
+import static android.app.StatusBarManager.DISABLE_NONE;
+import static android.app.StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
+import static android.app.StatusBarManager.DISABLE_SEARCH;
+import static android.content.Context.MODE_PRIVATE;
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
+import static android.content.pm.PackageManager.DONT_KILL_APP;
+import static android.content.pm.PackageManager.GET_ACTIVITIES;
+import static android.content.pm.PackageManager.GET_RECEIVERS;
+import static android.content.pm.PackageManager.GET_SERVICES;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.KEY_DETECT_CAPTIVE_PORTAL;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.app.StatusBarManager;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.ComponentInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ServiceInfo;
+import android.hardware.fingerprint.FingerprintManager;
+import android.os.Binder;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.net.ConnectivityManager;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.cyanogenmod.setupwizard.BluetoothSetupActivity;
+import com.cyanogenmod.setupwizard.ChooseDataSimActivity;
+import com.cyanogenmod.setupwizard.FingerprintActivity;
+import com.cyanogenmod.setupwizard.MobileDataActivity;
+import com.cyanogenmod.setupwizard.SetupWizardApp;
+import com.cyanogenmod.setupwizard.SimMissingActivity;
+import com.cyanogenmod.setupwizard.WifiSetupActivity;
+import com.cyanogenmod.setupwizard.wizardmanager.WizardManager;
+
+import org.lineageos.internal.util.PackageManagerUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import lineageos.providers.LineageSettings;
+
+public class SetupWizardUtils {
+
+    private static final String TAG = SetupWizardUtils.class.getSimpleName();
+
+    private static final String GMS_PACKAGE = "com.google.android.gms";
+    private static final String GMS_SUW_PACKAGE = "com.google.android.setupwizard";
+    private static final String GMS_TV_SUW_PACKAGE = "com.google.android.tungsten.setupwraith";
+
+    private static final String PROP_BUILD_DATE = "ro.build.date.utc";
+
+    private SetupWizardUtils(){}
+
+    public static SharedPreferences getPrefs(Context context) {
+        return context.getSharedPreferences("SetupWizardPrefs", MODE_PRIVATE);
+    }
+
+    public static boolean isMobileDataEnabled(Context context) {
+        try {
+            TelephonyManager tm = context.getSystemService(TelephonyManager.class);
+            return tm.getDataEnabled();
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    public static void setMobileDataEnabled(Context context, boolean enabled) {
+        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
+        if (tm.isMultiSimEnabled()) {
+            int phoneId = SubscriptionManager.from(context).getDefaultDataPhoneId();
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.MOBILE_DATA + phoneId, enabled ? 1 : 0);
+            int subId = SubscriptionManager.getDefaultDataSubscriptionId();
+            tm.setDataEnabled(subId, enabled);
+        } else {
+            android.provider.Settings.Global.putInt(context.getContentResolver(),
+                    android.provider.Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
+            tm.setDataEnabled(enabled);
+        }
+    }
+
+    public static boolean hasWifi(Context context) {
+        PackageManager packageManager = context.getPackageManager();
+        return packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI);
+    }
+
+    public static boolean hasTelephony(Context context) {
+        PackageManager packageManager = context.getPackageManager();
+        return packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
+    }
+
+    public static boolean isMultiSimDevice(Context context) {
+        TelephonyManager tm =
+                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        return tm.isMultiSimEnabled();
+    }
+
+    public static boolean isRadioReady(Context context, ServiceState state) {
+        final SetupWizardApp setupWizardApp = (SetupWizardApp)context.getApplicationContext();
+        if (setupWizardApp.isRadioReady()) {
+            return true;
+        } else {
+            final boolean ready = state != null
+                    && state.getState() != ServiceState.STATE_POWER_OFF;
+            setupWizardApp.setRadioReady(ready);
+            return ready;
+        }
+
+    }
+
+    public static boolean isOwner() {
+        return UserHandle.myUserId() == 0;
+    }
+
+    public static void disableCaptivePortalDetection(Context context) {
+        Settings.Global.putInt(context.getContentResolver(), KEY_DETECT_CAPTIVE_PORTAL, 0);
+    }
+
+    public static void enableCaptivePortalDetection(Context context) {
+        Settings.Global.putInt(context.getContentResolver(), KEY_DETECT_CAPTIVE_PORTAL, 1);
+    }
+
+    public static void disableStatusBar(Context context) {
+        StatusBarManager statusBarManager = context.getSystemService(StatusBarManager.class);
+        if (statusBarManager != null) {
+            statusBarManager.disable(DISABLE_NOTIFICATION_ALERTS | DISABLE_SEARCH
+            );
+        } else {
+            Log.w(SetupWizardApp.TAG,
+                    "Skip disabling notfications - could not get StatusBarManager");
+        }
+    }
+
+    public static void enableStatusBar(Context context) {
+        StatusBarManager statusBarManager = context.getSystemService(StatusBarManager.class);
+        if(statusBarManager != null) {
+            Log.i(SetupWizardApp.TAG, "Enabling notfications - StatusBarManager");
+            statusBarManager.disable(DISABLE_NONE);
+        } else {
+            Log.i(SetupWizardApp.TAG, "Skip enabling notfications - StatusBarManager is null");
+        }
+    }
+
+    public static boolean hasGMS(Context context) {
+        if (PackageManagerUtils.isAppInstalled(context, GMS_PACKAGE) &&
+                PackageManagerUtils.isAppInstalled(context, GMS_SUW_PACKAGE)) {
+            PackageManager packageManager = context.getPackageManager();
+            if (LOGV) {
+                Log.v(TAG, GMS_SUW_PACKAGE + " state = " +
+                        packageManager.getApplicationEnabledSetting(GMS_SUW_PACKAGE));
+            }
+            return packageManager.getApplicationEnabledSetting(GMS_SUW_PACKAGE) !=
+                    COMPONENT_ENABLED_STATE_DISABLED;
+        }
+        return false;
+    }
+
+    public static boolean isPackageInstalled(Context context, String packageName) {
+        PackageManager pm = context.getPackageManager();
+        try {
+            pm.getPackageInfo(packageName, GET_ACTIVITIES);
+            return true;
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+    }
+
+    public static void finishSetupWizard(Context context) {
+        ContentResolver contentResolver = context.getContentResolver();
+        Settings.Global.putInt(contentResolver,
+                Settings.Global.DEVICE_PROVISIONED, 1);
+        Settings.Secure.putInt(contentResolver,
+                Settings.Secure.USER_SETUP_COMPLETE, 1);
+
+        disableComponent(context, WizardManager.class);
+        disableHome(context);
+        context.sendStickyBroadcastAsUser(
+                new Intent(SetupWizardApp.ACTION_FINISHED),
+                Binder.getCallingUserHandle());
+        disableComponentSets(context, GET_RECEIVERS | GET_SERVICES);
+    }
+
+    public static boolean isEthernetConnected(Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context.
+            getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        return (cm.getActiveNetworkInfo() != null &&
+                cm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_ETHERNET);
+    }
+
+    public static boolean hasLeanback(Context context) {
+        PackageManager packageManager = context.getPackageManager();
+        return packageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
+    }
+
+    public static boolean hasFingerprint(Context context) {
+        FingerprintManager fingerprintManager = (FingerprintManager)
+                context.getSystemService(Context.FINGERPRINT_SERVICE);
+        return fingerprintManager.isHardwareDetected();
+    }
+
+    public static boolean simMissing() {
+        return PhoneMonitor.getInstance().simMissing();
+    }
+
+    public static void disableComponentsForMissingFeatures(Context context) {
+        if (!hasLeanback(context)) {
+            disableComponent(context, BluetoothSetupActivity.class);
+        }
+        if (!hasFingerprint(context)) {
+            disableComponent(context, FingerprintActivity.class);
+        }
+        if (!hasTelephony(context)) {
+            disableComponent(context, MobileDataActivity.class);
+            disableComponent(context, SimMissingActivity.class);
+            disableComponent(context, ChooseDataSimActivity.class);
+        }
+        if (!SetupWizardUtils.isMultiSimDevice(context)) {
+            disableComponent(context, ChooseDataSimActivity.class);
+        } else if (simMissing()) {
+            disableComponent(context, MobileDataActivity.class);
+            disableComponent(context, ChooseDataSimActivity.class);
+        }
+        if (!SetupWizardUtils.hasWifi(context) ||
+            isEthernetConnected(context)) {
+            disableComponent(context, WifiSetupActivity.class);
+        }
+
+        // Google's ATV SUW is shipped as it requires platform signature.
+        // Disable it if GMS is not installed by user.
+        if (hasLeanback(context) &&
+            !PackageManagerUtils.isAppInstalled(context, GMS_PACKAGE)) {
+            disableApplication(context, GMS_TV_SUW_PACKAGE);
+        }
+    }
+
+    public static void disableComponentsForGMS(Context context) {
+        disableComponent(context, WizardManager.class);
+        disableHome(context);
+    }
+
+    public static void disableHome(Context context) {
+        ComponentName homeComponent = getHomeComponent(context);
+        if (homeComponent != null) {
+            setComponentEnabledState(context, homeComponent, COMPONENT_ENABLED_STATE_DISABLED);
+        } else {
+            Log.w(TAG, "Home component not found. Skipping.");
+        }
+    }
+
+    public static ComponentName getHomeComponent(Context context) {
+        Intent intent = new Intent("android.intent.action.MAIN");
+        intent.addCategory("android.intent.category.HOME");
+        intent.setPackage(context.getPackageName());
+        ComponentName comp = intent.resolveActivity(context.getPackageManager());
+        if (SetupWizardApp.LOGV) {
+            Log.v(TAG, "resolveActivity for intent=" + intent + " returns " + comp);
+        }
+        return comp;
+    }
+
+    public static void disableApplication(Context context, String appname) {
+        context.getPackageManager().setApplicationEnabledSetting(appname,
+                COMPONENT_ENABLED_STATE_DISABLED, 0);
+    }
+
+    public static void disableComponentSets(Context context, int flags) {
+        setComponentListEnabledState(context, getComponentSets(context, flags),
+                COMPONENT_ENABLED_STATE_DISABLED);
+    }
+
+    public static void disableComponent(Context context, Class cls) {
+        setComponentEnabledState(context, new ComponentName(context, cls),
+                COMPONENT_ENABLED_STATE_DISABLED);
+    }
+
+    public static void enableComponent(Context context, Class<?> cls) {
+        setComponentEnabledState(context, new ComponentName(context, cls),
+                COMPONENT_ENABLED_STATE_ENABLED);
+    }
+
+    public static void resetComponentSets(Context context, int flags) {
+        setComponentListEnabledState(context, getComponentSets(context, flags),
+                COMPONENT_ENABLED_STATE_DEFAULT);
+    }
+
+    public static void resetComponent(Context context, Class<?> cls) {
+        setComponentEnabledState(context, new ComponentName(context, cls),
+                COMPONENT_ENABLED_STATE_DEFAULT);
+    }
+
+
+    public static void setComponentEnabledState(Context context, ComponentName componentName,
+            int enabledState) {
+        context.getPackageManager().setComponentEnabledSetting(componentName,
+                enabledState, DONT_KILL_APP);
+    }
+
+    public static void setComponentListEnabledState(Context context,
+            List<ComponentName> componentNames, int enabledState) {
+        for (ComponentName componentName : componentNames) {
+            setComponentEnabledState(context, componentName, enabledState);
+        }
+    }
+
+    public static List<ComponentName> getComponentSets(Context context, int flags) {
+        int i = 0;
+        List<ComponentName> componentNames = new ArrayList();
+        try {
+            PackageInfo allInfo = context.getPackageManager()
+                    .getPackageInfo(context.getPackageName(), flags);
+            if (allInfo != null) {
+                if (allInfo.activities != null && (flags & GET_ACTIVITIES) != 0) {
+                    for (ComponentInfo info : allInfo.activities) {
+                        componentNames.add(new ComponentName(context, info.name));
+                    }
+                }
+                if (allInfo.receivers != null && (flags & GET_RECEIVERS) != 0) {
+                    for (ComponentInfo info2 : allInfo.receivers) {
+                        componentNames.add(new ComponentName(context, info2.name));
+                    }
+                }
+                if (allInfo.services != null && (flags & GET_SERVICES) != 0) {
+                    ServiceInfo[] serviceInfoArr = allInfo.services;
+                    int length = serviceInfoArr.length;
+                    while (i < length) {
+                        componentNames.add(new ComponentName(context, serviceInfoArr[i].name));
+                        i++;
+                    }
+                }
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+        }
+        return componentNames;
+    }
+
+
+    public static final ComponentName mTvwifisettingsActivity =
+            new ComponentName("com.android.tv.settings",
+                    "com.android.tv.settings.connectivity.setup.WifiSetupActivity");
+
+    public static final ComponentName mTvAddAccessorySettingsActivity =
+            new ComponentName("com.android.tv.settings",
+                    "com.android.tv.settings.accessories.AddAccessoryActivity");
+
+    public static long getBuildDateTimestamp() {
+        return SystemProperties.getLong(PROP_BUILD_DATE, 0);
+    }
+}
diff --git a/src/org/lineageos/setupwizard/widget/LocalePicker.java b/src/org/lineageos/setupwizard/widget/LocalePicker.java
new file mode 100644
index 0000000..d063687
--- /dev/null
+++ b/src/org/lineageos/setupwizard/widget/LocalePicker.java
@@ -0,0 +1,2607 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.widget;
+
+import com.cyanogenmod.setupwizard.R;
+
+import android.annotation.Widget;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.text.InputFilter;
+import android.text.InputType;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.method.NumberKeyListener;
+import android.util.AttributeSet;
+import android.util.SparseArray;
+import android.util.TypedValue;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityManager;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.view.accessibility.AccessibilityNodeProvider;
+import android.view.animation.DecelerateInterpolator;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.Scroller;
+import android.widget.TextView;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+
+import libcore.icu.LocaleData;
+
+/**
+ * A widget that enables the user to select a number form a predefined range.
+ * There are two flavors of this widget and which one is presented to the user
+ * depends on the current theme.
+ * <ul>
+ * <li>
+ * If the current theme is derived from {@link android.R.style#Theme} the widget
+ * presents the current value as an editable input field with an increment button
+ * above and a decrement button below. Long pressing the buttons allows for a quick
+ * change of the current value. Tapping on the input field allows to type in
+ * a desired value.
+ * </li>
+ * <li>
+ * If the current theme is derived from {@link android.R.style#Theme_Holo} or
+ * {@link android.R.style#Theme_Holo_Light} the widget presents the current
+ * value as an editable input field with a lesser value above and a greater
+ * value below. Tapping on the lesser or greater value selects it by animating
+ * the number axis up or down to make the chosen value current. Flinging up
+ * or down allows for multiple increments or decrements of the current value.
+ * Long pressing on the lesser and greater values also allows for a quick change
+ * of the current value. Tapping on the current value allows to type in a
+ * desired value.
+ * </li>
+ * </ul>
+ * <p>
+ * For an example of using this widget, see {@link android.widget.TimePicker}.
+ * </p>
+ */
+@Widget
+public class LocalePicker extends LinearLayout {
+
+    /**
+     * The number of items show in the selector wheel.
+     */
+    private static int sSelectorWheelItemCount = 3;
+
+    /**
+     * The default update interval during long press.
+     */
+    private static final long DEFAULT_LONG_PRESS_UPDATE_INTERVAL = 300;
+
+    /**
+     * The index of the middle selector item.
+     */
+    private static int sSelectorMiddleItemIndex = sSelectorWheelItemCount / 2;
+
+    /**
+     * The coefficient by which to adjust (divide) the max fling velocity.
+     */
+    private static final int SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT = 8;
+
+    /**
+     * The the duration for adjusting the selector wheel.
+     */
+    private static final int SELECTOR_ADJUSTMENT_DURATION_MILLIS = 800;
+
+    /**
+     * The duration of scrolling while snapping to a given position.
+     */
+    private static final int SNAP_SCROLL_DURATION = 300;
+
+    /**
+     * The strength of fading in the top and bottom while drawing the selector.
+     */
+    private static final float TOP_AND_BOTTOM_FADING_EDGE_STRENGTH = 0.9f;
+
+    /**
+     * The default unscaled height of the selection divider.
+     */
+    private static final int UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT = 1;
+
+    /**
+     * The default unscaled distance between the selection dividers.
+     */
+    private static final int UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE = 48;
+
+    /**
+     * The resource id for the default layout.
+     */
+    private static final int DEFAULT_LAYOUT_RESOURCE_ID =
+            R.layout.locale_picker;
+
+    /**
+     * Constant for unspecified size.
+     */
+    private static final int SIZE_UNSPECIFIED = -1;
+
+    /**
+     * Use a custom NumberPicker formatting callback to use two-digit minutes
+     * strings like "01". Keeping a static formatter etc. is the most efficient
+     * way to do this; it avoids creating temporary objects on every call to
+     * format().
+     */
+    private static class TwoDigitFormatter implements LocalePicker.Formatter {
+        final StringBuilder mBuilder = new StringBuilder();
+
+        char mZeroDigit;
+        java.util.Formatter mFmt;
+
+        final Object[] mArgs = new Object[1];
+
+        TwoDigitFormatter() {
+            final Locale locale = Locale.getDefault();
+            init(locale);
+        }
+
+        private void init(Locale locale) {
+            mFmt = createFormatter(locale);
+            mZeroDigit = getZeroDigit(locale);
+        }
+
+        public String format(int value) {
+            final Locale currentLocale = Locale.getDefault();
+            if (mZeroDigit != getZeroDigit(currentLocale)) {
+                init(currentLocale);
+            }
+            mArgs[0] = value;
+            mBuilder.delete(0, mBuilder.length());
+            mFmt.format("%02d", mArgs);
+            return mFmt.toString();
+        }
+
+        private static char getZeroDigit(Locale locale) {
+            return LocaleData.get(locale).zeroDigit;
+        }
+
+        private java.util.Formatter createFormatter(Locale locale) {
+            return new java.util.Formatter(mBuilder, locale);
+        }
+    }
+
+    private static final TwoDigitFormatter sTwoDigitFormatter = new TwoDigitFormatter();
+
+    /**
+     * @hide
+     */
+    public static final Formatter getTwoDigitFormatter() {
+        return sTwoDigitFormatter;
+    }
+
+    /**
+     * The increment button.
+     */
+    private final ImageButton mIncrementButton;
+
+    /**
+     * The decrement button.
+     */
+    private final ImageButton mDecrementButton;
+
+    /**
+     * The text for showing the current value.
+     */
+    private final EditText mInputText;
+
+    /**
+     * The distance between the two selection dividers.
+     */
+    private final int mSelectionDividersDistance;
+
+    /**
+     * The min height of this widget.
+     */
+    private final int mMinHeight;
+
+    /**
+     * The max height of this widget.
+     */
+    private final int mMaxHeight;
+
+    /**
+     * The max width of this widget.
+     */
+    private final int mMinWidth;
+
+    /**
+     * The max width of this widget.
+     */
+    private int mMaxWidth;
+
+    /**
+     * Flag whether to compute the max width.
+     */
+    private final boolean mComputeMaxWidth;
+
+    /**
+     * The height of the text.
+     */
+    private final int mTextSize;
+
+    /**
+     * The height of the gap between text elements if the selector wheel.
+     */
+    private int mSelectorTextGapHeight;
+
+    /**
+     * The values to be displayed instead the indices.
+     */
+    private String[] mDisplayedValues;
+
+    /**
+     * Lower value of the range of numbers allowed for the NumberPicker
+     */
+    private int mMinValue;
+
+    /**
+     * Upper value of the range of numbers allowed for the NumberPicker
+     */
+    private int mMaxValue;
+
+    /**
+     * Current value of this NumberPicker
+     */
+    private int mValue;
+
+    /**
+     * Listener to be notified upon current value change.
+     */
+    private OnValueChangeListener mOnValueChangeListener;
+
+    /**
+     * Listener to be notified upon scroll state change.
+     */
+    private OnScrollListener mOnScrollListener;
+
+    /**
+     * Formatter for for displaying the current value.
+     */
+    private Formatter mFormatter;
+
+    /**
+     * The speed for updating the value form long press.
+     */
+    private long mLongPressUpdateInterval = DEFAULT_LONG_PRESS_UPDATE_INTERVAL;
+
+    /**
+     * Cache for the string representation of selector indices.
+     */
+    private final SparseArray<String> mSelectorIndexToStringCache = new SparseArray<String>();
+
+    /**
+     * The selector indices whose value are show by the selector.
+     */
+    private final int[] mSelectorIndices;
+
+    /**
+     * The {@link android.graphics.Paint} for drawing the selector.
+     */
+    private final Paint mSelectorWheelPaint;
+
+    /**
+     * The {@link android.graphics.drawable.Drawable} for pressed virtual (increment/decrement) buttons.
+     */
+    private final Drawable mVirtualButtonPressedDrawable;
+
+    /**
+     * The height of a selector element (text + gap).
+     */
+    private int mSelectorElementHeight;
+
+    /**
+     * The initial offset of the scroll selector.
+     */
+    private int mInitialScrollOffset = Integer.MIN_VALUE;
+
+    /**
+     * The current offset of the scroll selector.
+     */
+    private int mCurrentScrollOffset;
+
+    /**
+     * The {@link android.widget.Scroller} responsible for flinging the selector.
+     */
+    private final Scroller mFlingScroller;
+
+    /**
+     * The {@link android.widget.Scroller} responsible for adjusting the selector.
+     */
+    private final Scroller mAdjustScroller;
+
+    /**
+     * The previous Y coordinate while scrolling the selector.
+     */
+    private int mPreviousScrollerY;
+
+    /**
+     * Handle to the reusable command for setting the input text selection.
+     */
+    private SetSelectionCommand mSetSelectionCommand;
+
+    /**
+     * Handle to the reusable command for changing the current value from long
+     * press by one.
+     */
+    private ChangeCurrentByOneFromLongPressCommand mChangeCurrentByOneFromLongPressCommand;
+
+    /**
+     * Command for beginning an edit of the current value via IME on long press.
+     */
+    private BeginSoftInputOnLongPressCommand mBeginSoftInputOnLongPressCommand;
+
+    /**
+     * The Y position of the last down event.
+     */
+    private float mLastDownEventY;
+
+    /**
+     * The time of the last down event.
+     */
+    private long mLastDownEventTime;
+
+    /**
+     * The Y position of the last down or move event.
+     */
+    private float mLastDownOrMoveEventY;
+
+    /**
+     * Determines speed during touch scrolling.
+     */
+    private VelocityTracker mVelocityTracker;
+
+    /**
+     * @see android.view.ViewConfiguration#getScaledTouchSlop()
+     */
+    private int mTouchSlop;
+
+    /**
+     * @see android.view.ViewConfiguration#getScaledMinimumFlingVelocity()
+     */
+    private int mMinimumFlingVelocity;
+
+    /**
+     * @see android.view.ViewConfiguration#getScaledMaximumFlingVelocity()
+     */
+    private int mMaximumFlingVelocity;
+
+    /**
+     * Flag whether the selector should wrap around.
+     */
+    private boolean mWrapSelectorWheel;
+
+    /**
+     * The back ground color used to optimize scroller fading.
+     */
+    private final int mSolidColor;
+
+    /**
+     * Flag whether this widget has a selector wheel.
+     */
+    private final boolean mHasSelectorWheel;
+
+    /**
+     * Divider for showing item to be selected while scrolling
+     */
+    private final Drawable mSelectionDivider;
+
+    /**
+     * The height of the selection divider.
+     */
+    private final int mSelectionDividerHeight;
+
+    /**
+     * The current scroll state of the number picker.
+     */
+    private int mScrollState = OnScrollListener.SCROLL_STATE_IDLE;
+
+    /**
+     * Flag whether to ignore move events - we ignore such when we show in IME
+     * to prevent the content from scrolling.
+     */
+    private boolean mIngonreMoveEvents;
+
+    /**
+     * Flag whether to show soft input on tap.
+     */
+    private boolean mShowSoftInputOnTap;
+
+    /**
+     * The top of the top selection divider.
+     */
+    private int mTopSelectionDividerTop;
+
+    /**
+     * The bottom of the bottom selection divider.
+     */
+    private int mBottomSelectionDividerBottom;
+
+    /**
+     * The virtual id of the last hovered child.
+     */
+    private int mLastHoveredChildVirtualViewId;
+
+    /**
+     * Whether the increment virtual button is pressed.
+     */
+    private boolean mIncrementVirtualButtonPressed;
+
+    /**
+     * Whether the decrement virtual button is pressed.
+     */
+    private boolean mDecrementVirtualButtonPressed;
+
+    /**
+     * Provider to report to clients the semantic structure of this widget.
+     */
+    private AccessibilityNodeProviderImpl mAccessibilityNodeProvider;
+
+    /**
+     * Helper class for managing pressed state of the virtual buttons.
+     */
+    private final PressedStateHelper mPressedStateHelper;
+
+    /**
+     * The keycode of the last handled DPAD down event.
+     */
+    private int mLastHandledDownDpadKeyCode = -1;
+
+    /**
+     * Interface to listen for changes of the current value.
+     */
+    public interface OnValueChangeListener {
+
+        /**
+         * Called upon a change of the current value.
+         *
+         * @param picker The NumberPicker associated with this listener.
+         * @param oldVal The previous value.
+         * @param newVal The new value.
+         */
+        void onValueChange(LocalePicker picker, int oldVal, int newVal);
+    }
+
+    /**
+     * Interface to listen for the picker scroll state.
+     */
+    public interface OnScrollListener {
+
+        /**
+         * The view is not scrolling.
+         */
+        public static int SCROLL_STATE_IDLE = 0;
+
+        /**
+         * The user is scrolling using touch, and his finger is still on the screen.
+         */
+        public static int SCROLL_STATE_TOUCH_SCROLL = 1;
+
+        /**
+         * The user had previously been scrolling using touch and performed a fling.
+         */
+        public static int SCROLL_STATE_FLING = 2;
+
+        /**
+         * Callback invoked while the number picker scroll state has changed.
+         *
+         * @param view The view whose scroll state is being reported.
+         * @param scrollState The current scroll state. One of
+         *            {@link #SCROLL_STATE_IDLE},
+         *            {@link #SCROLL_STATE_TOUCH_SCROLL} or
+         *            {@link #SCROLL_STATE_IDLE}.
+         */
+        public void onScrollStateChange(LocalePicker view, int scrollState);
+    }
+
+    /**
+     * Interface used to format current value into a string for presentation.
+     */
+    public interface Formatter {
+
+        /**
+         * Formats a string representation of the current value.
+         *
+         * @param value The currently selected value.
+         * @return A formatted string representation.
+         */
+        public String format(int value);
+    }
+
+    /**
+     * Create a new number picker.
+     *
+     * @param context The application environment.
+     */
+    public LocalePicker(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * Create a new number picker.
+     *
+     * @param context The application environment.
+     * @param attrs A collection of attributes.
+     */
+    public LocalePicker(Context context, AttributeSet attrs) {
+        this(context, attrs, R.attr.localePickerStyle);
+    }
+
+    /**
+     * Create a new number picker
+     *
+     * @param context the application environment.
+     * @param attrs a collection of attributes.
+     * @param defStyle The default style to apply to this view.
+     */
+    public LocalePicker(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        sSelectorWheelItemCount = context.getResources().getInteger(R.integer.local_picker_items);
+        sSelectorMiddleItemIndex = context.getResources().getInteger(R.integer.local_picker_items)/2;
+        mSelectorIndices= new int[sSelectorWheelItemCount];
+        // process style attributes
+        TypedArray attributesArray = context.obtainStyledAttributes(
+                attrs, R.styleable.LocalePicker, defStyle, 0);
+        final int layoutResId = attributesArray.getResourceId(
+                R.styleable.LocalePicker_internalLayout, DEFAULT_LAYOUT_RESOURCE_ID);
+
+        mHasSelectorWheel = true;
+
+        mSolidColor = attributesArray.getColor(R.styleable.LocalePicker_solidColor, 0);
+
+        mSelectionDivider = attributesArray.getDrawable(R.styleable.LocalePicker_selectionDivider);
+
+        final int defSelectionDividerHeight = (int) TypedValue.applyDimension(
+                TypedValue.COMPLEX_UNIT_DIP, UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT,
+                getResources().getDisplayMetrics());
+        mSelectionDividerHeight = attributesArray.getDimensionPixelSize(
+                R.styleable.LocalePicker_selectionDividerHeight, defSelectionDividerHeight);
+
+        final int defSelectionDividerDistance = (int) TypedValue.applyDimension(
+                TypedValue.COMPLEX_UNIT_DIP, UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE,
+                getResources().getDisplayMetrics());
+        mSelectionDividersDistance = attributesArray.getDimensionPixelSize(
+                R.styleable.LocalePicker_selectionDividersDistance, defSelectionDividerDistance);
+
+        mMinHeight = attributesArray.getDimensionPixelSize(
+                R.styleable.LocalePicker_internalMinHeight, SIZE_UNSPECIFIED);
+
+        mMaxHeight = attributesArray.getDimensionPixelSize(
+                R.styleable.LocalePicker_internalMaxHeight, SIZE_UNSPECIFIED);
+        if (mMinHeight != SIZE_UNSPECIFIED && mMaxHeight != SIZE_UNSPECIFIED
+                && mMinHeight > mMaxHeight) {
+            throw new IllegalArgumentException("minHeight > maxHeight");
+        }
+
+        mMinWidth = attributesArray.getDimensionPixelSize(
+                R.styleable.LocalePicker_internalMinWidth, SIZE_UNSPECIFIED);
+
+        mMaxWidth = attributesArray.getDimensionPixelSize(
+                R.styleable.LocalePicker_internalMaxWidth, SIZE_UNSPECIFIED);
+        if (mMinWidth != SIZE_UNSPECIFIED && mMaxWidth != SIZE_UNSPECIFIED
+                && mMinWidth > mMaxWidth) {
+            throw new IllegalArgumentException("minWidth > maxWidth");
+        }
+
+        mComputeMaxWidth = (mMaxWidth == SIZE_UNSPECIFIED);
+
+        mVirtualButtonPressedDrawable = attributesArray.getDrawable(
+                R.styleable.LocalePicker_virtualButtonPressedDrawable);
+
+        attributesArray.recycle();
+
+        mPressedStateHelper = new PressedStateHelper();
+
+        // By default Linearlayout that we extend is not drawn. This is
+        // its draw() method is not called but dispatchDraw() is called
+        // directly (see ViewGroup.drawChild()). However, this class uses
+        // the fading edge effect implemented by View and we need our
+        // draw() method to be called. Therefore, we declare we will draw.
+        setWillNotDraw(!mHasSelectorWheel);
+
+        LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        inflater.inflate(layoutResId, this, true);
+
+        OnClickListener onClickListener = new OnClickListener() {
+            public void onClick(View v) {
+                hideSoftInput();
+                mInputText.clearFocus();
+                if (v.getId() == R.id.lp__increment) {
+                    changeValueByOne(true);
+                } else {
+                    changeValueByOne(false);
+                }
+            }
+        };
+
+        OnLongClickListener onLongClickListener = new OnLongClickListener() {
+            public boolean onLongClick(View v) {
+                hideSoftInput();
+                mInputText.clearFocus();
+                if (v.getId() == R.id.lp__increment) {
+                    postChangeCurrentByOneFromLongPress(true, 0);
+                } else {
+                    postChangeCurrentByOneFromLongPress(false, 0);
+                }
+                return true;
+            }
+        };
+
+        // increment button
+        if (!mHasSelectorWheel) {
+            mIncrementButton = (ImageButton) findViewById(R.id.lp__increment);
+            mIncrementButton.setOnClickListener(onClickListener);
+            mIncrementButton.setOnLongClickListener(onLongClickListener);
+        } else {
+            mIncrementButton = null;
+        }
+
+        // decrement button
+        if (!mHasSelectorWheel) {
+            mDecrementButton = (ImageButton) findViewById(R.id.lp__decrement);
+            mDecrementButton.setOnClickListener(onClickListener);
+            mDecrementButton.setOnLongClickListener(onLongClickListener);
+        } else {
+            mDecrementButton = null;
+        }
+
+        // input text
+        mInputText = (EditText) findViewById(R.id.localepicker_input);
+        mInputText.setOnFocusChangeListener(new OnFocusChangeListener() {
+            public void onFocusChange(View v, boolean hasFocus) {
+                if (hasFocus) {
+                    mInputText.selectAll();
+                } else {
+                    mInputText.setSelection(0, 0);
+                    validateInputTextView(v);
+                }
+            }
+        });
+        mInputText.setFilters(new InputFilter[] {
+            new InputTextFilter()
+        });
+
+        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
+        mInputText.setImeOptions(EditorInfo.IME_ACTION_DONE);
+
+        // initialize constants
+        ViewConfiguration configuration = ViewConfiguration.get(context);
+        mTouchSlop = configuration.getScaledTouchSlop();
+        mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
+        mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity()
+                / SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT;
+        mTextSize = (int) mInputText.getTextSize();
+
+        // create the selector wheel paint
+        Paint paint = new Paint();
+        paint.setAntiAlias(true);
+        paint.setTextAlign(Align.CENTER);
+        paint.setTextSize(mTextSize);
+        paint.setTypeface(mInputText.getTypeface());
+        ColorStateList colors = mInputText.getTextColors();
+        int color = colors.getColorForState(ENABLED_STATE_SET, Color.WHITE);
+        paint.setColor(color);
+        mSelectorWheelPaint = paint;
+
+        // create the fling and adjust scrollers
+        mFlingScroller = new Scroller(getContext(), null, true);
+        mAdjustScroller = new Scroller(getContext(), new DecelerateInterpolator(2.5f));
+
+        updateInputTextView();
+
+        // If not explicitly specified this view is important for accessibility.
+        if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+            setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        if (!mHasSelectorWheel) {
+            super.onLayout(changed, left, top, right, bottom);
+            return;
+        }
+        final int msrdWdth = getMeasuredWidth();
+        final int msrdHght = getMeasuredHeight();
+
+        // Input text centered horizontally.
+        final int inptTxtMsrdWdth = mInputText.getMeasuredWidth();
+        final int inptTxtMsrdHght = mInputText.getMeasuredHeight();
+        final int inptTxtLeft = (msrdWdth - inptTxtMsrdWdth) / 2;
+        final int inptTxtTop = (msrdHght - inptTxtMsrdHght) / 2;
+        final int inptTxtRight = inptTxtLeft + inptTxtMsrdWdth;
+        final int inptTxtBottom = inptTxtTop + inptTxtMsrdHght;
+        mInputText.layout(inptTxtLeft, inptTxtTop, inptTxtRight, inptTxtBottom);
+
+        if (changed) {
+            // need to do all this when we know our size
+            initializeSelectorWheel();
+            initializeFadingEdges();
+            mTopSelectionDividerTop = (getHeight() - mSelectionDividersDistance) / 2
+                    - mSelectionDividerHeight;
+            mBottomSelectionDividerBottom = mTopSelectionDividerTop + 2 * mSelectionDividerHeight
+                    + mSelectionDividersDistance;
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        if (!mHasSelectorWheel) {
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            return;
+        }
+        // Try greedily to fit the max width and height.
+        final int newWidthMeasureSpec = makeMeasureSpec(widthMeasureSpec, mMaxWidth);
+        final int newHeightMeasureSpec = makeMeasureSpec(heightMeasureSpec, mMaxHeight);
+        super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
+        // Flag if we are measured with width or height less than the respective min.
+        final int widthSize = resolveSizeAndStateRespectingMinSize(mMinWidth, getMeasuredWidth(),
+                widthMeasureSpec);
+        final int heightSize = resolveSizeAndStateRespectingMinSize(mMinHeight, getMeasuredHeight(),
+                heightMeasureSpec);
+        setMeasuredDimension(widthSize, heightSize);
+    }
+
+    /**
+     * Move to the final position of a scroller. Ensures to force finish the scroller
+     * and if it is not at its final position a scroll of the selector wheel is
+     * performed to fast forward to the final position.
+     *
+     * @param scroller The scroller to whose final position to get.
+     * @return True of the a move was performed, i.e. the scroller was not in final position.
+     */
+    private boolean moveToFinalScrollerPosition(Scroller scroller) {
+        scroller.forceFinished(true);
+        int amountToScroll = scroller.getFinalY() - scroller.getCurrY();
+        int futureScrollOffset = (mCurrentScrollOffset + amountToScroll) % mSelectorElementHeight;
+        int overshootAdjustment = mInitialScrollOffset - futureScrollOffset;
+        if (overshootAdjustment != 0) {
+            if (Math.abs(overshootAdjustment) > mSelectorElementHeight / 2) {
+                if (overshootAdjustment > 0) {
+                    overshootAdjustment -= mSelectorElementHeight;
+                } else {
+                    overshootAdjustment += mSelectorElementHeight;
+                }
+            }
+            amountToScroll += overshootAdjustment;
+            scrollBy(0, amountToScroll);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent event) {
+        if (!mHasSelectorWheel || !isEnabled()) {
+            return false;
+        }
+        final int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_DOWN: {
+                removeAllCallbacks();
+                mInputText.setVisibility(View.INVISIBLE);
+                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
+                mLastDownEventTime = event.getEventTime();
+                mIngonreMoveEvents = false;
+                mShowSoftInputOnTap = false;
+                // Handle pressed state before any state change.
+                if (mLastDownEventY < mTopSelectionDividerTop) {
+                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
+                        mPressedStateHelper.buttonPressDelayed(
+                                PressedStateHelper.BUTTON_DECREMENT);
+                    }
+                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
+                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
+                        mPressedStateHelper.buttonPressDelayed(
+                                PressedStateHelper.BUTTON_INCREMENT);
+                    }
+                }
+                // Make sure we support flinging inside scrollables.
+                getParent().requestDisallowInterceptTouchEvent(true);
+                if (!mFlingScroller.isFinished()) {
+                    mFlingScroller.forceFinished(true);
+                    mAdjustScroller.forceFinished(true);
+                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
+                } else if (!mAdjustScroller.isFinished()) {
+                    mFlingScroller.forceFinished(true);
+                    mAdjustScroller.forceFinished(true);
+                } else if (mLastDownEventY < mTopSelectionDividerTop) {
+                    hideSoftInput();
+                    postChangeCurrentByOneFromLongPress(
+                            false, ViewConfiguration.getLongPressTimeout());
+                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
+                    hideSoftInput();
+                    postChangeCurrentByOneFromLongPress(
+                            true, ViewConfiguration.getLongPressTimeout());
+                } else {
+                    mShowSoftInputOnTap = true;
+                    postBeginSoftInputOnLongPressCommand();
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (!isEnabled() || !mHasSelectorWheel) {
+            return false;
+        }
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(event);
+        int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_MOVE: {
+                if (mIngonreMoveEvents) {
+                    break;
+                }
+                float currentMoveY = event.getY();
+                if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
+                    int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
+                    if (deltaDownY > mTouchSlop) {
+                        removeAllCallbacks();
+                        onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
+                    }
+                } else {
+                    int deltaMoveY = (int) ((currentMoveY - mLastDownOrMoveEventY));
+                    scrollBy(0, deltaMoveY);
+                    invalidate();
+                }
+                mLastDownOrMoveEventY = currentMoveY;
+            } break;
+            case MotionEvent.ACTION_UP: {
+                removeBeginSoftInputCommand();
+                removeChangeCurrentByOneFromLongPress();
+                mPressedStateHelper.cancel();
+                VelocityTracker velocityTracker = mVelocityTracker;
+                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
+                int initialVelocity = (int) velocityTracker.getYVelocity();
+                if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
+                    fling(initialVelocity);
+                    onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
+                } else {
+                    int eventY = (int) event.getY();
+                    int deltaMoveY = (int) Math.abs(eventY - mLastDownEventY);
+                    long deltaTime = event.getEventTime() - mLastDownEventTime;
+                    if (deltaMoveY <= mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
+                        if (mShowSoftInputOnTap) {
+                            mShowSoftInputOnTap = false;
+                            showSoftInput();
+                        } else {
+                            int selectorIndexOffset = (eventY / mSelectorElementHeight)
+                                    - sSelectorMiddleItemIndex;
+                            if (selectorIndexOffset > 0) {
+                                changeValueByOne(true);
+                                mPressedStateHelper.buttonTapped(
+                                        PressedStateHelper.BUTTON_INCREMENT);
+                            } else if (selectorIndexOffset < 0) {
+                                changeValueByOne(false);
+                                mPressedStateHelper.buttonTapped(
+                                        PressedStateHelper.BUTTON_DECREMENT);
+                            }
+                        }
+                    } else {
+                        ensureScrollWheelAdjusted();
+                    }
+                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
+                }
+                mVelocityTracker.recycle();
+                mVelocityTracker = null;
+            } break;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean dispatchTouchEvent(MotionEvent event) {
+        final int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                removeAllCallbacks();
+                break;
+        }
+        return super.dispatchTouchEvent(event);
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        final int keyCode = event.getKeyCode();
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                removeAllCallbacks();
+                break;
+            case KeyEvent.KEYCODE_DPAD_DOWN:
+            case KeyEvent.KEYCODE_DPAD_UP:
+                if (!mHasSelectorWheel) {
+                    break;
+                }
+                switch (event.getAction()) {
+                    case KeyEvent.ACTION_DOWN:
+                        if (mWrapSelectorWheel || (keyCode == KeyEvent.KEYCODE_DPAD_DOWN)
+                                ? getValue() < getMaxValue() : getValue() > getMinValue()) {
+                            requestFocus();
+                            mLastHandledDownDpadKeyCode = keyCode;
+                            removeAllCallbacks();
+                            if (mFlingScroller.isFinished()) {
+                                changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
+                            }
+                            return true;
+                        }
+                        break;
+                    case KeyEvent.ACTION_UP:
+                        if (mLastHandledDownDpadKeyCode == keyCode) {
+                            mLastHandledDownDpadKeyCode = -1;
+                            return true;
+                        }
+                        break;
+                }
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    @Override
+    public boolean dispatchTrackballEvent(MotionEvent event) {
+        final int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                removeAllCallbacks();
+                break;
+        }
+        return super.dispatchTrackballEvent(event);
+    }
+
+    @Override
+    protected boolean dispatchHoverEvent(MotionEvent event) {
+        if (!mHasSelectorWheel) {
+            return super.dispatchHoverEvent(event);
+        }
+        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
+            final int eventY = (int) event.getY();
+            final int hoveredVirtualViewId;
+            if (eventY < mTopSelectionDividerTop) {
+                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_DECREMENT;
+            } else if (eventY > mBottomSelectionDividerBottom) {
+                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INCREMENT;
+            } else {
+                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INPUT;
+            }
+            final int action = event.getActionMasked();
+            AccessibilityNodeProviderImpl provider =
+                (AccessibilityNodeProviderImpl) getAccessibilityNodeProvider();
+            switch (action) {
+                case MotionEvent.ACTION_HOVER_ENTER: {
+                    provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
+                            AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
+                    mLastHoveredChildVirtualViewId = hoveredVirtualViewId;
+                    provider.performAction(hoveredVirtualViewId,
+                            AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
+                } break;
+                case MotionEvent.ACTION_HOVER_MOVE: {
+                    if (mLastHoveredChildVirtualViewId != hoveredVirtualViewId
+                            && mLastHoveredChildVirtualViewId != View.NO_ID) {
+                        provider.sendAccessibilityEventForVirtualView(
+                                mLastHoveredChildVirtualViewId,
+                                AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
+                        provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
+                                AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
+                        mLastHoveredChildVirtualViewId = hoveredVirtualViewId;
+                        provider.performAction(hoveredVirtualViewId,
+                                AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
+                    }
+                } break;
+                case MotionEvent.ACTION_HOVER_EXIT: {
+                    provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
+                            AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
+                    mLastHoveredChildVirtualViewId = View.NO_ID;
+                } break;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void computeScroll() {
+        Scroller scroller = mFlingScroller;
+        if (scroller.isFinished()) {
+            scroller = mAdjustScroller;
+            if (scroller.isFinished()) {
+                return;
+            }
+        }
+        scroller.computeScrollOffset();
+        int currentScrollerY = scroller.getCurrY();
+        if (mPreviousScrollerY == 0) {
+            mPreviousScrollerY = scroller.getStartY();
+        }
+        scrollBy(0, currentScrollerY - mPreviousScrollerY);
+        mPreviousScrollerY = currentScrollerY;
+        if (scroller.isFinished()) {
+            onScrollerFinished(scroller);
+        } else {
+            invalidate();
+        }
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        super.setEnabled(enabled);
+        if (!mHasSelectorWheel) {
+            mIncrementButton.setEnabled(enabled);
+        }
+        if (!mHasSelectorWheel) {
+            mDecrementButton.setEnabled(enabled);
+        }
+        mInputText.setEnabled(enabled);
+    }
+
+    @Override
+    public void scrollBy(int x, int y) {
+        int[] selectorIndices = mSelectorIndices;
+        if (!mWrapSelectorWheel && y > 0
+                && selectorIndices[sSelectorMiddleItemIndex] <= mMinValue) {
+            mCurrentScrollOffset = mInitialScrollOffset;
+            return;
+        }
+        if (!mWrapSelectorWheel && y < 0
+                && selectorIndices[sSelectorMiddleItemIndex] >= mMaxValue) {
+            mCurrentScrollOffset = mInitialScrollOffset;
+            return;
+        }
+        mCurrentScrollOffset += y;
+        while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
+            mCurrentScrollOffset -= mSelectorElementHeight;
+            decrementSelectorIndices(selectorIndices);
+            setValueInternal(selectorIndices[sSelectorMiddleItemIndex], true);
+            if (!mWrapSelectorWheel && selectorIndices[sSelectorMiddleItemIndex] <= mMinValue) {
+                mCurrentScrollOffset = mInitialScrollOffset;
+            }
+        }
+        while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
+            mCurrentScrollOffset += mSelectorElementHeight;
+            incrementSelectorIndices(selectorIndices);
+            setValueInternal(selectorIndices[sSelectorMiddleItemIndex], true);
+            if (!mWrapSelectorWheel && selectorIndices[sSelectorMiddleItemIndex] >= mMaxValue) {
+                mCurrentScrollOffset = mInitialScrollOffset;
+            }
+        }
+    }
+
+    @Override
+    public int getSolidColor() {
+        return mSolidColor;
+    }
+
+    /**
+     * Sets the listener to be notified on change of the current value.
+     *
+     * @param onValueChangedListener The listener.
+     */
+    public void setOnValueChangedListener(OnValueChangeListener onValueChangedListener) {
+        mOnValueChangeListener = onValueChangedListener;
+    }
+
+    /**
+     * Set listener to be notified for scroll state changes.
+     *
+     * @param onScrollListener The listener.
+     */
+    public void setOnScrollListener(OnScrollListener onScrollListener) {
+        mOnScrollListener = onScrollListener;
+    }
+
+    /**
+     * Set the formatter to be used for formatting the current value.
+     * <p>
+     * Note: If you have provided alternative values for the values this
+     * formatter is never invoked.
+     * </p>
+     *
+     * @param formatter The formatter object. If formatter is <code>null</code>,
+     *            {@link String#valueOf(int)} will be used.
+     *@see #setDisplayedValues(String[])
+     */
+    public void setFormatter(Formatter formatter) {
+        if (formatter == mFormatter) {
+            return;
+        }
+        mFormatter = formatter;
+        initializeSelectorWheelIndices();
+        updateInputTextView();
+    }
+
+    /**
+     * Set the current value for the number picker.
+     * <p>
+     * If the argument is less than the {@link LocalePicker#getMinValue()} and
+     * {@link LocalePicker#getWrapSelectorWheel()} is <code>false</code> the
+     * current value is set to the {@link LocalePicker#getMinValue()} value.
+     * </p>
+     * <p>
+     * If the argument is less than the {@link LocalePicker#getMinValue()} and
+     * {@link LocalePicker#getWrapSelectorWheel()} is <code>true</code> the
+     * current value is set to the {@link LocalePicker#getMaxValue()} value.
+     * </p>
+     * <p>
+     * If the argument is less than the {@link LocalePicker#getMaxValue()} and
+     * {@link LocalePicker#getWrapSelectorWheel()} is <code>false</code> the
+     * current value is set to the {@link LocalePicker#getMaxValue()} value.
+     * </p>
+     * <p>
+     * If the argument is less than the {@link LocalePicker#getMaxValue()} and
+     * {@link LocalePicker#getWrapSelectorWheel()} is <code>true</code> the
+     * current value is set to the {@link LocalePicker#getMinValue()} value.
+     * </p>
+     *
+     * @param value The current value.
+     * @see #setWrapSelectorWheel(boolean)
+     * @see #setMinValue(int)
+     * @see #setMaxValue(int)
+     */
+    public void setValue(int value) {
+        setValueInternal(value, false);
+    }
+
+    /**
+     * Shows the soft input for its input text.
+     */
+    private void showSoftInput() {
+        InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
+        if (inputMethodManager != null) {
+            if (mHasSelectorWheel) {
+                mInputText.setVisibility(View.VISIBLE);
+            }
+            mInputText.requestFocus();
+            inputMethodManager.showSoftInput(mInputText, 0);
+        }
+    }
+
+    /**
+     * Hides the soft input if it is active for the input text.
+     */
+    private void hideSoftInput() {
+        InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
+        if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
+            inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
+            if (mHasSelectorWheel) {
+                mInputText.setVisibility(View.INVISIBLE);
+            }
+        }
+    }
+
+    /**
+     * Computes the max width if no such specified as an attribute.
+     */
+    private void tryComputeMaxWidth() {
+        if (!mComputeMaxWidth) {
+            return;
+        }
+        int maxTextWidth = 0;
+        if (mDisplayedValues == null) {
+            float maxDigitWidth = 0;
+            for (int i = 0; i <= 9; i++) {
+                final float digitWidth = mSelectorWheelPaint.measureText(formatNumberWithLocale(i));
+                if (digitWidth > maxDigitWidth) {
+                    maxDigitWidth = digitWidth;
+                }
+            }
+            int numberOfDigits = 0;
+            int current = mMaxValue;
+            while (current > 0) {
+                numberOfDigits++;
+                current = current / 10;
+            }
+            maxTextWidth = (int) (numberOfDigits * maxDigitWidth);
+        } else {
+            final int valueCount = mDisplayedValues.length;
+            for (int i = 0; i < valueCount; i++) {
+                final float textWidth = mSelectorWheelPaint.measureText(mDisplayedValues[i]);
+                if (textWidth > maxTextWidth) {
+                    maxTextWidth = (int) textWidth;
+                }
+            }
+        }
+        maxTextWidth += mInputText.getPaddingLeft() + mInputText.getPaddingRight();
+        if (mMaxWidth != maxTextWidth) {
+            if (maxTextWidth > mMinWidth) {
+                mMaxWidth = maxTextWidth;
+            } else {
+                mMaxWidth = mMinWidth;
+            }
+            invalidate();
+        }
+    }
+
+    /**
+     * Gets whether the selector wheel wraps when reaching the min/max value.
+     *
+     * @return True if the selector wheel wraps.
+     *
+     * @see #getMinValue()
+     * @see #getMaxValue()
+     */
+    public boolean getWrapSelectorWheel() {
+        return mWrapSelectorWheel;
+    }
+
+    /**
+     * Sets whether the selector wheel shown during flinging/scrolling should
+     * wrap around the {@link LocalePicker#getMinValue()} and
+     * {@link LocalePicker#getMaxValue()} values.
+     * <p>
+     * By default if the range (max - min) is more than the number of items shown
+     * on the selector wheel the selector wheel wrapping is enabled.
+     * </p>
+     * <p>
+     * <strong>Note:</strong> If the number of items, i.e. the range (
+     * {@link #getMaxValue()} - {@link #getMinValue()}) is less than
+     * the number of items shown on the selector wheel, the selector wheel will
+     * not wrap. Hence, in such a case calling this method is a NOP.
+     * </p>
+     *
+     * @param wrapSelectorWheel Whether to wrap.
+     */
+    public void setWrapSelectorWheel(boolean wrapSelectorWheel) {
+        final boolean wrappingAllowed = (mMaxValue - mMinValue) >= mSelectorIndices.length;
+        if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != mWrapSelectorWheel) {
+            mWrapSelectorWheel = wrapSelectorWheel;
+        }
+    }
+
+    /**
+     * Sets the speed at which the numbers be incremented and decremented when
+     * the up and down buttons are long pressed respectively.
+     * <p>
+     * The default value is 300 ms.
+     * </p>
+     *
+     * @param intervalMillis The speed (in milliseconds) at which the numbers
+     *            will be incremented and decremented.
+     */
+    public void setOnLongPressUpdateInterval(long intervalMillis) {
+        mLongPressUpdateInterval = intervalMillis;
+    }
+
+    /**
+     * Returns the value of the picker.
+     *
+     * @return The value.
+     */
+    public int getValue() {
+        return mValue;
+    }
+
+    /**
+     * Returns the min value of the picker.
+     *
+     * @return The min value
+     */
+    public int getMinValue() {
+        return mMinValue;
+    }
+
+    /**
+     * Sets the min value of the picker.
+     *
+     * @param minValue The min value inclusive.
+     *
+     * <strong>Note:</strong> The length of the displayed values array
+     * set via {@link #setDisplayedValues(String[])} must be equal to the
+     * range of selectable numbers which is equal to
+     * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
+     */
+    public void setMinValue(int minValue) {
+        if (mMinValue == minValue) {
+            return;
+        }
+        if (minValue < 0) {
+            throw new IllegalArgumentException("minValue must be >= 0");
+        }
+        mMinValue = minValue;
+        if (mMinValue > mValue) {
+            mValue = mMinValue;
+        }
+        boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
+        setWrapSelectorWheel(wrapSelectorWheel);
+        initializeSelectorWheelIndices();
+        updateInputTextView();
+        tryComputeMaxWidth();
+        invalidate();
+    }
+
+    /**
+     * Returns the max value of the picker.
+     *
+     * @return The max value.
+     */
+    public int getMaxValue() {
+        return mMaxValue;
+    }
+
+    /**
+     * Sets the max value of the picker.
+     *
+     * @param maxValue The max value inclusive.
+     *
+     * <strong>Note:</strong> The length of the displayed values array
+     * set via {@link #setDisplayedValues(String[])} must be equal to the
+     * range of selectable numbers which is equal to
+     * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
+     */
+    public void setMaxValue(int maxValue) {
+        if (mMaxValue == maxValue) {
+            return;
+        }
+        if (maxValue < 0) {
+            throw new IllegalArgumentException("maxValue must be >= 0");
+        }
+        mMaxValue = maxValue;
+        if (mMaxValue < mValue) {
+            mValue = mMaxValue;
+        }
+        boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
+        setWrapSelectorWheel(wrapSelectorWheel);
+        initializeSelectorWheelIndices();
+        updateInputTextView();
+        tryComputeMaxWidth();
+        invalidate();
+    }
+
+    /**
+     * Gets the values to be displayed instead of string values.
+     *
+     * @return The displayed values.
+     */
+    public String[] getDisplayedValues() {
+        return mDisplayedValues;
+    }
+
+    /**
+     * Sets the values to be displayed.
+     *
+     * @param displayedValues The displayed values.
+     *
+     * <strong>Note:</strong> The length of the displayed values array
+     * must be equal to the range of selectable numbers which is equal to
+     * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
+     */
+    public void setDisplayedValues(String[] displayedValues) {
+        if (mDisplayedValues == displayedValues) {
+            return;
+        }
+        mDisplayedValues = displayedValues;
+        if (mDisplayedValues != null) {
+            // Allow text entry rather than strictly numeric entry.
+            mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT
+                    | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
+        } else {
+            mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
+        }
+        updateInputTextView();
+        initializeSelectorWheelIndices();
+        tryComputeMaxWidth();
+    }
+
+    @Override
+    protected float getTopFadingEdgeStrength() {
+        return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
+    }
+
+    @Override
+    protected float getBottomFadingEdgeStrength() {
+        return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        removeAllCallbacks();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (!mHasSelectorWheel) {
+            super.onDraw(canvas);
+            return;
+        }
+        float x = (mRight - mLeft) / 2;
+        float y = mCurrentScrollOffset;
+
+        // draw the virtual buttons pressed state if needed
+        if (mVirtualButtonPressedDrawable != null
+                && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
+            if (mDecrementVirtualButtonPressed) {
+                mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
+                mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
+                mVirtualButtonPressedDrawable.draw(canvas);
+            }
+            if (mIncrementVirtualButtonPressed) {
+                mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
+                mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight,
+                        mBottom);
+                mVirtualButtonPressedDrawable.draw(canvas);
+            }
+        }
+
+        // draw the selector wheel
+        int[] selectorIndices = mSelectorIndices;
+        for (int i = 0; i < selectorIndices.length; i++) {
+            int selectorIndex = selectorIndices[i];
+            String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
+            // Do not draw the middle item if input is visible since the input
+            // is shown only if the wheel is static and it covers the middle
+            // item. Otherwise, if the user starts editing the text via the
+            // IME he may see a dimmed version of the old value intermixed
+            // with the new one.
+            if (i != sSelectorMiddleItemIndex || mInputText.getVisibility() != VISIBLE) {
+                canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
+            }
+            y += mSelectorElementHeight;
+        }
+
+        // draw the selection dividers
+        if (mSelectionDivider != null) {
+            // draw the top divider
+            int topOfTopDivider = mTopSelectionDividerTop;
+            int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
+            mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
+            mSelectionDivider.draw(canvas);
+
+            // draw the bottom divider
+            int bottomOfBottomDivider = mBottomSelectionDividerBottom;
+            int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
+            mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
+            mSelectionDivider.draw(canvas);
+        }
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(LocalePicker.class.getName());
+        event.setScrollable(true);
+        event.setScrollY((mMinValue + mValue) * mSelectorElementHeight);
+        event.setMaxScrollY((mMaxValue - mMinValue) * mSelectorElementHeight);
+    }
+
+    @Override
+    public AccessibilityNodeProvider getAccessibilityNodeProvider() {
+        if (!mHasSelectorWheel) {
+            return super.getAccessibilityNodeProvider();
+        }
+        if (mAccessibilityNodeProvider == null) {
+            mAccessibilityNodeProvider = new AccessibilityNodeProviderImpl();
+        }
+        return mAccessibilityNodeProvider;
+    }
+
+    /**
+     * Makes a measure spec that tries greedily to use the max value.
+     *
+     * @param measureSpec The measure spec.
+     * @param maxSize The max value for the size.
+     * @return A measure spec greedily imposing the max size.
+     */
+    private int makeMeasureSpec(int measureSpec, int maxSize) {
+        if (maxSize == SIZE_UNSPECIFIED) {
+            return measureSpec;
+        }
+        final int size = MeasureSpec.getSize(measureSpec);
+        final int mode = MeasureSpec.getMode(measureSpec);
+        switch (mode) {
+            case MeasureSpec.EXACTLY:
+                return measureSpec;
+            case MeasureSpec.AT_MOST:
+                return MeasureSpec.makeMeasureSpec(Math.min(size, maxSize), MeasureSpec.EXACTLY);
+            case MeasureSpec.UNSPECIFIED:
+                return MeasureSpec.makeMeasureSpec(maxSize, MeasureSpec.EXACTLY);
+            default:
+                throw new IllegalArgumentException("Unknown measure mode: " + mode);
+        }
+    }
+
+    /**
+     * Utility to reconcile a desired size and state, with constraints imposed
+     * by a MeasureSpec. Tries to respect the min size, unless a different size
+     * is imposed by the constraints.
+     *
+     * @param minSize The minimal desired size.
+     * @param measuredSize The currently measured size.
+     * @param measureSpec The current measure spec.
+     * @return The resolved size and state.
+     */
+    private int resolveSizeAndStateRespectingMinSize(
+            int minSize, int measuredSize, int measureSpec) {
+        if (minSize != SIZE_UNSPECIFIED) {
+            final int desiredWidth = Math.max(minSize, measuredSize);
+            return resolveSizeAndState(desiredWidth, measureSpec, 0);
+        } else {
+            return measuredSize;
+        }
+    }
+
+    /**
+     * Resets the selector indices and clear the cached string representation of
+     * these indices.
+     */
+    private void initializeSelectorWheelIndices() {
+        mSelectorIndexToStringCache.clear();
+        int[] selectorIndices = mSelectorIndices;
+        int current = getValue();
+        for (int i = 0; i < mSelectorIndices.length; i++) {
+            int selectorIndex = current + (i - sSelectorMiddleItemIndex);
+            if (mWrapSelectorWheel) {
+                selectorIndex = getWrappedSelectorIndex(selectorIndex);
+            }
+            selectorIndices[i] = selectorIndex;
+            ensureCachedScrollSelectorValue(selectorIndices[i]);
+        }
+    }
+
+    /**
+     * Sets the current value of this NumberPicker.
+     *
+     * @param current The new value of the NumberPicker.
+     * @param notifyChange Whether to notify if the current value changed.
+     */
+    private void setValueInternal(int current, boolean notifyChange) {
+        if (mValue == current) {
+            return;
+        }
+        // Wrap around the values if we go past the start or end
+        if (mWrapSelectorWheel) {
+            current = getWrappedSelectorIndex(current);
+        } else {
+            current = Math.max(current, mMinValue);
+            current = Math.min(current, mMaxValue);
+        }
+        int previous = mValue;
+        mValue = current;
+        updateInputTextView();
+        if (notifyChange) {
+            notifyChange(previous, current);
+        }
+        initializeSelectorWheelIndices();
+        invalidate();
+    }
+
+    /**
+     * Changes the current value by one which is increment or
+     * decrement based on the passes argument.
+     * decrement the current value.
+     *
+     * @param increment True to increment, false to decrement.
+     */
+     private void changeValueByOne(boolean increment) {
+        if (mHasSelectorWheel) {
+            mInputText.setVisibility(View.INVISIBLE);
+            if (!moveToFinalScrollerPosition(mFlingScroller)) {
+                moveToFinalScrollerPosition(mAdjustScroller);
+            }
+            mPreviousScrollerY = 0;
+            if (increment) {
+                mFlingScroller.startScroll(0, 0, 0, -mSelectorElementHeight, SNAP_SCROLL_DURATION);
+            } else {
+                mFlingScroller.startScroll(0, 0, 0, mSelectorElementHeight, SNAP_SCROLL_DURATION);
+            }
+            invalidate();
+        } else {
+            if (increment) {
+                setValueInternal(mValue + 1, true);
+            } else {
+                setValueInternal(mValue - 1, true);
+            }
+        }
+    }
+
+    private void initializeSelectorWheel() {
+        initializeSelectorWheelIndices();
+        int[] selectorIndices = mSelectorIndices;
+        int totalTextHeight = selectorIndices.length * mTextSize;
+        float totalTextGapHeight = (mBottom - mTop) - totalTextHeight;
+        float textGapCount = selectorIndices.length;
+        mSelectorTextGapHeight = (int) (totalTextGapHeight / textGapCount + 0.5f);
+        mSelectorElementHeight = mTextSize + mSelectorTextGapHeight;
+        // Ensure that the middle item is positioned the same as the text in
+        // mInputText
+        int editTextTextPosition = mInputText.getBaseline() + mInputText.getTop();
+        mInitialScrollOffset = editTextTextPosition
+                - (mSelectorElementHeight * sSelectorMiddleItemIndex);
+        mCurrentScrollOffset = mInitialScrollOffset;
+        updateInputTextView();
+    }
+
+    private void initializeFadingEdges() {
+        setVerticalFadingEdgeEnabled(true);
+        setFadingEdgeLength((mBottom - mTop - mTextSize) / 2);
+    }
+
+    /**
+     * Callback invoked upon completion of a given <code>scroller</code>.
+     */
+    private void onScrollerFinished(Scroller scroller) {
+        if (scroller == mFlingScroller) {
+            if (!ensureScrollWheelAdjusted()) {
+                updateInputTextView();
+            }
+            onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
+        } else {
+            if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
+                updateInputTextView();
+            }
+        }
+    }
+
+    /**
+     * Handles transition to a given <code>scrollState</code>
+     */
+    private void onScrollStateChange(int scrollState) {
+        if (mScrollState == scrollState) {
+            return;
+        }
+        mScrollState = scrollState;
+        if (mOnScrollListener != null) {
+            mOnScrollListener.onScrollStateChange(this, scrollState);
+        }
+    }
+
+    /**
+     * Flings the selector with the given <code>velocityY</code>.
+     */
+    private void fling(int velocityY) {
+        mPreviousScrollerY = 0;
+
+        if (velocityY > 0) {
+            mFlingScroller.fling(0, 0, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
+        } else {
+            mFlingScroller.fling(0, Integer.MAX_VALUE, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
+        }
+
+        invalidate();
+    }
+
+    /**
+     * @return The wrapped index <code>selectorIndex</code> value.
+     */
+    private int getWrappedSelectorIndex(int selectorIndex) {
+        if (selectorIndex > mMaxValue) {
+            return mMinValue + (selectorIndex - mMaxValue) % (mMaxValue - mMinValue) - 1;
+        } else if (selectorIndex < mMinValue) {
+            return mMaxValue - (mMinValue - selectorIndex) % (mMaxValue - mMinValue) + 1;
+        }
+        return selectorIndex;
+    }
+
+    /**
+     * Increments the <code>selectorIndices</code> whose string representations
+     * will be displayed in the selector.
+     */
+    private void incrementSelectorIndices(int[] selectorIndices) {
+        for (int i = 0; i < selectorIndices.length - 1; i++) {
+            selectorIndices[i] = selectorIndices[i + 1];
+        }
+        int nextScrollSelectorIndex = selectorIndices[selectorIndices.length - 2] + 1;
+        if (mWrapSelectorWheel && nextScrollSelectorIndex > mMaxValue) {
+            nextScrollSelectorIndex = mMinValue;
+        }
+        selectorIndices[selectorIndices.length - 1] = nextScrollSelectorIndex;
+        ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
+    }
+
+    /**
+     * Decrements the <code>selectorIndices</code> whose string representations
+     * will be displayed in the selector.
+     */
+    private void decrementSelectorIndices(int[] selectorIndices) {
+        for (int i = selectorIndices.length - 1; i > 0; i--) {
+            selectorIndices[i] = selectorIndices[i - 1];
+        }
+        int nextScrollSelectorIndex = selectorIndices[1] - 1;
+        if (mWrapSelectorWheel && nextScrollSelectorIndex < mMinValue) {
+            nextScrollSelectorIndex = mMaxValue;
+        }
+        selectorIndices[0] = nextScrollSelectorIndex;
+        ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
+    }
+
+    /**
+     * Ensures we have a cached string representation of the given <code>
+     * selectorIndex</code> to avoid multiple instantiations of the same string.
+     */
+    private void ensureCachedScrollSelectorValue(int selectorIndex) {
+        SparseArray<String> cache = mSelectorIndexToStringCache;
+        String scrollSelectorValue = cache.get(selectorIndex);
+        if (scrollSelectorValue != null) {
+            return;
+        }
+        if (selectorIndex < mMinValue || selectorIndex > mMaxValue) {
+            scrollSelectorValue = "";
+        } else {
+            if (mDisplayedValues != null) {
+                int displayedValueIndex = selectorIndex - mMinValue;
+                scrollSelectorValue = mDisplayedValues[displayedValueIndex];
+            } else {
+                scrollSelectorValue = formatNumber(selectorIndex);
+            }
+        }
+        cache.put(selectorIndex, scrollSelectorValue);
+    }
+
+    private String formatNumber(int value) {
+        return (mFormatter != null) ? mFormatter.format(value) : formatNumberWithLocale(value);
+    }
+
+    private void validateInputTextView(View v) {
+        String str = String.valueOf(((TextView) v).getText());
+        if (TextUtils.isEmpty(str)) {
+            // Restore to the old value as we don't allow empty values
+            updateInputTextView();
+        } else {
+            // Check the new value and ensure it's in range
+            int current = getSelectedPos(str.toString());
+            setValueInternal(current, true);
+        }
+    }
+
+    /**
+     * Updates the view of this NumberPicker. If displayValues were specified in
+     * the string corresponding to the index specified by the current value will
+     * be returned. Otherwise, the formatter specified in {@link #setFormatter}
+     * will be used to format the number.
+     *
+     * @return Whether the text was updated.
+     */
+    private boolean updateInputTextView() {
+        /*
+         * If we don't have displayed values then use the current number else
+         * find the correct value in the displayed values for the current
+         * number.
+         */
+        String text = (mDisplayedValues == null) ? formatNumber(mValue)
+                : mDisplayedValues[mValue - mMinValue];
+        if (!TextUtils.isEmpty(text) && !text.equals(mInputText.getText().toString())) {
+            mInputText.setText(text);
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Notifies the listener, if registered, of a change of the value of this
+     * NumberPicker.
+     */
+    private void notifyChange(int previous, int current) {
+        if (mOnValueChangeListener != null) {
+            mOnValueChangeListener.onValueChange(this, previous, mValue);
+        }
+    }
+
+    /**
+     * Posts a command for changing the current value by one.
+     *
+     * @param increment Whether to increment or decrement the value.
+     */
+    private void postChangeCurrentByOneFromLongPress(boolean increment, long delayMillis) {
+        if (mChangeCurrentByOneFromLongPressCommand == null) {
+            mChangeCurrentByOneFromLongPressCommand = new ChangeCurrentByOneFromLongPressCommand();
+        } else {
+            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
+        }
+        mChangeCurrentByOneFromLongPressCommand.setStep(increment);
+        postDelayed(mChangeCurrentByOneFromLongPressCommand, delayMillis);
+    }
+
+    /**
+     * Removes the command for changing the current value by one.
+     */
+    private void removeChangeCurrentByOneFromLongPress() {
+        if (mChangeCurrentByOneFromLongPressCommand != null) {
+            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
+        }
+    }
+
+    /**
+     * Posts a command for beginning an edit of the current value via IME on
+     * long press.
+     */
+    private void postBeginSoftInputOnLongPressCommand() {
+        if (mBeginSoftInputOnLongPressCommand == null) {
+            mBeginSoftInputOnLongPressCommand = new BeginSoftInputOnLongPressCommand();
+        } else {
+            removeCallbacks(mBeginSoftInputOnLongPressCommand);
+        }
+        postDelayed(mBeginSoftInputOnLongPressCommand, ViewConfiguration.getLongPressTimeout());
+    }
+
+    /**
+     * Removes the command for beginning an edit of the current value via IME.
+     */
+    private void removeBeginSoftInputCommand() {
+        if (mBeginSoftInputOnLongPressCommand != null) {
+            removeCallbacks(mBeginSoftInputOnLongPressCommand);
+        }
+    }
+
+    /**
+     * Removes all pending callback from the message queue.
+     */
+    private void removeAllCallbacks() {
+        if (mChangeCurrentByOneFromLongPressCommand != null) {
+            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
+        }
+        if (mSetSelectionCommand != null) {
+            removeCallbacks(mSetSelectionCommand);
+        }
+        if (mBeginSoftInputOnLongPressCommand != null) {
+            removeCallbacks(mBeginSoftInputOnLongPressCommand);
+        }
+        mPressedStateHelper.cancel();
+    }
+
+    /**
+     * @return The selected index given its displayed <code>value</code>.
+     */
+    private int getSelectedPos(String value) {
+        if (mDisplayedValues == null) {
+            try {
+                return Integer.parseInt(value);
+            } catch (NumberFormatException e) {
+                // Ignore as if it's not a number we don't care
+            }
+        } else {
+            for (int i = 0; i < mDisplayedValues.length; i++) {
+                // Don't force the user to type in jan when ja will do
+                value = value.toLowerCase();
+                if (mDisplayedValues[i].toLowerCase().startsWith(value)) {
+                    return mMinValue + i;
+                }
+            }
+
+            /*
+             * The user might have typed in a number into the month field i.e.
+             * 10 instead of OCT so support that too.
+             */
+            try {
+                return Integer.parseInt(value);
+            } catch (NumberFormatException e) {
+
+                // Ignore as if it's not a number we don't care
+            }
+        }
+        return mMinValue;
+    }
+
+    /**
+     * Posts an {@link SetSelectionCommand} from the given <code>selectionStart
+     * </code> to <code>selectionEnd</code>.
+     */
+    private void postSetSelectionCommand(int selectionStart, int selectionEnd) {
+        if (mSetSelectionCommand == null) {
+            mSetSelectionCommand = new SetSelectionCommand();
+        } else {
+            removeCallbacks(mSetSelectionCommand);
+        }
+        mSetSelectionCommand.mSelectionStart = selectionStart;
+        mSetSelectionCommand.mSelectionEnd = selectionEnd;
+        post(mSetSelectionCommand);
+    }
+
+    /**
+     * The numbers accepted by the input text's {@link android.view.LayoutInflater.Filter}
+     */
+    private static final char[] DIGIT_CHARACTERS = new char[] {
+            // Latin digits are the common case
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+            // Arabic-Indic
+            '\u0660', '\u0661', '\u0662', '\u0663', '\u0664', '\u0665', '\u0666', '\u0667', '\u0668'
+            , '\u0669',
+            // Extended Arabic-Indic
+            '\u06f0', '\u06f1', '\u06f2', '\u06f3', '\u06f4', '\u06f5', '\u06f6', '\u06f7', '\u06f8'
+            , '\u06f9'
+    };
+
+    /**
+     * Filter for accepting only valid indices or prefixes of the string
+     * representation of valid indices.
+     */
+    class InputTextFilter extends NumberKeyListener {
+
+        // XXX This doesn't allow for range limits when controlled by a
+        // soft input method!
+        public int getInputType() {
+            return InputType.TYPE_CLASS_TEXT;
+        }
+
+        @Override
+        protected char[] getAcceptedChars() {
+            return DIGIT_CHARACTERS;
+        }
+
+        @Override
+        public CharSequence filter(
+                CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {
+            if (mDisplayedValues == null) {
+                CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
+                if (filtered == null) {
+                    filtered = source.subSequence(start, end);
+                }
+
+                String result = String.valueOf(dest.subSequence(0, dstart)) + filtered
+                        + dest.subSequence(dend, dest.length());
+
+                if ("".equals(result)) {
+                    return result;
+                }
+                int val = getSelectedPos(result);
+
+                /*
+                 * Ensure the user can't type in a value greater than the max
+                 * allowed. We have to allow less than min as the user might
+                 * want to delete some numbers and then type a new number.
+                 * And prevent multiple-"0" that exceeds the length of upper
+                 * bound number.
+                 */
+                if (val > mMaxValue || result.length() > String.valueOf(mMaxValue).length()) {
+                    return "";
+                } else {
+                    return filtered;
+                }
+            } else {
+                CharSequence filtered = String.valueOf(source.subSequence(start, end));
+                if (TextUtils.isEmpty(filtered)) {
+                    return "";
+                }
+                String result = String.valueOf(dest.subSequence(0, dstart)) + filtered
+                        + dest.subSequence(dend, dest.length());
+                String str = String.valueOf(result).toLowerCase();
+                for (String val : mDisplayedValues) {
+                    String valLowerCase = val.toLowerCase();
+                    if (valLowerCase.startsWith(str)) {
+                        postSetSelectionCommand(result.length(), val.length());
+                        return val.subSequence(dstart, val.length());
+                    }
+                }
+                return "";
+            }
+        }
+    }
+
+    /**
+     * Ensures that the scroll wheel is adjusted i.e. there is no offset and the
+     * middle element is in the middle of the widget.
+     *
+     * @return Whether an adjustment has been made.
+     */
+    private boolean ensureScrollWheelAdjusted() {
+        // adjust to the closest value
+        int deltaY = mInitialScrollOffset - mCurrentScrollOffset;
+        if (deltaY != 0) {
+            mPreviousScrollerY = 0;
+            if (Math.abs(deltaY) > mSelectorElementHeight / 2) {
+                deltaY += (deltaY > 0) ? -mSelectorElementHeight : mSelectorElementHeight;
+            }
+            mAdjustScroller.startScroll(0, 0, 0, deltaY, SELECTOR_ADJUSTMENT_DURATION_MILLIS);
+            invalidate();
+            return true;
+        }
+        return false;
+    }
+
+    class PressedStateHelper implements Runnable {
+        public static final int BUTTON_INCREMENT = 1;
+        public static final int BUTTON_DECREMENT = 2;
+
+        private final int MODE_PRESS = 1;
+        private final int MODE_TAPPED = 2;
+
+        private int mManagedButton;
+        private int mMode;
+
+        public void cancel() {
+            mMode = 0;
+            mManagedButton = 0;
+            LocalePicker.this.removeCallbacks(this);
+            if (mIncrementVirtualButtonPressed) {
+                mIncrementVirtualButtonPressed = false;
+                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+            }
+            mDecrementVirtualButtonPressed = false;
+            if (mDecrementVirtualButtonPressed) {
+                invalidate(0, 0, mRight, mTopSelectionDividerTop);
+            }
+        }
+
+        public void buttonPressDelayed(int button) {
+            cancel();
+            mMode = MODE_PRESS;
+            mManagedButton = button;
+            LocalePicker.this.postDelayed(this, ViewConfiguration.getTapTimeout());
+        }
+
+        public void buttonTapped(int button) {
+            cancel();
+            mMode = MODE_TAPPED;
+            mManagedButton = button;
+            LocalePicker.this.post(this);
+        }
+
+        @Override
+        public void run() {
+            switch (mMode) {
+                case MODE_PRESS: {
+                    switch (mManagedButton) {
+                        case BUTTON_INCREMENT: {
+                            mIncrementVirtualButtonPressed = true;
+                            invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                        } break;
+                        case BUTTON_DECREMENT: {
+                            mDecrementVirtualButtonPressed = true;
+                            invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                        }
+                    }
+                } break;
+                case MODE_TAPPED: {
+                    switch (mManagedButton) {
+                        case BUTTON_INCREMENT: {
+                            if (!mIncrementVirtualButtonPressed) {
+                                LocalePicker.this.postDelayed(this,
+                                        ViewConfiguration.getPressedStateDuration());
+                            }
+                            mIncrementVirtualButtonPressed ^= true;
+                            invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                        } break;
+                        case BUTTON_DECREMENT: {
+                            if (!mDecrementVirtualButtonPressed) {
+                                LocalePicker.this.postDelayed(this,
+                                        ViewConfiguration.getPressedStateDuration());
+                            }
+                            mDecrementVirtualButtonPressed ^= true;
+                            invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                        }
+                    }
+                } break;
+            }
+        }
+    }
+
+    /**
+     * Command for setting the input text selection.
+     */
+    class SetSelectionCommand implements Runnable {
+        private int mSelectionStart;
+
+        private int mSelectionEnd;
+
+        public void run() {
+            mInputText.setSelection(mSelectionStart, mSelectionEnd);
+        }
+    }
+
+    /**
+     * Command for changing the current value from a long press by one.
+     */
+    class ChangeCurrentByOneFromLongPressCommand implements Runnable {
+        private boolean mIncrement;
+
+        private void setStep(boolean increment) {
+            mIncrement = increment;
+        }
+
+        @Override
+        public void run() {
+            changeValueByOne(mIncrement);
+            postDelayed(this, mLongPressUpdateInterval);
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public static class CustomEditText extends EditText {
+
+        public CustomEditText(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        @Override
+        public void onEditorAction(int actionCode) {
+            super.onEditorAction(actionCode);
+            if (actionCode == EditorInfo.IME_ACTION_DONE) {
+                clearFocus();
+            }
+        }
+    }
+
+    /**
+     * Command for beginning soft input on long press.
+     */
+    class BeginSoftInputOnLongPressCommand implements Runnable {
+
+        @Override
+        public void run() {
+            showSoftInput();
+            mIngonreMoveEvents = true;
+        }
+    }
+
+    /**
+     * Class for managing virtual view tree rooted at this picker.
+     */
+    class AccessibilityNodeProviderImpl extends AccessibilityNodeProvider {
+        private static final int UNDEFINED = Integer.MIN_VALUE;
+
+        private static final int VIRTUAL_VIEW_ID_INCREMENT = 1;
+
+        private static final int VIRTUAL_VIEW_ID_INPUT = 2;
+
+        private static final int VIRTUAL_VIEW_ID_DECREMENT = 3;
+
+        private final Rect mTempRect = new Rect();
+
+        private final int[] mTempArray = new int[2];
+
+        private int mAccessibilityFocusedView = UNDEFINED;
+
+        @Override
+        public AccessibilityNodeInfo createAccessibilityNodeInfo(int virtualViewId) {
+            switch (virtualViewId) {
+                case View.NO_ID:
+                    return createAccessibilityNodeInfoForNumberPicker( mScrollX, mScrollY,
+                            mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
+                case VIRTUAL_VIEW_ID_DECREMENT:
+                    return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_DECREMENT,
+                            getVirtualDecrementButtonText(), mScrollX, mScrollY,
+                            mScrollX + (mRight - mLeft),
+                            mTopSelectionDividerTop + mSelectionDividerHeight);
+                case VIRTUAL_VIEW_ID_INPUT:
+                    return createAccessibiltyNodeInfoForInputText(mScrollX,
+                            mTopSelectionDividerTop + mSelectionDividerHeight,
+                            mScrollX + (mRight - mLeft),
+                            mBottomSelectionDividerBottom - mSelectionDividerHeight);
+                case VIRTUAL_VIEW_ID_INCREMENT:
+                    return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_INCREMENT,
+                            getVirtualIncrementButtonText(), mScrollX,
+                            mBottomSelectionDividerBottom - mSelectionDividerHeight,
+                            mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
+            }
+            return super.createAccessibilityNodeInfo(virtualViewId);
+        }
+
+        @Override
+        public List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String searched,
+                int virtualViewId) {
+            if (TextUtils.isEmpty(searched)) {
+                return Collections.emptyList();
+            }
+            String searchedLowerCase = searched.toLowerCase();
+            List<AccessibilityNodeInfo> result = new ArrayList<AccessibilityNodeInfo>();
+            switch (virtualViewId) {
+                case View.NO_ID: {
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
+                            VIRTUAL_VIEW_ID_DECREMENT, result);
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
+                            VIRTUAL_VIEW_ID_INPUT, result);
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
+                            VIRTUAL_VIEW_ID_INCREMENT, result);
+                    return result;
+                }
+                case VIRTUAL_VIEW_ID_DECREMENT:
+                case VIRTUAL_VIEW_ID_INCREMENT:
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase, virtualViewId,
+                            result);
+                    return result;
+                }
+            }
+            return super.findAccessibilityNodeInfosByText(searched, virtualViewId);
+        }
+
+        @Override
+        public boolean performAction(int virtualViewId, int action, Bundle arguments) {
+            switch (virtualViewId) {
+                case View.NO_ID: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                requestAccessibilityFocus();
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                clearAccessibilityFocus();
+                                return true;
+                            }
+                            return false;
+                        }
+                        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
+                            if (LocalePicker.this.isEnabled()
+                                    && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
+                                changeValueByOne(true);
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
+                            if (LocalePicker.this.isEnabled()
+                                    && (getWrapSelectorWheel() || getValue() > getMinValue())) {
+                                changeValueByOne(false);
+                                return true;
+                            }
+                        } return false;
+                    }
+                } break;
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_FOCUS: {
+                            if (LocalePicker.this.isEnabled() && !mInputText.isFocused()) {
+                                return mInputText.requestFocus();
+                            }
+                        } break;
+                        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS: {
+                            if (LocalePicker.this.isEnabled() && mInputText.isFocused()) {
+                                mInputText.clearFocus();
+                                return true;
+                            }
+                            return false;
+                        }
+                        case AccessibilityNodeInfo.ACTION_CLICK: {
+                            if (LocalePicker.this.isEnabled()) {
+                                showSoftInput();
+                                return true;
+                            }
+                            return false;
+                        }
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
+                                mInputText.invalidate();
+                                return true;
+                            }
+                        } return false;
+                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
+                                mInputText.invalidate();
+                                return true;
+                            }
+                        } return false;
+                        default: {
+                            return mInputText.performAccessibilityAction(action, arguments);
+                        }
+                    }
+                } return false;
+                case VIRTUAL_VIEW_ID_INCREMENT: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_CLICK: {
+                            if (LocalePicker.this.isEnabled()) {
+                                LocalePicker.this.changeValueByOne(true);
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_CLICKED);
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
+                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                                return true;
+                            }
+                        } return false;
+                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
+                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                                return true;
+                            }
+                        } return false;
+                    }
+                } return false;
+                case VIRTUAL_VIEW_ID_DECREMENT: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_CLICK: {
+                            if (LocalePicker.this.isEnabled()) {
+                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
+                                LocalePicker.this.changeValueByOne(increment);
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_CLICKED);
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
+                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                                return true;
+                            }
+                        } return false;
+                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
+                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                                return true;
+                            }
+                        } return false;
+                    }
+                } return false;
+            }
+            return super.performAction(virtualViewId, action, arguments);
+        }
+
+        public void sendAccessibilityEventForVirtualView(int virtualViewId, int eventType) {
+            switch (virtualViewId) {
+                case VIRTUAL_VIEW_ID_DECREMENT: {
+                    if (hasVirtualDecrementButton()) {
+                        sendAccessibilityEventForVirtualButton(virtualViewId, eventType,
+                                getVirtualDecrementButtonText());
+                    }
+                } break;
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    sendAccessibilityEventForVirtualText(eventType);
+                } break;
+                case VIRTUAL_VIEW_ID_INCREMENT: {
+                    if (hasVirtualIncrementButton()) {
+                        sendAccessibilityEventForVirtualButton(virtualViewId, eventType,
+                                getVirtualIncrementButtonText());
+                    }
+                } break;
+            }
+        }
+
+        private void sendAccessibilityEventForVirtualText(int eventType) {
+            if (AccessibilityManager.getInstance(mContext).isEnabled()) {
+                AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
+                mInputText.onInitializeAccessibilityEvent(event);
+                mInputText.onPopulateAccessibilityEvent(event);
+                event.setSource(LocalePicker.this, VIRTUAL_VIEW_ID_INPUT);
+                requestSendAccessibilityEvent(LocalePicker.this, event);
+            }
+        }
+
+        private void sendAccessibilityEventForVirtualButton(int virtualViewId, int eventType,
+                String text) {
+            if (AccessibilityManager.getInstance(mContext).isEnabled()) {
+                AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
+                event.setClassName(Button.class.getName());
+                event.setPackageName(mContext.getPackageName());
+                event.getText().add(text);
+                event.setEnabled(LocalePicker.this.isEnabled());
+                event.setSource(LocalePicker.this, virtualViewId);
+                requestSendAccessibilityEvent(LocalePicker.this, event);
+            }
+        }
+
+        private void findAccessibilityNodeInfosByTextInChild(String searchedLowerCase,
+                int virtualViewId, List<AccessibilityNodeInfo> outResult) {
+            switch (virtualViewId) {
+                case VIRTUAL_VIEW_ID_DECREMENT: {
+                    String text = getVirtualDecrementButtonText();
+                    if (!TextUtils.isEmpty(text)
+                            && text.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_DECREMENT));
+                    }
+                } return;
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    CharSequence text = mInputText.getText();
+                    if (!TextUtils.isEmpty(text) &&
+                            text.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT));
+                        return;
+                    }
+                    CharSequence contentDesc = mInputText.getText();
+                    if (!TextUtils.isEmpty(contentDesc) &&
+                            contentDesc.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT));
+                        return;
+                    }
+                } break;
+                case VIRTUAL_VIEW_ID_INCREMENT: {
+                    String text = getVirtualIncrementButtonText();
+                    if (!TextUtils.isEmpty(text)
+                            && text.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INCREMENT));
+                    }
+                } return;
+            }
+        }
+
+        private AccessibilityNodeInfo createAccessibiltyNodeInfoForInputText(
+                int left, int top, int right, int bottom) {
+            AccessibilityNodeInfo info = mInputText.createAccessibilityNodeInfo();
+            info.setSource(LocalePicker.this, VIRTUAL_VIEW_ID_INPUT);
+            if (mAccessibilityFocusedView != VIRTUAL_VIEW_ID_INPUT) {
+                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+            }
+            if (mAccessibilityFocusedView == VIRTUAL_VIEW_ID_INPUT) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
+            }
+            Rect boundsInParent = mTempRect;
+            boundsInParent.set(left, top, right, bottom);
+            info.setVisibleToUser(isVisibleToUser(boundsInParent));
+            info.setBoundsInParent(boundsInParent);
+            Rect boundsInScreen = boundsInParent;
+            int[] locationOnScreen = mTempArray;
+            getLocationOnScreen(locationOnScreen);
+            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
+            info.setBoundsInScreen(boundsInScreen);
+            return info;
+        }
+
+        private AccessibilityNodeInfo createAccessibilityNodeInfoForVirtualButton(int virtualViewId,
+                String text, int left, int top, int right, int bottom) {
+            AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
+            info.setClassName(Button.class.getName());
+            info.setPackageName(mContext.getPackageName());
+            info.setSource(LocalePicker.this, virtualViewId);
+            info.setParent(LocalePicker.this);
+            info.setText(text);
+            info.setClickable(true);
+            info.setLongClickable(true);
+            info.setEnabled(LocalePicker.this.isEnabled());
+            Rect boundsInParent = mTempRect;
+            boundsInParent.set(left, top, right, bottom);
+            info.setVisibleToUser(isVisibleToUser(boundsInParent));
+            info.setBoundsInParent(boundsInParent);
+            Rect boundsInScreen = boundsInParent;
+            int[] locationOnScreen = mTempArray;
+            getLocationOnScreen(locationOnScreen);
+            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
+            info.setBoundsInScreen(boundsInScreen);
+
+            if (mAccessibilityFocusedView != virtualViewId) {
+                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+            }
+            if (mAccessibilityFocusedView == virtualViewId) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
+            }
+            if (LocalePicker.this.isEnabled()) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
+            }
+
+            return info;
+        }
+
+        private AccessibilityNodeInfo createAccessibilityNodeInfoForNumberPicker(int left, int top,
+                int right, int bottom) {
+            AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
+            info.setClassName(LocalePicker.class.getName());
+            info.setPackageName(mContext.getPackageName());
+            info.setSource(LocalePicker.this);
+
+            if (hasVirtualDecrementButton()) {
+                info.addChild(LocalePicker.this, VIRTUAL_VIEW_ID_DECREMENT);
+            }
+            info.addChild(LocalePicker.this, VIRTUAL_VIEW_ID_INPUT);
+            if (hasVirtualIncrementButton()) {
+                info.addChild(LocalePicker.this, VIRTUAL_VIEW_ID_INCREMENT);
+            }
+
+            info.setParent((View) getParentForAccessibility());
+            info.setEnabled(LocalePicker.this.isEnabled());
+            info.setScrollable(true);
+
+            final float applicationScale =
+                getContext().getResources().getCompatibilityInfo().applicationScale;
+
+            Rect boundsInParent = mTempRect;
+            boundsInParent.set(left, top, right, bottom);
+            boundsInParent.scale(applicationScale);
+            info.setBoundsInParent(boundsInParent);
+
+            info.setVisibleToUser(isVisibleToUser());
+
+            Rect boundsInScreen = boundsInParent;
+            int[] locationOnScreen = mTempArray;
+            getLocationOnScreen(locationOnScreen);
+            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
+            boundsInScreen.scale(applicationScale);
+            info.setBoundsInScreen(boundsInScreen);
+
+            if (mAccessibilityFocusedView != View.NO_ID) {
+                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+            }
+            if (mAccessibilityFocusedView == View.NO_ID) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
+            }
+            if (LocalePicker.this.isEnabled()) {
+                if (getWrapSelectorWheel() || getValue() < getMaxValue()) {
+                    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
+                }
+                if (getWrapSelectorWheel() || getValue() > getMinValue()) {
+                    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
+                }
+            }
+
+            return info;
+        }
+
+        private boolean hasVirtualDecrementButton() {
+            return getWrapSelectorWheel() || getValue() > getMinValue();
+        }
+
+        private boolean hasVirtualIncrementButton() {
+            return getWrapSelectorWheel() || getValue() < getMaxValue();
+        }
+
+        private String getVirtualDecrementButtonText() {
+            int value = mValue - 1;
+            if (mWrapSelectorWheel) {
+                value = getWrappedSelectorIndex(value);
+            }
+            if (value >= mMinValue) {
+                return (mDisplayedValues == null) ? formatNumber(value)
+                        : mDisplayedValues[value - mMinValue];
+            }
+            return null;
+        }
+
+        private String getVirtualIncrementButtonText() {
+            int value = mValue + 1;
+            if (mWrapSelectorWheel) {
+                value = getWrappedSelectorIndex(value);
+            }
+            if (value <= mMaxValue) {
+                return (mDisplayedValues == null) ? formatNumber(value)
+                        : mDisplayedValues[value - mMinValue];
+            }
+            return null;
+        }
+    }
+
+    static private String formatNumberWithLocale(int value) {
+        return String.format(Locale.getDefault(), "%d", value);
+    }
+}
diff --git a/src/org/lineageos/setupwizard/widget/ScrimInsetsFrameLayout.java b/src/org/lineageos/setupwizard/widget/ScrimInsetsFrameLayout.java
new file mode 100644
index 0000000..662e3a8
--- /dev/null
+++ b/src/org/lineageos/setupwizard/widget/ScrimInsetsFrameLayout.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.widget;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.support.v4.view.ViewCompat;
+import android.util.AttributeSet;
+import android.widget.FrameLayout;
+
+import com.cyanogenmod.setupwizard.R;
+
+/**
+ * A layout that draws something in the insets passed to {@link #fitSystemWindows(android.graphics.Rect)}, i.e. the area above UI chrome
+ * (status and navigation bars, overlay action bars).
+ */
+public class ScrimInsetsFrameLayout extends FrameLayout {
+    private Drawable mInsetForeground;
+
+    private Rect mInsets;
+    private Rect mTempRect = new Rect();
+    private OnInsetsCallback mOnInsetsCallback;
+
+    public ScrimInsetsFrameLayout(Context context) {
+        super(context);
+        init(context, null, 0);
+    }
+
+    public ScrimInsetsFrameLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context, attrs, 0);
+    }
+
+    public ScrimInsetsFrameLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context, attrs, defStyle);
+    }
+
+    private void init(Context context, AttributeSet attrs, int defStyle) {
+        final TypedArray a = context.obtainStyledAttributes(attrs,
+                R.styleable.ScrimInsetsView, defStyle, 0);
+        if (a == null) {
+            return;
+        }
+        mInsetForeground = a.getDrawable(R.styleable.ScrimInsetsView_insetForeground);
+        a.recycle();
+
+        setWillNotDraw(true);
+    }
+
+    @Override
+    protected boolean fitSystemWindows(Rect insets) {
+        mInsets = new Rect(insets);
+        setWillNotDraw(mInsetForeground == null);
+        ViewCompat.postInvalidateOnAnimation(this);
+        if (mOnInsetsCallback != null) {
+            mOnInsetsCallback.onInsetsChanged(insets);
+        }
+        return true; // consume insets
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        super.draw(canvas);
+
+        int width = getWidth();
+        int height = getHeight();
+        if (mInsets != null && mInsetForeground != null) {
+            int sc = canvas.save();
+            canvas.translate(getScrollX(), getScrollY());
+
+            // Top
+            mTempRect.set(0, 0, width, mInsets.top);
+            mInsetForeground.setBounds(mTempRect);
+            mInsetForeground.draw(canvas);
+
+            // Bottom
+            mTempRect.set(0, height - mInsets.bottom, width, height);
+            mInsetForeground.setBounds(mTempRect);
+            mInsetForeground.draw(canvas);
+
+            // Left
+            mTempRect.set(0, mInsets.top, mInsets.left, height - mInsets.bottom);
+            mInsetForeground.setBounds(mTempRect);
+            mInsetForeground.draw(canvas);
+
+            // Right
+            mTempRect.set(width - mInsets.right, mInsets.top, width, height - mInsets.bottom);
+            mInsetForeground.setBounds(mTempRect);
+            mInsetForeground.draw(canvas);
+
+            canvas.restoreToCount(sc);
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (mInsetForeground != null) {
+            mInsetForeground.setCallback(this);
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (mInsetForeground != null) {
+            mInsetForeground.setCallback(null);
+        }
+    }
+
+    /**
+     * Allows the calling container to specify a callback for custom processing when insets change (i.e. when
+     * {@link #fitSystemWindows(android.graphics.Rect)} is called. This is useful for setting padding on UI elements based on
+     * UI chrome insets (e.g. a Google Map or a ListView). When using with ListView or GridView, remember to set
+     * clipToPadding to false.
+     */
+    public void setOnInsetsCallback(OnInsetsCallback onInsetsCallback) {
+        mOnInsetsCallback = onInsetsCallback;
+    }
+
+    public static interface OnInsetsCallback {
+        public void onInsetsChanged(Rect insets);
+    }
+}
\ No newline at end of file
diff --git a/src/org/lineageos/setupwizard/wizardmanager/WizardAction.java b/src/org/lineageos/setupwizard/wizardmanager/WizardAction.java
new file mode 100644
index 0000000..903d58f
--- /dev/null
+++ b/src/org/lineageos/setupwizard/wizardmanager/WizardAction.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.wizardmanager;
+
+import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.content.Intent;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import com.android.internal.util.XmlUtils;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.net.URISyntaxException;
+
+public class WizardAction implements Parcelable {
+
+    private static final String TAG = "WizardAction";
+
+    private final String mId;
+    private final String mUri;
+    private final WizardTransitions mTransitions;
+
+    public WizardAction(String id, String uri, WizardTransitions transitions) {
+        if (transitions == null) {
+            throw new IllegalArgumentException("WizardTransitions cannot be null");
+        }
+        mId = id;
+        mUri = uri;
+        mTransitions = transitions;
+    }
+
+    public String getId() {
+        return mId;
+    }
+
+    public String getUri() {
+        return mUri;
+    }
+
+    public Intent getIntent() {
+        Intent intent = null;
+        try {
+            intent = Intent.parseUri(mUri, FLAG_GRANT_READ_URI_PERMISSION);
+        } catch(URISyntaxException e) {
+            Log.e(TAG, "Bad URI: " + mUri);
+        }
+        return intent;
+    }
+
+    public String getNextAction(int resultCode) {
+        return mTransitions.getAction(resultCode);
+    }
+
+    @Override
+    public String toString() {
+        return "WizardAction{" +
+                "mId='" + mId + '\'' +
+                ", mUri='" + mUri + '\'' +
+                ", mTransitions=" + mTransitions +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof WizardAction)) return false;
+
+        WizardAction that = (WizardAction) o;
+
+        if (mId != null ? !mId.equals(that.mId) : that.mId != null) return false;
+        if (mUri != null ? !mUri.equals(that.mUri) : that.mUri != null) return false;
+        return mTransitions != null ?
+                mTransitions.equals(that.mTransitions) :
+                that.mTransitions == null;
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = mId != null ? mId.hashCode() : 0;
+        result = 31 * result + (mUri != null ? mUri.hashCode() : 0);
+        result = 31 * result + (mTransitions != null ? mTransitions.hashCode() : 0);
+        return result;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mUri);
+        dest.writeString(mId);
+        dest.writeParcelable(mTransitions, flags);
+    }
+
+    public static final Creator<WizardAction> CREATOR = new Creator<WizardAction>() {
+        public WizardAction createFromParcel(Parcel source) {
+            return new WizardAction(source.readString(),
+                    source.readString(),
+                    source.readParcelable(WizardTransitions.class.getClassLoader()));
+        }
+
+        public WizardAction[] newArray(int size) {
+            return new WizardAction[size];
+        }
+    };
+
+    private static void parseResult(WizardTransitions transitions, XmlPullParser parser) {
+        String resultCode = parser.getAttributeValue(WizardScript.WIZARD_SCRIPT_NAMESPACE,
+                WizardScript.ATTR_RESULT_CODE);
+        String action = parser.getAttributeValue(WizardScript.WIZARD_SCRIPT_NAMESPACE,
+                WizardScript.ATTR_ACTION);
+        if (LOGV) {
+            Log.v(TAG, "parseResult{" +
+                    "resultCode='" + resultCode + '\'' +
+                    ", action=" + action +
+                    '}');
+        }
+        if (resultCode == null) {
+            transitions.setDefaultAction(action);
+        } else {
+            transitions.put(Integer.valueOf(resultCode).intValue(), action);
+        }
+    }
+
+    public static WizardAction parseWizardAction(XmlPullParser parser) throws XmlPullParserException,
+            IOException {
+        String id = parser.getAttributeValue(null, WizardScript.ATTR_ID);
+        String uri = parser.getAttributeValue(WizardScript.WIZARD_SCRIPT_NAMESPACE,
+                WizardScript.ATTR_URI);
+        WizardTransitions transitions = new WizardTransitions();
+        if (id == null) {
+            throw new XmlPullParserException("WizardAction must define an id");
+        }
+
+        if (uri == null) {
+            throw new XmlPullParserException("WizardAction must define an intent URI");
+        }
+        if (LOGV) {
+            Log.v(TAG, "parseWizardAction{" +
+                    "id='" + id + '\'' +
+                    ", uri=" + uri +
+                    '}');
+        }
+        int type;
+        final int depth = parser.getDepth();
+        while (((type = parser.next()) != XmlPullParser.END_TAG ||
+                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
+            if (!(type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT)) {
+                if (parser.getName().equals(WizardScript.TAG_RESULT)) {
+                    parseResult(transitions, parser);
+                } else {
+                    XmlUtils.skipCurrentTag(parser);
+                }
+            }
+        }
+
+        return new WizardAction(id, uri, transitions);
+    }
+}
diff --git a/src/org/lineageos/setupwizard/wizardmanager/WizardManager.java b/src/org/lineageos/setupwizard/wizardmanager/WizardManager.java
new file mode 100644
index 0000000..a3363cd
--- /dev/null
+++ b/src/org/lineageos/setupwizard/wizardmanager/WizardManager.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.wizardmanager;
+
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_LOAD;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.ACTION_NEXT;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_ACTION_ID;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_FIRST_RUN;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_RESULT_CODE;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.EXTRA_SCRIPT_URI;
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import com.android.setupwizardlib.util.ResultCodes;
+import com.android.setupwizardlib.util.WizardManagerHelper;
+
+import com.cyanogenmod.setupwizard.util.SetupWizardUtils;
+
+import android.annotation.Nullable;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.util.Log;
+
+import java.util.HashMap;
+
+
+public class WizardManager extends Activity {
+
+    private static final String TAG = WizardManager.class.getSimpleName();
+
+    private static HashMap<String, WizardScript> sWizardScripts = new HashMap();
+
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (LOGV) {
+            Log.v(TAG, "onCreate savedInstanceState=" + savedInstanceState);
+        }
+        Intent intent = this.getIntent();
+        if (intent != null) {
+            String action = intent.getAction();
+            int resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, 0);
+            String scriptUri = intent.getStringExtra(EXTRA_SCRIPT_URI);
+            String actionId = intent.getStringExtra(EXTRA_ACTION_ID);
+            if (LOGV) {
+                Log.v(TAG, "  action=" + action + " resultCode=" + resultCode + " scriptUri="
+                        + scriptUri + " actionId=" + actionId + " extras=" + intent.getExtras());
+            }
+
+            if (ACTION_LOAD.equals(action)) {
+                load(scriptUri, intent);
+                finish();
+                return;
+            }
+
+            if (ACTION_NEXT.equals(action)) {
+                next(scriptUri, actionId, resultCode, intent);
+                finish();
+                return;
+            }
+
+            Log.e(TAG, "ERROR: Unknown action");
+        } else {
+            Log.e(TAG, "ERROR: Intent not available");
+        }
+        finish();
+    }
+
+    private void addExtras(Intent intent) {
+        intent.putExtra(WizardManagerHelper.EXTRA_USE_IMMERSIVE_MODE, true);
+        intent.putExtra(EXTRA_FIRST_RUN, true);
+        intent.putExtra(WizardManagerHelper.EXTRA_THEME, WizardManagerHelper.THEME_MATERIAL_LIGHT);
+    }
+
+    private void doAction(String scriptUri, WizardAction action, Intent extras) {
+        Intent intent = action.getIntent();
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        if(LOGV) {
+            Log.v(TAG, "doAction scriptUri=" + scriptUri + " extras=" + extras
+                    + " intent=" + intent + " extras2=" + intent.getExtras() + " action=" + action);
+        }
+
+        addExtras(intent);
+        if(extras != null) {
+            intent.putExtras(extras);
+        }
+
+        intent.putExtra(EXTRA_SCRIPT_URI, scriptUri);
+        intent.putExtra(EXTRA_ACTION_ID, action.getId());
+        startActivity(intent);
+    }
+
+    private void load(String scriptUri, Intent extras) {
+        WizardScript wizardScript = getWizardScript(this, scriptUri);
+        WizardAction wizardAction;
+        for(wizardAction = wizardScript.getFirstAction();
+            wizardAction != null;
+            wizardAction = wizardScript.getNextAction(wizardAction.getId(),
+                    ResultCodes.RESULT_ACTIVITY_NOT_FOUND)) {
+            if (isActionAvailable(this, wizardAction)) {
+                break;
+            }
+
+            if(LOGV) {
+                Log.v(TAG, "load action not available " + wizardAction);
+            }
+        }
+
+        if (wizardAction != null) {
+            doAction(scriptUri, wizardAction, extras);
+        } else {
+            Log.e(TAG, "load could not resolve first action scriptUri=" +
+                    scriptUri + " actionId=" + wizardScript.getFirstActionId());
+            exit(scriptUri);
+        }
+    }
+
+    private void next(String scriptUri, String actionId, int resultCode, Intent extras) {
+        if(LOGV) {
+            Log.v(TAG, "next actionId=" + actionId + " resultCode=" + resultCode);
+        }
+        WizardAction wizardAction = checkNextAction(this, scriptUri,
+                actionId, resultCode);
+        if (wizardAction != null) {
+            doAction(scriptUri, wizardAction, extras);
+        }  else {
+            exit(scriptUri);
+        }
+    }
+
+    private void exit(String scriptUri) {
+        if(LOGV) {
+            Log.v(TAG, "exit scriptUri=" + scriptUri);
+        }
+        WizardManager.sWizardScripts.remove(scriptUri);
+        SetupWizardUtils.disableComponent(this, WizardManager.class);
+    }
+
+    private static WizardAction checkNextAction(Context context, String scriptUri, String actionId,
+            int resultCode) {
+        if(LOGV) {
+            Log.v(TAG, "checkNextAction scriptUri=" + scriptUri + " actionId="
+                    + actionId + " resultCode=" + resultCode);
+        }
+
+        WizardScript wizardScript = getWizardScript(context, scriptUri);
+        WizardAction wizardAction;
+        for ( wizardAction = wizardScript.getNextAction(actionId, resultCode);
+             wizardAction != null;
+             wizardAction = wizardScript.getNextAction(wizardAction.getId(),
+                     ResultCodes.RESULT_ACTIVITY_NOT_FOUND)) {
+            if (WizardManager.isActionAvailable(context, wizardAction)) {
+                break;
+            }
+
+            if(LOGV) {
+                Log.v(TAG, "checkNextAction action not available " + wizardAction);
+            }
+        }
+
+        if (LOGV) {
+            Log.v(TAG, "checkNextAction action=" + wizardAction);
+        }
+
+        return wizardAction;
+    }
+
+    private static boolean isActionAvailable(Context context, WizardAction action) {
+        return isIntentAvailable(context, action.getIntent());
+    }
+
+    private static boolean isIntentAvailable(Context context, Intent intent) {
+        if (context.getPackageManager().queryIntentActivities(intent,
+                PackageManager.MATCH_DEFAULT_ONLY).size() > 0) {
+            return true;
+        }
+        return false;
+    }
+
+    private static WizardScript getWizardScript(Context context, String scriptUri) {
+        WizardScript wizardScript = sWizardScripts.get(scriptUri);
+        if (wizardScript == null) {
+            wizardScript = WizardScript.loadFromUri(context, scriptUri);
+            sWizardScripts.put(scriptUri, wizardScript);
+        }
+        return wizardScript;
+    }
+
+}
diff --git a/src/org/lineageos/setupwizard/wizardmanager/WizardScript.java b/src/org/lineageos/setupwizard/wizardmanager/WizardScript.java
new file mode 100644
index 0000000..9e93618
--- /dev/null
+++ b/src/org/lineageos/setupwizard/wizardmanager/WizardScript.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.wizardmanager;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import com.android.internal.util.XmlUtils;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+import android.util.Xml;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class WizardScript implements Parcelable {
+
+    private static final String TAG = "WizardScript";
+
+    static final String WIZARD_SCRIPT_NAMESPACE =
+            "http://schemas.android.com/apk/res/com.google.android.setupwizard";
+
+    public static final String TAG_WIZARD_SCRIPT = "WizardScript";
+    public static final String TAG_WIZARD_ACTION = "WizardAction";
+    public static final String TAG_RESULT = "result";
+    public static final String ATTR_ID = "id";
+    public static final String ATTR_URI = "uri";
+    public static final String ATTR_ACTION = "action";
+    public static final String ATTR_FIRST_ACTION = "firstAction";
+    public static final String ATTR_RESULT_CODE = "resultCode";
+
+    private final Map<String, WizardAction> mActions;
+    private final String mFirstActionId;
+
+    public WizardScript(Map<String, WizardAction> actions, String firstActionId) {
+        mActions = Collections.unmodifiableMap(actions);
+        mFirstActionId = firstActionId;
+    }
+
+    public WizardAction getAction(String actionId) {
+        return mActions.get(actionId);
+    }
+
+    public WizardAction getFirstAction() {
+        return getAction(mFirstActionId);
+    }
+
+    public String getFirstActionId() {
+        return mFirstActionId;
+    }
+
+    public WizardAction getNextAction(String currentActionId, int resultCode) {
+        WizardAction wizardAction = null;
+        String nextActionId = getNextActionId(currentActionId, resultCode);
+        if (nextActionId != null) {
+            wizardAction = getAction(nextActionId);
+        }
+        return wizardAction;
+    }
+
+    public String getNextActionId(String currentActionId, int resultCode) {
+        String nextActionId = null;
+        if(resultCode != Activity.RESULT_CANCELED) {
+            WizardAction wizardAction = mActions.get(currentActionId);
+            if (LOGV) {
+                StringBuilder currentAction =
+                        new StringBuilder().append("getNextActionId(").append(currentActionId)
+                        .append(",").append(resultCode).append(")").append(" current uri=");
+                String uri = wizardAction == null ? "n/a" : wizardAction.getUri();
+                Log.v(TAG, currentAction.append(uri).toString());
+            }
+            nextActionId = wizardAction.getNextAction(resultCode);
+        } else {
+            if (LOGV) {
+                Log.v(TAG, "getNextActionId(" + currentActionId + "," + resultCode
+                        + ")" + " RESULT_CANCELED not expected; ignored");
+            }
+        }
+        return nextActionId;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(this.mFirstActionId);
+        dest.writeTypedList(new ArrayList(this.mActions.values()));
+    }
+
+    public static final Creator<WizardScript> CREATOR = new Creator<WizardScript>() {
+        public WizardScript createFromParcel(Parcel source) {
+            String firstActionId = source.readString();
+            HashMap<String, WizardAction> actions = new HashMap();
+            ArrayList<WizardAction> actionList = new ArrayList();
+            source.readTypedList(actionList, WizardAction.CREATOR);
+            for (WizardAction action : actionList) {
+                actions.put(action.getId(), action);
+            }
+            return new WizardScript(actions, firstActionId);
+        }
+
+        public WizardScript[] newArray(int size) {
+            return new WizardScript[size];
+        }
+    };
+
+    public static WizardScript loadFromUri(Context context, String uriString) {
+        XmlPullParser xmlPullParser;
+        WizardScript wizardScript = null;
+        try {
+            ContentResolver.OpenResourceIdResult openResourceIdResult =
+                    context.getContentResolver().getResourceId(Uri
+                    .parse(uriString));
+            if("xml".equals(openResourceIdResult.r.getResourceTypeName(openResourceIdResult.id))) {
+                xmlPullParser =
+                        openResourceIdResult.r.getXml(openResourceIdResult.id);
+            } else {
+                InputStream inputStream =
+                        openResourceIdResult.r.openRawResource(openResourceIdResult.id);
+                xmlPullParser = Xml.newPullParser();
+                xmlPullParser.setInput(inputStream, null);
+            }
+
+            int next;
+            do {
+                next = xmlPullParser.next();
+                if (next == XmlPullParser.END_DOCUMENT) {
+                    break;
+                }
+            }
+            while (next != XmlPullParser.START_TAG);
+
+            return parseWizardScript(xmlPullParser);
+        } catch (XmlPullParserException e) {
+            Log.e(TAG, "Ill-formatted wizard_script: " + uriString);
+            Log.e(TAG, e.getMessage());
+            return wizardScript;
+        } catch(FileNotFoundException fnfe) {
+            Log.e(TAG, "Cannot find file: " + uriString);
+            Log.e(TAG, fnfe.getMessage());
+            return wizardScript;
+        } catch(IOException ioe) {
+            Log.e(TAG, "Unable to read wizard_script: " + uriString);
+            Log.e(TAG, ioe.getMessage());
+            return wizardScript;
+        }
+    }
+
+    private static WizardScript parseWizardScript(XmlPullParser parser)
+            throws XmlPullParserException, IOException {
+        String startTag = parser.getName();
+        if(!TAG_WIZARD_SCRIPT.equals(startTag)) {
+            throw new XmlPullParserException("XML document must start with " +
+                    "<WizardScript> tag; found "
+                    + startTag + " at " + parser.getPositionDescription());
+        }
+
+        String firstAction = parser.getAttributeValue(WIZARD_SCRIPT_NAMESPACE, ATTR_FIRST_ACTION);
+        if(firstAction == null) {
+            throw new XmlPullParserException("WizardScript must define a firstAction");
+        }
+
+        HashMap wizardActions = new HashMap();
+        int type;
+        final int depth = parser.getDepth();
+        while (((type = parser.next()) != XmlPullParser.END_TAG ||
+                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
+            final int next = parser.next();
+            if (next != XmlPullParser.END_TAG || next != XmlPullParser.TEXT) {
+                if (TAG_WIZARD_ACTION.equals(parser.getName())) {
+                    WizardAction action = WizardAction.parseWizardAction(parser);
+                    if (action != null) {
+                        wizardActions.put(action.getId(), action);
+                    }
+                } else {
+                    XmlUtils.skipCurrentTag(parser);
+                }
+            }
+        }
+
+        return new WizardScript(wizardActions, firstAction);
+    }
+}
diff --git a/src/org/lineageos/setupwizard/wizardmanager/WizardTransitions.java b/src/org/lineageos/setupwizard/wizardmanager/WizardTransitions.java
new file mode 100644
index 0000000..c7b826c
--- /dev/null
+++ b/src/org/lineageos/setupwizard/wizardmanager/WizardTransitions.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2017 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.wizardmanager;
+
+import static com.cyanogenmod.setupwizard.SetupWizardApp.LOGV;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.cyanogenmod.setupwizard.SetupWizardApp;
+
+public class WizardTransitions extends SparseArray<String> implements Parcelable {
+
+    private static final String TAG = "WizardTransitions";
+
+    private String mDefaultAction;
+
+    public static final Creator<WizardTransitions> CREATOR = new Creator<WizardTransitions>() {
+        public WizardTransitions createFromParcel(Parcel source) {
+            WizardTransitions transitions = new WizardTransitions(source);
+            SparseArray<String> actions = source.readSparseArray(null);
+            for (int i = 0; i < actions.size(); i++) {
+                transitions.put(actions.keyAt(i), actions.valueAt(i));
+            }
+            return transitions;
+        }
+
+        public WizardTransitions[] newArray(int size) {
+            return new WizardTransitions[size];
+        }
+    };
+
+    public WizardTransitions() {}
+
+    public void setDefaultAction(String action) {
+        mDefaultAction = action;
+    }
+
+    public String getAction(int resultCode) {
+        return get(resultCode, mDefaultAction);
+    }
+
+    @Override
+    public void put(int key, String value) {
+        if (LOGV) {
+            Log.v(TAG, "put{" +
+                    "key='" + key + '\'' +
+                    ", value=" + value +
+                    '}');
+        }
+        super.put(key, value);
+    }
+
+    public String toString() {
+        return super.toString() + " mDefaultAction: " + mDefaultAction;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        WizardTransitions that = (WizardTransitions) o;
+        return mDefaultAction != null ? mDefaultAction.equals(that.mDefaultAction) : that.mDefaultAction == null;
+
+    }
+
+    public int hashCode() {
+        return  super.hashCode() + mDefaultAction.hashCode();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mDefaultAction);
+        int size = size();
+        SparseArray sparseArray = new SparseArray<>(size);
+        for (int i = 0; i < size; i++) {
+            sparseArray.put(keyAt(i), valueAt(i));
+        }
+        dest.writeSparseArray(sparseArray);
+    }
+
+    protected WizardTransitions(Parcel in) {
+        mDefaultAction = in.readString();
+    }
+
+
+}
diff --git a/tests/res/layout/cmaccount_test.xml b/tests/res/layout/cmaccount_test.xml
deleted file mode 100644
index 488f691..0000000
--- a/tests/res/layout/cmaccount_test.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-     Copyright (C) 2013 The CyanogenMod Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-            android:layout_height="match_parent"
-            android:layout_width="match_parent">
-    <LinearLayout android:layout_height="match_parent"
-                  android:layout_width="match_parent"
-                  android:orientation="vertical">
-
-        <Button android:id="@+id/enable_setup"
-                android:layout_height="wrap_content"
-                android:layout_width="match_parent"
-                android:text="@string/enable_setup"/>
-
-        <Button android:id="@+id/enable_google_setup"
-                android:layout_height="wrap_content"
-                android:layout_width="match_parent"
-                android:text="@string/enable_google_setup"/>
-
-        <Button android:id="@+id/setup_complete_flag"
-                android:layout_height="wrap_content"
-                android:layout_width="match_parent"
-                android:text="@string/user_setup_complete"/>
-
-    </LinearLayout>
-</ScrollView>
diff --git a/tests/res/layout/setupwizard_test.xml b/tests/res/layout/setupwizard_test.xml
new file mode 100644
index 0000000..488f691
--- /dev/null
+++ b/tests/res/layout/setupwizard_test.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2013 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_height="match_parent"
+            android:layout_width="match_parent">
+    <LinearLayout android:layout_height="match_parent"
+                  android:layout_width="match_parent"
+                  android:orientation="vertical">
+
+        <Button android:id="@+id/enable_setup"
+                android:layout_height="wrap_content"
+                android:layout_width="match_parent"
+                android:text="@string/enable_setup"/>
+
+        <Button android:id="@+id/enable_google_setup"
+                android:layout_height="wrap_content"
+                android:layout_width="match_parent"
+                android:text="@string/enable_google_setup"/>
+
+        <Button android:id="@+id/setup_complete_flag"
+                android:layout_height="wrap_content"
+                android:layout_width="match_parent"
+                android:text="@string/user_setup_complete"/>
+
+    </LinearLayout>
+</ScrollView>
diff --git a/tests/src/com/cyanogenmod/setupwizard/tests/ManualTestActivity.java b/tests/src/com/cyanogenmod/setupwizard/tests/ManualTestActivity.java
deleted file mode 100644
index 1618ccd..0000000
--- a/tests/src/com/cyanogenmod/setupwizard/tests/ManualTestActivity.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (C) 2013 The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cyanogenmod.setupwizard.tests;
-
-
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_ACTIVITIES;
-import static android.content.pm.PackageManager.GET_RECEIVERS;
-import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.content.pm.PackageManager.MATCH_DISABLED_COMPONENTS;
-
-import android.app.Activity;
-import android.content.ComponentName;
-import android.content.Intent;
-import android.content.pm.ComponentInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.View;
-import android.widget.Toast;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class ManualTestActivity extends Activity {
-
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.cmaccount_test);
-
-        findViewById(R.id.enable_setup).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                enableSetup();
-            }
-        });
-        findViewById(R.id.enable_google_setup).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                enableGoogleSetup();
-            }
-        });
-        findViewById(R.id.setup_complete_flag).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                setSetupComplete();
-            }
-        });
-    }
-
-    private void enableSetup() {
-        try {
-            Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0);
-            Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0);
-            final Intent intent = new Intent("android.intent.action.MAIN");
-            intent.addCategory("android.intent.category.HOME");
-            resetComponentSets("com.cyanogenmod.setupwizard", GET_ACTIVITIES |
-                    GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
-            resetComponentSets("com.google.android.setupwizard", GET_ACTIVITIES |
-                    GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
-            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | intent.getFlags());
-            startActivity(intent);
-            finish();
-        } catch (Exception e) {
-            Toast.makeText(this, "Error enabling setup " + e.toString(), Toast.LENGTH_SHORT).show();
-            e.printStackTrace();
-        }
-    }
-
-
-    private void enableGoogleSetup() {
-        try {
-            Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0);
-            Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0);
-            Intent intent = new Intent("android.intent.action.MAIN");
-            intent.addCategory("android.intent.category.HOME");
-            resetComponentSets("com.google.android.setupwizard", GET_ACTIVITIES |
-                    GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
-            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | intent.getFlags());
-            startActivity(intent);
-            finish();
-        } catch (Exception e) {
-            Toast.makeText(this, "GMS not installed", Toast.LENGTH_SHORT).show();
-            e.printStackTrace();
-        }
-    }
-
-    private void setSetupComplete() {
-        Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1);
-        Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 1);
-        Intent intent = new Intent("android.intent.action.MAIN");
-        intent.addCategory("android.intent.category.HOME");
-        disableComponentSets("com.cyanogenmod.setupwizard",  GET_ACTIVITIES |
-                GET_RECEIVERS | GET_SERVICES);
-        try {
-            disableComponentSets("com.google.android.setupwizard",  GET_ACTIVITIES |
-                    GET_RECEIVERS | GET_SERVICES);
-        } catch (Exception e) {
-            Toast.makeText(this, "GMS not installed", Toast.LENGTH_SHORT).show();
-            e.printStackTrace();
-        }
-        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | intent.getFlags());
-        startActivity(intent);
-        finish();
-    }
-
-    private void disableComponentSets(String packageName, int flags) {
-        setComponentListEnabledState(getComponentSets(packageName, flags),
-                COMPONENT_ENABLED_STATE_DISABLED);
-    }
-
-    private void resetComponentSets(String packageName, int flags) {
-        setComponentListEnabledState(getComponentSets(packageName, flags),
-                COMPONENT_ENABLED_STATE_DEFAULT);
-    }
-
-    private void setComponentListEnabledState(List<ComponentName> componentNames,
-                                                    int enabledState) {
-        for (ComponentName componentName : componentNames) {
-            Log.i("ManualTestActivity", " Changing component state " +
-                    componentName.flattenToString() + " state=" + enabledState);
-            setComponentEnabledState(componentName, enabledState);
-        }
-    }
-
-    private void setComponentEnabledState(ComponentName componentName,
-                                                int enabledState) {
-        getPackageManager().setComponentEnabledSetting(componentName,
-                enabledState, DONT_KILL_APP);
-    }
-
-    private List<ComponentName> getComponentSets(String packageName, int flags) {
-        int i = 0;
-        List<ComponentName> componentNames = new ArrayList();
-        try {
-            PackageInfo allInfo = getPackageManager()
-                    .getPackageInfo(packageName, flags);
-            if (allInfo != null) {
-                if (allInfo.activities != null && (flags & GET_ACTIVITIES) != 0) {
-                    for (ComponentInfo info : allInfo.activities) {
-                        componentNames.add(new ComponentName(packageName, info.name));
-                    }
-                }
-                if (allInfo.receivers != null && (flags & GET_RECEIVERS) != 0) {
-                    for (ComponentInfo info2 : allInfo.receivers) {
-                        componentNames.add(new ComponentName(packageName, info2.name));
-                    }
-                }
-                if (allInfo.services != null && (flags & GET_SERVICES) != 0) {
-                    ServiceInfo[] serviceInfoArr = allInfo.services;
-                    int length = serviceInfoArr.length;
-                    while (i < length) {
-                        componentNames.add(new ComponentName(packageName, serviceInfoArr[i].name));
-                        i++;
-                    }
-                }
-            }
-        } catch (PackageManager.NameNotFoundException e) {
-        }
-        return componentNames;
-    }
-
-}
\ No newline at end of file
diff --git a/tests/src/org/lineageos/setupwizard/tests/ManualTestActivity.java b/tests/src/org/lineageos/setupwizard/tests/ManualTestActivity.java
new file mode 100644
index 0000000..1618ccd
--- /dev/null
+++ b/tests/src/org/lineageos/setupwizard/tests/ManualTestActivity.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2013 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cyanogenmod.setupwizard.tests;
+
+
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
+import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
+import static android.content.pm.PackageManager.DONT_KILL_APP;
+import static android.content.pm.PackageManager.GET_ACTIVITIES;
+import static android.content.pm.PackageManager.GET_RECEIVERS;
+import static android.content.pm.PackageManager.GET_SERVICES;
+import static android.content.pm.PackageManager.MATCH_DISABLED_COMPONENTS;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.content.pm.ComponentInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ServiceInfo;
+import android.os.Bundle;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.View;
+import android.widget.Toast;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ManualTestActivity extends Activity {
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.cmaccount_test);
+
+        findViewById(R.id.enable_setup).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                enableSetup();
+            }
+        });
+        findViewById(R.id.enable_google_setup).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                enableGoogleSetup();
+            }
+        });
+        findViewById(R.id.setup_complete_flag).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                setSetupComplete();
+            }
+        });
+    }
+
+    private void enableSetup() {
+        try {
+            Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0);
+            Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0);
+            final Intent intent = new Intent("android.intent.action.MAIN");
+            intent.addCategory("android.intent.category.HOME");
+            resetComponentSets("com.cyanogenmod.setupwizard", GET_ACTIVITIES |
+                    GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
+            resetComponentSets("com.google.android.setupwizard", GET_ACTIVITIES |
+                    GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
+            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | intent.getFlags());
+            startActivity(intent);
+            finish();
+        } catch (Exception e) {
+            Toast.makeText(this, "Error enabling setup " + e.toString(), Toast.LENGTH_SHORT).show();
+            e.printStackTrace();
+        }
+    }
+
+
+    private void enableGoogleSetup() {
+        try {
+            Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0);
+            Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0);
+            Intent intent = new Intent("android.intent.action.MAIN");
+            intent.addCategory("android.intent.category.HOME");
+            resetComponentSets("com.google.android.setupwizard", GET_ACTIVITIES |
+                    GET_RECEIVERS | GET_SERVICES | MATCH_DISABLED_COMPONENTS);
+            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | intent.getFlags());
+            startActivity(intent);
+            finish();
+        } catch (Exception e) {
+            Toast.makeText(this, "GMS not installed", Toast.LENGTH_SHORT).show();
+            e.printStackTrace();
+        }
+    }
+
+    private void setSetupComplete() {
+        Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1);
+        Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 1);
+        Intent intent = new Intent("android.intent.action.MAIN");
+        intent.addCategory("android.intent.category.HOME");
+        disableComponentSets("com.cyanogenmod.setupwizard",  GET_ACTIVITIES |
+                GET_RECEIVERS | GET_SERVICES);
+        try {
+            disableComponentSets("com.google.android.setupwizard",  GET_ACTIVITIES |
+                    GET_RECEIVERS | GET_SERVICES);
+        } catch (Exception e) {
+            Toast.makeText(this, "GMS not installed", Toast.LENGTH_SHORT).show();
+            e.printStackTrace();
+        }
+        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | intent.getFlags());
+        startActivity(intent);
+        finish();
+    }
+
+    private void disableComponentSets(String packageName, int flags) {
+        setComponentListEnabledState(getComponentSets(packageName, flags),
+                COMPONENT_ENABLED_STATE_DISABLED);
+    }
+
+    private void resetComponentSets(String packageName, int flags) {
+        setComponentListEnabledState(getComponentSets(packageName, flags),
+                COMPONENT_ENABLED_STATE_DEFAULT);
+    }
+
+    private void setComponentListEnabledState(List<ComponentName> componentNames,
+                                                    int enabledState) {
+        for (ComponentName componentName : componentNames) {
+            Log.i("ManualTestActivity", " Changing component state " +
+                    componentName.flattenToString() + " state=" + enabledState);
+            setComponentEnabledState(componentName, enabledState);
+        }
+    }
+
+    private void setComponentEnabledState(ComponentName componentName,
+                                                int enabledState) {
+        getPackageManager().setComponentEnabledSetting(componentName,
+                enabledState, DONT_KILL_APP);
+    }
+
+    private List<ComponentName> getComponentSets(String packageName, int flags) {
+        int i = 0;
+        List<ComponentName> componentNames = new ArrayList();
+        try {
+            PackageInfo allInfo = getPackageManager()
+                    .getPackageInfo(packageName, flags);
+            if (allInfo != null) {
+                if (allInfo.activities != null && (flags & GET_ACTIVITIES) != 0) {
+                    for (ComponentInfo info : allInfo.activities) {
+                        componentNames.add(new ComponentName(packageName, info.name));
+                    }
+                }
+                if (allInfo.receivers != null && (flags & GET_RECEIVERS) != 0) {
+                    for (ComponentInfo info2 : allInfo.receivers) {
+                        componentNames.add(new ComponentName(packageName, info2.name));
+                    }
+                }
+                if (allInfo.services != null && (flags & GET_SERVICES) != 0) {
+                    ServiceInfo[] serviceInfoArr = allInfo.services;
+                    int length = serviceInfoArr.length;
+                    while (i < length) {
+                        componentNames.add(new ComponentName(packageName, serviceInfoArr[i].name));
+                        i++;
+                    }
+                }
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+        }
+        return componentNames;
+    }
+
+}
\ No newline at end of file
-- 
2.7.4

