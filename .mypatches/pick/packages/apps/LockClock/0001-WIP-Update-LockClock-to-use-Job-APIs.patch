From 46f55085cdf413d8deeff0eb51c0dafc3a155eaa Mon Sep 17 00:00:00 2001
From: Namnodorel <namnodorel1@gmail.com>
Date: Thu, 1 Mar 2018 17:21:29 +0100
Subject: [PATCH] WIP: Update LockClock to use Job APIs

Change-Id: I68a74c1e70171b3ee4770b098627c05ff20338cc
---
 AndroidManifest.xml                           |   9 +-
 .../lockclock/ClockWidgetProvider.java        |  29 +++--
 .../lockclock/ClockWidgetService.java         |  70 +++++++----
 .../lockclock/WidgetApplication.java          |   6 +-
 .../calendar/CalendarViewsService.java        |  25 +++-
 .../preference/WeatherPreferences.java        |   6 +-
 .../lockclock/weather/ForecastActivity.java   |   4 +-
 .../weather/WeatherSourceListenerService.java |   7 +-
 .../weather/WeatherUpdateService.java         | 110 +++++++++++-------
 9 files changed, 162 insertions(+), 104 deletions(-)

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 0b1ac30..f282c19 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -16,12 +16,12 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="org.lineageos.lockclock"
-    android:versionCode="22"
+    android:versionCode="26"
     android:versionName="3.5" >
 
     <original-package android:name="com.cyanogenmod.lockclock" />
 
-    <uses-sdk android:minSdkVersion="24" android:targetSdkVersion="24" />
+    <uses-sdk android:minSdkVersion="24" android:targetSdkVersion="26" />
 
     <!-- Weather -->
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
@@ -99,9 +99,8 @@
             </intent-filter>
         </receiver>
 
-        <service android:name=".ClockWidgetService"></service>
-        <service android:name=".DeviceStatusService"></service>
-        <service android:name=".weather.WeatherUpdateService"></service>
+        <service android:name=".ClockWidgetService" android:permission="android.permission.BIND_JOB_SERVICE"></service>
+        <service android:name=".weather.WeatherUpdateService" android:permission="android.permission.BIND_JOB_SERVICE"></service>
         <service android:name=".weather.WeatherSourceListenerService"></service>
         <service android:name=".calendar.CalendarViewsService"
             android:permission="android.permission.BIND_REMOTEVIEWS">
diff --git a/src/org/lineageos/lockclock/ClockWidgetProvider.java b/src/org/lineageos/lockclock/ClockWidgetProvider.java
index 1c39384..e533938 100644
--- a/src/org/lineageos/lockclock/ClockWidgetProvider.java
+++ b/src/org/lineageos/lockclock/ClockWidgetProvider.java
@@ -16,10 +16,14 @@
 
 package org.lineageos.lockclock;
 
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetProvider;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.os.PersistableBundle;
 import android.util.Log;
 
 import org.lineageos.lockclock.misc.Constants;
@@ -30,6 +34,8 @@ import org.lineageos.lockclock.weather.Utils;
 import org.lineageos.lockclock.weather.WeatherSourceListenerService;
 import org.lineageos.lockclock.weather.WeatherUpdateService;
 
+import static android.app.job.JobInfo.NETWORK_TYPE_ANY;
+
 public class ClockWidgetProvider extends AppWidgetProvider {
     private static final String TAG = "ClockWidgetProvider";
     private static boolean D = Constants.DEBUG;
@@ -92,26 +98,31 @@ public class ClockWidgetProvider extends AppWidgetProvider {
      */
     private void updateWidgets(Context context, boolean refreshCalendar, boolean hideCalendar) {
         // Build the intent and pass on the weather and calendar refresh triggers
-        Intent i = new Intent(context.getApplicationContext(), ClockWidgetService.class);
+        ComponentName serviceComponent = new ComponentName(context, ClockWidgetService.class);
+        JobInfo.Builder builder = new JobInfo.Builder(0, serviceComponent);
+        PersistableBundle args = new PersistableBundle();
         if (refreshCalendar) {
-            i.setAction(ClockWidgetService.ACTION_REFRESH_CALENDAR);
+            args.putString("action", ClockWidgetService.ACTION_REFRESH_CALENDAR);
         } else if (hideCalendar) {
-            i.setAction(ClockWidgetService.ACTION_HIDE_CALENDAR);
+            args.putString("action", ClockWidgetService.ACTION_HIDE_CALENDAR);
         } else {
-            i.setAction(ClockWidgetService.ACTION_REFRESH);
+            args.putString("action", ClockWidgetService.ACTION_REFRESH);
         }
+        builder.setExtras(args);
+        builder.setOverrideDeadline(500);
+
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        jobScheduler.schedule(builder.build());
+
+
 
         // Start the service. The service itself will take care of scheduling refreshes if needed
-        if (D) Log.d(TAG, "Starting the service to update the widgets...");
-        context.startService(i);
     }
 
     @Override
     public void onEnabled(Context context) {
         if (D) Log.d(TAG, "Scheduling next weather update");
         if (Utils.isWeatherServiceAvailable(context)) {
-            context.startService(new Intent(context, WeatherSourceListenerService.class));
-            context.startService(new Intent(context, DeviceStatusService.class));
             WeatherUpdateService.scheduleNextUpdate(context, true);
         }
 
@@ -128,8 +139,6 @@ public class ClockWidgetProvider extends AppWidgetProvider {
     public void onDisabled(Context context) {
         if (D) Log.d(TAG, "Cleaning up: Clearing all pending alarms");
         if (Utils.isWeatherServiceAvailable(context)) {
-            context.stopService(new Intent(context, WeatherSourceListenerService.class));
-            context.stopService(new Intent(context, DeviceStatusService.class));
             ClockWidgetService.cancelUpdates(context);
             WeatherUpdateService.cancelUpdates(context);
         }
diff --git a/src/org/lineageos/lockclock/ClockWidgetService.java b/src/org/lineageos/lockclock/ClockWidgetService.java
index 9fc40b3..0c1fa6f 100644
--- a/src/org/lineageos/lockclock/ClockWidgetService.java
+++ b/src/org/lineageos/lockclock/ClockWidgetService.java
@@ -19,6 +19,10 @@ package org.lineageos.lockclock;
 import android.app.AlarmManager;
 import android.app.IntentService;
 import android.app.PendingIntent;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobService;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetProviderInfo;
 import android.content.ComponentName;
@@ -27,6 +31,7 @@ import android.content.Intent;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.Bundle;
+import android.os.PersistableBundle;
 import android.text.TextUtils;
 import android.text.format.DateFormat;
 import android.util.Log;
@@ -50,7 +55,7 @@ import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 
-public class ClockWidgetService extends IntentService {
+public class ClockWidgetService extends JobService {
     private static final String TAG = "ClockWidgetService";
     private static final boolean D = Constants.DEBUG;
 
@@ -65,9 +70,6 @@ public class ClockWidgetService extends IntentService {
     private AppWidgetManager mAppWidgetManager;
     private Context mContext;
 
-    public ClockWidgetService() {
-        super("ClockWidgetService");
-    }
 
     @Override
     public void onCreate() {
@@ -80,17 +82,17 @@ public class ClockWidgetService extends IntentService {
     }
 
     @Override
-    protected void onHandleIntent(Intent intent) {
-        if (D) Log.d(TAG, "Got intent " + intent);
+    public boolean onStartJob(JobParameters params) {
+        String action = params.getExtras().getString("action");
 
         if (mWidgetIds != null && mWidgetIds.length != 0) {
             // Check passed in intents
-            if (intent != null) {
-                if (ACTION_HIDE_CALENDAR.equals(intent.getAction())) {
+            if (params != null) {
+                if (ACTION_HIDE_CALENDAR.equals(action)) {
                     if (D) Log.v(TAG, "Force hiding the calendar panel");
                     // Explicitly hide the panel since we received a broadcast indicating no events
                     mHideCalendar = true;
-                } else if (ACTION_REFRESH_CALENDAR.equals(intent.getAction())) {
+                } else if (ACTION_REFRESH_CALENDAR.equals(action)) {
                     if (D) Log.v(TAG, "Forcing a calendar refresh");
                     // Start with the panel not explicitly hidden
                     // If there are no events, a broadcast to the service will hide the panel
@@ -100,6 +102,12 @@ public class ClockWidgetService extends IntentService {
             }
             refreshWidget();
         }
+        return false;
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters jobParameters) {
+        return false;
     }
 
     /**
@@ -502,7 +510,7 @@ public class ClockWidgetService extends IntentService {
         }
 
         // Register an onClickListener on Weather
-        setWeatherClickListener(weatherViews, false);
+        //setWeatherClickListener(weatherViews, false);
     }
 
     /**
@@ -553,26 +561,28 @@ public class ClockWidgetService extends IntentService {
         // Register an onClickListener on Weather with the default (Refresh) action
         if (!firstRun) {
             if (activeProviderLabel != null) {
-                setWeatherClickListener(weatherViews, true);
+                //setWeatherClickListener(weatherViews, true);
             } else {
-                setWeatherClickListener(weatherViews);
+                //setWeatherClickListener(weatherViews);
             }
         }
     }
 
-    private void setWeatherClickListener(RemoteViews weatherViews, boolean forceRefresh) {
+    //TODO Make available again through helper intent possibly?
+    /*private void setWeatherClickListener(RemoteViews weatherViews, boolean forceRefresh) {
         // Register an onClickListener on the Weather panel, default action is show forecast
         PendingIntent pi = null;
         if (forceRefresh) {
-            pi = WeatherUpdateService.getUpdateIntent(this, true);
-        }
-
-        if (pi == null) {
+            Intent i = new Intent(mContext, ClockWidgetService.class);
+            pi = PendingIntent.getService(mContext, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
+        }else {
             Intent i = new Intent(this, ClockWidgetProvider.class);
             i.setAction(Constants.ACTION_SHOW_FORECAST);
             pi = PendingIntent.getBroadcast(this, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
         }
         weatherViews.setOnClickPendingIntent(R.id.weather_panel, pi);
+
+
     }
 
     private void setWeatherClickListener(RemoteViews weatherViews) {
@@ -580,7 +590,7 @@ public class ClockWidgetService extends IntentService {
                 new Intent("lineageos.intent.action.MANAGE_WEATHER_PROVIDER_SERVICES"),
                         PendingIntent.FLAG_UPDATE_CURRENT);
         weatherViews.setOnClickPendingIntent(R.id.weather_panel, pi);
-    }
+    }*/
 
     //===============================================================================================
     // Calendar related functionality
@@ -615,14 +625,26 @@ public class ClockWidgetService extends IntentService {
         calendarViews.setPendingIntentTemplate(R.id.calendar_list, eventClickPendingIntent);
     }
 
-    public static PendingIntent getRefreshIntent(Context context) {
-        Intent i = new Intent(context, ClockWidgetService.class);
-        i.setAction(ClockWidgetService.ACTION_REFRESH_CALENDAR);
-        return PendingIntent.getService(context, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
+    public static void scheduleUpdate(Context context, String action){
+        ComponentName serviceComponent = new ComponentName(context, ClockWidgetService.class);
+        JobInfo.Builder builder = new JobInfo.Builder(0, serviceComponent);
+
+        PersistableBundle args = new PersistableBundle();
+        args.putString("action", action);
+        builder.setExtras(args);
+
+        builder.setOverrideDeadline(10);
+
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        jobScheduler.schedule(builder.build());
     }
 
     public static void cancelUpdates(Context context) {
-        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
-        am.cancel(getRefreshIntent(context));
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        for(JobInfo jobInfo : jobScheduler.getAllPendingJobs()){
+            if(jobInfo.getService().getClassName().equals(ClockWidgetService.class.getName())){
+                jobScheduler.cancel(jobInfo.getId());
+            }
+        }
     }
 }
diff --git a/src/org/lineageos/lockclock/WidgetApplication.java b/src/org/lineageos/lockclock/WidgetApplication.java
index 7fe47be..7039a51 100644
--- a/src/org/lineageos/lockclock/WidgetApplication.java
+++ b/src/org/lineageos/lockclock/WidgetApplication.java
@@ -52,9 +52,7 @@ public class WidgetApplication extends Application {
                 scheduleClockRefresh(context);
 
                 // Refresh the widget
-                Intent refreshIntent = new Intent(context, ClockWidgetProvider.class);
-                refreshIntent.setAction(ClockWidgetService.ACTION_REFRESH);
-                context.sendBroadcast(refreshIntent);
+                ClockWidgetService.scheduleUpdate(context, ClockWidgetService.ACTION_REFRESH);
 
                 // We no longer need the tick receiver, its done its job, stop it
                 stopTickReceiver();
@@ -92,7 +90,7 @@ public class WidgetApplication extends Application {
         AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
         am.cancel(getClockRefreshIntent(context));
     }
-
+    //TODO Pending intent doesn't work here anymore
     private static PendingIntent getClockRefreshIntent(Context context) {
         Intent i = new Intent(context, ClockWidgetService.class);
         i.setAction(ClockWidgetService.ACTION_REFRESH);
diff --git a/src/org/lineageos/lockclock/calendar/CalendarViewsService.java b/src/org/lineageos/lockclock/calendar/CalendarViewsService.java
index c49a6ac..4b28c2b 100755
--- a/src/org/lineageos/lockclock/calendar/CalendarViewsService.java
+++ b/src/org/lineageos/lockclock/calendar/CalendarViewsService.java
@@ -18,12 +18,16 @@ package org.lineageos.lockclock.calendar;
 
 import android.app.AlarmManager;
 import android.app.PendingIntent;
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.content.ComponentName;
 import android.content.ContentUris;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
 import android.graphics.Typeface;
 import android.net.Uri;
+import android.os.PersistableBundle;
 import android.provider.CalendarContract;
 import android.provider.CalendarContract.Events;
 import android.text.SpannableString;
@@ -48,6 +52,8 @@ import java.util.Calendar;
 import java.util.Date;
 import java.util.Set;
 
+import static android.app.job.JobInfo.NETWORK_TYPE_ANY;
+
 public class CalendarViewsService extends RemoteViewsService {
 
     @Override
@@ -473,16 +479,25 @@ class CalendarRemoteViewsFactory implements RemoteViewsFactory {
      * the next event time boundary (start/end).
      */
     private void scheduleCalendarUpdate(Context context) {
-        PendingIntent pi = ClockWidgetService.getRefreshIntent(context);
         long updateTime = calculateUpdateTime(context);
 
-        // Clear any old alarms and schedule the new alarm
+        // Clear any old jobs and schedule the new job
         // Since the updates are now only done very infrequently, it can wake the device to ensure
         // the latest date is available when the user turns the screen on after a few hours sleep
-        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
-        am.cancel(pi);
+
+        ClockWidgetService.cancelUpdates(context);
+
+
         if (updateTime > 0) {
-            am.set(AlarmManager.RTC_WAKEUP, updateTime, pi);
+            ComponentName serviceComponent = new ComponentName(context, ClockWidgetService.class);
+            JobInfo.Builder builder = new JobInfo.Builder(0, serviceComponent);
+            PersistableBundle args = new PersistableBundle();
+            args.putString("action", ClockWidgetService.ACTION_REFRESH_CALENDAR);
+            builder.setExtras(args);
+
+            builder.setOverrideDeadline(updateTime);
+            JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+            jobScheduler.schedule(builder.build());
         }
     }
 
diff --git a/src/org/lineageos/lockclock/preference/WeatherPreferences.java b/src/org/lineageos/lockclock/preference/WeatherPreferences.java
index eeb63f0..30390e6 100644
--- a/src/org/lineageos/lockclock/preference/WeatherPreferences.java
+++ b/src/org/lineageos/lockclock/preference/WeatherPreferences.java
@@ -214,11 +214,7 @@ public class WeatherPreferences extends PreferenceFragment implements
         }
 
         if (Preferences.showWeather(mContext) && (needWeatherUpdate || forceWeatherUpdate)) {
-            Intent updateIntent = new Intent(mContext, WeatherUpdateService.class);
-            if (forceWeatherUpdate) {
-                updateIntent.setAction(WeatherUpdateService.ACTION_FORCE_UPDATE);
-            }
-            mContext.startService(updateIntent);
+            WeatherUpdateService.scheduleNextUpdate(mContext, forceWeatherUpdate);
         }
 
         Intent updateIntent = new Intent(mContext, ClockWidgetProvider.class);
diff --git a/src/org/lineageos/lockclock/weather/ForecastActivity.java b/src/org/lineageos/lockclock/weather/ForecastActivity.java
index 0658889..c617ea1 100644
--- a/src/org/lineageos/lockclock/weather/ForecastActivity.java
+++ b/src/org/lineageos/lockclock/weather/ForecastActivity.java
@@ -117,9 +117,7 @@ public class ForecastActivity extends Activity implements OnClickListener {
             anim.setDuration(700);
             view.startAnimation(anim); 
 
-            Intent i = new Intent(this, WeatherUpdateService.class);
-            i.setAction(WeatherUpdateService.ACTION_FORCE_UPDATE);
-            startService(i);
+            WeatherUpdateService.scheduleNextUpdate(this, true);
         } else {
             finish();
         }
diff --git a/src/org/lineageos/lockclock/weather/WeatherSourceListenerService.java b/src/org/lineageos/lockclock/weather/WeatherSourceListenerService.java
index 4d17ad5..b736b69 100644
--- a/src/org/lineageos/lockclock/weather/WeatherSourceListenerService.java
+++ b/src/org/lineageos/lockclock/weather/WeatherSourceListenerService.java
@@ -47,12 +47,11 @@ public class WeatherSourceListenerService extends Service
         Preferences.setUseCustomWeatherLocation(mContext, false);
 
         //Refresh the widget
-        mContext.startService(new Intent(mContext, ClockWidgetService.class)
-                .setAction(ClockWidgetService.ACTION_REFRESH));
+        ClockWidgetService.scheduleUpdate(mContext, ClockWidgetService.ACTION_REFRESH);
+
 
         if (providerLabel != null) {
-            mContext.startService(new Intent(mContext, WeatherUpdateService.class)
-                    .putExtra(WeatherUpdateService.ACTION_FORCE_UPDATE, true));
+            WeatherUpdateService.scheduleNextUpdate(mContext, true);
         }
     }
 
diff --git a/src/org/lineageos/lockclock/weather/WeatherUpdateService.java b/src/org/lineageos/lockclock/weather/WeatherUpdateService.java
index 711d571..e3ae800 100644
--- a/src/org/lineageos/lockclock/weather/WeatherUpdateService.java
+++ b/src/org/lineageos/lockclock/weather/WeatherUpdateService.java
@@ -19,6 +19,11 @@ package org.lineageos.lockclock.weather;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
 import android.app.Service;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobService;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.location.Criteria;
@@ -32,6 +37,7 @@ import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.Looper;
 import android.os.Message;
+import android.os.PersistableBundle;
 import android.os.PowerManager;
 import android.os.PowerManager.WakeLock;
 import android.os.SystemClock;
@@ -53,8 +59,12 @@ import org.lineageos.internal.util.PackageManagerUtils;
 
 import java.lang.ref.WeakReference;
 import java.util.Date;
+import java.util.HashSet;
+import java.util.Set;
 
-public class WeatherUpdateService extends Service {
+import static android.app.job.JobInfo.NETWORK_TYPE_ANY;
+
+public class WeatherUpdateService extends JobService {
     private static final String TAG = "WeatherUpdateService";
     private static final boolean D = Constants.DEBUG;
 
@@ -95,52 +105,54 @@ public class WeatherUpdateService extends Service {
     }
 
     @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        if (D) Log.v(TAG, "Got intent " + intent);
-
-        if (ACTION_CANCEL_LOCATION_UPDATE.equals(intent.getAction())) {
+    public boolean onStartJob(JobParameters params) {
+        String action = params.getExtras().getString("action", "");
+        Log.e("TESTING", "LockWeather Job Started!!!! " + action);
+        if (ACTION_CANCEL_LOCATION_UPDATE.equals(action)) {
             WeatherLocationListener.cancel(this);
             if (!mWorkerThread.isProcessing()) {
                 stopSelf();
             }
-            return START_NOT_STICKY;
+            return false;
         }
 
-        if (ACTION_CANCEL_UPDATE_WEATHER_REQUEST.equals(intent.getAction())) {
+        if (ACTION_CANCEL_UPDATE_WEATHER_REQUEST.equals(action)) {
             if (mWorkerThread.isProcessing()) {
                 mWorkerThread.getHandler().obtainMessage(
                         WorkerThread.MSG_CANCEL_UPDATE_WEATHER_REQUEST).sendToTarget();
-                mHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        final Context context = getApplicationContext();
-                        final LineageWeatherManager weatherManager
-                                = LineageWeatherManager.getInstance(context);
-                        final String activeProviderLabel
-                                = weatherManager.getActiveWeatherServiceProviderLabel();
-                        final String noData
-                                = getString(R.string.weather_cannot_reach_provider,
-                                    activeProviderLabel);
-                        Toast.makeText(context, noData, Toast.LENGTH_SHORT).show();
-                    }
+                mHandler.post(() -> {
+                    final Context context = getApplicationContext();
+                    final LineageWeatherManager weatherManager
+                            = LineageWeatherManager.getInstance(context);
+                    final String activeProviderLabel
+                            = weatherManager.getActiveWeatherServiceProviderLabel();
+                    final String noData
+                            = getString(R.string.weather_cannot_reach_provider,
+                                activeProviderLabel);
+                    Toast.makeText(context, noData, Toast.LENGTH_SHORT).show();
                 });
             }
             stopSelf();
-            return START_NOT_STICKY;
+            return false;
         }
 
-        boolean force = ACTION_FORCE_UPDATE.equals(intent.getAction());
+        boolean force = ACTION_FORCE_UPDATE.equals(action);
         if (!shouldUpdate(force)) {
             Log.d(TAG, "Service started, but shouldn't update ... stopping");
             sendCancelledBroadcast();
             stopSelf();
-            return START_NOT_STICKY;
+            return false;
         }
-
+        mWorkerThread.setCallback(() -> jobFinished(params, false));
         mWorkerThread.getHandler().obtainMessage(WorkerThread.MSG_ON_NEW_WEATHER_REQUEST)
                 .sendToTarget();
 
-        return START_REDELIVER_INTENT;
+        return true;
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters jobParameters) {
+        return false;
     }
 
     private boolean shouldUpdate(boolean force) {
@@ -206,6 +218,8 @@ public class WeatherUpdateService extends Service {
         private final LineageWeatherManager mWeatherManager;
         final private Context mContext;
 
+        private Runnable callback;
+
         public WorkerThread(Context context) {
             super("weather-service-worker");
             mContext = context;
@@ -224,13 +238,16 @@ public class WeatherUpdateService extends Service {
                         case MSG_ON_WEATHER_REQUEST_COMPLETED:
                             WeatherInfo info = (WeatherInfo) msg.obj;
                             onWeatherRequestCompleted(info);
+                            if(callback != null) callback.run();
                             break;
                         case MSG_WEATHER_REQUEST_FAILED:
                             int status = msg.arg1;
                             onWeatherRequestFailed(status);
+                            if(callback != null) callback.run();
                             break;
                         case MSG_CANCEL_UPDATE_WEATHER_REQUEST:
                             onCancelUpdateWeatherRequest();
+                            if(callback != null) callback.run();
                             break;
                         default:
                             //Unknown message, pass it on...
@@ -239,7 +256,11 @@ public class WeatherUpdateService extends Service {
                 }
             };
         }
+        public void setCallback(Runnable callback){
+            this.callback = callback;
+        }
 
+        //TODO PendingIntent doesn't work here anymore - maybe trigger the job through a BroadcastReceiver?
         private void startTimeoutAlarm() {
             Intent intent = new Intent(mContext, WeatherUpdateService.class);
             intent.setAction(ACTION_CANCEL_UPDATE_WEATHER_REQUEST);
@@ -403,7 +424,7 @@ public class WeatherUpdateService extends Service {
             if (D) Log.d(TAG, "RELEASING WAKELOCK");
             mWakeLock.release();
             mIsProcessingWeatherUpdate = false;
-            mContext.stopService(new Intent(mContext, WeatherUpdateService.class));
+            cancelUpdates(mContext);
         }
 
         @Override
@@ -424,11 +445,6 @@ public class WeatherUpdateService extends Service {
         sendBroadcast(finishedIntent);
     }
 
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
     @Override
     public void onDestroy() {
         Log.d(TAG, "onDestroy");
@@ -485,6 +501,7 @@ public class WeatherUpdateService extends Service {
             mContext = context;
         }
 
+        //TODO PendingIntent doesn't work here anymore
         private void setTimeoutAlarm() {
             Intent intent = new Intent(mContext, WeatherUpdateService.class);
             intent.setAction(ACTION_CANCEL_LOCATION_UPDATE);
@@ -541,11 +558,21 @@ public class WeatherUpdateService extends Service {
     }
 
     private static void scheduleUpdate(Context context, long millisFromNow, boolean force) {
-        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
         long due = SystemClock.elapsedRealtime() + millisFromNow;
         if (D) Log.d(TAG, "Next update scheduled at "
                 + new Date(System.currentTimeMillis() + millisFromNow));
-        am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, due, getUpdateIntent(context, force));
+
+        ComponentName serviceComponent = new ComponentName(context, WeatherUpdateService.class);
+        JobInfo.Builder builder = new JobInfo.Builder(10, serviceComponent);
+        if(force){
+            PersistableBundle args = new PersistableBundle();
+            args.putString("action", ACTION_FORCE_UPDATE);
+            builder.setExtras(args);
+        }
+        builder.setOverrideDeadline(due);
+        builder.setRequiredNetworkType(NETWORK_TYPE_ANY);
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        jobScheduler.schedule(builder.build());
     }
 
     public static void scheduleNextUpdate(Context context, boolean force) {
@@ -563,18 +590,13 @@ public class WeatherUpdateService extends Service {
         }
     }
 
-    public static PendingIntent getUpdateIntent(Context context, boolean force) {
-        Intent i = new Intent(context, WeatherUpdateService.class);
-        if (force) {
-            i.setAction(ACTION_FORCE_UPDATE);
-        }
-        return PendingIntent.getService(context, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
-    }
-
     public static void cancelUpdates(Context context) {
-        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
-        am.cancel(getUpdateIntent(context, true));
-        am.cancel(getUpdateIntent(context, false));
+        JobScheduler jobScheduler = context.getSystemService(JobScheduler.class);
+        for(JobInfo jobInfo : jobScheduler.getAllPendingJobs()){
+            if(jobInfo.getService().getClassName().equals(WeatherUpdateService.class.getName())){
+                jobScheduler.cancel(jobInfo.getId());
+            }
+        }
         WeatherLocationListener.cancel(context);
     }
 }
-- 
2.17.1

