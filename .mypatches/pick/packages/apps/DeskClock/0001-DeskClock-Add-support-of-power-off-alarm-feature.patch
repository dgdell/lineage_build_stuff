From 0c3069607f47fdc23aaf420fb4298996439df64b Mon Sep 17 00:00:00 2001
From: Mao Jinlong <jinlmao@codeaurora.org>
Date: Tue, 6 Mar 2018 17:48:40 +0800
Subject: [PATCH 1/2] DeskClock: Add support of power off alarm feature

1. Add set and cancel power off alarm actions

Power off alarm feature is based on DeskClock app. Add set and cancel
power off alarm actions for the feature.

2. update alarm if it is handled in min framework

Update the alarm instance status when the power off alarm is handled
in min framework mode.

CRs-Fixed: 2200664
Change-Id: I9442b05b8c4d6213676943163e3c0b995047d903
---
 AndroidManifest.xml                           |  1 +
 .../android/deskclock/AlarmInitReceiver.java  | 51 +++++++++++++++++++
 .../deskclock/alarms/AlarmNotifications.java  |  4 +-
 .../deskclock/alarms/AlarmStateManager.java   | 36 +++++++++++++
 4 files changed, 90 insertions(+), 2 deletions(-)

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 1f5697da4..fdc9ef245 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -167,6 +167,7 @@
                 <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
                 <action android:name="android.intent.action.TIME_SET" />
                 <action android:name="android.intent.action.TIMEZONE_CHANGED" />
+                <action android:name="org.codeaurora.poweroffalarm.action.UPDATE_ALARM" />
             </intent-filter>
         </receiver>
 
diff --git a/src/com/android/deskclock/AlarmInitReceiver.java b/src/com/android/deskclock/AlarmInitReceiver.java
index 8bd7cdec7..d62917dd4 100644
--- a/src/com/android/deskclock/AlarmInitReceiver.java
+++ b/src/com/android/deskclock/AlarmInitReceiver.java
@@ -18,16 +18,32 @@ package com.android.deskclock;
 
 import android.annotation.SuppressLint;
 import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.os.PowerManager.WakeLock;
 
 import com.android.deskclock.alarms.AlarmStateManager;
+import com.android.deskclock.alarms.AlarmNotifications;
 import com.android.deskclock.controller.Controller;
 import com.android.deskclock.data.DataModel;
+import com.android.deskclock.provider.AlarmInstance;
+
+import java.util.Calendar;
+import java.util.List;
 
 public class AlarmInitReceiver extends BroadcastReceiver {
 
+    private static final String ACTION_UPDATE_ALARM_STATUS =
+            "org.codeaurora.poweroffalarm.action.UPDATE_ALARM";
+
+    private static final int SNOOZE_STATUS = 2;
+    private static final int DISMISS_STATUS = 3;
+
+    private static final String STATUS = "status";
+    private static final String TIME = "time";
+    private static final String SNOOZE_TIME = "snooze_time";
+
     /**
      * When running on N devices, we're interested in the boot completed event that is sent while
      * the user is still locked, so that we can schedule alarms.
@@ -85,6 +101,41 @@ public class AlarmInitReceiver extends BroadcastReceiver {
             Controller.getController().updateShortcuts();
         }
 
+        // Update alarm status once receive the status update broadcast
+        if (ACTION_UPDATE_ALARM_STATUS.equals(action)) {
+            long alarmTime = intent.getLongExtra(TIME, 0L);
+            int alarmStatus = intent.getIntExtra(STATUS, 0);
+
+            if (alarmTime != 0) {
+                ContentResolver cr = context.getContentResolver();
+                List<AlarmInstance> alarmInstances = AlarmInstance.getInstances(cr, null);
+                AlarmInstance alarmInstance = null;
+                for (AlarmInstance instance : alarmInstances) {
+                    if (instance.getAlarmTime().getTimeInMillis() == alarmTime) {
+                        alarmInstance = instance;
+                        break;
+                    }
+                }
+
+                if (alarmInstance != null) {
+                    // Update alarm status if the alarm instance is not null
+                    if (alarmStatus == DISMISS_STATUS) {
+                        AlarmStateManager.setDismissState(context, alarmInstance);
+                    } else if (alarmStatus == SNOOZE_STATUS) {
+                        long snoozeTime = intent.getLongExtra(SNOOZE_TIME, 0L);
+                        if (snoozeTime > System.currentTimeMillis()) {
+                            AlarmNotifications.clearNotification(context, alarmInstance);
+                            Calendar c = Calendar.getInstance();
+                            c.setTimeInMillis(snoozeTime);
+                            alarmInstance.setAlarmTime(c);
+                            alarmInstance.mAlarmState = AlarmInstance.SNOOZE_STATE;
+                            AlarmInstance.updateInstance(cr, alarmInstance);
+                        }
+                    }
+                }
+            }
+        }
+
         AsyncHandler.post(new Runnable() {
             @Override
             public void run() {
diff --git a/src/com/android/deskclock/alarms/AlarmNotifications.java b/src/com/android/deskclock/alarms/AlarmNotifications.java
index df711d23a..5312f43fc 100644
--- a/src/com/android/deskclock/alarms/AlarmNotifications.java
+++ b/src/com/android/deskclock/alarms/AlarmNotifications.java
@@ -43,7 +43,7 @@ import java.text.SimpleDateFormat;
 import java.util.Locale;
 import java.util.Objects;
 
-final class AlarmNotifications {
+public final class AlarmNotifications {
     static final String EXTRA_NOTIFICATION_ID = "extra_notification_id";
 
     /**
@@ -438,7 +438,7 @@ final class AlarmNotifications {
         service.startForeground(ALARM_FIRING_NOTIFICATION_ID, notification.build());
     }
 
-    static synchronized void clearNotification(Context context, AlarmInstance instance) {
+    public static synchronized void clearNotification(Context context, AlarmInstance instance) {
         LogUtils.v("Clearing notifications for alarm instance: " + instance.mId);
         NotificationManagerCompat nm = NotificationManagerCompat.from(context);
         final int id = instance.hashCode();
diff --git a/src/com/android/deskclock/alarms/AlarmStateManager.java b/src/com/android/deskclock/alarms/AlarmStateManager.java
index f0a8db56f..a49e616af 100644
--- a/src/com/android/deskclock/alarms/AlarmStateManager.java
+++ b/src/com/android/deskclock/alarms/AlarmStateManager.java
@@ -143,6 +143,17 @@ public final class AlarmStateManager extends BroadcastReceiver {
     private static StateChangeScheduler sStateChangeScheduler =
             new AlarmManagerStateChangeScheduler();
 
+    private static final String ACTION_SET_POWEROFF_ALARM =
+            "org.codeaurora.poweroffalarm.action.SET_ALARM";
+
+    private static final String ACTION_CANCEL_POWEROFF_ALARM =
+            "org.codeaurora.poweroffalarm.action.CANCEL_ALARM";
+
+    private static final String POWER_OFF_ALARM_PACKAGE =
+            "com.qualcomm.qti.poweroffalarm";
+
+    private static final String TIME = "time";
+
     private static Calendar getCurrentTime() {
         return sCurrentTimeFactory == null
                 ? DataModel.getDataModel().getCalendar()
@@ -167,6 +178,10 @@ public final class AlarmStateManager extends BroadcastReceiver {
     private static void updateNextAlarm(Context context) {
         final AlarmInstance nextAlarm = getNextFiringAlarm(context);
 
+        if (nextAlarm != null) {
+            setPowerOffAlarm(context, nextAlarm);
+        }
+
         if (Utils.isPreL()) {
             updateNextAlarmInSystemSettings(context, nextAlarm);
         } else {
@@ -543,6 +558,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
         scheduleInstanceStateChange(context, instance.getMissedTimeToLive(),
                 instance, AlarmInstance.DISMISSED_STATE);
 
+        cancelPowerOffAlarm(context, instance);
         // Instance is not valid anymore, so find next alarm that will fire and notify system
         updateNextAlarm(context);
     }
@@ -572,6 +588,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
             updateParentAlarm(context, instance);
         }
 
+        cancelPowerOffAlarm(context, instance);
         updateNextAlarm(context);
     }
 
@@ -583,6 +600,8 @@ public final class AlarmStateManager extends BroadcastReceiver {
         instance.mAlarmState = AlarmInstance.DISMISSED_STATE;
         final ContentResolver contentResolver = context.getContentResolver();
         AlarmInstance.updateInstance(contentResolver, instance);
+
+        cancelPowerOffAlarm(context, instance);
     }
 
     /**
@@ -992,6 +1011,23 @@ public final class AlarmStateManager extends BroadcastReceiver {
         void cancelScheduledInstanceStateChange(Context context, AlarmInstance instance);
     }
 
+    private static void setPowerOffAlarm(Context context, AlarmInstance instance) {
+         LogUtils.i("Set next power off alarm : instance id "+ instance.mId);
+         Intent intent = new Intent(ACTION_SET_POWEROFF_ALARM);
+         intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+         intent.setPackage(POWER_OFF_ALARM_PACKAGE);
+         intent.putExtra(TIME, instance.getAlarmTime().getTimeInMillis());
+         context.sendBroadcast(intent);
+    }
+
+    private static void cancelPowerOffAlarm(Context context, AlarmInstance instance) {
+         Intent intent = new Intent(ACTION_CANCEL_POWEROFF_ALARM);
+         intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+         intent.putExtra(TIME, instance.getAlarmTime().getTimeInMillis());
+         intent.setPackage(POWER_OFF_ALARM_PACKAGE);
+         context.sendBroadcast(intent);
+    }
+
     /**
      * Schedules state change callbacks within the AlarmManager.
      */
-- 
2.17.1

