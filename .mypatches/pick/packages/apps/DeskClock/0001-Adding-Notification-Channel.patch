From 89e891e85b1ca27ca21fa5f89eb4975cc2c5e07c Mon Sep 17 00:00:00 2001
From: Mahesh Kumar <mahesh.kumar@mediatek.com>
Date: Thu, 8 Mar 2018 22:07:55 +0530
Subject: [PATCH 1/2] Adding Notification Channel

Java exception occurs when notification is posted by DeskClock
because Notification channel is not implemented.
To fix, Notification channel needs to implement and used
when notification is posted.

Change-Id: Ie4b2b46685fd150f5a0f7e6434ff487a56570107
Test: Manual and cts, passed always tried more than 100 times
---
 res/values/cm_strings.xml                     |   4 +
 .../deskclock/DeskClockApplication.java       |   1 -
 .../deskclock/NotificationChannelManager.java | 158 ++++++++++++++++++
 .../deskclock/alarms/AlarmNotifications.java  |  24 ++-
 .../data/StopwatchNotificationBuilder.java    |   3 +
 .../data/TimerNotificationBuilder.java        |   6 +
 6 files changed, 188 insertions(+), 8 deletions(-)
 create mode 100755 src/com/android/deskclock/NotificationChannelManager.java

diff --git a/res/values/cm_strings.xml b/res/values/cm_strings.xml
index ebae31669..3259b71c6 100644
--- a/res/values/cm_strings.xml
+++ b/res/values/cm_strings.xml
@@ -33,4 +33,8 @@
     <!-- Setting title for accessing the cLock widget settings -->
     <string name="menu_item_widget_settings">Widget settings</string>
 
+    <!-- Notification channels -->
+    <string name="channel_default">Others</string>
+    <string name="channel_expired_events">Firing alarms &amp; timers</string>
+    <string name="channel_important">Important notifications</string>
 </resources>
diff --git a/src/com/android/deskclock/DeskClockApplication.java b/src/com/android/deskclock/DeskClockApplication.java
index 395d38518..e19885cab 100644
--- a/src/com/android/deskclock/DeskClockApplication.java
+++ b/src/com/android/deskclock/DeskClockApplication.java
@@ -36,7 +36,6 @@ public class DeskClockApplication extends Application {
 
         final Context applicationContext = getApplicationContext();
         final SharedPreferences prefs = getDefaultSharedPreferences(applicationContext);
-
         DataModel.getDataModel().init(applicationContext, prefs);
         UiDataModel.getUiDataModel().init(applicationContext, prefs);
         Controller.getController().setContext(applicationContext);
diff --git a/src/com/android/deskclock/NotificationChannelManager.java b/src/com/android/deskclock/NotificationChannelManager.java
new file mode 100755
index 000000000..c0dd1a912
--- /dev/null
+++ b/src/com/android/deskclock/NotificationChannelManager.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.deskclock;
+
+import android.annotation.TargetApi;
+import android.app.NotificationChannel;
+import android.app.NotificationChannelGroup;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.net.Uri;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.StringDef;
+import android.support.v4.app.NotificationCompat;
+import android.support.v4.os.BuildCompat;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Contains info on how to create {@link NotificationChannel
+ * NotificationChannels}
+ */
+public class NotificationChannelManager {
+
+    private static NotificationChannelManager sInstance;
+
+    public static NotificationChannelManager getInstance() {
+        if (sInstance == null) {
+            sInstance = new NotificationChannelManager();
+        }
+        return sInstance;
+    }
+
+    /**
+     * Set the channel of notification appropriately. Will create the channel if
+     * it does not already exist. Safe to call pre-O (will no-op).
+     */
+    @TargetApi(26)
+    public static void applyChannel(@NonNull NotificationCompat.Builder notification,
+            @NonNull Context context, @Channel String channelId) {
+        if (!BuildCompat.isAtLeastO()) {
+            return;
+        }
+
+        NotificationChannel channel = NotificationChannelManager
+                .getInstance().getChannel(context, channelId);
+        notification.setChannelId(channel.getId());
+    }
+
+    /** The base Channel IDs for {@link NotificationChannel} */
+    @Retention(RetentionPolicy.SOURCE)
+    @StringDef({ Channel.EVENT_EXPIRED, Channel.HIGH_NOTIFICATION,
+            Channel.DEFAULT_NOTIFICATION })
+    public @interface Channel {
+        String EVENT_EXPIRED = "eventExpire";
+        String HIGH_NOTIFICATION = "highNotif";
+        String DEFAULT_NOTIFICATION = "defaultNotif";
+    }
+
+    @Channel
+    private static final String[] allChannels = new String[] {
+            Channel.EVENT_EXPIRED,
+            Channel.HIGH_NOTIFICATION,
+            Channel.DEFAULT_NOTIFICATION
+    };
+
+    @NonNull
+    @RequiresApi(26)
+    private NotificationChannel getChannel(@NonNull Context context,
+            @Channel String channelId) {
+        NotificationChannel channel = getNotificationManager(context)
+                .getNotificationChannel(channelId);
+        if (channel == null) {
+            channel = createChannel(context, channelId);
+        }
+        return channel;
+    }
+
+    @RequiresApi(26)
+    private NotificationChannel createChannel(Context context,
+            @Channel String channelId) {
+        Uri silentRingtone = Uri.EMPTY;
+        CharSequence name;
+        int importance;
+        boolean canShowBadge;
+        boolean lights;
+        boolean vibration;
+        boolean dnd;
+        Uri sound;
+
+        switch (channelId) {
+        case Channel.EVENT_EXPIRED:
+            name = context.getString(R.string.channel_expired_events);
+            importance = NotificationManager.IMPORTANCE_HIGH;
+            canShowBadge = false;
+            lights = false;
+            vibration = false;
+            sound = null;
+            dnd = true;
+            break;
+
+        case Channel.HIGH_NOTIFICATION:
+            name = context.getString(R.string.channel_important);
+            importance = NotificationManager.IMPORTANCE_DEFAULT;
+            canShowBadge = false;
+            lights = false;
+            vibration = false;
+            sound = null;
+            dnd = true;
+            break;
+
+        case Channel.DEFAULT_NOTIFICATION:
+            name = context.getString(R.string.channel_default);
+            importance = NotificationManager.IMPORTANCE_LOW;
+            canShowBadge = false;
+            lights = false;
+            vibration = false;
+            sound = null;
+            dnd = true;
+            break;
+
+        default:
+            throw new IllegalArgumentException("Unknown channel: " + channelId);
+        }
+        NotificationChannel channel = new NotificationChannel(channelId, name,
+                importance);
+        channel.setShowBadge(canShowBadge);
+        channel.enableVibration(vibration);
+        channel.setSound(sound, null);
+        channel.enableLights(lights);
+        channel.setBypassDnd(dnd);
+
+        getNotificationManager(context).createNotificationChannel(channel);
+        return channel;
+    }
+
+    private static NotificationManager getNotificationManager(
+            @NonNull Context context) {
+        return context.getSystemService(NotificationManager.class);
+    }
+}
diff --git a/src/com/android/deskclock/alarms/AlarmNotifications.java b/src/com/android/deskclock/alarms/AlarmNotifications.java
index ad2f75efd..a21235330 100644
--- a/src/com/android/deskclock/alarms/AlarmNotifications.java
+++ b/src/com/android/deskclock/alarms/AlarmNotifications.java
@@ -33,6 +33,8 @@ import com.android.deskclock.AlarmClockFragment;
 import com.android.deskclock.AlarmUtils;
 import com.android.deskclock.DeskClock;
 import com.android.deskclock.LogUtils;
+import com.android.deskclock.NotificationChannelManager;
+import com.android.deskclock.NotificationChannelManager.Channel;
 import com.android.deskclock.R;
 import com.android.deskclock.Utils;
 import com.android.deskclock.provider.Alarm;
@@ -86,7 +88,8 @@ final class AlarmNotifications {
             AlarmInstance instance) {
         LogUtils.v("Displaying low priority notification for alarm instance: " + instance.mId);
 
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(context)
+        NotificationCompat.Builder builder = new NotificationCompat.Builder(context,
+                Channel.DEFAULT_NOTIFICATION)
                 .setShowWhen(false)
                 .setContentTitle(context.getString(
                         R.string.alarm_alert_predismiss_title))
@@ -135,7 +138,8 @@ final class AlarmNotifications {
             AlarmInstance instance) {
         LogUtils.v("Displaying high priority notification for alarm instance: " + instance.mId);
 
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(context)
+        NotificationCompat.Builder builder = new NotificationCompat.Builder(context,
+                Channel.HIGH_NOTIFICATION)
                 .setShowWhen(false)
                 .setContentTitle(context.getString(R.string.alarm_alert_predismiss_title))
                 .setContentText(AlarmUtils.getAlarmText(context, instance, true /* includeLabel */))
@@ -243,7 +247,7 @@ final class AlarmNotifications {
         Notification summary = getActiveGroupSummaryNotification(context, UPCOMING_GROUP_KEY);
         if (summary == null
                 || !Objects.equals(summary.contentIntent, firstUpcoming.contentIntent)) {
-            summary = new NotificationCompat.Builder(context)
+            summary = new NotificationCompat.Builder(context, Channel.HIGH_NOTIFICATION)
                     .setShowWhen(false)
                     .setContentIntent(firstUpcoming.contentIntent)
                     .setColor(ContextCompat.getColor(context, R.color.default_background))
@@ -277,7 +281,7 @@ final class AlarmNotifications {
         Notification summary = getActiveGroupSummaryNotification(context, MISSED_GROUP_KEY);
         if (summary == null
                 || !Objects.equals(summary.contentIntent, firstMissed.contentIntent)) {
-            summary = new NotificationCompat.Builder(context)
+            summary = new NotificationCompat.Builder(context, Channel.HIGH_NOTIFICATION)
                     .setShowWhen(false)
                     .setContentIntent(firstMissed.contentIntent)
                     .setColor(ContextCompat.getColor(context, R.color.default_background))
@@ -297,7 +301,8 @@ final class AlarmNotifications {
             AlarmInstance instance) {
         LogUtils.v("Displaying snoozed notification for alarm instance: " + instance.mId);
 
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(context)
+        NotificationCompat.Builder builder = new NotificationCompat.Builder(context,
+                Channel.HIGH_NOTIFICATION)
                 .setShowWhen(false)
                 .setContentTitle(instance.getLabelOrDefault(context))
                 .setContentText(context.getString(R.string.alarm_alert_snooze_until,
@@ -341,7 +346,9 @@ final class AlarmNotifications {
 
         String label = instance.mLabel;
         String alarmTime = AlarmUtils.getFormattedTime(context, instance.getAlarmTime());
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(context)
+
+        NotificationCompat.Builder builder = new NotificationCompat.Builder(context,
+                Channel.HIGH_NOTIFICATION)
                 .setShowWhen(false)
                 .setContentTitle(context.getString(R.string.alarm_missed_title))
                 .setContentText(instance.mLabel.isEmpty() ? alarmTime :
@@ -384,7 +391,9 @@ final class AlarmNotifications {
         LogUtils.v("Displaying alarm notification for alarm instance: " + instance.mId);
 
         Resources resources = service.getResources();
-        NotificationCompat.Builder notification = new NotificationCompat.Builder(service)
+
+        NotificationCompat.Builder notification = new NotificationCompat.Builder(service,
+                Channel.EVENT_EXPIRED)
                 .setContentTitle(instance.getLabelOrDefault(service))
                 .setContentText(AlarmUtils.getFormattedTime(service, instance.getAlarmTime()))
                 .setColor(ContextCompat.getColor(service, R.color.default_background))
@@ -434,6 +443,7 @@ final class AlarmNotifications {
                 true);
         notification.setPriority(NotificationCompat.PRIORITY_MAX);
 
+        NotificationChannelManager.applyChannel(notification, service, Channel.EVENT_EXPIRED);
         clearNotification(service, instance);
         service.startForeground(ALARM_FIRING_NOTIFICATION_ID, notification.build());
     }
diff --git a/src/com/android/deskclock/data/StopwatchNotificationBuilder.java b/src/com/android/deskclock/data/StopwatchNotificationBuilder.java
index 6e62f06f6..6bff9b981 100644
--- a/src/com/android/deskclock/data/StopwatchNotificationBuilder.java
+++ b/src/com/android/deskclock/data/StopwatchNotificationBuilder.java
@@ -33,6 +33,8 @@ import android.widget.RemoteViews;
 import com.android.deskclock.R;
 import com.android.deskclock.Utils;
 import com.android.deskclock.events.Events;
+import com.android.deskclock.NotificationChannelManager.Channel;
+import com.android.deskclock.NotificationChannelManager;
 import com.android.deskclock.stopwatch.StopwatchService;
 
 import java.util.ArrayList;
@@ -138,6 +140,7 @@ class StopwatchNotificationBuilder {
                 .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
                 .setColor(ContextCompat.getColor(context, R.color.default_background));
 
+        NotificationChannelManager.applyChannel(notification, context, Channel.HIGH_NOTIFICATION);
         if (Utils.isNOrLater()) {
             notification.setGroup(nm.getStopwatchNotificationGroupKey());
         }
diff --git a/src/com/android/deskclock/data/TimerNotificationBuilder.java b/src/com/android/deskclock/data/TimerNotificationBuilder.java
index 2119869ba..4f6057809 100644
--- a/src/com/android/deskclock/data/TimerNotificationBuilder.java
+++ b/src/com/android/deskclock/data/TimerNotificationBuilder.java
@@ -35,6 +35,9 @@ import com.android.deskclock.AlarmUtils;
 import com.android.deskclock.R;
 import com.android.deskclock.Utils;
 import com.android.deskclock.events.Events;
+import com.android.deskclock.NotificationChannelManager.Channel;
+import com.android.deskclock.NotificationChannelManager;
+
 import com.android.deskclock.timer.ExpiredTimersActivity;
 import com.android.deskclock.timer.TimerService;
 
@@ -162,6 +165,7 @@ class TimerNotificationBuilder {
                 .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
                 .setColor(ContextCompat.getColor(context, R.color.default_background));
 
+        NotificationChannelManager.applyChannel(notification, context, Channel.HIGH_NOTIFICATION);
         for (Action action : actions) {
             notification.addAction(action);
         }
@@ -278,6 +282,7 @@ class TimerNotificationBuilder {
             notification.addAction(action);
         }
 
+        NotificationChannelManager.applyChannel(notification, context, Channel.EVENT_EXPIRED);
         if (Utils.isNOrLater()) {
             notification.setCustomContentView(buildChronometer(pname, base, true, stateText));
         } else {
@@ -358,6 +363,7 @@ class TimerNotificationBuilder {
                 .addAction(action)
                 .setColor(ContextCompat.getColor(context, R.color.default_background));
 
+        NotificationChannelManager.applyChannel(notification, context, Channel.HIGH_NOTIFICATION);
         if (Utils.isNOrLater()) {
             notification.setCustomContentView(buildChronometer(pname, base, true, stateText))
                     .setGroup(nm.getTimerNotificationGroupKey());
-- 
2.17.0

