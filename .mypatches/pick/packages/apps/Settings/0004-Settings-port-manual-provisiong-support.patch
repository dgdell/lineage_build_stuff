From 54c645f5d0fb74d87a0425c155f0fb90b35caca6 Mon Sep 17 00:00:00 2001
From: Thecrazyskull <anaskarbila@gmail.com>
Date: Mon, 27 Feb 2017 16:15:22 -0500
Subject: [PATCH 4/8] Settings: port manual provisiong support

commit 7adcacb2b7b586f2cc1fe26db769e63553a89494
Author: Ricardo Cerqueira <ricardo@cyngn.com>
Date:   Thu Jul 28 12:29:40 2016 +0100

    SimSettings: Make provisioning optional even if qti-telephony is present

    Current code assumes the manual provisioning options should come
    up if the qti-telephony blob is present. Don't make that assumption.

    Change-Id: I5e4f28b628e3fe3fe9e506631e92c85103e87ccf

commit bdc7782bceb1dfe27996aa4be6bdbae865777aaa
Author: Venkatraman Nerellapalli <venkataraman.nerellapalli@codeaurora.org>
Date:   Sat Jan 9 17:20:00 2016 +0530

    Telephony(MSIM): Fix ANR on SIM deactivation

    Dismiss dialog box on confirmation.
    SIM activation & deactivation in background thread.

    Change-Id: I0268a710f35e30b2abec3dd671942b52fc0e0b46
    CRs-Fixed: 957308

commit e7f94ba9a879bd0928efade6ed3734eb829ed834
Author: Luca Stefani <luca.stefani.ge1@gmail.com>
Date:   Sun Jul 3 21:56:08 2016 +0200

    Settings: Disable sim switch if subscription isn't valid

    Change-Id: I22ba9a3270da13f77fdd43586b7dc487f0929453

commit c6856615eb456139108570dc855356e0cb95ab7c
Author: LuK1337 <priv.luk@gmail.com>
Date:   Sun Jul 3 22:11:26 2016 +0200

    Settings: Don't set the icon for sim activation / deactivation dialog

    * This icon doesn't look any good.
      It's better to just get rid of it.

    Change-Id: I47f70a80136695e9aa61ff98999a2cf770390079

commit 9e21654c1d8f3393cfb662866b64e3531645e31b
Author: LuK1337 <priv.luk@gmail.com>
Date:   Sun Jan 3 22:32:00 2016 +0100

    Hide manual provisioning switch when extphone framework is not present

    * It doesn't work without it.

    Change-Id: Iec11ec2006059f26668f2a6fee4c2c9ca6650119

commit 00823fa8f1f91da538440425e676b95b4d829457
Author: Ricardo Cerqueira <ricardo@cyngn.com>
Date:   Thu Nov 5 18:23:52 2015 +0000

    Break MSIM dependency on qci-telephony-framework

    If the provisioning state is invalid, the framework is most likely
    absent. Consider the card as provisioned to pass all relevant checks.

    Change-Id: I975ff156e4328e9d3f6e2626a863bbacb29e3337

commit e92619a138fc1a2370ed0d583bae0573c214eaf0
Author: Sandeep Gutta <sangutta@codeaurora.org>
Date:   Mon Sep 14 20:14:07 2015 +0530

    Telephony(MSIM): Select preferred primary sub.

    Add UI to select preferred primary sub.
    It is used when two SIM cards inserted have same
    priority as per policy.

    Change-Id: I5726fe9f4df03e680dc2406854d08da77297444d

commit dade627ff0569117908a5ef47f93251530c6f319
Author: Sandeep Gutta <sangutta@codeaurora.org>
Date:   Sun Sep 13 22:09:23 2015 +0530

    Telephony(MSIM): Fix to do not allow both SIM deactivation

    Use proper SubInfo record object to do not allow
    user to deactivate both SIMs on DSDS devices.

    Change-Id: I6f56d819367272b3a009c7a8133709c643e8bd84
    CRs-Fixed: 893504

commit d9983cb15c59672f3030869a6b5f143da5320866
Author: Sandeep Gutta <sangutta@codeaurora.org>
Date:   Mon Aug 10 15:09:59 2015 +0530

    Telephony(MSIM): Manual provision related fixes

    - Consider Manual provision state while displaying
      active sub info list.
    - Enable sms/data user preference option only
      if more than one subscription active.
    - Introduce below system proeprty to control AOSP
      behavior of user selection of fallback preference
      for sms/data
      "persist.radio.aosp_usr_pref_sel"

    Change-Id: I2b308b801f3f677c5a3ffaee5a8e6beda12aedd2

commit 86b04f6dfd56383bc0142cb5d03ebca9648b5061
Author: Chaitanya Saggurthi <csaggurt@codeaurora.org>
Date:   Thu Jul 16 16:33:34 2015 +0530

    Telephony(MSIM): Add Manual provisioning support

    Add toggle switch UI option in SimSettings screen to
    enable/disable SIM cards

    Change-Id: Id07271aedb12eabc0b106ac278ba2e12c71cfe03

Change-Id: Iead0e90ad52288ea023798a19f7178ef66414c7a

Clean up SIM enable toggle implementation

- Move strings to cm_strings.xml
- Improve string wording
- Remove unused code
- Streamline implementation
- Fix possible NPE on SIM settings shutdown
- RU
@xyyx: port to O

Change-Id: Iba3110c0bbc1038873510b17b88a5388285e08a8
---
 Android.mk                                    |   3 +-
 res/layout/custom_sim_switch.xml              |  39 ++
 res/values/cm_strings.xml                     |  18 +
 res/values/config.xml                         |   6 +
 src/com/android/settings/sim/SimSettings.java | 540 +++++++++++++++++++++++++-
 5 files changed, 597 insertions(+), 9 deletions(-)
 create mode 100644 res/layout/custom_sim_switch.xml

diff --git a/Android.mk b/Android.mk
index a72311d..0ea3df6 100644
--- a/Android.mk
+++ b/Android.mk
@@ -32,7 +32,8 @@ LOCAL_JAVA_LIBRARIES := \
     bouncycastle \
     core-oj \
     telephony-common \
-    ims-common
+    ims-common \
+    telephony-ext
 
 LOCAL_STATIC_JAVA_LIBRARIES := \
     jsr305 \
diff --git a/res/layout/custom_sim_switch.xml b/res/layout/custom_sim_switch.xml
new file mode 100644
index 0000000..8e540c3
--- /dev/null
+++ b/res/layout/custom_sim_switch.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ /* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+-->
+<Switch xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/sub_switch_widget"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_gravity="center"
+    android:clickable="true"
+    android:focusable="false"
+    android:padding="8dip" />
diff --git a/res/values/cm_strings.xml b/res/values/cm_strings.xml
index 7ecf489..b5a4b61 100644
--- a/res/values/cm_strings.xml
+++ b/res/values/cm_strings.xml
@@ -266,4 +266,22 @@
     <string name="app_ops_reset_confirm_mesg">Are you sure you wish to reset counters?</string>
 
     <string name="ok">OK</string>
+
+    <!-- Manual provisioning support -->
+    <string name="sim_enabler_summary"><xliff:g id="displayName">%1$s</xliff:g> is <xliff:g id="status" example="disabled">%2$s</xliff:g></string>
+    <string name="sim_enabled">enabled</string>
+    <string name="sim_disabled">disabled</string>
+    <string name="sim_missing">missing or faulty</string>
+    <string name="sim_enabler_need_disable_sim">SIM card will be deactivated. Do you want to continue?</string>
+    <string name="sim_enabler_will_disable_sim_title">Attention</string>
+    <string name="sim_enabler_need_switch_data_service">This SIM will be disabled and SIM <xliff:g id="slotid">%1$s</xliff:g> will be used for data services. Are you sure you want to continue?</string>
+    <string name="sim_enabler_airplane_on">Unable to perform the operation while airplane mode is on.</string>
+    <string name="sim_enabler_in_call">Unable to perform the operation while in call.</string>
+    <string name="sim_enabler_both_inactive">Can\'t disable all SIM cards</string>
+    <string name="sim_enabler_enabling">Activating\u2026</string>
+    <string name="sim_enabler_disabling">Deactivating\u2026</string>
+    <string name="sub_activate_success">SIM activated.</string>
+    <string name="sub_activate_failed">Activation failed.</string>
+    <string name="sub_deactivate_success">SIM deactivated.</string>
+    <string name="sub_deactivate_failed">Deactivation failed.</string>
 </resources>
diff --git a/res/values/config.xml b/res/values/config.xml
index e7febaa..354d293 100755
--- a/res/values/config.xml
+++ b/res/values/config.xml
@@ -127,4 +127,10 @@
     -->
     <integer name="config_fingerprintSensorLocation">0</integer>
 
+    <!-- Does the device allow for manual subscription provisioning? Only works for multi-sim devices,
+         and currently depends on QC's proprietary telephony stack -->
+    <bool name="config_enableManualSubProvisioning">false</bool>
+
+    <!-- Whether notify user that switch data service -->
+    <bool name="confirm_to_switch_data_service">false</bool>
 </resources>
diff --git a/src/com/android/settings/sim/SimSettings.java b/src/com/android/settings/sim/SimSettings.java
index 3d6bfb1..07ea2c3 100644
--- a/src/com/android/settings/sim/SimSettings.java
+++ b/src/com/android/settings/sim/SimSettings.java
@@ -16,15 +16,31 @@
 
 package com.android.settings.sim;
 
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.ProgressDialog;
+import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.res.Resources;
 import android.graphics.drawable.BitmapDrawable;
+import android.os.AsyncTask;
 import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
 import android.os.SystemProperties;
 import android.provider.SearchIndexableResource;
+import android.provider.Settings;
 import android.support.v7.preference.Preference;
+import android.support.v7.preference.PreferenceCategory;
+import android.support.v7.preference.PreferenceGroup;
+import android.support.v7.preference.PreferenceManager;
 import android.support.v7.preference.PreferenceScreen;
+import android.support.v7.preference.PreferenceViewHolder;
 import android.telecom.PhoneAccountHandle;
 import android.telecom.TelecomManager;
 import android.telephony.PhoneNumberUtils;
@@ -33,9 +49,16 @@ import android.telephony.SubscriptionInfo;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.AttributeSet;
 import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CompoundButton;
+import android.widget.CompoundButton.OnCheckedChangeListener;
 
 import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
+import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.TelephonyProperties;
 import com.android.settings.R;
 import com.android.settings.RestrictedSettingsFragment;
@@ -43,6 +66,8 @@ import com.android.settings.Utils;
 import com.android.settings.search.BaseSearchIndexProvider;
 import com.android.settings.search.Indexable;
 
+import org.codeaurora.internal.IExtTelephony;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -50,6 +75,13 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
     private static final String TAG = "SimSettings";
     private static final boolean DBG = false;
 
+    // These are the list of  possible values that
+    // IExtTelephony.getCurrentUiccCardProvisioningStatus() can return
+    private static final int PROVISIONED = 1;
+    private static final int NOT_PROVISIONED = 0;
+    private static final int INVALID_STATE = -1;
+    private static final int CARD_NOT_PRESENT = -2;
+
     private static final String DISALLOW_CONFIG_SIM = "no_config_sim";
     private static final String SIM_CARD_CATEGORY = "sim_cards";
     private static final String KEY_CELLULAR_DATA = "sim_cellular_data";
@@ -66,15 +98,25 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
     private List<SubscriptionInfo> mAvailableSubInfos = null;
     private List<SubscriptionInfo> mSubInfoList = null;
     private List<SubscriptionInfo> mSelectableSubInfos = null;
-    private PreferenceScreen mSimCards = null;
+    private PreferenceGroup mSimCards = null;
     private SubscriptionManager mSubscriptionManager;
     private int mNumSlots;
     private Context mContext;
+    private IExtTelephony mExtTelephony;
 
     private int mPhoneCount = TelephonyManager.getDefault().getPhoneCount();
     private int[] mCallState = new int[mPhoneCount];
     private PhoneStateListener[] mPhoneStateListener = new PhoneStateListener[mPhoneCount];
 
+    private AlertDialog mAlertDialog = null;
+    private ProgressDialog mProgressDialog = null;
+    private boolean mNeedsUpdate = false;
+    private int[] mUiccProvisionStatus = new int[mPhoneCount];
+
+    private static final String ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED =
+            "org.codeaurora.intent.action.ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED";
+    private static final String EXTRA_NEW_PROVISION_STATE = "newProvisionState";
+
     public SimSettings() {
         super(DISALLOW_CONFIG_SIM);
     }
@@ -92,13 +134,25 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         mSubscriptionManager = SubscriptionManager.from(getActivity());
         final TelephonyManager tm =
                 (TelephonyManager) getActivity().getSystemService(Context.TELEPHONY_SERVICE);
+        mExtTelephony = IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
+
         addPreferencesFromResource(R.xml.sim_settings);
 
         mNumSlots = tm.getSimCount();
-        mSimCards = (PreferenceScreen)findPreference(SIM_CARD_CATEGORY);
+        mSimCards = (PreferenceGroup)findPreference(SIM_CARD_CATEGORY);
         mAvailableSubInfos = new ArrayList<SubscriptionInfo>(mNumSlots);
         mSelectableSubInfos = new ArrayList<SubscriptionInfo>();
         SimSelectNotification.cancelNotification(getActivity());
+
+        IntentFilter intentFilter = new IntentFilter(ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED);
+        mContext.registerReceiver(mReceiver, intentFilter);
+    }
+
+    @Override
+    public void onDestroy() {
+        mContext.unregisterReceiver(mReceiver);
+        Log.d(TAG,"on onDestroy");
+        super.onDestroy();
     }
 
     private final SubscriptionManager.OnSubscriptionsChangedListener mOnSubscriptionsChangeListener
@@ -106,7 +160,9 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         @Override
         public void onSubscriptionsChanged() {
             if (DBG) log("onSubscriptionsChanged:");
-            updateSubscriptions();
+            if (isAdded()) {
+                updateSubscriptions();
+            }
         }
     };
 
@@ -124,11 +180,11 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         for (int i = 0; i < mNumSlots; ++i) {
             final SubscriptionInfo sir = mSubscriptionManager
                     .getActiveSubscriptionInfoForSimSlotIndex(i);
-            SimPreference simPreference = new SimPreference(getPrefContext(), sir, i);
+            SimPreference simPreference = new SimEnablerPreference(getPrefContext(), sir, i);
             simPreference.setOrder(i-mNumSlots);
             mSimCards.addPreference(simPreference);
             mAvailableSubInfos.add(sir);
-            if (sir != null) {
+            if (sir != null && mUiccProvisionStatus[i] == PROVISIONED) {
                 mSelectableSubInfos.add(sir);
             }
         }
@@ -234,6 +290,14 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
                 mPhoneStateListener[i] = null;
             }
         }
+
+        for (int i = 0; i < mSimCards.getPreferenceCount(); ++i) {
+            Preference pref = mSimCards.getPreference(i);
+            if (pref instanceof SimEnablerPreference) {
+                // Calling cleanUp() here to dismiss/cleanup any pending dialog exists.
+                ((SimEnablerPreference)pref).cleanUpPendingDialogs();
+            }
+        }
     }
 
     private PhoneStateListener getPhoneStateListener(int phoneId, int subId) {
@@ -277,14 +341,30 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         return true;
     }
 
+    @Override
+    public void onAttach(Context context) {
+        super.onAttach(context);
+        if (mNeedsUpdate) {
+            mNeedsUpdate = false;
+            updateAllOptions();
+        }
+    }
+
+    private void simEnablerUpdate() {
+        if (isAdded()) {
+            updateAllOptions();
+        } else {
+            mNeedsUpdate = true;
+        }
+    }
+
     private class SimPreference extends Preference {
-        private SubscriptionInfo mSubInfoRecord;
-        private int mSlotId;
+        SubscriptionInfo mSubInfoRecord;
+        int mSlotId;
         Context mContext;
 
         public SimPreference(Context context, SubscriptionInfo subInfoRecord, int slotId) {
             super(context);
-
             mContext = context;
             mSubInfoRecord = subInfoRecord;
             mSlotId = slotId;
@@ -305,6 +385,7 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
                             PhoneNumberUtils.createTtsSpannable(getPhoneNumber(mSubInfoRecord)));
                     setEnabled(true);
                 }
+                setSummary(determineSummary());
                 setIcon(new BitmapDrawable(res, (mSubInfoRecord.createIconBitmap(mContext))));
             } else {
                 setSummary(R.string.sim_slot_empty);
@@ -313,11 +394,437 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
             }
         }
 
+        protected boolean isValid() {
+            return mSubInfoRecord != null;
+        }
+
+        protected CharSequence determineSummary() {
+            CharSequence number = getPhoneNumber(mSubInfoRecord);
+            if (TextUtils.isEmpty(number)) {
+                return mSubInfoRecord.getDisplayName();
+            } else {
+                return mSubInfoRecord.getDisplayName() + " - " +
+                        PhoneNumberUtils.createTtsSpannable(number);
+            }
+        }
+
         private int getSlotId() {
             return mSlotId;
         }
     }
 
+    // This is to show SIM Enable options on/off on UI for user selection.
+    //  User can activate/de-activate through SIM on/off options.
+    private class SimEnablerPreference extends SimPreference implements OnCheckedChangeListener {
+        private static final int EVT_UPDATE = 1;
+        private static final int EVT_SHOW_RESULT_DLG = 2;
+        private static final int EVT_SHOW_PROGRESS_DLG = 3;
+        private static final int EVT_PROGRESS_DLG_TIME_OUT = 4;
+
+        private static final int CONFIRM_ALERT_DLG_ID = 1;
+        private static final int ERROR_ALERT_DLG_ID = 2;
+        private static final int RESULT_ALERT_DLG_ID = 3;
+
+        private boolean mCurrentUiccProvisionState;
+        private boolean mIsChecked;
+
+        private boolean mCmdInProgress = false;
+        private CompoundButton mSwitch;
+        //Delay for progress dialog to dismiss
+        private static final int PROGRESS_DLG_TIME_OUT = 30000;
+        private static final int MSG_DELAY_TIME = 2000;
+
+        public SimEnablerPreference(Context context, SubscriptionInfo sir, int slotId) {
+            super(context, sir, slotId);
+            setWidgetLayoutResource(R.layout.custom_sim_switch);
+        }
+
+        private void sendMessage(int event, Handler handler, int delay) {
+            Message message = handler.obtainMessage(event);
+            handler.sendMessageDelayed(message, delay);
+        }
+
+        private void sendMessage(int event, Handler handler, int delay, int arg1, int arg2) {
+            Message message = handler.obtainMessage(event, arg1, arg2);
+            handler.sendMessageDelayed(message, delay);
+        }
+
+        private boolean hasCard() {
+            return TelephonyManager.getDefault().hasIccCard(mSlotId);
+        }
+
+        private boolean isAirplaneModeOn() {
+            return (Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.AIRPLANE_MODE_ON, 0) != 0);
+        }
+
+        private int getProvisionStatus(int slotId) {
+            return mUiccProvisionStatus[slotId];
+        }
+
+        @Override
+        public void onBindViewHolder(PreferenceViewHolder holder) {
+            super.onBindViewHolder(holder);
+            logd("onBindView....");
+            mSwitch = (CompoundButton) holder.findViewById(R.id.sub_switch_widget);
+            mSwitch.setOnCheckedChangeListener(this);
+
+            // Hide manual provisioning if the extphone framework
+            // is not present, as the operation relies on said framework.
+            if (mExtTelephony == null ||
+                   !mContext.getResources().getBoolean(R.bool.config_enableManualSubProvisioning)) {
+                mSwitch.setVisibility(View.GONE);
+            } else {
+                mSwitch.setVisibility(View.VISIBLE);
+                mSwitch.setEnabled(!isAirplaneModeOn() || isValid());
+                setChecked(getProvisionStatus(mSlotId) == PROVISIONED);
+            }
+        }
+
+        @Override
+        public void update() {
+            final Resources res = mContext.getResources();
+            logd("update()" + mSubInfoRecord);
+
+            if (mExtTelephony != null) {
+                try {
+                    //get current provision state of the SIM.
+                    mUiccProvisionStatus[mSlotId] =
+                            mExtTelephony.getCurrentUiccCardProvisioningStatus(mSlotId);
+                } catch (RemoteException ex) {
+                    mUiccProvisionStatus[mSlotId] = INVALID_STATE;
+                    loge("Failed to get pref, slotId: "+ mSlotId +" Exception: " + ex);
+                }
+            } else {
+                // if we don't have telephony-ext, assume provisioned state
+                mUiccProvisionStatus[mSlotId] = PROVISIONED;
+            }
+
+            super.update();
+        }
+
+        // This method returns true if SubScription record corresponds to this
+        // Preference screen has a valid SIM and slot index/SubId.
+        @Override
+        protected boolean isValid() {
+            return super.isValid() && getProvisionStatus(mSlotId) >= 0;
+        }
+
+        // Based on the received SIM provision state this method
+        // sets the check box on Sim Preference UI and updates new
+        // state to mCurrentUiccProvisionState.
+        private void setChecked(boolean uiccProvisionState) {
+            logd("setChecked: uiccProvisionState " + uiccProvisionState + "sir:" + mSubInfoRecord);
+            if (mSwitch != null) {
+                mSwitch.setOnCheckedChangeListener(null);
+                // Do not update update checkstatus again in progress
+                if (!mCmdInProgress) {
+                    mSwitch.setChecked(uiccProvisionState);
+                }
+                mSwitch.setOnCheckedChangeListener(this);
+                mCurrentUiccProvisionState = uiccProvisionState;
+            }
+        }
+
+        @Override
+        protected CharSequence determineSummary() {
+            if (getProvisionStatus(mSlotId) != PROVISIONED) {
+                CharSequence state = mContext.getString(
+                        hasCard() ? R.string.sim_disabled : R.string.sim_missing);
+                return mContext.getString(R.string.sim_enabler_summary,
+                        mSubInfoRecord.getDisplayName(), state);
+            } else {
+                return super.determineSummary();
+            }
+        }
+
+        /**
+        * get number of Subs provisioned on the device
+        * @param context
+        * @return
+        */
+        public int getNumOfSubsProvisioned() {
+            int activeSubInfoCount = 0;
+            List<SubscriptionInfo> subInfoLists =
+                    mSubscriptionManager.getActiveSubscriptionInfoList();
+            if (subInfoLists != null) {
+                for (SubscriptionInfo subInfo : subInfoLists) {
+                    if (getProvisionStatus(subInfo.getSimSlotIndex()) == PROVISIONED) {
+                        activeSubInfoCount++;
+                    }
+                }
+            }
+            return activeSubInfoCount;
+        }
+
+        @Override
+        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+            mIsChecked = isChecked;
+            logd("onClick: " + isChecked);
+
+            handleUserRequest();
+        }
+
+        // This internal method called when user changes preference from UI
+        // 1. For activation/deactivation request from User, if device in APM mode
+        //    OR if voice call active on any SIM it dispay error dialog and returns.
+        // 2. For deactivation request it returns error dialog if only one SUB in
+        //    active state.
+        // 3. In other cases it sends user request to framework.
+        private void handleUserRequest() {
+            if (isAirplaneModeOn()) {
+                // do nothing but warning
+                logd("APM is on, EXIT!");
+                showAlertDialog(ERROR_ALERT_DLG_ID, R.string.sim_enabler_airplane_on);
+                return;
+            }
+            for (int i = 0; i < mPhoneCount; i++) {
+                int[] subId = SubscriptionManager.getSubId(i);
+                //when voice call in progress, subscription can't be activate/deactivate.
+                if (TelephonyManager.getDefault().getCallState(subId[0])
+                        != TelephonyManager.CALL_STATE_IDLE) {
+                    logd("Call state for phoneId: " + i + " is not idle, EXIT!");
+                    showAlertDialog(ERROR_ALERT_DLG_ID, R.string.sim_enabler_in_call);
+                    return;
+                }
+            }
+
+            if (!mIsChecked) {
+                if (getNumOfSubsProvisioned() > 1) {
+                    logd("More than one sub is active, Deactivation possible.");
+                    showAlertDialog(CONFIRM_ALERT_DLG_ID, 0);
+                } else {
+                    logd("Only one sub is active. Deactivation not possible.");
+                    showAlertDialog(ERROR_ALERT_DLG_ID, R.string.sim_enabler_both_inactive);
+                    return;
+                }
+            } else {
+                logd("Activate the sub");
+                sendUiccProvisioningRequest();
+            }
+        }
+
+        private void sendUiccProvisioningRequest() {
+            if (!mSwitch.isEnabled()) {
+                return;
+            }
+            new SimEnablerDisabler().execute();
+        }
+
+        private class SimEnablerDisabler extends AsyncTask<Void, Void, Integer> {
+
+            int newProvisionedState = NOT_PROVISIONED;
+
+            @Override
+            protected void onPreExecute() {
+                super.onPreExecute();
+                mCmdInProgress = true;
+                showProgressDialog();
+                setEnabled(false);
+            }
+
+            @Override
+            protected Integer doInBackground(Void... params) {
+                int result = -1;
+                newProvisionedState = NOT_PROVISIONED;
+                try {
+                    if (mIsChecked) {
+                        result = mExtTelephony.activateUiccCard(mSlotId);
+                        newProvisionedState = PROVISIONED;
+                    } else {
+                        result = mExtTelephony.deactivateUiccCard(mSlotId);
+                    }
+                } catch (RemoteException ex) {
+                    loge("Activate  sub failed " + result + " phoneId " + mSlotId);
+                } catch (NullPointerException ex) {
+                    loge("Failed to activate sub Exception: " + ex);
+                }
+                return result;
+            }
+
+            @Override
+            protected void onPostExecute(Integer result) {
+                processSetUiccDone(result.intValue(), newProvisionedState);
+            }
+        }
+
+        private void processSetUiccDone(int result, int newProvisionedState) {
+            sendMessage(EVT_UPDATE, mHandler, MSG_DELAY_TIME);
+            sendMessage(EVT_SHOW_RESULT_DLG, mHandler, MSG_DELAY_TIME, result, newProvisionedState);
+            mCmdInProgress = false;
+        }
+
+        private void showAlertDialog(int dialogId, int msgId) {
+            String title = mSubInfoRecord.getDisplayName().toString();
+            // Confirm only one AlertDialog instance to show.
+            dismissDialog(mAlertDialog);
+            dismissDialog(mProgressDialog);
+            AlertDialog.Builder builder = new AlertDialog.Builder(mContext)
+                    .setTitle(title);
+
+            switch(dialogId) {
+                case CONFIRM_ALERT_DLG_ID:
+                    String message;
+                    if (mContext.getResources().getBoolean(
+                            R.bool.confirm_to_switch_data_service)) {
+                        if (SubscriptionManager.getDefaultDataSubscriptionId() ==
+                                mSubInfoRecord.getSubscriptionId()) {
+                            message = mContext.getString(
+                                    R.string.sim_enabler_need_switch_data_service,
+                                    getProvisionedSlotId());
+                        } else {
+                            message = mContext.getString(R.string.sim_enabler_need_disable_sim);
+                        }
+                        builder.setTitle(R.string.sim_enabler_will_disable_sim_title);
+                    } else {
+                        message = mContext.getString(R.string.sim_enabler_need_disable_sim);
+                    }
+                    builder.setMessage(message);
+                    builder.setPositiveButton(android.R.string.ok, mDialogClickListener);
+                    builder.setNegativeButton(android.R.string.no, mDialogClickListener);
+                    builder.setOnCancelListener(mDialogCanceListener);
+                    break;
+
+                case ERROR_ALERT_DLG_ID:
+                    builder.setMessage(mContext.getString(msgId));
+                    builder.setNeutralButton(android.R.string.ok, mDialogClickListener);
+                    builder.setOnCancelListener(mDialogCanceListener);
+                    break;
+
+                case RESULT_ALERT_DLG_ID:
+                    String msg = mCurrentUiccProvisionState ?
+                             mContext.getString(R.string.sub_activate_success) :
+                            mContext.getString(R.string.sub_deactivate_success);
+                    builder.setMessage(msg);
+                    builder.setNeutralButton(android.R.string.ok, null);
+                    break;
+                default:
+                    break;
+            }
+
+            mAlertDialog = builder.create();
+            mAlertDialog.setCanceledOnTouchOutside(false);
+            mAlertDialog.show();
+        }
+
+        private int getProvisionedSlotId() {
+            int activeSlotId = -1;
+            List<SubscriptionInfo> subInfoLists =
+                    mSubscriptionManager.getActiveSubscriptionInfoList();
+            if (subInfoLists != null) {
+                for (SubscriptionInfo subInfo : subInfoLists) {
+                    if (getProvisionStatus(subInfo.getSimSlotIndex()) == PROVISIONED
+                            && subInfo.getSubscriptionId() != mSubInfoRecord.getSubscriptionId())
+                        activeSlotId = subInfo.getSimSlotIndex() + 1;
+                }
+            }
+            return activeSlotId;
+        }
+
+        private void showProgressDialog() {
+            String title = mSubInfoRecord.getDisplayName().toString();
+
+            String msg = mContext.getString(mIsChecked ? R.string.sim_enabler_enabling
+                    : R.string.sim_enabler_disabling);
+            dismissDialog(mProgressDialog);
+            mProgressDialog = new ProgressDialog(mContext);
+            mProgressDialog.setIndeterminate(true);
+            mProgressDialog.setTitle(title);
+            mProgressDialog.setMessage(msg);
+            mProgressDialog.setCancelable(false);
+            mProgressDialog.setCanceledOnTouchOutside(false);
+            mProgressDialog.show();
+
+            sendMessage(EVT_PROGRESS_DLG_TIME_OUT, mHandler, PROGRESS_DLG_TIME_OUT);
+        }
+
+        private void dismissDialog(Dialog dialog) {
+            if((dialog != null) && (dialog.isShowing())) {
+                dialog.dismiss();
+                dialog = null;
+            }
+        }
+
+        public void cleanUpPendingDialogs() {
+            dismissDialog(mProgressDialog);
+            dismissDialog(mAlertDialog);
+        }
+
+        private DialogInterface.OnClickListener mDialogClickListener = new DialogInterface
+                .OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                        if (which == DialogInterface.BUTTON_POSITIVE) {
+                            dismissDialog(mAlertDialog);
+                            sendUiccProvisioningRequest();
+                        } else if (which == DialogInterface.BUTTON_NEGATIVE) {
+                            update();
+                        } else if (which == DialogInterface.BUTTON_NEUTRAL) {
+                            update();
+                        }
+                    }
+                };
+
+        private DialogInterface.OnCancelListener mDialogCanceListener = new DialogInterface
+                .OnCancelListener() {
+                    public void onCancel(DialogInterface dialog) {
+                        update();
+                    }
+                };
+
+
+        private Handler mHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+
+                    switch(msg.what) {
+                        case EVT_UPDATE:
+                            simEnablerUpdate();
+
+                        case EVT_SHOW_RESULT_DLG:
+                            int result = msg.arg1;
+                            int newProvisionedState = msg.arg2;
+                            logd("EVT_SHOW_RESULT_DLG result: " + result +
+                                    " new provisioned state " + newProvisionedState);
+                            update();
+                            if (result != 0) {
+                                int msgId = (newProvisionedState == PROVISIONED) ?
+                                        R.string.sub_activate_failed :
+                                        R.string.sub_deactivate_failed;
+                                showAlertDialog(ERROR_ALERT_DLG_ID, msgId);
+                            } else {
+                                mCurrentUiccProvisionState = newProvisionedState == PROVISIONED;
+                                showAlertDialog(RESULT_ALERT_DLG_ID, 0);
+                            }
+                            mHandler.removeMessages(EVT_PROGRESS_DLG_TIME_OUT);
+                            break;
+
+                        case EVT_SHOW_PROGRESS_DLG:
+                            logd("EVT_SHOW_PROGRESS_DLG");
+                            showProgressDialog();
+                            break;
+
+                        case EVT_PROGRESS_DLG_TIME_OUT:
+                            logd("EVT_PROGRESS_DLG_TIME_OUT");
+                            dismissDialog(mProgressDialog);
+                            // Must update UI when time out
+                            update();
+                            break;
+
+                        default:
+                        break;
+                    }
+                }
+            };
+
+        private void logd(String msg) {
+            if (DBG) Log.d(TAG + "(" + mSlotId + ")", msg);
+        }
+
+        private void loge(String msg) {
+            if (DBG) Log.e(TAG + "(" + mSlotId + ")", msg);
+        }
+    }
+
     // Returns the line1Number. Line1number should always be read from TelephonyManager since it can
     // be overridden for display purposes.
     private String getPhoneNumber(SubscriptionInfo info) {
@@ -361,4 +868,21 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         Log.d(TAG, "isCallStateIdle " + callStateIdle);
         return callStateIdle;
     }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            Log.d(TAG, "Intent received: " + action);
+            if (ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED.equals(action)) {
+                int phoneId = intent.getIntExtra(PhoneConstants.PHONE_KEY,
+                        SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+                int newProvisionedState = intent.getIntExtra(EXTRA_NEW_PROVISION_STATE,
+                        NOT_PROVISIONED);
+                 updateSubscriptions();
+                 Log.d(TAG, "Received ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED on phoneId: "
+                         + phoneId + " new sub state " + newProvisionedState);
+            }
+        }
+    };
 }
-- 
2.7.4

