From c53682daf699efeeef96b7c7136566b2a8e31ed1 Mon Sep 17 00:00:00 2001
From: codeworkx <daniel.hillenbrand@codeworkx.de>
Date: Tue, 30 Jan 2018 19:59:15 +0100
Subject: [PATCH 1/3] DataUsageProvider: rebrand to lineageos

Change-Id: I1a3867c8cb599d53dea023110a8309505eb4e1b4
---
 Android.mk                                         |   3 +-
 AndroidManifest.xml                                |  16 +-
 .../cyanogenmod/providers/datausage/AppItem.java   |  85 ----
 .../providers/datausage/BootReceiver.java          |  38 --
 .../datausage/DataUsageAppInstallReceiver.java     |  49 --
 .../datausage/DataUsageAppInstallService.java      |  89 ----
 .../datausage/DataUsageConnectivityReceiver.java   |  43 --
 .../datausage/DataUsageNotificationReceiver.java   |  89 ----
 .../providers/datausage/DataUsageProvider.java     | 266 ----------
 .../providers/datausage/DataUsageService.java      | 560 --------------------
 .../datausage/DataUsageServiceEnableReceiver.java  |  33 --
 .../providers/datausage/DataUsageUtils.java        | 197 --------
 .../cyanogenmod/providers/datausage/UidDetail.java |  23 -
 .../providers/datausage/UidDetailProvider.java     | 175 -------
 src/org/lineage/providers/datausage/AppItem.java   |  86 ++++
 .../lineage/providers/datausage/BootReceiver.java  |  39 ++
 .../datausage/DataUsageAppInstallReceiver.java     |  50 ++
 .../datausage/DataUsageAppInstallService.java      |  90 ++++
 .../datausage/DataUsageConnectivityReceiver.java   |  44 ++
 .../datausage/DataUsageNotificationReceiver.java   |  90 ++++
 .../providers/datausage/DataUsageProvider.java     | 267 ++++++++++
 .../providers/datausage/DataUsageService.java      | 561 +++++++++++++++++++++
 .../datausage/DataUsageServiceEnableReceiver.java  |  34 ++
 .../providers/datausage/DataUsageUtils.java        | 198 ++++++++
 src/org/lineage/providers/datausage/UidDetail.java |  24 +
 .../providers/datausage/UidDetailProvider.java     | 176 +++++++
 26 files changed, 1670 insertions(+), 1655 deletions(-)
 delete mode 100644 src/org/cyanogenmod/providers/datausage/AppItem.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/BootReceiver.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageAppInstallReceiver.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageAppInstallService.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageConnectivityReceiver.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageNotificationReceiver.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageProvider.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageService.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageServiceEnableReceiver.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/DataUsageUtils.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/UidDetail.java
 delete mode 100644 src/org/cyanogenmod/providers/datausage/UidDetailProvider.java
 create mode 100644 src/org/lineage/providers/datausage/AppItem.java
 create mode 100644 src/org/lineage/providers/datausage/BootReceiver.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageAppInstallReceiver.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageAppInstallService.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageConnectivityReceiver.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageNotificationReceiver.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageProvider.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageService.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageServiceEnableReceiver.java
 create mode 100644 src/org/lineage/providers/datausage/DataUsageUtils.java
 create mode 100644 src/org/lineage/providers/datausage/UidDetail.java
 create mode 100644 src/org/lineage/providers/datausage/UidDetailProvider.java

diff --git a/Android.mk b/Android.mk
index 1d0fafd..cad858f 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,4 +1,5 @@
 # Copyright (C) 2016 The CyanogenMod Project
+# Copyright (C) 2018 The LineageOS Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -18,7 +19,7 @@ include $(CLEAR_VARS)
 LOCAL_MODULE_TAGS := optional
 
 LOCAL_STATIC_JAVA_LIBRARIES := \
-    org.cyanogenmod.platform.sdk \
+    org.lineageos.platform.sdk \
     android-support-v4 \
     android-support-v13 \
     gson
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 66f2b50..b41b802 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -2,6 +2,8 @@
 
 <!--
 Copyright (C) 2015 The CyanogenMod Project
+Copyright (C) 2018 The LineageOS Project
+
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
@@ -16,7 +18,7 @@ limitations under the License.
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="org.cyanogenmod.providers.datausage"
+          package="org.lineageos.providers.datausage"
           android:sharedUserId="android.uid.system"
           android:versionCode="1"
           android:versionName="1.0">
@@ -41,22 +43,22 @@ limitations under the License.
         </service>
 
         <provider android:name=".DataUsageProvider"
-                  android:authorities="org.cyanogenmod.providers.datausage"
-                  android:readPermission="cyanogenmod.permission.READ_DATAUSAGE"
-                  android:writePermission="cyanogenmod.permission.WRITE_DATAUSAGE"
+                  android:authorities="org.lineageos.providers.datausage"
+                  android:readPermission="lineageos.permission.READ_DATAUSAGE"
+                  android:writePermission="lineageos.permission.WRITE_DATAUSAGE"
                   android:exported="true">
         </provider>
 
         <receiver android:name=".DataUsageServiceEnableReceiver">
             <intent-filter>
-                <action android:name="org.cyanogenmod.providers.datausage.enable" />
+                <action android:name="org.lineageos.providers.datausage.enable" />
             </intent-filter>
         </receiver>
 
         <receiver android:name=".DataUsageNotificationReceiver">
             <intent-filter>
-                <action android:name="org.cyanogenmod.providers.datausage.hide_action"/>
-                <action android:name="org.cyanogenmod.providers.datausage.disable_action"/>
+                <action android:name="org.lineageos.providers.datausage.hide_action"/>
+                <action android:name="org.lineageos.providers.datausage.disable_action"/>
             </intent-filter>
         </receiver>
 
diff --git a/src/org/cyanogenmod/providers/datausage/AppItem.java b/src/org/cyanogenmod/providers/datausage/AppItem.java
deleted file mode 100644
index c81b5f7..0000000
--- a/src/org/cyanogenmod/providers/datausage/AppItem.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.SparseBooleanArray;
-
-public class AppItem implements Comparable<AppItem>, Parcelable {
-    public static final int CATEGORY_USER = 0;
-    public static final int CATEGORY_APP_TITLE = 1;
-    public static final int CATEGORY_APP = 2;
-
-    public final int key;
-    public boolean restricted;
-    public int category;
-
-    public SparseBooleanArray uids = new SparseBooleanArray();
-    public long total;
-
-    public AppItem() {
-        this.key = 0;
-    }
-
-    public AppItem(int key) {
-        this.key = key;
-    }
-
-    public AppItem(Parcel parcel) {
-        key = parcel.readInt();
-        uids = parcel.readSparseBooleanArray();
-        total = parcel.readLong();
-    }
-
-    public void addUid(int uid) {
-        uids.put(uid, true);
-    }
-
-    @Override
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeInt(key);
-        dest.writeSparseBooleanArray(uids);
-        dest.writeLong(total);
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-
-    @Override
-    public int compareTo(AppItem another) {
-        int comparison = Integer.compare(category, another.category);
-        if (comparison == 0) {
-            comparison = Long.compare(another.total, total);
-        }
-        return comparison;
-    }
-
-    public static final Creator<AppItem> CREATOR = new Creator<AppItem>() {
-        @Override
-        public AppItem createFromParcel(Parcel in) {
-            return new AppItem(in);
-        }
-
-        @Override
-        public AppItem[] newArray(int size) {
-            return new AppItem[size];
-        }
-    };
-}
diff --git a/src/org/cyanogenmod/providers/datausage/BootReceiver.java b/src/org/cyanogenmod/providers/datausage/BootReceiver.java
deleted file mode 100644
index bbae1df..0000000
--- a/src/org/cyanogenmod/providers/datausage/BootReceiver.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class BootReceiver extends BroadcastReceiver {
-
-    private static final String TAG = BootReceiver.class.getSimpleName();
-    private static final boolean DEBUG = true;
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        boolean qualified = DataUsageUtils.isDataUsageQualified(context);
-
-        // start DataUsage service once the device boots up, but only if
-        // on qualified network and the service itself is enabled from the Settings->DataUsage
-        if (qualified) {
-            DataUsageUtils.startDataUsageServiceIfEnabled(context);
-        }
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageAppInstallReceiver.java b/src/org/cyanogenmod/providers/datausage/DataUsageAppInstallReceiver.java
deleted file mode 100644
index 1b8c107..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageAppInstallReceiver.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-
-/**
- * This class implements the receiver that will handle app installs & uninstalls
- * when an app is installed, add an entry in the datausage table
- * when an app is removed, remove the entry from the datausage table
- */
-
-public class DataUsageAppInstallReceiver extends BroadcastReceiver {
-    private static final String TAG = DataUsageAppInstallReceiver.class.getSimpleName();
-    private static final boolean DEBUG = false;
-
-    @Override
-    public void onReceive(final Context context, Intent intent) {
-        if (DEBUG) {
-            Log.v(TAG, "AppInstallReceiver: onReceive");
-        }
-
-        Intent appInstallServiceIntent = new Intent(context, DataUsageAppInstallService.class);
-        appInstallServiceIntent.setAction(intent.getAction());
-        if (intent.hasExtra(Intent.EXTRA_UID)) {
-            appInstallServiceIntent.putExtra(
-                    Intent.EXTRA_UID,
-                    intent.getIntExtra(Intent.EXTRA_UID, 0));
-        }
-        context.startService(appInstallServiceIntent);
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageAppInstallService.java b/src/org/cyanogenmod/providers/datausage/DataUsageAppInstallService.java
deleted file mode 100644
index 3a9ccbf..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageAppInstallService.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-
-public class DataUsageAppInstallService extends IntentService {
-    private static final String TAG = DataUsageAppInstallService.class.getSimpleName();
-    private static final boolean DEBUG = true;
-
-    /**
-     * Creates an IntentService.  Invoked by your subclass's constructor.
-     *
-     * @param name Used to name the worker thread, important only for debugging.
-     */
-    public DataUsageAppInstallService() {
-        super(TAG);
-    }
-
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        String action = intent.getAction();
-        Context context = this;
-
-        final boolean added;
-        final boolean removed;
-        if (Intent.ACTION_PACKAGE_ADDED.equalsIgnoreCase(action)) {
-            added = true;
-            removed = false;
-        } else if (Intent.ACTION_PACKAGE_CHANGED.equalsIgnoreCase(action)) {
-            added = false;
-            removed = false;
-        } else if (Intent.ACTION_PACKAGE_REPLACED.equalsIgnoreCase(action)) {
-            added = false;
-            removed = false;
-        } else if (Intent.ACTION_PACKAGE_REMOVED.equalsIgnoreCase(action)) {
-            added = false;
-            removed = true;
-        } else if (Intent.ACTION_PACKAGE_FULLY_REMOVED.equalsIgnoreCase(action)) {
-            added = false;
-            removed = true;
-        } else {
-            Log.e(TAG, "Unknown Action:" + action);
-            return;
-        }
-
-        int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
-        if (uid <= 0) {
-            Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
-            return;
-        }
-
-        UidDetailProvider uidDetailProvider = new UidDetailProvider(context);
-        UidDetail uidDetail = uidDetailProvider.getUidDetail(uid, true);
-        String label = "";
-        if (uidDetail != null) {
-            label = uidDetail.label.toString();
-        }
-
-        if (added) {
-            if (DEBUG) {
-                Log.v(TAG, "Adding " + label + " to DataUsage DB");
-            }
-            DataUsageUtils.addApp(context, uid, label);
-        } else if (removed) {
-            if (DEBUG) {
-                Log.v(TAG, "Removing " + label + " to DataUsage DB");
-            }
-            DataUsageUtils.removeApp(context, uid);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageConnectivityReceiver.java b/src/org/cyanogenmod/providers/datausage/DataUsageConnectivityReceiver.java
deleted file mode 100644
index 0f6e0a5..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageConnectivityReceiver.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-
-
-public class DataUsageConnectivityReceiver extends BroadcastReceiver {
-    private static final String TAG = DataUsageConnectivityReceiver.class.getSimpleName();
-    private static final boolean DEBUG = true;
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        // datausage service is only run for metered mobile connections
-        boolean qualified = DataUsageUtils.isDataUsageQualified(context);
-        if (DEBUG) {
-            Log.v(TAG, "onReceived: qualified: " + qualified);
-        }
-        if (qualified) {
-            // start DataUsage service, but only if enabled
-            DataUsageUtils.startDataUsageServiceIfEnabled(context);
-        } else {
-            // stop DataUsage service
-            DataUsageUtils.enableDataUsageService(context, false);
-        }
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageNotificationReceiver.java b/src/org/cyanogenmod/providers/datausage/DataUsageNotificationReceiver.java
deleted file mode 100644
index 33534b2..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageNotificationReceiver.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.app.NotificationManager;
-import android.content.BroadcastReceiver;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-import android.widget.Toast;
-
-import android.net.NetworkPolicyManager;
-import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_DATA;
-
-import cyanogenmod.providers.DataUsageContract;
-
-
-/**
- * This class implements the receiver that will handle clicks on the buttons
- * in the Data Usage Notification
- * Disable - disables the wireless network traffic for the specified uid
- * Hide - disables data usage checks for the specified uid
- */
-
-public class DataUsageNotificationReceiver extends BroadcastReceiver {
-    private static final String TAG = DataUsageNotificationReceiver.class.getSimpleName();
-    private static final boolean DEBUG = true;
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        String action = intent.getAction();
-        int uid = 0;
-        String title;
-        if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID)) {
-            // Settings app uses long, but NetworkPolicyManager uses int
-            // I guess UIDs are limited to 32 bits, so casting should not cause a problem
-            uid = (int)intent.getLongExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID, 0);
-        }
-
-        if (uid == 0) {
-            Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
-            return;
-        }
-
-        if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE)) {
-            title = intent.getStringExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE);
-        } else {
-            title = "";
-        }
-
-        if (DataUsageService.HIDE_ACTION.equals(action)) {
-            Toast.makeText(context, context.getString(R.string.data_usage_hide_message, title),
-                    Toast.LENGTH_LONG).show();
-
-            ContentValues values = new ContentValues();
-            values.put(DataUsageContract.ENABLE, 0);
-            values.put(DataUsageContract.ACTIVE, 0);
-            values.put(DataUsageContract.BYTES, 0);
-
-            DataUsageUtils.enableApp(context, uid, false);
-
-        } else if (DataUsageService.DISABLE_ACTION.equals(action)) {
-            Toast.makeText(context, context.getString(R.string.data_usage_disable_message, title),
-                    Toast.LENGTH_LONG).show();
-            NetworkPolicyManager policyManager = NetworkPolicyManager.from(context);
-            policyManager.addUidPolicy(uid, POLICY_REJECT_ON_DATA);
-        }
-
-        // cancel the notification
-        NotificationManager notificationManager = (NotificationManager)context.getSystemService
-                (Context.NOTIFICATION_SERVICE);
-        notificationManager.cancel(DataUsageService.DATA_USAGE_SERVICE_NOTIFICATION_ID);
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageProvider.java b/src/org/cyanogenmod/providers/datausage/DataUsageProvider.java
deleted file mode 100644
index be87ea7..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageProvider.java
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.content.ContentProvider;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.UriMatcher;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.net.Uri;
-import android.provider.ContactsContract;
-import android.util.Log;
-
-import cyanogenmod.providers.DataUsageContract;
-
-/**
- * ContentProvider for the DataUsage statistics gathering of the Settings App
- * Keeps track of various per App configuration/state variables that are used to determine
- * if and when to generate an App specific DataUsage warning
- */
-
-public class DataUsageProvider extends ContentProvider {
-    private static final boolean DEBUG = false;
-    private static final String TAG = DataUsageProvider.class.getSimpleName();
-    private static final String DATABASE_NAME = "datausage.db";
-    private static final int DATABASE_VERSION = 1;
-
-    private DatabaseHelper mOpenHelper;
-
-    // define database matching constants
-    private static final int DATAUSAGE_ALL      = 0;
-    private static final int DATAUSAGE_ID       = 1;
-    private static final int DATAUSAGE_UID      = 2;
-
-    // build a URI matcher - add routes to it (if any)
-    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
-    static {
-        sURIMatcher.addURI(DataUsageContract.DATAUSAGE_AUTHORITY,
-                DataUsageContract.DATAUSAGE_TABLE,            DATAUSAGE_ALL);
-        sURIMatcher.addURI(DataUsageContract.DATAUSAGE_AUTHORITY,
-                DataUsageContract.DATAUSAGE_TABLE + "/#",     DATAUSAGE_ID);
-        sURIMatcher.addURI(DataUsageContract.DATAUSAGE_AUTHORITY,
-                DataUsageContract.DATAUSAGE_TABLE + "/uid/*", DATAUSAGE_UID);
-    }
-
-    // Database Helper Class
-    private static class DatabaseHelper extends SQLiteOpenHelper {
-        private Context mContext;
-
-        public DatabaseHelper (Context context) {
-            super(context, DATABASE_NAME, null, DATABASE_VERSION);
-            mContext = context;
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-            // setup database schema
-            db.execSQL(
-                    "CREATE TABLE " + DataUsageContract.DATAUSAGE_TABLE +
-                            "(" + DataUsageContract._ID + " INTEGER PRIMARY KEY, " +
-                            DataUsageContract.UID + " INTEGER, " +
-                            DataUsageContract.ENABLE + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.ACTIVE + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.LABEL + " STRING, " +
-                            DataUsageContract.BYTES + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.SLOW_AVG + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.SLOW_SAMPLES + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.FAST_AVG + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.FAST_SAMPLES + " INTEGER DEFAULT 0, " +
-                            DataUsageContract.EXTRA + " STRING );"
-            );
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            return;
-        }
-    }
-
-
-    @Override
-    public boolean onCreate() {
-        mOpenHelper = new DatabaseHelper(getContext());
-        return true;
-    }
-
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
-            String sortOrder
-    ) {
-        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
-        qb.setTables(DataUsageContract.DATAUSAGE_TABLE);
-
-        int match = sURIMatcher.match(uri);
-
-        if (DEBUG) {
-            Log.v(TAG, "Query uri=" + uri + ", match=" + match);
-        }
-
-        switch (match) {
-            case DATAUSAGE_ALL:
-                break;
-
-            case DATAUSAGE_ID:
-                break;
-
-            case DATAUSAGE_UID:
-                break;
-
-            default:
-                Log.e(TAG, "query: invalid request: " + uri);
-                return null;
-        }
-
-        Cursor cursor;
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-        cursor = qb.query(db, projection, selection, selectionArgs, null, null, sortOrder);
-
-        return cursor;
-    }
-
-    @Override
-    public String getType(Uri uri) {
-        int match = sURIMatcher.match(uri);
-
-        switch(match) {
-            case DATAUSAGE_ALL:
-                return "vnd.android.cursor.dir/datausage_entry";
-            case DATAUSAGE_ID:
-            case DATAUSAGE_UID:
-                return "vnd.android.cursor.item/datausage_entry";
-            default:
-                throw new IllegalArgumentException("UNKNOWN URI: " + uri);
-        }
-    }
-
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        int match = sURIMatcher.match(uri);
-        if (DEBUG) {
-            Log.v(TAG, "Insert uri=" + uri + ", match=" + match);
-        }
-
-        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-        long rowID = db.insert(DataUsageContract.DATAUSAGE_TABLE, null, values);
-
-        if (DEBUG) {
-            Log.v(TAG, "inserted " + values + " rowID=" + rowID);
-        }
-
-        return ContentUris.withAppendedId(DataUsageContract.CONTENT_URI, rowID);
-    }
-
-    @Override
-    public int delete(Uri uri, String selection, String[] selectionArgs) {
-        int match = sURIMatcher.match(uri);
-        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-
-        if (DEBUG) {
-            Log.v(TAG, "Delete uri=" + uri + ", match=" + match);
-        }
-
-        switch(match) {
-            case DATAUSAGE_ALL:
-                break;
-            case DATAUSAGE_UID:
-                if (selection != null || selectionArgs != null) {
-                    throw new UnsupportedOperationException(
-                            "Cannot delete URI:" + uri + " with a select clause"
-                    );
-                }
-                String uidNumber = uri.getLastPathSegment();
-                selection = DataUsageContract.UID + " = ? ";
-                selectionArgs = new String [] {uidNumber};
-                break;
-            default:
-                throw new UnsupportedOperationException(
-                        "Cannot delete URI:" + uri
-                );
-        }
-        int count = db.delete(DataUsageContract.DATAUSAGE_TABLE, selection, selectionArgs);
-        return count;
-    }
-
-    // update is always done by UID
-    @Override
-    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-        long count = 0;
-        int match = sURIMatcher.match(uri);
-        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-        String uid;
-
-        if (DEBUG) {
-            Log.v(TAG, "Update uri=" + uri + ", match=" + match);
-        }
-
-        switch(match) {
-            case DATAUSAGE_ALL:
-                uid = selectionArgs[0];
-                break;
-            case DATAUSAGE_UID:
-                if (selection != null || selectionArgs != null) {
-                    throw new UnsupportedOperationException(
-                            "Cannot update URI " + uri + " with a select clause"
-                    );
-                }
-                selection = DataUsageContract.UID + " = ? ";
-                uid = uri.getLastPathSegment();
-                selectionArgs = new String [] { uid };
-                break;
-            default:
-                throw new UnsupportedOperationException("Cannot update that URI: " + uri);
-
-        }
-
-        // if no record is found, then perform an insert, so make the db transaction atomic
-        if (DEBUG) {
-            Log.v(TAG, "Update: Values:" + values.toString() + " selection:" + selection + " " +
-                    " selectionArgs:" + selectionArgs[0]);
-        }
-
-        db.beginTransaction();
-        try {
-            count = db.update(DataUsageContract.DATAUSAGE_TABLE, values, selection, selectionArgs);
-
-            if (DEBUG) {
-                Log.v(TAG, "Update count:" + count);
-            }
-            if (count == 0) {
-                if (DEBUG) {
-                    Log.v(TAG, "Count==0, Performing Insert");
-                }
-                values.put(DataUsageContract.UID, uid);
-                count = db.insert(DataUsageContract.DATAUSAGE_TABLE, null, values);
-            }
-            db.setTransactionSuccessful();
-        } finally {
-            if (DEBUG) {
-                Log.v(TAG, "dbEndTransaction");
-            }
-            db.endTransaction();
-        }
-        if (DEBUG) {
-            Log.v(TAG, "Update result for uri=" + uri + " count=" + count);
-        }
-        return (int)count;
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageService.java b/src/org/cyanogenmod/providers/datausage/DataUsageService.java
deleted file mode 100644
index c4a9179..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageService.java
+++ /dev/null
@@ -1,560 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.app.ActivityManager;
-import android.app.IntentService;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.TaskStackBuilder;
-import android.content.ComponentName;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.database.Cursor;
-import android.net.ConnectivityManager;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.Settings;
-import android.telephony.TelephonyManager;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import android.net.NetworkTemplate;
-import static android.net.NetworkTemplate.buildTemplateMobileAll;
-import android.net.INetworkStatsService;
-import android.net.INetworkStatsSession;
-import static android.net.TrafficStats.UID_REMOVED;
-
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.net.NetworkStats;
-import android.os.ServiceManager;
-import android.os.SystemProperties;
-import android.content.pm.UserInfo;
-
-import android.util.SparseArray;
-import com.google.gson.Gson;
-
-import cyanogenmod.providers.DataUsageContract;
-import cyanogenmod.providers.CMSettings;
-
-
-/**
- * IntentService, launched by the AlarmManager at Boot Time from (BootReceiver) used
- * to collect per app cellular usage networking statistics and generate warning messages
- * to the user when an App consumes too much BW, giving the user an option to disable
- * Warning Message generation or to disable Network Access for the offending App
- */
-
-public class DataUsageService extends IntentService {
-    private final static String TAG = DataUsageService.class.getSimpleName();
-    private final static String TAB_MOBILE = "mobile";
-    private Context mContext;
-    private final static boolean DEBUG = false;
-
-    // Service worker tasks will run on the background thread, create a Handler to
-    // communicate with UI Thread, if needed
-    private Handler mUiHandler = new Handler();
-
-    private INetworkStatsService mStatsService;
-    private INetworkStatsSession mStatsSession;
-    private NetworkTemplate mTemplate;
-    private SubscriptionManager mSubscriptionManager;
-    private List<SubscriptionInfo> mSubInfoList;
-    private Map<Integer,String> mMobileTagMap;
-    private UserManager mUserManager;
-    private List<UserHandle> mProfiles;
-    private long mLargest;
-    private int mCurrentUserId;
-    private UidDetailProvider mUidDetailProvider;
-    SparseArray<AppItem> mKnownItems;
-    private NotificationManager mNotificationManager;
-
-    // quick way to generate warnings
-    // TODO - set to false before releasing
-    private static final boolean FAST_MODE = false;
-
-    // specifies minimum number of samples to collect before running algorithm
-    // 1 hours worth of active traffic to establish a baseline
-    private static final int MIN_SLOW_SAMPLE_COUNT = FAST_MODE ? 5 : 60;
-    // 5 min worth of active traffic
-    private static final int MIN_FAST_SAMPLE_COUNT = FAST_MODE ? 1 : 5;
-
-    // specifies percentage by which fast average must exceed slow avg to trigger a warning
-    // one standard deviation - or should it be 34%, since we are only looking at above and not
-    // below. And how many standard deviations should it be?
-    private static final int WARNING_PERCENTAGE = FAST_MODE ? 10 : 68;
-
-    // specifies the number of samples to keep in the database for postprocessing and
-    // algorithm evaluation
-    private final static int MAX_EXTRA_SAMPLE_COUNT = 1000;
-
-    // specifies maximum bw that is still considered as idle - to discard pings, etc...
-    private static final long MAX_IDLE_BW = 5 * 1024;
-    // specifies the sample period in msec
-    public static final long SAMPLE_PERIOD = 60000;
-    public static final long START_DELAY = 60000;
-
-    // notification ID to use by the DataUsageService for updates to notifications
-    public static final int DATA_USAGE_SERVICE_NOTIFICATION_ID = 102030;
-
-    public static final String HIDE_ACTION      =
-            "org.cyanogenmod.providers.datausage.hide_action";
-    public static final String DISABLE_ACTION   =
-            "org.cyanogenmod.providers.datausage.disable_action";
-    public static final int DATA_USAGE_BROADCAST_REQUEST_CODE   = 0x102040; // TODO - ???
-    public static final String DATA_USAGE_NOTIFICATION_UID   =
-            "org.cyanogenmod.providers.datausage.notification_uid";
-    public static final String DATA_USAGE_NOTIFICATION_TITLE =
-            "org.cyanogenmod.providers.datausage.notification_title";
-
-    public DataUsageService() {
-        super(TAG);
-    }
-
-    @android.support.annotation.Nullable
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-    /**
-     * When periodic alarm is generated, via AlarmManager, the Intent is delivered here
-     * @param intent
-     */
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        mContext = this;
-
-        // initialize various networking managers/interfaces/sessions/etc...
-        mStatsService = INetworkStatsService.Stub.asInterface(
-                ServiceManager.getService(Context.NETWORK_STATS_SERVICE));
-        mStatsSession = null;
-        try {
-            mStatsSession = mStatsService.openSession();
-            mSubscriptionManager = SubscriptionManager.from(mContext);
-            mSubInfoList = mSubscriptionManager.getActiveSubscriptionInfoList();
-            mMobileTagMap = initMobileTabTag(mSubInfoList);
-            mTemplate = buildTemplateMobileAll(
-                    getActiveSubscriberId(mContext, getSubId(TAB_MOBILE + "1")));
-        } catch (RemoteException e) {
-            Log.e(TAG, "RemoteException: " + e.getMessage());
-        }
-
-        mUserManager = (UserManager)mContext.getSystemService(Context.USER_SERVICE);
-        mProfiles = mUserManager.getUserProfiles();
-        mCurrentUserId = ActivityManager.getCurrentUser();
-        mUidDetailProvider = new UidDetailProvider(mContext);
-        mKnownItems = new SparseArray<AppItem>();
-        mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
-
-        // run the actual dataUsage collection and processing
-        dataUsageUpdate();
-    }
-
-    private static String getActiveSubscriberId(Context context, int subId) {
-        final TelephonyManager tele = TelephonyManager.from(context);
-        String retVal = tele.getSubscriberId(subId);
-        return retVal;
-    }
-
-
-    private int getSubId(String currentTab) {
-        if (mMobileTagMap != null) {
-            Set<Integer> set = mMobileTagMap.keySet();
-            for (Integer subId : set) {
-                if (mMobileTagMap.get(subId).equals(currentTab)) {
-                    return subId;
-                }
-            }
-        }
-        return -1;
-    }
-
-    private Map<Integer, String> initMobileTabTag(List<SubscriptionInfo> subInfoList) {
-        Map<Integer, String> map = null;
-        if (subInfoList != null) {
-            String mobileTag;
-            map = new HashMap<Integer, String>();
-            for (SubscriptionInfo subInfo : subInfoList) {
-                mobileTag = TAB_MOBILE + String.valueOf(subInfo.getSubscriptionId());
-                map.put(subInfo.getSubscriptionId(), mobileTag);
-            }
-        }
-        return map;
-    }
-
-    /**
-     * Accumulate data usage of a network stats entry for the item mapped by the collapse key.
-     * Creates the item, if needed
-     *
-     */
-    private void accumulate(int collapseKey, NetworkStats.Entry entry, int itemCategory) {
-        int uid = entry.uid;
-        AppItem item = mKnownItems.get(collapseKey);
-        if (item == null) {
-            item = new AppItem(collapseKey);
-            item.category = itemCategory;
-            mKnownItems.put(item.key, item);
-        }
-        item.addUid(uid);
-        item.total += entry.rxBytes + entry.txBytes;
-        if (mLargest < item.total) {
-            mLargest = item.total;
-        }
-
-    }
-
-    private void clearStats() {
-        for(int i = 0; i < mKnownItems.size(); i++) {
-            int key = mKnownItems.keyAt(i);
-            AppItem appItem = mKnownItems.get(key);
-            appItem.total = 0;
-        }
-    }
-
-    private class DataUsageExtraInfo {
-        ArrayList<Long> samples;
-    }
-    private String mAppWarnExtra;
-
-    private void dataUsageUpdate() {
-        long startTime = 0;
-        long endTime = System.currentTimeMillis();
-        mLargest = 0;
-
-        clearStats();
-
-        NetworkStats networkStats = null;
-        try {
-            if (mStatsSession != null) {
-                networkStats = mStatsSession.getSummaryForAllUid(mTemplate, startTime, endTime,
-                        false);
-            }
-        } catch (RemoteException e) {
-            Log.e(TAG, "RemoteException: " + e.getMessage());
-        }
-
-        // collect network stats for all app consuming bw
-        if (networkStats != null) {
-            int size = networkStats.size();
-            NetworkStats.Entry entry = null;
-
-            for(int i = 0; i < size; i++) {
-                entry = networkStats.getValues(i, entry);
-                int collapseKey;
-                int category;
-                int uid = entry.uid;
-                int userId = UserHandle.getUserId(uid);
-                if (UserHandle.isApp(uid)) {
-                    if (mProfiles.contains(new UserHandle(userId))) {
-                        if (userId != mCurrentUserId) {
-                            // add to a managed user item
-                            int managedKey = UidDetailProvider.buildKeyForUser(userId);
-                            accumulate(managedKey, entry, AppItem.CATEGORY_USER);
-                        }
-                        collapseKey = uid;
-                        category = AppItem.CATEGORY_APP;
-                    } else {
-                        // if it is a removed user, add it to the removed users' key
-                        UserInfo userInfo = mUserManager.getUserInfo(userId);
-                        if (userInfo == null) {
-                            collapseKey = UID_REMOVED;
-                            category = AppItem.CATEGORY_APP;
-                        } else {
-                            collapseKey = UidDetailProvider.buildKeyForUser(userId);
-                            category = AppItem.CATEGORY_USER;
-                        }
-                    }
-                    accumulate(collapseKey, entry, category);
-                }
-            }
-        }
-        boolean appWarnActive = false;
-        long appWarnBytes = 0;
-        long appWarnUid;
-        int appWarnSlowSamples;
-        int appWarnFastSamples;
-        long appWarnSlowAvg;
-        long appWarnFastAvg;
-        String appWarnExtra = "";
-
-        // lookup Apps in the DB that have warning enabled
-        Cursor cursor = getContentResolver().query(
-                DataUsageContract.CONTENT_URI,
-                null,       // projection - return all
-                DataUsageContract.ENABLE + " = ? ",
-                new String [] { "1" },
-                null
-        );
-        if (cursor == null) {
-            return;
-        }
-
-        while(cursor.moveToNext()) {
-            appWarnUid = cursor.getInt(DataUsageContract.COLUMN_OF_UID);
-            appWarnActive = cursor.getInt(DataUsageContract.COLUMN_OF_ACTIVE) > 0;
-            appWarnBytes = cursor.getLong(DataUsageContract.COLUMN_OF_BYTES);
-            appWarnSlowSamples = cursor.getInt(DataUsageContract.COLUMN_OF_SLOW_SAMPLES);
-            appWarnSlowAvg = cursor.getLong(DataUsageContract.COLUMN_OF_SLOW_AVG);
-            appWarnFastSamples = cursor.getInt(DataUsageContract.COLUMN_OF_FAST_SAMPLES);
-            appWarnFastAvg = cursor.getLong(DataUsageContract.COLUMN_OF_FAST_AVG);
-            mAppWarnExtra = cursor.getString(DataUsageContract.COLUMN_OF_EXTRA);
-
-            AppItem appItem = mKnownItems.get((int)appWarnUid);
-
-            if (appItem != null) {
-                final UidDetail detail = mUidDetailProvider.getUidDetail(appItem.key, true);
-                long bytesDelta = appWarnBytes == 0 ? 0 : appItem.total - appWarnBytes;
-                if (DEBUG) {
-                    Log.v(TAG, detail.label.toString() +
-                            " cur:" + appItem.total +
-                            " prev:" + appWarnBytes +
-                            " SlowSamples:" + appWarnSlowSamples +
-                            " SlowAvg:" + appWarnSlowAvg +
-                            " FastSamples:" + appWarnFastSamples +
-                            " FastAvg:" + appWarnFastAvg
-                    );
-                }
-                if (bytesDelta > MAX_IDLE_BW) {
-                    // enough BW consumed during this sample - evaluate algorithm
-                    if (appWarnSlowSamples < MIN_SLOW_SAMPLE_COUNT) {
-                        // not enough samples acquired for the slow average, keep accumulating
-                        // samples
-                        appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples,
-                                MIN_SLOW_SAMPLE_COUNT, bytesDelta);
-                        appWarnSlowSamples++;
-
-                        // fast average requires fewer samples than slow average, so at this point
-                        // we may have accumulated enough or not, need to check
-                        if (appWarnFastSamples < MIN_FAST_SAMPLE_COUNT) {
-                            // not enough fast samples
-                            appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples,
-                                    MIN_FAST_SAMPLE_COUNT, bytesDelta);
-                            appWarnFastSamples++;
-                        } else {
-                            // enough fast samples
-                            appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples,
-                                    MIN_FAST_SAMPLE_COUNT, bytesDelta);
-                        }
-
-                        updateDb(appItem.key,
-                                appWarnSlowAvg, appWarnSlowSamples,
-                                appWarnFastAvg, appWarnFastSamples,
-                                0, appItem.total);
-                    } else {
-                        // enough samples acquired for the average, evaluate warning algorithm
-                        float avgExceedPercent = appWarnFastAvg-appWarnSlowAvg;
-                        avgExceedPercent /= appWarnSlowAvg;
-                        avgExceedPercent *= 100;
-
-                        if ((appWarnFastAvg > appWarnSlowAvg) && (avgExceedPercent >
-                                WARNING_PERCENTAGE)) {
-                            genNotification(appItem.key, detail.label.toString(), !appWarnActive);
-                            if (!appWarnActive) {
-                                appWarnActive = true;
-                            }
-                        } else {
-                            appWarnActive = false;
-                        }
-                        appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples,
-                                MIN_SLOW_SAMPLE_COUNT, bytesDelta);
-                        appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples,
-                                MIN_FAST_SAMPLE_COUNT, bytesDelta);
-                        updateDb(
-                                appItem.key,
-                                appWarnSlowAvg, appWarnSlowSamples,
-                                appWarnFastAvg, appWarnFastSamples,
-                                appWarnActive ? 1 : 0, appItem.total
-                        );
-
-                    }
-                } else {
-                    // not enough BW consumed during this sample - simply update bytes
-                    updateDb(appItem.key, appItem.total);
-                }
-            }
-        }
-        cursor.close();
-    }
-
-    long computeAvg(long avg, int samples, int min_samples, long delta) {
-        float temp;
-
-        if (samples < min_samples) {
-            temp = avg * samples;
-            temp += delta;
-            temp /= (samples + 1);
-            return (long)temp;
-        } else {
-            temp = avg * (samples - 1);
-            temp += delta;
-            temp /= samples;
-            return (long)temp;
-        }
-    }
-
-
-    private void updateDb(int uid, long bytes) {
-        ContentValues values = new ContentValues();
-
-        values.put(DataUsageContract.BYTES, bytes);
-        getContentResolver().update(
-                DataUsageContract.CONTENT_URI,
-                values,
-                DataUsageContract.UID + " = ? ",
-                new String[]{String.valueOf(uid)}
-        );
-    }
-
-    private void updateDb(
-            int uid, long slowAvg, int slowSamples, long fastAvg, int fastSamples,
-            int active, long bytes
-    ) {
-        ContentValues values = new ContentValues();
-        String extraInfo = genExtraInfo(bytes);
-        values.put(DataUsageContract.SLOW_AVG, slowAvg);
-        values.put(DataUsageContract.SLOW_SAMPLES, slowSamples);
-        values.put(DataUsageContract.FAST_AVG, fastAvg);
-        values.put(DataUsageContract.FAST_SAMPLES, fastSamples);
-        values.put(DataUsageContract.ACTIVE, active);
-        values.put(DataUsageContract.BYTES, bytes);
-        values.put(DataUsageContract.EXTRA, extraInfo);
-
-        getContentResolver().update(
-                DataUsageContract.CONTENT_URI,
-                values,
-                DataUsageContract.UID + " = ? ",
-                new String[]{String.valueOf(uid)}
-        );
-    }
-
-
-    /**
-     * In debug mode, generate extra samples inforamation that can be used to analyze
-     * algorithm manually
-     */
-    private String genExtraInfo(long bytes) {
-        if (!DEBUG) {
-            return "";
-        }
-
-        Gson gson = new Gson();
-        DataUsageExtraInfo extraInfo;
-
-        if (mAppWarnExtra == null || mAppWarnExtra == "") {
-            extraInfo = null;
-        } else {
-            try {
-                extraInfo = gson.fromJson(mAppWarnExtra, DataUsageExtraInfo.class);
-            } catch (Exception e) {
-                extraInfo = null;
-            }
-        }
-
-        if (extraInfo == null) {
-            extraInfo = new DataUsageExtraInfo();
-            extraInfo.samples = new ArrayList<Long>();
-        }
-
-        if (extraInfo.samples.size() == MAX_EXTRA_SAMPLE_COUNT) {
-            extraInfo.samples.remove(0);
-        }
-        extraInfo.samples.add(bytes);
-        String extraInfoJson = gson.toJson(extraInfo);
-        return extraInfoJson;
-    }
-
-
-
-    private void genNotification(long uid, String appTitle, boolean firstTime) {
-        Intent hideIntent = new Intent();
-        hideIntent.setAction(HIDE_ACTION);
-        hideIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
-        hideIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
-        PendingIntent hidePendingIntent = PendingIntent.getBroadcast(
-                mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, hideIntent,
-                PendingIntent.FLAG_UPDATE_CURRENT
-        );
-
-        Intent disableIntent = new Intent();
-        disableIntent.setAction(DISABLE_ACTION);
-        disableIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
-        disableIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
-        PendingIntent disablePendingIntent = PendingIntent.getBroadcast(
-                mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, disableIntent,
-                PendingIntent.FLAG_UPDATE_CURRENT
-        );
-
-        Intent dataUsageIntent = new Intent();
-        dataUsageIntent.setAction(cyanogenmod.providers.CMSettings.ACTION_DATA_USAGE);
-        dataUsageIntent.addCategory(Intent.CATEGORY_DEFAULT);
-        dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
-        dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
-
-        PendingIntent dataUsagePendingIntent = PendingIntent.getActivity(mContext, 0,
-                dataUsageIntent, 0);
-
-        // NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)
-        Notification.Builder builder = new Notification.Builder(mContext)
-                .setSmallIcon(R.drawable.data_usage_48dp)
-                .setContentTitle(getResources().getString(R.string.data_usage_notify_title))
-                .setAutoCancel(true)        // remove notification when clicked on
-                .setContentText(appTitle)   // non-expanded view message
-                .setColor(mContext.getColor(R.color.data_usage_notification_icon_color))
-                .setStyle(new Notification.BigTextStyle()
-                        .bigText(getResources().getString(R.string.data_usage_notify_big_text, appTitle)));
-
-        if (firstTime) {
-            builder.addAction(
-                    // R.drawable.data_warning_disable,
-                    // android.R.drawable.stat_sys_data_bluetooth,
-                    R.drawable.data_usage_disable_24dp,
-                    getResources().getString(R.string.data_usage_disable_long),
-                    disablePendingIntent);
-        } else {
-            builder.addAction(
-                    // R.drawable.data_warning_disable,
-                    // android.R.drawable.stat_sys_data_bluetooth,
-                    R.drawable.data_usage_disable_24dp,
-                    getResources().getString(R.string.data_usage_disable_short),
-                    disablePendingIntent);
-            builder.addAction(
-                    // R.drawable.data_warning_hide,
-                    // android.R.drawable.stat_sys_download_done,
-                    R.drawable.data_usage_hide_24dp,
-                    getResources().getString(R.string.data_usage_hide),
-                    hidePendingIntent)
-            ;
-        }
-
-        builder.setContentIntent(dataUsagePendingIntent);
-        mNotificationManager.notify(DATA_USAGE_SERVICE_NOTIFICATION_ID, builder.build());
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageServiceEnableReceiver.java b/src/org/cyanogenmod/providers/datausage/DataUsageServiceEnableReceiver.java
deleted file mode 100644
index 739d41f..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageServiceEnableReceiver.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class DataUsageServiceEnableReceiver extends BroadcastReceiver {
-    private static final String TAG = DataUsageServiceEnableReceiver.class.getSimpleName();
-    public static final String PREF_FILE = "data_usage_service";
-    public static final String PREF_ENB_DATA_USAGE_NOTIFY = "enb_data_usage_notify";
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        boolean enb = intent.getBooleanExtra("enable", false);
-        DataUsageUtils.enableDataUsageService(context, enb);
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/DataUsageUtils.java b/src/org/cyanogenmod/providers/datausage/DataUsageUtils.java
deleted file mode 100644
index aab8e6d..0000000
--- a/src/org/cyanogenmod/providers/datausage/DataUsageUtils.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.app.AlarmManager;
-import android.app.PendingIntent;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.UserInfo;
-import android.database.Cursor;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.util.Log;
-
-import cyanogenmod.providers.DataUsageContract;
-
-
-public final class DataUsageUtils {
-
-    private static final String TAG = DataUsageUtils.class.getSimpleName();
-    private static final int DATAUSAGE_SERVICE_ALARM_ID = 0x102030;
-    private static boolean DEBUG = false;
-
-    public static final String PREF_FILE = "data_usage_service";
-    public static final String PREF_ENABLE_DATA_USAGE_NOTIFY = "enable_data_usage_notify";
-
-    /**
-     * Returns a label for the user, in the form of "User: user name" or "Work profile".
-     */
-    public static String getUserLabel(Context context, UserInfo info) {
-        String name = info != null ? info.name : null;
-        if (info.isManagedProfile()) {
-            // We use predefined values for managed profiles
-            return context.getString(R.string.managed_user_title);
-        } else if (info.isGuest()) {
-            name = context.getString(R.string.user_guest);
-        }
-        if (name == null && info != null) {
-            name = Integer.toString(info.id);
-        } else if (info == null) {
-            name = context.getString(R.string.unknown);
-        }
-        return context.getResources().getString(R.string.running_process_item_user_label, name);
-    }
-
-    public static void addApp(Context context, int uid, String label) {
-        if (DEBUG) {
-            Log.v(TAG, "addApp: uid:" + uid + " label:" + label);
-        }
-
-        ContentValues values = new ContentValues();
-
-        values.put(DataUsageContract.UID, uid);
-        values.put(DataUsageContract.LABEL, label);
-
-        context.getContentResolver().insert(
-                DataUsageContract.CONTENT_URI,
-                values
-        );
-    }
-
-    public static void removeApp(Context context, int uid) {
-        if (DEBUG) {
-            Log.v(TAG, "removeApp: uid:" + uid);
-        }
-        context.getContentResolver().delete(
-                DataUsageContract.CONTENT_URI,
-                DataUsageContract.UID + " = ? ",
-                new String [] { String.valueOf(uid)}
-        );
-    }
-
-    public static void enableApp(Context context, int uid, boolean enable) {
-        enableApp(context, uid, enable, null);
-    }
-
-    public static void enableApp(Context context, int uid, boolean enable, String label) {
-        if (DEBUG) {
-            Log.v(TAG, "enableApp: uid:" + uid + " enable:" + enable + ((label == null) ? "" :
-                    (" label:" + label)));
-        }
-        ContentValues values = new ContentValues();
-
-        values.put(DataUsageContract.ENABLE, enable);
-        if (label != null) {
-            values.put(DataUsageContract.LABEL, label);
-        }
-        context.getContentResolver().update(
-                DataUsageContract.CONTENT_URI,
-                values,
-                DataUsageContract.UID + " = ? ",
-                new String [] { String.valueOf(uid)}
-        );
-    }
-
-    public static boolean getAppEnable(Context context, int uid) {
-        boolean appEnable = false;
-        Cursor cursor = context.getContentResolver().query(
-                DataUsageContract.CONTENT_URI,
-                null,
-                DataUsageContract.UID + " = ? ",
-                new String [] { String.valueOf(uid) },
-                null
-        );
-        if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {
-            int enableValue = cursor.getInt(DataUsageContract.COLUMN_OF_ENABLE);
-            if (enableValue == 1) {
-                appEnable = true;
-            }
-        }
-
-        if (cursor != null) {
-            cursor.close();
-        }
-
-        if (DEBUG) {
-            Log.v(TAG, "getAppEnable: uid:" + uid + " enable:" + appEnable);
-        }
-
-        return appEnable;
-    }
-
-    public static void enableDataUsageService(Context context, boolean enable) {
-        SharedPreferences prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
-        prefs.edit().putBoolean(PREF_ENABLE_DATA_USAGE_NOTIFY, enable).apply();
-        // start DataUsage service, but only if on qualified mobile network
-        // if the service is not started now, it will be started when the network state changes
-        // and the connected network is qualified for the DataUsage service
-        if (isDataUsageQualified(context)) {
-            startDataUsageService(context, enable);
-        }
-    }
-
-    public static void startDataUsageService(Context context, boolean enable) {
-        Intent dataUsageServiceIntent = new Intent(context, DataUsageService.class);
-        PendingIntent alarmIntent = PendingIntent.getService(
-                context, DATAUSAGE_SERVICE_ALARM_ID, dataUsageServiceIntent, 0);
-        AlarmManager alarmManager = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
-
-        if (enable) {
-            alarmManager.setRepeating(
-                    AlarmManager.ELAPSED_REALTIME,
-                    DataUsageService.START_DELAY,
-                    DataUsageService.SAMPLE_PERIOD,
-                    alarmIntent
-            );
-        } else {
-            alarmManager.cancel(alarmIntent);
-        }
-        if (DEBUG) {
-            Log.v(TAG, "enableDataUsageService: enable:" + enable);
-        }
-    }
-
-    public static void startDataUsageServiceIfEnabled(Context context) {
-        SharedPreferences prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
-        boolean enable = prefs.getBoolean(PREF_ENABLE_DATA_USAGE_NOTIFY, false);
-        if (enable) {
-            startDataUsageService(context, true);
-        }
-        if (DEBUG) {
-            Log.v(TAG, "startDataUsageServiceIfEnabled: enable: " + enable);
-        }
-    }
-
-    // determine if the currently connected network qualified for the DataUsage service
-    public static boolean isDataUsageQualified(Context context) {
-        // only perform DataUsage collection for metered networks
-        ConnectivityManager connectivityManager =
-                (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
-        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
-        if (activeNetworkInfo != null) {
-            boolean isConnected = activeNetworkInfo.isConnected();
-            boolean isMobile = activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE;
-            boolean qualified = isConnected && isMobile && connectivityManager.isActiveNetworkMetered();
-            return qualified;
-        } else {
-            return false;
-        }
-    }
-}
diff --git a/src/org/cyanogenmod/providers/datausage/UidDetail.java b/src/org/cyanogenmod/providers/datausage/UidDetail.java
deleted file mode 100644
index 68a7a3e..0000000
--- a/src/org/cyanogenmod/providers/datausage/UidDetail.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.graphics.drawable.Drawable;
-
-public class UidDetail {
-    public CharSequence label;
-}
diff --git a/src/org/cyanogenmod/providers/datausage/UidDetailProvider.java b/src/org/cyanogenmod/providers/datausage/UidDetailProvider.java
deleted file mode 100644
index 0b93788..0000000
--- a/src/org/cyanogenmod/providers/datausage/UidDetailProvider.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2016, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.cyanogenmod.providers.datausage;
-
-import android.app.AppGlobals;
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.IPackageManager;
-import android.content.pm.UserInfo;
-import android.content.res.Resources;
-import android.graphics.drawable.Drawable;
-import android.net.TrafficStats;
-import android.os.RemoteException;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.text.TextUtils;
-import android.util.Log;
-import android.util.SparseArray;
-
-
-import android.content.pm.IPackageManager;
-import android.content.pm.UserInfo;
-
-
-/**
- * Return details about a specific UID, handling special cases like
- * {@link TrafficStats#UID_TETHERING} and {@link UserInfo}.
- */
-public class UidDetailProvider {
-    private static final String TAG = "DataUsage";
-    private final Context mContext;
-    private final SparseArray<UidDetail> mUidDetailCache;
-
-    public static final int OTHER_USER_RANGE_START = -2000;
-
-    public static int buildKeyForUser(int userHandle) {
-        return OTHER_USER_RANGE_START - userHandle;
-    }
-
-    public static boolean isKeyForUser(int key) {
-        return key <= OTHER_USER_RANGE_START;
-    }
-
-    public static int getUserIdForKey(int key) {
-        return OTHER_USER_RANGE_START - key;
-    }
-
-    public UidDetailProvider(Context context) {
-        mContext = context.getApplicationContext();
-        mUidDetailCache = new SparseArray<UidDetail>();
-    }
-
-    public void clearCache() {
-        synchronized (mUidDetailCache) {
-            mUidDetailCache.clear();
-        }
-    }
-
-    /**
-     * Resolve best descriptive label for the given UID.
-     */
-    public UidDetail getUidDetail(int uid, boolean blocking) {
-        UidDetail detail;
-
-        synchronized (mUidDetailCache) {
-            detail = mUidDetailCache.get(uid);
-        }
-
-        if (detail != null) {
-            return detail;
-        } else if (!blocking) {
-            return null;
-        }
-
-        detail = buildUidDetail(uid);
-
-        synchronized (mUidDetailCache) {
-            mUidDetailCache.put(uid, detail);
-        }
-
-        return detail;
-    }
-
-    /**
-     * Build {@link UidDetail} object, blocking until all {@link Drawable}
-     * lookup is finished.
-     */
-    private UidDetail buildUidDetail(int uid) {
-        final Resources res = mContext.getResources();
-        final PackageManager pm = mContext.getPackageManager();
-
-        final UidDetail detail = new UidDetail();
-        detail.label = pm.getNameForUid(uid);
-
-        // handle special case labels
-        switch (uid) {
-            case android.os.Process.SYSTEM_UID:
-                detail.label = res.getString(R.string.process_kernel_label);
-                return detail;
-            case TrafficStats.UID_REMOVED:
-                detail.label = res.getString(UserManager.supportsMultipleUsers()
-                        ? R.string.data_usage_uninstalled_apps_users
-                        : R.string.data_usage_uninstalled_apps);
-                return detail;
-        }
-
-        final UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
-
-        // Handle keys that are actually user handles
-        if (isKeyForUser(uid)) {
-            final int userHandle = getUserIdForKey(uid);
-            final UserInfo info = um.getUserInfo(userHandle);
-            if (info != null) {
-                detail.label = DataUsageUtils.getUserLabel(mContext, info);
-                return detail;
-            }
-        }
-
-        // otherwise fall back to using packagemanager labels
-        final String[] packageNames = pm.getPackagesForUid(uid);
-        final int length = packageNames != null ? packageNames.length : 0;
-        try {
-            final int userId = UserHandle.getUserId(uid);
-            UserHandle userHandle = new UserHandle(userId);
-            IPackageManager ipm = AppGlobals.getPackageManager();
-            if (length == 1) {
-                final ApplicationInfo info = ipm.getApplicationInfo(packageNames[0],
-                        0 /* no flags */, userId);
-                if (info != null) {
-                    detail.label = info.loadLabel(pm).toString();
-                }
-            } else if (length > 1) {
-                for (int i = 0; i < length; i++) {
-                    final String packageName = packageNames[i];
-                    final PackageInfo packageInfo = pm.getPackageInfo(packageName, 0);
-                    final ApplicationInfo appInfo = ipm.getApplicationInfo(packageName,
-                            0 /* no flags */, userId);
-
-                    if (appInfo != null) {
-                        if (packageInfo.sharedUserLabel != 0) {
-                            detail.label = pm.getText(packageName, packageInfo.sharedUserLabel,
-                                    packageInfo.applicationInfo).toString();
-                        }
-                    }
-                }
-            }
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.w(TAG, "Error while building UI detail for uid "+uid, e);
-        } catch (RemoteException e) {
-            Log.w(TAG, "Error while building UI detail for uid "+uid, e);
-        }
-
-        if (TextUtils.isEmpty(detail.label)) {
-            detail.label = Integer.toString(uid);
-        }
-
-        return detail;
-    }
-}
diff --git a/src/org/lineage/providers/datausage/AppItem.java b/src/org/lineage/providers/datausage/AppItem.java
new file mode 100644
index 0000000..2de9877
--- /dev/null
+++ b/src/org/lineage/providers/datausage/AppItem.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.SparseBooleanArray;
+
+public class AppItem implements Comparable<AppItem>, Parcelable {
+    public static final int CATEGORY_USER = 0;
+    public static final int CATEGORY_APP_TITLE = 1;
+    public static final int CATEGORY_APP = 2;
+
+    public final int key;
+    public boolean restricted;
+    public int category;
+
+    public SparseBooleanArray uids = new SparseBooleanArray();
+    public long total;
+
+    public AppItem() {
+        this.key = 0;
+    }
+
+    public AppItem(int key) {
+        this.key = key;
+    }
+
+    public AppItem(Parcel parcel) {
+        key = parcel.readInt();
+        uids = parcel.readSparseBooleanArray();
+        total = parcel.readLong();
+    }
+
+    public void addUid(int uid) {
+        uids.put(uid, true);
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(key);
+        dest.writeSparseBooleanArray(uids);
+        dest.writeLong(total);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public int compareTo(AppItem another) {
+        int comparison = Integer.compare(category, another.category);
+        if (comparison == 0) {
+            comparison = Long.compare(another.total, total);
+        }
+        return comparison;
+    }
+
+    public static final Creator<AppItem> CREATOR = new Creator<AppItem>() {
+        @Override
+        public AppItem createFromParcel(Parcel in) {
+            return new AppItem(in);
+        }
+
+        @Override
+        public AppItem[] newArray(int size) {
+            return new AppItem[size];
+        }
+    };
+}
diff --git a/src/org/lineage/providers/datausage/BootReceiver.java b/src/org/lineage/providers/datausage/BootReceiver.java
new file mode 100644
index 0000000..1b04a43
--- /dev/null
+++ b/src/org/lineage/providers/datausage/BootReceiver.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class BootReceiver extends BroadcastReceiver {
+
+    private static final String TAG = BootReceiver.class.getSimpleName();
+    private static final boolean DEBUG = true;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        boolean qualified = DataUsageUtils.isDataUsageQualified(context);
+
+        // start DataUsage service once the device boots up, but only if
+        // on qualified network and the service itself is enabled from the Settings->DataUsage
+        if (qualified) {
+            DataUsageUtils.startDataUsageServiceIfEnabled(context);
+        }
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageAppInstallReceiver.java b/src/org/lineage/providers/datausage/DataUsageAppInstallReceiver.java
new file mode 100644
index 0000000..e4e0f1f
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageAppInstallReceiver.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+/**
+ * This class implements the receiver that will handle app installs & uninstalls
+ * when an app is installed, add an entry in the datausage table
+ * when an app is removed, remove the entry from the datausage table
+ */
+
+public class DataUsageAppInstallReceiver extends BroadcastReceiver {
+    private static final String TAG = DataUsageAppInstallReceiver.class.getSimpleName();
+    private static final boolean DEBUG = false;
+
+    @Override
+    public void onReceive(final Context context, Intent intent) {
+        if (DEBUG) {
+            Log.v(TAG, "AppInstallReceiver: onReceive");
+        }
+
+        Intent appInstallServiceIntent = new Intent(context, DataUsageAppInstallService.class);
+        appInstallServiceIntent.setAction(intent.getAction());
+        if (intent.hasExtra(Intent.EXTRA_UID)) {
+            appInstallServiceIntent.putExtra(
+                    Intent.EXTRA_UID,
+                    intent.getIntExtra(Intent.EXTRA_UID, 0));
+        }
+        context.startService(appInstallServiceIntent);
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageAppInstallService.java b/src/org/lineage/providers/datausage/DataUsageAppInstallService.java
new file mode 100644
index 0000000..a5fa7d2
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageAppInstallService.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.app.IntentService;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+public class DataUsageAppInstallService extends IntentService {
+    private static final String TAG = DataUsageAppInstallService.class.getSimpleName();
+    private static final boolean DEBUG = true;
+
+    /**
+     * Creates an IntentService.  Invoked by your subclass's constructor.
+     *
+     * @param name Used to name the worker thread, important only for debugging.
+     */
+    public DataUsageAppInstallService() {
+        super(TAG);
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        String action = intent.getAction();
+        Context context = this;
+
+        final boolean added;
+        final boolean removed;
+        if (Intent.ACTION_PACKAGE_ADDED.equalsIgnoreCase(action)) {
+            added = true;
+            removed = false;
+        } else if (Intent.ACTION_PACKAGE_CHANGED.equalsIgnoreCase(action)) {
+            added = false;
+            removed = false;
+        } else if (Intent.ACTION_PACKAGE_REPLACED.equalsIgnoreCase(action)) {
+            added = false;
+            removed = false;
+        } else if (Intent.ACTION_PACKAGE_REMOVED.equalsIgnoreCase(action)) {
+            added = false;
+            removed = true;
+        } else if (Intent.ACTION_PACKAGE_FULLY_REMOVED.equalsIgnoreCase(action)) {
+            added = false;
+            removed = true;
+        } else {
+            Log.e(TAG, "Unknown Action:" + action);
+            return;
+        }
+
+        int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
+        if (uid <= 0) {
+            Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
+            return;
+        }
+
+        UidDetailProvider uidDetailProvider = new UidDetailProvider(context);
+        UidDetail uidDetail = uidDetailProvider.getUidDetail(uid, true);
+        String label = "";
+        if (uidDetail != null) {
+            label = uidDetail.label.toString();
+        }
+
+        if (added) {
+            if (DEBUG) {
+                Log.v(TAG, "Adding " + label + " to DataUsage DB");
+            }
+            DataUsageUtils.addApp(context, uid, label);
+        } else if (removed) {
+            if (DEBUG) {
+                Log.v(TAG, "Removing " + label + " to DataUsage DB");
+            }
+            DataUsageUtils.removeApp(context, uid);
+        }
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageConnectivityReceiver.java b/src/org/lineage/providers/datausage/DataUsageConnectivityReceiver.java
new file mode 100644
index 0000000..4982a37
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageConnectivityReceiver.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+
+public class DataUsageConnectivityReceiver extends BroadcastReceiver {
+    private static final String TAG = DataUsageConnectivityReceiver.class.getSimpleName();
+    private static final boolean DEBUG = true;
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // datausage service is only run for metered mobile connections
+        boolean qualified = DataUsageUtils.isDataUsageQualified(context);
+        if (DEBUG) {
+            Log.v(TAG, "onReceived: qualified: " + qualified);
+        }
+        if (qualified) {
+            // start DataUsage service, but only if enabled
+            DataUsageUtils.startDataUsageServiceIfEnabled(context);
+        } else {
+            // stop DataUsage service
+            DataUsageUtils.enableDataUsageService(context, false);
+        }
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageNotificationReceiver.java b/src/org/lineage/providers/datausage/DataUsageNotificationReceiver.java
new file mode 100644
index 0000000..6c7a806
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageNotificationReceiver.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project+
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.app.NotificationManager;
+import android.content.BroadcastReceiver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+import android.widget.Toast;
+
+import android.net.NetworkPolicyManager;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_DATA;
+
+import lineageos.providers.DataUsageContract;
+
+
+/**
+ * This class implements the receiver that will handle clicks on the buttons
+ * in the Data Usage Notification
+ * Disable - disables the wireless network traffic for the specified uid
+ * Hide - disables data usage checks for the specified uid
+ */
+
+public class DataUsageNotificationReceiver extends BroadcastReceiver {
+    private static final String TAG = DataUsageNotificationReceiver.class.getSimpleName();
+    private static final boolean DEBUG = true;
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        int uid = 0;
+        String title;
+        if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID)) {
+            // Settings app uses long, but NetworkPolicyManager uses int
+            // I guess UIDs are limited to 32 bits, so casting should not cause a problem
+            uid = (int)intent.getLongExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID, 0);
+        }
+
+        if (uid == 0) {
+            Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
+            return;
+        }
+
+        if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE)) {
+            title = intent.getStringExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE);
+        } else {
+            title = "";
+        }
+
+        if (DataUsageService.HIDE_ACTION.equals(action)) {
+            Toast.makeText(context, context.getString(R.string.data_usage_hide_message, title),
+                    Toast.LENGTH_LONG).show();
+
+            ContentValues values = new ContentValues();
+            values.put(DataUsageContract.ENABLE, 0);
+            values.put(DataUsageContract.ACTIVE, 0);
+            values.put(DataUsageContract.BYTES, 0);
+
+            DataUsageUtils.enableApp(context, uid, false);
+
+        } else if (DataUsageService.DISABLE_ACTION.equals(action)) {
+            Toast.makeText(context, context.getString(R.string.data_usage_disable_message, title),
+                    Toast.LENGTH_LONG).show();
+            NetworkPolicyManager policyManager = NetworkPolicyManager.from(context);
+            policyManager.addUidPolicy(uid, POLICY_REJECT_ON_DATA);
+        }
+
+        // cancel the notification
+        NotificationManager notificationManager = (NotificationManager)context.getSystemService
+                (Context.NOTIFICATION_SERVICE);
+        notificationManager.cancel(DataUsageService.DATA_USAGE_SERVICE_NOTIFICATION_ID);
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageProvider.java b/src/org/lineage/providers/datausage/DataUsageProvider.java
new file mode 100644
index 0000000..2cec42c
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageProvider.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import lineageos.providers.DataUsageContract;
+
+/**
+ * ContentProvider for the DataUsage statistics gathering of the Settings App
+ * Keeps track of various per App configuration/state variables that are used to determine
+ * if and when to generate an App specific DataUsage warning
+ */
+
+public class DataUsageProvider extends ContentProvider {
+    private static final boolean DEBUG = false;
+    private static final String TAG = DataUsageProvider.class.getSimpleName();
+    private static final String DATABASE_NAME = "datausage.db";
+    private static final int DATABASE_VERSION = 1;
+
+    private DatabaseHelper mOpenHelper;
+
+    // define database matching constants
+    private static final int DATAUSAGE_ALL      = 0;
+    private static final int DATAUSAGE_ID       = 1;
+    private static final int DATAUSAGE_UID      = 2;
+
+    // build a URI matcher - add routes to it (if any)
+    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    static {
+        sURIMatcher.addURI(DataUsageContract.DATAUSAGE_AUTHORITY,
+                DataUsageContract.DATAUSAGE_TABLE,            DATAUSAGE_ALL);
+        sURIMatcher.addURI(DataUsageContract.DATAUSAGE_AUTHORITY,
+                DataUsageContract.DATAUSAGE_TABLE + "/#",     DATAUSAGE_ID);
+        sURIMatcher.addURI(DataUsageContract.DATAUSAGE_AUTHORITY,
+                DataUsageContract.DATAUSAGE_TABLE + "/uid/*", DATAUSAGE_UID);
+    }
+
+    // Database Helper Class
+    private static class DatabaseHelper extends SQLiteOpenHelper {
+        private Context mContext;
+
+        public DatabaseHelper (Context context) {
+            super(context, DATABASE_NAME, null, DATABASE_VERSION);
+            mContext = context;
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            // setup database schema
+            db.execSQL(
+                    "CREATE TABLE " + DataUsageContract.DATAUSAGE_TABLE +
+                            "(" + DataUsageContract._ID + " INTEGER PRIMARY KEY, " +
+                            DataUsageContract.UID + " INTEGER, " +
+                            DataUsageContract.ENABLE + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.ACTIVE + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.LABEL + " STRING, " +
+                            DataUsageContract.BYTES + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.SLOW_AVG + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.SLOW_SAMPLES + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.FAST_AVG + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.FAST_SAMPLES + " INTEGER DEFAULT 0, " +
+                            DataUsageContract.EXTRA + " STRING );"
+            );
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            return;
+        }
+    }
+
+
+    @Override
+    public boolean onCreate() {
+        mOpenHelper = new DatabaseHelper(getContext());
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
+            String sortOrder
+    ) {
+        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+        qb.setTables(DataUsageContract.DATAUSAGE_TABLE);
+
+        int match = sURIMatcher.match(uri);
+
+        if (DEBUG) {
+            Log.v(TAG, "Query uri=" + uri + ", match=" + match);
+        }
+
+        switch (match) {
+            case DATAUSAGE_ALL:
+                break;
+
+            case DATAUSAGE_ID:
+                break;
+
+            case DATAUSAGE_UID:
+                break;
+
+            default:
+                Log.e(TAG, "query: invalid request: " + uri);
+                return null;
+        }
+
+        Cursor cursor;
+        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
+        cursor = qb.query(db, projection, selection, selectionArgs, null, null, sortOrder);
+
+        return cursor;
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        int match = sURIMatcher.match(uri);
+
+        switch(match) {
+            case DATAUSAGE_ALL:
+                return "vnd.android.cursor.dir/datausage_entry";
+            case DATAUSAGE_ID:
+            case DATAUSAGE_UID:
+                return "vnd.android.cursor.item/datausage_entry";
+            default:
+                throw new IllegalArgumentException("UNKNOWN URI: " + uri);
+        }
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        int match = sURIMatcher.match(uri);
+        if (DEBUG) {
+            Log.v(TAG, "Insert uri=" + uri + ", match=" + match);
+        }
+
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        long rowID = db.insert(DataUsageContract.DATAUSAGE_TABLE, null, values);
+
+        if (DEBUG) {
+            Log.v(TAG, "inserted " + values + " rowID=" + rowID);
+        }
+
+        return ContentUris.withAppendedId(DataUsageContract.CONTENT_URI, rowID);
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        int match = sURIMatcher.match(uri);
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+        if (DEBUG) {
+            Log.v(TAG, "Delete uri=" + uri + ", match=" + match);
+        }
+
+        switch(match) {
+            case DATAUSAGE_ALL:
+                break;
+            case DATAUSAGE_UID:
+                if (selection != null || selectionArgs != null) {
+                    throw new UnsupportedOperationException(
+                            "Cannot delete URI:" + uri + " with a select clause"
+                    );
+                }
+                String uidNumber = uri.getLastPathSegment();
+                selection = DataUsageContract.UID + " = ? ";
+                selectionArgs = new String [] {uidNumber};
+                break;
+            default:
+                throw new UnsupportedOperationException(
+                        "Cannot delete URI:" + uri
+                );
+        }
+        int count = db.delete(DataUsageContract.DATAUSAGE_TABLE, selection, selectionArgs);
+        return count;
+    }
+
+    // update is always done by UID
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        long count = 0;
+        int match = sURIMatcher.match(uri);
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        String uid;
+
+        if (DEBUG) {
+            Log.v(TAG, "Update uri=" + uri + ", match=" + match);
+        }
+
+        switch(match) {
+            case DATAUSAGE_ALL:
+                uid = selectionArgs[0];
+                break;
+            case DATAUSAGE_UID:
+                if (selection != null || selectionArgs != null) {
+                    throw new UnsupportedOperationException(
+                            "Cannot update URI " + uri + " with a select clause"
+                    );
+                }
+                selection = DataUsageContract.UID + " = ? ";
+                uid = uri.getLastPathSegment();
+                selectionArgs = new String [] { uid };
+                break;
+            default:
+                throw new UnsupportedOperationException("Cannot update that URI: " + uri);
+
+        }
+
+        // if no record is found, then perform an insert, so make the db transaction atomic
+        if (DEBUG) {
+            Log.v(TAG, "Update: Values:" + values.toString() + " selection:" + selection + " " +
+                    " selectionArgs:" + selectionArgs[0]);
+        }
+
+        db.beginTransaction();
+        try {
+            count = db.update(DataUsageContract.DATAUSAGE_TABLE, values, selection, selectionArgs);
+
+            if (DEBUG) {
+                Log.v(TAG, "Update count:" + count);
+            }
+            if (count == 0) {
+                if (DEBUG) {
+                    Log.v(TAG, "Count==0, Performing Insert");
+                }
+                values.put(DataUsageContract.UID, uid);
+                count = db.insert(DataUsageContract.DATAUSAGE_TABLE, null, values);
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            if (DEBUG) {
+                Log.v(TAG, "dbEndTransaction");
+            }
+            db.endTransaction();
+        }
+        if (DEBUG) {
+            Log.v(TAG, "Update result for uri=" + uri + " count=" + count);
+        }
+        return (int)count;
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageService.java b/src/org/lineage/providers/datausage/DataUsageService.java
new file mode 100644
index 0000000..f64e4bc
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageService.java
@@ -0,0 +1,561 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.app.ActivityManager;
+import android.app.IntentService;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.TaskStackBuilder;
+import android.content.ComponentName;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.ConnectivityManager;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import android.net.NetworkTemplate;
+import static android.net.NetworkTemplate.buildTemplateMobileAll;
+import android.net.INetworkStatsService;
+import android.net.INetworkStatsSession;
+import static android.net.TrafficStats.UID_REMOVED;
+
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.net.NetworkStats;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.content.pm.UserInfo;
+
+import android.util.SparseArray;
+import com.google.gson.Gson;
+
+import lineageos.providers.DataUsageContract;
+import lineageos.providers.CMSettings;
+
+
+/**
+ * IntentService, launched by the AlarmManager at Boot Time from (BootReceiver) used
+ * to collect per app cellular usage networking statistics and generate warning messages
+ * to the user when an App consumes too much BW, giving the user an option to disable
+ * Warning Message generation or to disable Network Access for the offending App
+ */
+
+public class DataUsageService extends IntentService {
+    private final static String TAG = DataUsageService.class.getSimpleName();
+    private final static String TAB_MOBILE = "mobile";
+    private Context mContext;
+    private final static boolean DEBUG = false;
+
+    // Service worker tasks will run on the background thread, create a Handler to
+    // communicate with UI Thread, if needed
+    private Handler mUiHandler = new Handler();
+
+    private INetworkStatsService mStatsService;
+    private INetworkStatsSession mStatsSession;
+    private NetworkTemplate mTemplate;
+    private SubscriptionManager mSubscriptionManager;
+    private List<SubscriptionInfo> mSubInfoList;
+    private Map<Integer,String> mMobileTagMap;
+    private UserManager mUserManager;
+    private List<UserHandle> mProfiles;
+    private long mLargest;
+    private int mCurrentUserId;
+    private UidDetailProvider mUidDetailProvider;
+    SparseArray<AppItem> mKnownItems;
+    private NotificationManager mNotificationManager;
+
+    // quick way to generate warnings
+    // TODO - set to false before releasing
+    private static final boolean FAST_MODE = false;
+
+    // specifies minimum number of samples to collect before running algorithm
+    // 1 hours worth of active traffic to establish a baseline
+    private static final int MIN_SLOW_SAMPLE_COUNT = FAST_MODE ? 5 : 60;
+    // 5 min worth of active traffic
+    private static final int MIN_FAST_SAMPLE_COUNT = FAST_MODE ? 1 : 5;
+
+    // specifies percentage by which fast average must exceed slow avg to trigger a warning
+    // one standard deviation - or should it be 34%, since we are only looking at above and not
+    // below. And how many standard deviations should it be?
+    private static final int WARNING_PERCENTAGE = FAST_MODE ? 10 : 68;
+
+    // specifies the number of samples to keep in the database for postprocessing and
+    // algorithm evaluation
+    private final static int MAX_EXTRA_SAMPLE_COUNT = 1000;
+
+    // specifies maximum bw that is still considered as idle - to discard pings, etc...
+    private static final long MAX_IDLE_BW = 5 * 1024;
+    // specifies the sample period in msec
+    public static final long SAMPLE_PERIOD = 60000;
+    public static final long START_DELAY = 60000;
+
+    // notification ID to use by the DataUsageService for updates to notifications
+    public static final int DATA_USAGE_SERVICE_NOTIFICATION_ID = 102030;
+
+    public static final String HIDE_ACTION      =
+            "org.lineageos.providers.datausage.hide_action";
+    public static final String DISABLE_ACTION   =
+            "org.lineageos.providers.datausage.disable_action";
+    public static final int DATA_USAGE_BROADCAST_REQUEST_CODE   = 0x102040; // TODO - ???
+    public static final String DATA_USAGE_NOTIFICATION_UID   =
+            "org.lineageos.providers.datausage.notification_uid";
+    public static final String DATA_USAGE_NOTIFICATION_TITLE =
+            "org.lineageos.providers.datausage.notification_title";
+
+    public DataUsageService() {
+        super(TAG);
+    }
+
+    @android.support.annotation.Nullable
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    /**
+     * When periodic alarm is generated, via AlarmManager, the Intent is delivered here
+     * @param intent
+     */
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        mContext = this;
+
+        // initialize various networking managers/interfaces/sessions/etc...
+        mStatsService = INetworkStatsService.Stub.asInterface(
+                ServiceManager.getService(Context.NETWORK_STATS_SERVICE));
+        mStatsSession = null;
+        try {
+            mStatsSession = mStatsService.openSession();
+            mSubscriptionManager = SubscriptionManager.from(mContext);
+            mSubInfoList = mSubscriptionManager.getActiveSubscriptionInfoList();
+            mMobileTagMap = initMobileTabTag(mSubInfoList);
+            mTemplate = buildTemplateMobileAll(
+                    getActiveSubscriberId(mContext, getSubId(TAB_MOBILE + "1")));
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException: " + e.getMessage());
+        }
+
+        mUserManager = (UserManager)mContext.getSystemService(Context.USER_SERVICE);
+        mProfiles = mUserManager.getUserProfiles();
+        mCurrentUserId = ActivityManager.getCurrentUser();
+        mUidDetailProvider = new UidDetailProvider(mContext);
+        mKnownItems = new SparseArray<AppItem>();
+        mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
+
+        // run the actual dataUsage collection and processing
+        dataUsageUpdate();
+    }
+
+    private static String getActiveSubscriberId(Context context, int subId) {
+        final TelephonyManager tele = TelephonyManager.from(context);
+        String retVal = tele.getSubscriberId(subId);
+        return retVal;
+    }
+
+
+    private int getSubId(String currentTab) {
+        if (mMobileTagMap != null) {
+            Set<Integer> set = mMobileTagMap.keySet();
+            for (Integer subId : set) {
+                if (mMobileTagMap.get(subId).equals(currentTab)) {
+                    return subId;
+                }
+            }
+        }
+        return -1;
+    }
+
+    private Map<Integer, String> initMobileTabTag(List<SubscriptionInfo> subInfoList) {
+        Map<Integer, String> map = null;
+        if (subInfoList != null) {
+            String mobileTag;
+            map = new HashMap<Integer, String>();
+            for (SubscriptionInfo subInfo : subInfoList) {
+                mobileTag = TAB_MOBILE + String.valueOf(subInfo.getSubscriptionId());
+                map.put(subInfo.getSubscriptionId(), mobileTag);
+            }
+        }
+        return map;
+    }
+
+    /**
+     * Accumulate data usage of a network stats entry for the item mapped by the collapse key.
+     * Creates the item, if needed
+     *
+     */
+    private void accumulate(int collapseKey, NetworkStats.Entry entry, int itemCategory) {
+        int uid = entry.uid;
+        AppItem item = mKnownItems.get(collapseKey);
+        if (item == null) {
+            item = new AppItem(collapseKey);
+            item.category = itemCategory;
+            mKnownItems.put(item.key, item);
+        }
+        item.addUid(uid);
+        item.total += entry.rxBytes + entry.txBytes;
+        if (mLargest < item.total) {
+            mLargest = item.total;
+        }
+
+    }
+
+    private void clearStats() {
+        for(int i = 0; i < mKnownItems.size(); i++) {
+            int key = mKnownItems.keyAt(i);
+            AppItem appItem = mKnownItems.get(key);
+            appItem.total = 0;
+        }
+    }
+
+    private class DataUsageExtraInfo {
+        ArrayList<Long> samples;
+    }
+    private String mAppWarnExtra;
+
+    private void dataUsageUpdate() {
+        long startTime = 0;
+        long endTime = System.currentTimeMillis();
+        mLargest = 0;
+
+        clearStats();
+
+        NetworkStats networkStats = null;
+        try {
+            if (mStatsSession != null) {
+                networkStats = mStatsSession.getSummaryForAllUid(mTemplate, startTime, endTime,
+                        false);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException: " + e.getMessage());
+        }
+
+        // collect network stats for all app consuming bw
+        if (networkStats != null) {
+            int size = networkStats.size();
+            NetworkStats.Entry entry = null;
+
+            for(int i = 0; i < size; i++) {
+                entry = networkStats.getValues(i, entry);
+                int collapseKey;
+                int category;
+                int uid = entry.uid;
+                int userId = UserHandle.getUserId(uid);
+                if (UserHandle.isApp(uid)) {
+                    if (mProfiles.contains(new UserHandle(userId))) {
+                        if (userId != mCurrentUserId) {
+                            // add to a managed user item
+                            int managedKey = UidDetailProvider.buildKeyForUser(userId);
+                            accumulate(managedKey, entry, AppItem.CATEGORY_USER);
+                        }
+                        collapseKey = uid;
+                        category = AppItem.CATEGORY_APP;
+                    } else {
+                        // if it is a removed user, add it to the removed users' key
+                        UserInfo userInfo = mUserManager.getUserInfo(userId);
+                        if (userInfo == null) {
+                            collapseKey = UID_REMOVED;
+                            category = AppItem.CATEGORY_APP;
+                        } else {
+                            collapseKey = UidDetailProvider.buildKeyForUser(userId);
+                            category = AppItem.CATEGORY_USER;
+                        }
+                    }
+                    accumulate(collapseKey, entry, category);
+                }
+            }
+        }
+        boolean appWarnActive = false;
+        long appWarnBytes = 0;
+        long appWarnUid;
+        int appWarnSlowSamples;
+        int appWarnFastSamples;
+        long appWarnSlowAvg;
+        long appWarnFastAvg;
+        String appWarnExtra = "";
+
+        // lookup Apps in the DB that have warning enabled
+        Cursor cursor = getContentResolver().query(
+                DataUsageContract.CONTENT_URI,
+                null,       // projection - return all
+                DataUsageContract.ENABLE + " = ? ",
+                new String [] { "1" },
+                null
+        );
+        if (cursor == null) {
+            return;
+        }
+
+        while(cursor.moveToNext()) {
+            appWarnUid = cursor.getInt(DataUsageContract.COLUMN_OF_UID);
+            appWarnActive = cursor.getInt(DataUsageContract.COLUMN_OF_ACTIVE) > 0;
+            appWarnBytes = cursor.getLong(DataUsageContract.COLUMN_OF_BYTES);
+            appWarnSlowSamples = cursor.getInt(DataUsageContract.COLUMN_OF_SLOW_SAMPLES);
+            appWarnSlowAvg = cursor.getLong(DataUsageContract.COLUMN_OF_SLOW_AVG);
+            appWarnFastSamples = cursor.getInt(DataUsageContract.COLUMN_OF_FAST_SAMPLES);
+            appWarnFastAvg = cursor.getLong(DataUsageContract.COLUMN_OF_FAST_AVG);
+            mAppWarnExtra = cursor.getString(DataUsageContract.COLUMN_OF_EXTRA);
+
+            AppItem appItem = mKnownItems.get((int)appWarnUid);
+
+            if (appItem != null) {
+                final UidDetail detail = mUidDetailProvider.getUidDetail(appItem.key, true);
+                long bytesDelta = appWarnBytes == 0 ? 0 : appItem.total - appWarnBytes;
+                if (DEBUG) {
+                    Log.v(TAG, detail.label.toString() +
+                            " cur:" + appItem.total +
+                            " prev:" + appWarnBytes +
+                            " SlowSamples:" + appWarnSlowSamples +
+                            " SlowAvg:" + appWarnSlowAvg +
+                            " FastSamples:" + appWarnFastSamples +
+                            " FastAvg:" + appWarnFastAvg
+                    );
+                }
+                if (bytesDelta > MAX_IDLE_BW) {
+                    // enough BW consumed during this sample - evaluate algorithm
+                    if (appWarnSlowSamples < MIN_SLOW_SAMPLE_COUNT) {
+                        // not enough samples acquired for the slow average, keep accumulating
+                        // samples
+                        appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples,
+                                MIN_SLOW_SAMPLE_COUNT, bytesDelta);
+                        appWarnSlowSamples++;
+
+                        // fast average requires fewer samples than slow average, so at this point
+                        // we may have accumulated enough or not, need to check
+                        if (appWarnFastSamples < MIN_FAST_SAMPLE_COUNT) {
+                            // not enough fast samples
+                            appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples,
+                                    MIN_FAST_SAMPLE_COUNT, bytesDelta);
+                            appWarnFastSamples++;
+                        } else {
+                            // enough fast samples
+                            appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples,
+                                    MIN_FAST_SAMPLE_COUNT, bytesDelta);
+                        }
+
+                        updateDb(appItem.key,
+                                appWarnSlowAvg, appWarnSlowSamples,
+                                appWarnFastAvg, appWarnFastSamples,
+                                0, appItem.total);
+                    } else {
+                        // enough samples acquired for the average, evaluate warning algorithm
+                        float avgExceedPercent = appWarnFastAvg-appWarnSlowAvg;
+                        avgExceedPercent /= appWarnSlowAvg;
+                        avgExceedPercent *= 100;
+
+                        if ((appWarnFastAvg > appWarnSlowAvg) && (avgExceedPercent >
+                                WARNING_PERCENTAGE)) {
+                            genNotification(appItem.key, detail.label.toString(), !appWarnActive);
+                            if (!appWarnActive) {
+                                appWarnActive = true;
+                            }
+                        } else {
+                            appWarnActive = false;
+                        }
+                        appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples,
+                                MIN_SLOW_SAMPLE_COUNT, bytesDelta);
+                        appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples,
+                                MIN_FAST_SAMPLE_COUNT, bytesDelta);
+                        updateDb(
+                                appItem.key,
+                                appWarnSlowAvg, appWarnSlowSamples,
+                                appWarnFastAvg, appWarnFastSamples,
+                                appWarnActive ? 1 : 0, appItem.total
+                        );
+
+                    }
+                } else {
+                    // not enough BW consumed during this sample - simply update bytes
+                    updateDb(appItem.key, appItem.total);
+                }
+            }
+        }
+        cursor.close();
+    }
+
+    long computeAvg(long avg, int samples, int min_samples, long delta) {
+        float temp;
+
+        if (samples < min_samples) {
+            temp = avg * samples;
+            temp += delta;
+            temp /= (samples + 1);
+            return (long)temp;
+        } else {
+            temp = avg * (samples - 1);
+            temp += delta;
+            temp /= samples;
+            return (long)temp;
+        }
+    }
+
+
+    private void updateDb(int uid, long bytes) {
+        ContentValues values = new ContentValues();
+
+        values.put(DataUsageContract.BYTES, bytes);
+        getContentResolver().update(
+                DataUsageContract.CONTENT_URI,
+                values,
+                DataUsageContract.UID + " = ? ",
+                new String[]{String.valueOf(uid)}
+        );
+    }
+
+    private void updateDb(
+            int uid, long slowAvg, int slowSamples, long fastAvg, int fastSamples,
+            int active, long bytes
+    ) {
+        ContentValues values = new ContentValues();
+        String extraInfo = genExtraInfo(bytes);
+        values.put(DataUsageContract.SLOW_AVG, slowAvg);
+        values.put(DataUsageContract.SLOW_SAMPLES, slowSamples);
+        values.put(DataUsageContract.FAST_AVG, fastAvg);
+        values.put(DataUsageContract.FAST_SAMPLES, fastSamples);
+        values.put(DataUsageContract.ACTIVE, active);
+        values.put(DataUsageContract.BYTES, bytes);
+        values.put(DataUsageContract.EXTRA, extraInfo);
+
+        getContentResolver().update(
+                DataUsageContract.CONTENT_URI,
+                values,
+                DataUsageContract.UID + " = ? ",
+                new String[]{String.valueOf(uid)}
+        );
+    }
+
+
+    /**
+     * In debug mode, generate extra samples inforamation that can be used to analyze
+     * algorithm manually
+     */
+    private String genExtraInfo(long bytes) {
+        if (!DEBUG) {
+            return "";
+        }
+
+        Gson gson = new Gson();
+        DataUsageExtraInfo extraInfo;
+
+        if (mAppWarnExtra == null || mAppWarnExtra == "") {
+            extraInfo = null;
+        } else {
+            try {
+                extraInfo = gson.fromJson(mAppWarnExtra, DataUsageExtraInfo.class);
+            } catch (Exception e) {
+                extraInfo = null;
+            }
+        }
+
+        if (extraInfo == null) {
+            extraInfo = new DataUsageExtraInfo();
+            extraInfo.samples = new ArrayList<Long>();
+        }
+
+        if (extraInfo.samples.size() == MAX_EXTRA_SAMPLE_COUNT) {
+            extraInfo.samples.remove(0);
+        }
+        extraInfo.samples.add(bytes);
+        String extraInfoJson = gson.toJson(extraInfo);
+        return extraInfoJson;
+    }
+
+
+
+    private void genNotification(long uid, String appTitle, boolean firstTime) {
+        Intent hideIntent = new Intent();
+        hideIntent.setAction(HIDE_ACTION);
+        hideIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
+        hideIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
+        PendingIntent hidePendingIntent = PendingIntent.getBroadcast(
+                mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, hideIntent,
+                PendingIntent.FLAG_UPDATE_CURRENT
+        );
+
+        Intent disableIntent = new Intent();
+        disableIntent.setAction(DISABLE_ACTION);
+        disableIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
+        disableIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
+        PendingIntent disablePendingIntent = PendingIntent.getBroadcast(
+                mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, disableIntent,
+                PendingIntent.FLAG_UPDATE_CURRENT
+        );
+
+        Intent dataUsageIntent = new Intent();
+        dataUsageIntent.setAction(lineageos.providers.CMSettings.ACTION_DATA_USAGE);
+        dataUsageIntent.addCategory(Intent.CATEGORY_DEFAULT);
+        dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
+        dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+
+        PendingIntent dataUsagePendingIntent = PendingIntent.getActivity(mContext, 0,
+                dataUsageIntent, 0);
+
+        // NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)
+        Notification.Builder builder = new Notification.Builder(mContext)
+                .setSmallIcon(R.drawable.data_usage_48dp)
+                .setContentTitle(getResources().getString(R.string.data_usage_notify_title))
+                .setAutoCancel(true)        // remove notification when clicked on
+                .setContentText(appTitle)   // non-expanded view message
+                .setColor(mContext.getColor(R.color.data_usage_notification_icon_color))
+                .setStyle(new Notification.BigTextStyle()
+                        .bigText(getResources().getString(R.string.data_usage_notify_big_text, appTitle)));
+
+        if (firstTime) {
+            builder.addAction(
+                    // R.drawable.data_warning_disable,
+                    // android.R.drawable.stat_sys_data_bluetooth,
+                    R.drawable.data_usage_disable_24dp,
+                    getResources().getString(R.string.data_usage_disable_long),
+                    disablePendingIntent);
+        } else {
+            builder.addAction(
+                    // R.drawable.data_warning_disable,
+                    // android.R.drawable.stat_sys_data_bluetooth,
+                    R.drawable.data_usage_disable_24dp,
+                    getResources().getString(R.string.data_usage_disable_short),
+                    disablePendingIntent);
+            builder.addAction(
+                    // R.drawable.data_warning_hide,
+                    // android.R.drawable.stat_sys_download_done,
+                    R.drawable.data_usage_hide_24dp,
+                    getResources().getString(R.string.data_usage_hide),
+                    hidePendingIntent)
+            ;
+        }
+
+        builder.setContentIntent(dataUsagePendingIntent);
+        mNotificationManager.notify(DATA_USAGE_SERVICE_NOTIFICATION_ID, builder.build());
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageServiceEnableReceiver.java b/src/org/lineage/providers/datausage/DataUsageServiceEnableReceiver.java
new file mode 100644
index 0000000..3f862bc
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageServiceEnableReceiver.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class DataUsageServiceEnableReceiver extends BroadcastReceiver {
+    private static final String TAG = DataUsageServiceEnableReceiver.class.getSimpleName();
+    public static final String PREF_FILE = "data_usage_service";
+    public static final String PREF_ENB_DATA_USAGE_NOTIFY = "enb_data_usage_notify";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        boolean enb = intent.getBooleanExtra("enable", false);
+        DataUsageUtils.enableDataUsageService(context, enb);
+    }
+}
diff --git a/src/org/lineage/providers/datausage/DataUsageUtils.java b/src/org/lineage/providers/datausage/DataUsageUtils.java
new file mode 100644
index 0000000..5c84962
--- /dev/null
+++ b/src/org/lineage/providers/datausage/DataUsageUtils.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.UserInfo;
+import android.database.Cursor;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.util.Log;
+
+import lineageos.providers.DataUsageContract;
+
+
+public final class DataUsageUtils {
+
+    private static final String TAG = DataUsageUtils.class.getSimpleName();
+    private static final int DATAUSAGE_SERVICE_ALARM_ID = 0x102030;
+    private static boolean DEBUG = false;
+
+    public static final String PREF_FILE = "data_usage_service";
+    public static final String PREF_ENABLE_DATA_USAGE_NOTIFY = "enable_data_usage_notify";
+
+    /**
+     * Returns a label for the user, in the form of "User: user name" or "Work profile".
+     */
+    public static String getUserLabel(Context context, UserInfo info) {
+        String name = info != null ? info.name : null;
+        if (info.isManagedProfile()) {
+            // We use predefined values for managed profiles
+            return context.getString(R.string.managed_user_title);
+        } else if (info.isGuest()) {
+            name = context.getString(R.string.user_guest);
+        }
+        if (name == null && info != null) {
+            name = Integer.toString(info.id);
+        } else if (info == null) {
+            name = context.getString(R.string.unknown);
+        }
+        return context.getResources().getString(R.string.running_process_item_user_label, name);
+    }
+
+    public static void addApp(Context context, int uid, String label) {
+        if (DEBUG) {
+            Log.v(TAG, "addApp: uid:" + uid + " label:" + label);
+        }
+
+        ContentValues values = new ContentValues();
+
+        values.put(DataUsageContract.UID, uid);
+        values.put(DataUsageContract.LABEL, label);
+
+        context.getContentResolver().insert(
+                DataUsageContract.CONTENT_URI,
+                values
+        );
+    }
+
+    public static void removeApp(Context context, int uid) {
+        if (DEBUG) {
+            Log.v(TAG, "removeApp: uid:" + uid);
+        }
+        context.getContentResolver().delete(
+                DataUsageContract.CONTENT_URI,
+                DataUsageContract.UID + " = ? ",
+                new String [] { String.valueOf(uid)}
+        );
+    }
+
+    public static void enableApp(Context context, int uid, boolean enable) {
+        enableApp(context, uid, enable, null);
+    }
+
+    public static void enableApp(Context context, int uid, boolean enable, String label) {
+        if (DEBUG) {
+            Log.v(TAG, "enableApp: uid:" + uid + " enable:" + enable + ((label == null) ? "" :
+                    (" label:" + label)));
+        }
+        ContentValues values = new ContentValues();
+
+        values.put(DataUsageContract.ENABLE, enable);
+        if (label != null) {
+            values.put(DataUsageContract.LABEL, label);
+        }
+        context.getContentResolver().update(
+                DataUsageContract.CONTENT_URI,
+                values,
+                DataUsageContract.UID + " = ? ",
+                new String [] { String.valueOf(uid)}
+        );
+    }
+
+    public static boolean getAppEnable(Context context, int uid) {
+        boolean appEnable = false;
+        Cursor cursor = context.getContentResolver().query(
+                DataUsageContract.CONTENT_URI,
+                null,
+                DataUsageContract.UID + " = ? ",
+                new String [] { String.valueOf(uid) },
+                null
+        );
+        if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {
+            int enableValue = cursor.getInt(DataUsageContract.COLUMN_OF_ENABLE);
+            if (enableValue == 1) {
+                appEnable = true;
+            }
+        }
+
+        if (cursor != null) {
+            cursor.close();
+        }
+
+        if (DEBUG) {
+            Log.v(TAG, "getAppEnable: uid:" + uid + " enable:" + appEnable);
+        }
+
+        return appEnable;
+    }
+
+    public static void enableDataUsageService(Context context, boolean enable) {
+        SharedPreferences prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
+        prefs.edit().putBoolean(PREF_ENABLE_DATA_USAGE_NOTIFY, enable).apply();
+        // start DataUsage service, but only if on qualified mobile network
+        // if the service is not started now, it will be started when the network state changes
+        // and the connected network is qualified for the DataUsage service
+        if (isDataUsageQualified(context)) {
+            startDataUsageService(context, enable);
+        }
+    }
+
+    public static void startDataUsageService(Context context, boolean enable) {
+        Intent dataUsageServiceIntent = new Intent(context, DataUsageService.class);
+        PendingIntent alarmIntent = PendingIntent.getService(
+                context, DATAUSAGE_SERVICE_ALARM_ID, dataUsageServiceIntent, 0);
+        AlarmManager alarmManager = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
+
+        if (enable) {
+            alarmManager.setRepeating(
+                    AlarmManager.ELAPSED_REALTIME,
+                    DataUsageService.START_DELAY,
+                    DataUsageService.SAMPLE_PERIOD,
+                    alarmIntent
+            );
+        } else {
+            alarmManager.cancel(alarmIntent);
+        }
+        if (DEBUG) {
+            Log.v(TAG, "enableDataUsageService: enable:" + enable);
+        }
+    }
+
+    public static void startDataUsageServiceIfEnabled(Context context) {
+        SharedPreferences prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
+        boolean enable = prefs.getBoolean(PREF_ENABLE_DATA_USAGE_NOTIFY, false);
+        if (enable) {
+            startDataUsageService(context, true);
+        }
+        if (DEBUG) {
+            Log.v(TAG, "startDataUsageServiceIfEnabled: enable: " + enable);
+        }
+    }
+
+    // determine if the currently connected network qualified for the DataUsage service
+    public static boolean isDataUsageQualified(Context context) {
+        // only perform DataUsage collection for metered networks
+        ConnectivityManager connectivityManager =
+                (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
+        if (activeNetworkInfo != null) {
+            boolean isConnected = activeNetworkInfo.isConnected();
+            boolean isMobile = activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE;
+            boolean qualified = isConnected && isMobile && connectivityManager.isActiveNetworkMetered();
+            return qualified;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/org/lineage/providers/datausage/UidDetail.java b/src/org/lineage/providers/datausage/UidDetail.java
new file mode 100644
index 0000000..4893c88
--- /dev/null
+++ b/src/org/lineage/providers/datausage/UidDetail.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.graphics.drawable.Drawable;
+
+public class UidDetail {
+    public CharSequence label;
+}
diff --git a/src/org/lineage/providers/datausage/UidDetailProvider.java b/src/org/lineage/providers/datausage/UidDetailProvider.java
new file mode 100644
index 0000000..a579d52
--- /dev/null
+++ b/src/org/lineage/providers/datausage/UidDetailProvider.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2016, The CyanogenMod Project
+ * Copyright (c) 2018, The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.providers.datausage;
+
+import android.app.AppGlobals;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.IPackageManager;
+import android.content.pm.UserInfo;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.net.TrafficStats;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseArray;
+
+
+import android.content.pm.IPackageManager;
+import android.content.pm.UserInfo;
+
+
+/**
+ * Return details about a specific UID, handling special cases like
+ * {@link TrafficStats#UID_TETHERING} and {@link UserInfo}.
+ */
+public class UidDetailProvider {
+    private static final String TAG = "DataUsage";
+    private final Context mContext;
+    private final SparseArray<UidDetail> mUidDetailCache;
+
+    public static final int OTHER_USER_RANGE_START = -2000;
+
+    public static int buildKeyForUser(int userHandle) {
+        return OTHER_USER_RANGE_START - userHandle;
+    }
+
+    public static boolean isKeyForUser(int key) {
+        return key <= OTHER_USER_RANGE_START;
+    }
+
+    public static int getUserIdForKey(int key) {
+        return OTHER_USER_RANGE_START - key;
+    }
+
+    public UidDetailProvider(Context context) {
+        mContext = context.getApplicationContext();
+        mUidDetailCache = new SparseArray<UidDetail>();
+    }
+
+    public void clearCache() {
+        synchronized (mUidDetailCache) {
+            mUidDetailCache.clear();
+        }
+    }
+
+    /**
+     * Resolve best descriptive label for the given UID.
+     */
+    public UidDetail getUidDetail(int uid, boolean blocking) {
+        UidDetail detail;
+
+        synchronized (mUidDetailCache) {
+            detail = mUidDetailCache.get(uid);
+        }
+
+        if (detail != null) {
+            return detail;
+        } else if (!blocking) {
+            return null;
+        }
+
+        detail = buildUidDetail(uid);
+
+        synchronized (mUidDetailCache) {
+            mUidDetailCache.put(uid, detail);
+        }
+
+        return detail;
+    }
+
+    /**
+     * Build {@link UidDetail} object, blocking until all {@link Drawable}
+     * lookup is finished.
+     */
+    private UidDetail buildUidDetail(int uid) {
+        final Resources res = mContext.getResources();
+        final PackageManager pm = mContext.getPackageManager();
+
+        final UidDetail detail = new UidDetail();
+        detail.label = pm.getNameForUid(uid);
+
+        // handle special case labels
+        switch (uid) {
+            case android.os.Process.SYSTEM_UID:
+                detail.label = res.getString(R.string.process_kernel_label);
+                return detail;
+            case TrafficStats.UID_REMOVED:
+                detail.label = res.getString(UserManager.supportsMultipleUsers()
+                        ? R.string.data_usage_uninstalled_apps_users
+                        : R.string.data_usage_uninstalled_apps);
+                return detail;
+        }
+
+        final UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
+
+        // Handle keys that are actually user handles
+        if (isKeyForUser(uid)) {
+            final int userHandle = getUserIdForKey(uid);
+            final UserInfo info = um.getUserInfo(userHandle);
+            if (info != null) {
+                detail.label = DataUsageUtils.getUserLabel(mContext, info);
+                return detail;
+            }
+        }
+
+        // otherwise fall back to using packagemanager labels
+        final String[] packageNames = pm.getPackagesForUid(uid);
+        final int length = packageNames != null ? packageNames.length : 0;
+        try {
+            final int userId = UserHandle.getUserId(uid);
+            UserHandle userHandle = new UserHandle(userId);
+            IPackageManager ipm = AppGlobals.getPackageManager();
+            if (length == 1) {
+                final ApplicationInfo info = ipm.getApplicationInfo(packageNames[0],
+                        0 /* no flags */, userId);
+                if (info != null) {
+                    detail.label = info.loadLabel(pm).toString();
+                }
+            } else if (length > 1) {
+                for (int i = 0; i < length; i++) {
+                    final String packageName = packageNames[i];
+                    final PackageInfo packageInfo = pm.getPackageInfo(packageName, 0);
+                    final ApplicationInfo appInfo = ipm.getApplicationInfo(packageName,
+                            0 /* no flags */, userId);
+
+                    if (appInfo != null) {
+                        if (packageInfo.sharedUserLabel != 0) {
+                            detail.label = pm.getText(packageName, packageInfo.sharedUserLabel,
+                                    packageInfo.applicationInfo).toString();
+                        }
+                    }
+                }
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.w(TAG, "Error while building UI detail for uid "+uid, e);
+        } catch (RemoteException e) {
+            Log.w(TAG, "Error while building UI detail for uid "+uid, e);
+        }
+
+        if (TextUtils.isEmpty(detail.label)) {
+            detail.label = Integer.toString(uid);
+        }
+
+        return detail;
+    }
+}
-- 
2.7.4

