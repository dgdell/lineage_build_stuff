From b2f4b505f3ede218e0139f7bc2b35ed7a55b5638 Mon Sep 17 00:00:00 2001
From: Danesh M <daneshm90@gmail.com>
Date: Mon, 29 Feb 2016 10:02:34 -0800
Subject: [PATCH 77/81] [2/3] NetworkManagement : Add ability to restrict app
 data/wifi usage

CYAN-3976
CRACKLING-834

Change-Id: Iaa0483d0ad64511184f0f31d93552a93fbab6dd0
---
 .../android/net/NetworkPolicyManager.java     |   4 +
 .../android/os/INetworkManagementService.aidl |   6 +
 .../server/NetworkManagementService.java      | 112 ++++++++++++++++++
 .../net/NetworkPolicyManagerService.java      |   9 ++
 4 files changed, 131 insertions(+)

diff --git a/core/java/android/net/NetworkPolicyManager.java b/core/java/android/net/NetworkPolicyManager.java
index 75fd77e70a1..f291c6724ad 100644
--- a/core/java/android/net/NetworkPolicyManager.java
+++ b/core/java/android/net/NetworkPolicyManager.java
@@ -54,6 +54,10 @@ public class NetworkPolicyManager {
     public static final int POLICY_REJECT_METERED_BACKGROUND = 0x1;
     /** Allow metered network use in the background even when in data usage save mode. */
     public static final int POLICY_ALLOW_METERED_BACKGROUND = 0x4;
+    /** Reject application network traffic on cellular network */
+    public static final int POLICY_REJECT_ON_DATA = 0x10000;
+    /** Reject application network traffic on wifi network */
+    public static final int POLICY_REJECT_ON_WLAN = 0x8000;
 
     /*
      * Rules defining whether an uid has access to a network given its type (metered / non-metered).
diff --git a/core/java/android/os/INetworkManagementService.aidl b/core/java/android/os/INetworkManagementService.aidl
index 31dbafad62e..48515978323 100644
--- a/core/java/android/os/INetworkManagementService.aidl
+++ b/core/java/android/os/INetworkManagementService.aidl
@@ -450,4 +450,10 @@ interface INetworkManagementService
     void setAllowOnlyVpnForUids(boolean enable, in UidRange[] uidRanges);
 
     boolean isNetworkRestricted(int uid);
+
+    /**
+     * Restrict UID from accessing data/wifi
+     */
+    void restrictAppOnData(int uid, boolean restrict);
+    void restrictAppOnWlan(int uid, boolean restrict);
 }
diff --git a/services/core/java/com/android/server/NetworkManagementService.java b/services/core/java/com/android/server/NetworkManagementService.java
index 6d6fd84dafa..0383e0449c7 100644
--- a/services/core/java/com/android/server/NetworkManagementService.java
+++ b/services/core/java/com/android/server/NetworkManagementService.java
@@ -53,8 +53,11 @@ import static com.android.server.NetworkManagementSocketTagger.PROP_QTAGUID_ENAB
 
 import android.annotation.NonNull;
 import android.app.ActivityManager;
+import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.INetd;
 import android.net.INetworkManagementEventObserver;
@@ -62,6 +65,7 @@ import android.net.ITetheringStatsProvider;
 import android.net.InterfaceConfiguration;
 import android.net.IpPrefix;
 import android.net.LinkAddress;
+import android.net.LinkProperties;
 import android.net.Network;
 import android.net.NetworkPolicyManager;
 import android.net.NetworkStats;
@@ -236,6 +240,10 @@ public class NetworkManagementService extends INetworkManagementService.Stub
 
     private INetd mNetdService;
 
+    private String mDataInterfaceName;
+    private String mWlanInterfaceName;
+    private BroadcastReceiver mPendingDataRestrictReceiver;
+
     private IBatteryStats mBatteryStats;
 
     private final Thread mThread;
@@ -269,6 +277,12 @@ public class NetworkManagementService extends INetworkManagementService.Stub
     /** Set of UIDs whitelisted on metered networks. */
     @GuardedBy("mRulesLock")
     private SparseBooleanArray mUidAllowOnMetered = new SparseBooleanArray();
+    /** Set of UIDs blacklisted on cellular networks. */
+    @GuardedBy("mQuotaLock")
+    final SparseBooleanArray mDataBlacklist = new SparseBooleanArray();
+    /** Set of UIDs blacklisted on WiFi networks. */
+    @GuardedBy("mQuotaLock")
+    final SparseBooleanArray mWlanBlacklist = new SparseBooleanArray();
     /** Set of UIDs with cleartext penalties. */
     @GuardedBy("mQuotaLock")
     private SparseIntArray mUidCleartextPolicy = new SparseIntArray();
@@ -326,6 +340,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub
     private final RemoteCallbackList<INetworkActivityListener> mNetworkActivityListeners =
             new RemoteCallbackList<>();
     private boolean mNetworkActive;
+    private SparseBooleanArray mPendingRestrictOnData = new SparseBooleanArray();
 
     /**
      * Constructs a new NetworkManagementService instance
@@ -352,6 +367,8 @@ public class NetworkManagementService extends INetworkManagementService.Stub
                 FgThread.get().getLooper());
         mThread = new Thread(mConnector, NETD_TAG);
 
+        mWlanInterfaceName = SystemProperties.get("wifi.interface");
+
         mDaemonHandler = new Handler(FgThread.get().getLooper());
 
         // Add ourself to the Watchdog monitors.
@@ -404,6 +421,18 @@ public class NetworkManagementService extends INetworkManagementService.Stub
         } else {
             prepareNativeDaemon();
         }
+        // Note: processPendingDataRestrictRequests() will unregister
+        // mPendingDataRestrictReceiver once it has been able to determine
+        // the cellular network interface name.
+        mPendingDataRestrictReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                processPendingDataRestrictRequests();
+           }
+        };
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+        mContext.registerReceiver(mPendingDataRestrictReceiver, filter);
     }
 
     private IBatteryStats getBatteryStats() {
@@ -1786,6 +1815,77 @@ public class NetworkManagementService extends INetworkManagementService.Stub
         }
     }
 
+    @Override
+    public void restrictAppOnData(int uid, boolean restrict) {
+        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
+        // silently discard when control disabled
+        if (!mBandwidthControlEnabled) return;
+
+        initDataInterface();
+        if (TextUtils.isEmpty(mDataInterfaceName)) {
+            // We don't have an interface name since data is not active
+            // yet, so queue up the request for when it comes up alive
+            mPendingRestrictOnData.put(uid, restrict);
+            return;
+        }
+
+        synchronized (mQuotaLock) {
+            boolean oldValue = mDataBlacklist.get(uid, false);
+            if (oldValue == restrict) {
+                return;
+            }
+            mDataBlacklist.put(uid, restrict);
+        }
+
+        try {
+            final String action = restrict ? "add" : "remove";
+            mConnector.execute("bandwidth", action + "restrictappsondata",
+                    mDataInterfaceName, uid);
+        } catch (NativeDaemonConnectorException e) {
+            throw e.rethrowAsParcelableException();
+        }
+    }
+
+    @Override
+    public void restrictAppOnWlan(int uid, boolean restrict) {
+        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
+        // silently discard when control disabled
+        if (!mBandwidthControlEnabled) return;
+
+        synchronized (mQuotaLock) {
+            boolean oldValue = mWlanBlacklist.get(uid, false);
+            if (oldValue == restrict) {
+                return;
+            }
+            mWlanBlacklist.put(uid, restrict);
+        }
+
+        try {
+            final String action = restrict ? "add" : "remove";
+            mConnector.execute("bandwidth", action + "restrictappsonwlan",
+                    mWlanInterfaceName, uid);
+        } catch (NativeDaemonConnectorException e) {
+            throw e.rethrowAsParcelableException();
+        }
+    }
+
+    private void processPendingDataRestrictRequests() {
+        initDataInterface();
+        if (TextUtils.isEmpty(mDataInterfaceName)) {
+            return;
+        }
+        if (mPendingDataRestrictReceiver != null) {
+            mContext.unregisterReceiver(mPendingDataRestrictReceiver);
+            mPendingDataRestrictReceiver = null;
+        }
+        int count = mPendingRestrictOnData.size();
+        for (int i = 0; i < count; i++) {
+            restrictAppOnData(mPendingRestrictOnData.keyAt(i),
+                    mPendingRestrictOnData.valueAt(i));
+        }
+        mPendingRestrictOnData.clear();
+    }
+
     @Override
     public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges)
             throws ServiceSpecificException {
@@ -2737,6 +2837,18 @@ public class NetworkManagementService extends INetworkManagementService.Stub
         }
     }
 
+    private void initDataInterface() {
+        if (!TextUtils.isEmpty(mDataInterfaceName)) {
+            return;
+        }
+        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
+                Context.CONNECTIVITY_SERVICE);
+        LinkProperties linkProperties = cm.getLinkProperties(ConnectivityManager.TYPE_MOBILE);
+        if (linkProperties != null) {
+            mDataInterfaceName = linkProperties.getInterfaceName();
+        }
+    }
+
     @VisibleForTesting
     class LocalService extends NetworkManagementInternal {
         @Override
diff --git a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
index ab482bb2da9..db33bd8f08d 100644
--- a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
+++ b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
@@ -56,6 +56,8 @@ import static android.net.NetworkPolicyManager.MASK_METERED_NETWORKS;
 import static android.net.NetworkPolicyManager.POLICY_ALLOW_METERED_BACKGROUND;
 import static android.net.NetworkPolicyManager.POLICY_NONE;
 import static android.net.NetworkPolicyManager.POLICY_REJECT_METERED_BACKGROUND;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_DATA;
+import static android.net.NetworkPolicyManager.POLICY_REJECT_ON_WLAN;
 import static android.net.NetworkPolicyManager.RULE_ALLOW_ALL;
 import static android.net.NetworkPolicyManager.RULE_ALLOW_METERED;
 import static android.net.NetworkPolicyManager.RULE_NONE;
@@ -3991,6 +3993,13 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         final int oldRule = oldUidRules & MASK_METERED_NETWORKS;
         int newRule = RULE_NONE;
 
+        try {
+            mNetworkManager.restrictAppOnData(uid, (uidPolicy & POLICY_REJECT_ON_DATA) != 0);
+            mNetworkManager.restrictAppOnWlan(uid, (uidPolicy & POLICY_REJECT_ON_WLAN) != 0);
+        } catch (RemoteException e) {
+            // ignored; service lives in system_server
+        }
+
         // First step: define the new rule based on user restrictions and foreground state.
         if (isRestrictedByAdmin) {
             newRule = RULE_REJECT_METERED;
-- 
2.17.1

