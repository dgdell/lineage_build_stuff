From 3fcf31ae81e4e558c406d49b25ce369a7fcc9bc3 Mon Sep 17 00:00:00 2001
From: Utkarsh Gupta <utkarsh.eminem@gmail.com>
Date: Tue, 18 Aug 2015 12:27:39 +0530
Subject: [PATCH 56/70] SystemUI: Add visualizer feature

This is a squash of the following commits:

Author: Utkarsh Gupta <utkarsh.eminem@gmail.com>
Date:   Tue Aug 18 12:27:39 2015 +0530

    SystemUI: use new visualizer from Eleven

    Change-Id: I4441440868cac71caa32c91a0875f00a630fe596
    Signed-off-by: Utkarsh Gupta <utkarsh.eminem@gmail.com>
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Mikalacki Sava <mikalackis@gmail.com>
Date:   Thu Sep 3 23:10:35 2015 +0200

    SystemUI: fix NPE crash when Visualizer is not initialized

    Change-Id: Ic3774011acfae0312f1642d88c7f5bf2abc9f5a7

Author: Roman Birg <roman@cyngn.com>
Date:   Fri Sep 4 15:55:39 2015 -0700

    SystemUI: hide visualizer when keyguard is occluded

    Change-Id: Ia943fd829f7a379fee0f657bb08c34b8c6f36caa
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Roman Birg <roman@cyngn.com>
Date:   Thu Jan 7 19:27:38 2016 +0100

    SystemUI: Make lockscreen visualizer battery friendly

    In case of offloaded playback, the device is allowed to sleep.
    However, if the lockscreen visualizer is enabled, the device
    hardly enters deep sleep, even if the screen is off. To prevent
    this, enable the visualizer only when the lockscreen is shown.

    Change-Id: I484270694b734c9b53e61a7c0ad74391b54fe8cd

Author: Roman Birg <roman@cyngn.com>
Date:   Thu Mar 17 09:18:56 2016 -0700

    SystemUI: more consistent visualizer logic

    - only call setVisible from screen on and screen off methods
    - eagerly unregister self to make sure we don't get added twice as a
      listener
    - Add some debugging under the DEBUG flag

    Change-Id: Iada13058f87d4c8d8c8b60f6eebf055652ff2c8d
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Roman Birg <roman@cyngn.com>
Date:   Mon Apr 4 15:29:34 2016 -0700

    SystemUI: show visualizer in shade-locked view

    This brings back the behavior we had in 12.1 - visualizer would still be
    visible in the shade locked state.

    Also with the following improvements:
        * use less alpha
        * always attach/detach in a background thread (Async task)
        * use the statusbar state instead keyguard view state listener

    Change-Id: I6b8a57f9f0bba6ba0591de0cb1f94a0eb904cc1c
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Dan Pasanen <invisiblek@cyanogenmod.org>
Date:   Wed May 18 20:27:47 2016 -0500

    Visualizer: Let visualizer fill the entire available screen

    * This will allow it to be more dynamic (landscape lock screen for instance)

    Change-Id: I2ffd6b0ca8832812faaa4cc0ec4cdd6071fbec8c

Author: Matthias Yzusqui <myzb.dev@gmail.com>
Date:   Wed Sep 21 15:25:00 2016 +0200

    SystemUI: fix navbar drawing glitch

    Change-Id: I58e255517d35675c043061f2edb398dab0d16ba8

Author: Zhao Wei Liew <zhaoweiliew@gmail.com>
Date:   Fri Oct 7 08:56:25 2016 +0800

    SystemUI: Use Tuner API for CM settings

    Get rid of all the excess code by implementing TunerService.Tunable
    and observing any changes made to the settings through it.

    Remove UserContentObserver as the Tuner API handles user switches.

    Also remove some unused imports that were introduced in earlier
    CM commits, but were never removed since.

    Change-Id: Iecafafabdaec82b3b3c72293bea865de48f0e90a

Author: Bruno Martins <bgcngm@gmail.com>
Date:   Sat Dec 2 15:10:28 2017 +0000
Edit:   Forward-port visualizer feature to O

Author: Bruno Martins <bgcngm@gmail.com>
Date:   Sat Aug 25 01:42:06 2018 +0100
Edit:   Forward-port visualizer feature to P

Change-Id: I556a233f70f53f08084fd2cca319e3fb05f47243
---
 packages/SystemUI/LineageManifest.xml         |   4 +
 .../SystemUI/res/layout/super_status_bar.xml  |   9 +
 .../statusbar/NotificationMediaManager.java   |  14 +
 .../systemui/statusbar/VisualizerView.java    | 376 ++++++++++++++++++
 .../systemui/statusbar/phone/StatusBar.java   |  43 +-
 .../phone/StatusBarKeyguardViewManager.java   |   1 +
 6 files changed, 444 insertions(+), 3 deletions(-)
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/VisualizerView.java

diff --git a/packages/SystemUI/LineageManifest.xml b/packages/SystemUI/LineageManifest.xml
index cdd9f2576b0..36d137103de 100644
--- a/packages/SystemUI/LineageManifest.xml
+++ b/packages/SystemUI/LineageManifest.xml
@@ -27,6 +27,10 @@
     <uses-permission android:name="lineageos.permission.WRITE_SETTINGS" />
     <uses-permission android:name="lineageos.permission.WRITE_SECURE_SETTINGS" />
 
+    <!-- Visualizer -->
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
+    <uses-permission android:name="android.permission.RECORD_AUDIO" />
+
     <!-- SystemUI Tuner -->
     <application>
         <activity-alias
diff --git a/packages/SystemUI/res/layout/super_status_bar.xml b/packages/SystemUI/res/layout/super_status_bar.xml
index 0cc3c9eb55d..c37b05752a0 100644
--- a/packages/SystemUI/res/layout/super_status_bar.xml
+++ b/packages/SystemUI/res/layout/super_status_bar.xml
@@ -51,6 +51,15 @@
         sysui:ignoreRightInset="true"
         />
 
+    <com.android.systemui.statusbar.VisualizerView
+        android:id="@+id/visualizerview"
+        android:gravity="bottom"
+        android:layout_gravity="bottom"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:visibility="visible"
+        sysui:ignoreRightInset="true" />
+
     <FrameLayout
         android:id="@+id/status_bar_container"
         android:layout_width="match_parent"
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationMediaManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationMediaManager.java
index f737a8cec4f..acd6343bdcd 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationMediaManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationMediaManager.java
@@ -25,7 +25,9 @@ import android.media.session.PlaybackState;
 import android.os.UserHandle;
 import android.util.Log;
 
+import com.android.systemui.statusbar.phone.StatusBar;
 import com.android.systemui.Dumpable;
+import com.android.systemui.SysUiServiceProvider;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -43,6 +45,8 @@ public class NotificationMediaManager implements Dumpable {
     private final Context mContext;
     private final MediaSessionManager mMediaSessionManager;
 
+    private final StatusBar mStatusBar;
+
     protected NotificationPresenter mPresenter;
     protected NotificationEntryManager mEntryManager;
     private MediaController mMediaController;
@@ -61,6 +65,10 @@ public class NotificationMediaManager implements Dumpable {
                     clearCurrentMediaNotification();
                     mPresenter.updateMediaMetaData(true, true);
                 }
+                if (mStatusBar != null) {
+                    mStatusBar.getVisualizer().setPlaying(state.getState()
+                            == PlaybackState.STATE_PLAYING);
+                }
             }
         }
 
@@ -81,6 +89,8 @@ public class NotificationMediaManager implements Dumpable {
                 = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
         // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
         // in session state
+
+        mStatusBar = SysUiServiceProvider.getComponent(mContext, StatusBar.class);
     }
 
     public void setUpWithPresenter(NotificationPresenter presenter,
@@ -100,6 +110,10 @@ public class NotificationMediaManager implements Dumpable {
         return mMediaNotificationKey;
     }
 
+    public MediaController getMediaController() {
+        return mMediaController;
+    }
+
     public MediaMetadata getMediaMetadata() {
         return mMediaMetadata;
     }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/VisualizerView.java b/packages/SystemUI/src/com/android/systemui/statusbar/VisualizerView.java
new file mode 100644
index 00000000000..79532e3937c
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/VisualizerView.java
@@ -0,0 +1,376 @@
+/*
+* Copyright (C) 2015 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.systemui.statusbar;
+
+import android.animation.ObjectAnimator;
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.media.audiofx.Visualizer;
+import android.os.AsyncTask;
+import android.os.UserHandle;
+import android.support.v7.graphics.Palette;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+
+import com.android.systemui.Dependency;
+import com.android.systemui.tuner.TunerService;
+
+import lineageos.providers.LineageSettings;
+
+public class VisualizerView extends View
+        implements Palette.PaletteAsyncListener, TunerService.Tunable {
+
+    private static final String TAG = VisualizerView.class.getSimpleName();
+    private static final boolean DEBUG = false;
+
+    private static final String LOCKSCREEN_VISUALIZER_ENABLED =
+            "lineagesecure:" + LineageSettings.Secure.LOCKSCREEN_VISUALIZER_ENABLED;
+
+    private Paint mPaint;
+    private Visualizer mVisualizer;
+    private ObjectAnimator mVisualizerColorAnimator;
+
+    private ValueAnimator[] mValueAnimators;
+    private float[] mFFTPoints;
+
+    private int mStatusBarState;
+    private boolean mVisualizerEnabled = false;
+    private boolean mVisible = false;
+    private boolean mPlaying = false;
+    private boolean mPowerSaveMode = false;
+    private boolean mDisplaying = false; // the state we're animating to
+    private boolean mDozing = false;
+    private boolean mOccluded = false;
+
+    private int mColor;
+    private Bitmap mCurrentBitmap;
+
+    private Visualizer.OnDataCaptureListener mVisualizerListener =
+            new Visualizer.OnDataCaptureListener() {
+        byte rfk, ifk;
+        int dbValue;
+        float magnitude;
+
+        @Override
+        public void onWaveFormDataCapture(Visualizer visualizer, byte[] bytes, int samplingRate) {
+        }
+
+        @Override
+        public void onFftDataCapture(Visualizer visualizer, byte[] fft, int samplingRate) {
+            for (int i = 0; i < 32; i++) {
+                mValueAnimators[i].cancel();
+                rfk = fft[i * 2 + 2];
+                ifk = fft[i * 2 + 3];
+                magnitude = rfk * rfk + ifk * ifk;
+                dbValue = magnitude > 0 ? (int) (10 * Math.log10(magnitude)) : 0;
+
+                mValueAnimators[i].setFloatValues(mFFTPoints[i * 4 + 1],
+                        mFFTPoints[3] - (dbValue * 16f));
+                mValueAnimators[i].start();
+            }
+        }
+    };
+
+    private final Runnable mLinkVisualizer = new Runnable() {
+        @Override
+        public void run() {
+            if (DEBUG) {
+                Log.w(TAG, "+++ mLinkVisualizer run()");
+            }
+
+            try {
+                mVisualizer = new Visualizer(0);
+            } catch (Exception e) {
+                Log.e(TAG, "error initializing visualizer", e);
+                return;
+            }
+
+            mVisualizer.setEnabled(false);
+            mVisualizer.setCaptureSize(66);
+            mVisualizer.setDataCaptureListener(mVisualizerListener,Visualizer.getMaxCaptureRate(),
+                    false, true);
+            mVisualizer.setEnabled(true);
+
+            if (DEBUG) {
+                Log.w(TAG, "--- mLinkVisualizer run()");
+            }
+        }
+    };
+
+    private final Runnable mAsyncUnlinkVisualizer = new Runnable() {
+        @Override
+        public void run() {
+            AsyncTask.execute(mUnlinkVisualizer);
+        }
+    };
+
+    private final Runnable mUnlinkVisualizer = new Runnable() {
+        @Override
+        public void run() {
+            if (DEBUG) {
+                Log.w(TAG, "+++ mUnlinkVisualizer run(), mVisualizer: " + mVisualizer);
+            }
+            if (mVisualizer != null) {
+                mVisualizer.setEnabled(false);
+                mVisualizer.release();
+                mVisualizer = null;
+            }
+            if (DEBUG) {
+                Log.w(TAG, "--- mUninkVisualizer run()");
+            }
+        }
+    };
+
+    public VisualizerView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        mColor = Color.TRANSPARENT;
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setColor(mColor);
+
+        mFFTPoints = new float[128];
+        mValueAnimators = new ValueAnimator[32];
+        for (int i = 0; i < 32; i++) {
+            final int j = i * 4 + 1;
+            mValueAnimators[i] = new ValueAnimator();
+            mValueAnimators[i].setDuration(128);
+            mValueAnimators[i].addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                @Override
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    mFFTPoints[j] = (float) animation.getAnimatedValue();
+                    postInvalidate();
+                }
+            });
+        }
+    }
+
+    public VisualizerView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public VisualizerView(Context context) {
+        this(context, null, 0);
+    }
+
+    private void updateViewVisibility() {
+        final int curVis = getVisibility();
+        final int newVis = mStatusBarState != StatusBarState.SHADE
+                && mVisualizerEnabled ? View.VISIBLE : View.GONE;
+        if (curVis != newVis) {
+            setVisibility(newVis);
+            checkStateChanged();
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        Dependency.get(TunerService.class).addTunable(this, LOCKSCREEN_VISUALIZER_ENABLED);
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        Dependency.get(TunerService.class).removeTunable(this);
+        mCurrentBitmap = null;
+    }
+
+    @Override
+    public void onTuningChanged(String key, String newValue) {
+        if (LOCKSCREEN_VISUALIZER_ENABLED.equals(key)) {
+            mVisualizerEnabled = newValue == null || Integer.parseInt(newValue) != 0;
+            checkStateChanged();
+            updateViewVisibility();
+        }
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        float barUnit = w / 32f;
+        float barWidth = barUnit * 8f / 9f;
+        barUnit = barWidth + (barUnit - barWidth) * 32f / 31f;
+        mPaint.setStrokeWidth(barWidth);
+
+        for (int i = 0; i < 32; i++) {
+            mFFTPoints[i * 4] = mFFTPoints[i * 4 + 2] = i * barUnit + (barWidth / 2);
+            mFFTPoints[i * 4 + 1] = h;
+            mFFTPoints[i * 4 + 3] = h;
+        }
+    }
+
+    @Override
+    public boolean hasOverlappingRendering() {
+        return false;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (mVisualizer != null) {
+            canvas.drawLines(mFFTPoints, mPaint);
+        }
+    }
+
+    public void setVisible(boolean visible) {
+        if (mVisible != visible) {
+            if (DEBUG) {
+                Log.i(TAG, "setVisible() called with visible = [" + visible + "]");
+            }
+            mVisible = visible;
+            checkStateChanged();
+        }
+    }
+
+    public void setDozing(boolean dozing) {
+        if (mDozing != dozing) {
+            if (DEBUG) {
+                Log.i(TAG, "setDozing() called with dozing = [" + dozing + "]");
+            }
+            mDozing = dozing;
+            checkStateChanged();
+        }
+    }
+
+    public void setPlaying(boolean playing) {
+        if (mPlaying != playing) {
+            if (DEBUG) {
+                Log.i(TAG, "setPlaying() called with playing = [" + playing + "]");
+            }
+            mPlaying = playing;
+            checkStateChanged();
+        }
+    }
+
+    public void setPowerSaveMode(boolean powerSaveMode) {
+        if (mPowerSaveMode != powerSaveMode) {
+            if (DEBUG) {
+                Log.i(TAG, "setPowerSaveMode() called with powerSaveMode = [" + powerSaveMode + "]");
+            }
+            mPowerSaveMode = powerSaveMode;
+            checkStateChanged();
+        }
+    }
+
+    public void setOccluded(boolean occluded) {
+        if (mOccluded != occluded) {
+            if (DEBUG) {
+                Log.i(TAG, "setOccluded() called with occluded = [" + occluded + "]");
+            }
+            mOccluded = occluded;
+            checkStateChanged();
+        }
+    }
+
+    public void setStatusBarState(int statusBarState) {
+        if (mStatusBarState != statusBarState) {
+            mStatusBarState = statusBarState;
+            updateViewVisibility();
+        }
+    }
+
+    public void setBitmap(Bitmap bitmap) {
+        if (mCurrentBitmap == bitmap) {
+            return;
+        }
+        mCurrentBitmap = bitmap;
+        if (bitmap != null) {
+            Palette.generateAsync(bitmap, this);
+        } else {
+            setColor(Color.TRANSPARENT);
+        }
+    }
+
+    @Override
+    public void onGenerated(Palette palette) {
+        int color = Color.TRANSPARENT;
+
+        color = palette.getVibrantColor(color);
+        if (color == Color.TRANSPARENT) {
+            color = palette.getLightVibrantColor(color);
+            if (color == Color.TRANSPARENT) {
+                color = palette.getDarkVibrantColor(color);
+            }
+        }
+
+        setColor(color);
+    }
+
+    private void setColor(int color) {
+        if (color == Color.TRANSPARENT) {
+            color = Color.WHITE;
+        }
+
+        color = Color.argb(140, Color.red(color), Color.green(color), Color.blue(color));
+
+        if (mColor != color) {
+            mColor = color;
+
+            if (mVisualizer != null) {
+                if (mVisualizerColorAnimator != null) {
+                    mVisualizerColorAnimator.cancel();
+                }
+
+                mVisualizerColorAnimator = ObjectAnimator.ofArgb(mPaint, "color",
+                        mPaint.getColor(), mColor);
+                mVisualizerColorAnimator.setStartDelay(600);
+                mVisualizerColorAnimator.setDuration(1200);
+                mVisualizerColorAnimator.start();
+            } else {
+                mPaint.setColor(mColor);
+            }
+        }
+    }
+
+    private void checkStateChanged() {
+        if (getVisibility() == View.VISIBLE && mVisible && mPlaying && !mDozing && !mPowerSaveMode
+                && mVisualizerEnabled && !mOccluded) {
+            if (!mDisplaying) {
+                mDisplaying = true;
+                AsyncTask.execute(mLinkVisualizer);
+                animate()
+                        .alpha(1f)
+                        .withEndAction(null)
+                        .setDuration(800);
+            }
+        } else {
+            if (mDisplaying) {
+                mDisplaying = false;
+                if (mVisible) {
+                    animate()
+                            .alpha(0f)
+                            .withEndAction(mAsyncUnlinkVisualizer)
+                            .setDuration(600);
+                } else {
+                    animate().
+                            alpha(0f)
+                            .withEndAction(mAsyncUnlinkVisualizer)
+                            .setDuration(0);
+                }
+            }
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
index 8a4c9a14f51..3eeb9dafe4e 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
@@ -85,6 +85,7 @@ import android.graphics.drawable.Drawable;
 import android.hardware.display.DisplayManager;
 import android.media.AudioAttributes;
 import android.media.MediaMetadata;
+import android.media.session.PlaybackState;
 import android.metrics.LogMaker;
 import android.net.Uri;
 import android.os.AsyncTask;
@@ -219,6 +220,7 @@ import com.android.systemui.statusbar.RemoteInputController;
 import com.android.systemui.statusbar.ScrimView;
 import com.android.systemui.statusbar.StatusBarState;
 import com.android.systemui.statusbar.VibratorHelper;
+import com.android.systemui.statusbar.VisualizerView;
 import com.android.systemui.statusbar.notification.AboveShelfObserver;
 import com.android.systemui.statusbar.notification.ActivityLaunchAnimator;
 import com.android.systemui.statusbar.notification.VisualStabilityManager;
@@ -597,6 +599,10 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
     protected NotificationLockscreenUserManager mLockscreenUserManager;
     protected NotificationRemoteInputManager mRemoteInputManager;
 
+    private VisualizerView mVisualizerView;
+    private boolean mScreenOn;
+    private boolean mKeyguardShowingMedia;
+
     private BroadcastReceiver mWallpaperChangedReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -1074,6 +1080,8 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         mDozeScrimController = new DozeScrimController(mScrimController, context,
                 DozeParameters.getInstance(context));
 
+        mVisualizerView = (VisualizerView) mStatusBarWindow.findViewById(R.id.visualizerview);
+
         // Other icons
         mVolumeComponent = getComponent(VolumeComponent.class);
 
@@ -1141,9 +1149,8 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         }
 
         PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
-        if (!pm.isScreenOn()) {
-            mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        }
+        mBroadcastReceiver.onReceive(mContext,
+                new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
         mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,
                 "GestureWakeLock");
         mVibrator = mContext.getSystemService(Vibrator.class);
@@ -1158,6 +1165,7 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
         filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_SCREEN_ON);
         filter.addAction(DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG);
         filter.addAction(lineageos.content.Intent.ACTION_SCREEN_CAMERA_GESTURE);
         context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
@@ -1749,6 +1757,8 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
                 artworkDrawable = new BitmapDrawable(mBackdropBack.getResources(), artworkBitmap);
             }
         }
+        mKeyguardShowingMedia = artworkDrawable != null;
+
         boolean allowWhenShade = false;
         if (ENABLE_LOCKSCREEN_WALLPAPER && artworkDrawable == null) {
             Bitmap lockWallpaper = mLockscreenWallpaper.getBitmap();
@@ -1765,8 +1775,23 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         boolean hideBecauseOccluded = mStatusBarKeyguardViewManager != null
                 && mStatusBarKeyguardViewManager.isOccluded();
 
+        final boolean keyguardVisible = (mState != StatusBarState.SHADE);
         final boolean hasArtwork = artworkDrawable != null;
 
+        if (!mKeyguardFadingAway && keyguardVisible && hasArtwork && mScreenOn) {
+            // if there's album art, ensure visualizer is visible
+            mVisualizerView.setPlaying(mMediaManager.getMediaController() != null
+                    && mMediaManager.getMediaController().getPlaybackState() != null
+                    && mMediaManager.getMediaController().getPlaybackState().getState()
+                            == PlaybackState.STATE_PLAYING);
+        }
+
+        if (keyguardVisible && mKeyguardShowingMedia &&
+                (artworkDrawable instanceof BitmapDrawable)) {
+            // always use current backdrop to color eq
+            mVisualizerView.setBitmap(((BitmapDrawable)artworkDrawable).getBitmap());
+        }
+
         if ((hasArtwork || DEBUG_MEDIA_FAKE_ARTWORK) && !mDozing
                 && (mState != StatusBarState.SHADE || allowWhenShade)
                 && mFingerprintUnlockController.getMode()
@@ -3267,9 +3292,13 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
                 }
             }
             else if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                mScreenOn = false;
                 finishBarAnimations();
                 resetUserExpandedStates();
             }
+            else if (Intent.ACTION_SCREEN_ON.equals(action)) {
+                mScreenOn = true;
+            }
             else if (DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG.equals(action)) {
                 mQSPanel.showDeviceMonitoringDialog();
             }
@@ -4175,6 +4204,7 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         mDozeScrimController.setDozing(mDozing);
         mKeyguardIndicationController.setDozing(mDozing);
         mNotificationPanel.setDozing(mDozing, animate);
+        mVisualizerView.setDozing(mDozing);
         updateQsExpansionEnabled();
         Trace.endSection();
     }
@@ -4318,6 +4348,7 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
             maybeEscalateHeadsUp();
         }
         mState = state;
+        mVisualizerView.setStatusBarState(state);
         mGroupManager.setStatusBarState(state);
         mHeadsUpManager.setStatusBarState(state);
         mFalsingManager.setStatusBarState(state);
@@ -4794,12 +4825,14 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         @Override
         public void onScreenTurnedOn() {
             mScrimController.onScreenTurnedOn();
+            mVisualizerView.setVisible(true);
         }
 
         @Override
         public void onScreenTurnedOff() {
             mFalsingManager.onScreenOff();
             mScrimController.onScreenTurnedOff();
+            mVisualizerView.setVisible(false);
             // If we pulse in from AOD, we turn the screen off first. However, updatingIsKeyguard
             // in that case destroys the HeadsUpManager state, so don't do it in that case.
             if (!isPulsing()) {
@@ -5017,6 +5050,10 @@ public class StatusBar extends SystemUI implements DemoMode, TunerService.Tunabl
         Trace.endSection();
     }
 
+    public VisualizerView getVisualizer() {
+        return mVisualizerView;
+    }
+
     public boolean isKeyguardShowing() {
         if (mStatusBarKeyguardViewManager == null) {
             Slog.i(TAG, "isKeyguardShowing() called before startKeyguard(), returning true");
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
index 16a6e0e4135..995fdbd61b4 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
@@ -405,6 +405,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             mStatusBar.updateMediaMetaData(false, animate && !occluded);
         }
         mStatusBarWindowManager.setKeyguardOccluded(occluded);
+        mStatusBar.getVisualizer().setOccluded(occluded);
 
         // setDozing(false) will call reset once we stop dozing.
         if (!mDozing) {
-- 
2.17.1

