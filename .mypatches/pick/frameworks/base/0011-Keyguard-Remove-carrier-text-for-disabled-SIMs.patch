From abb4e346a111069dfeea1baf7d89437c471e5900 Mon Sep 17 00:00:00 2001
From: Michael W <baddaemon87@gmail.com>
Date: Sat, 2 Jun 2018 17:52:56 +0200
Subject: [PATCH 11/20] Keyguard: Remove carrier text for disabled SIMs

* By setting the State to "NOT_READY", the behaviour of the carrier text
  on the lockscreen is the same as it would be with one SIM only

Change-Id: Iafe7ad820e59f4d960383309a7c4e1a87581cc51
---
 .../keyguard/KeyguardUpdateMonitor.java       | 29 ++++++++++++++++++-
 1 file changed, 28 insertions(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index e5eb78f3e1f..21b45dc4dd7 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -81,6 +81,9 @@ import com.android.systemui.recents.misc.SystemServicesProxy.TaskStackListener;
 
 import com.google.android.collect.Lists;
 
+import org.lineageos.internal.util.TelephonyExtUtils;
+import org.lineageos.internal.util.TelephonyExtUtils.ProvisioningChangedListener;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.ref.WeakReference;
@@ -100,7 +103,8 @@ import java.util.concurrent.ConcurrentHashMap;
  * the device, and {@link #getFailedUnlockAttempts()}, {@link #reportFailedAttempt()}
  * and {@link #clearFailedUnlockAttempts()}.  Maybe we should rename this 'KeyguardContext'...
  */
-public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
+public class KeyguardUpdateMonitor implements TrustManager.TrustListener,
+        ProvisioningChangedListener {
 
     private static final String TAG = "KeyguardUpdateMonitor";
     private static final boolean DEBUG = KeyguardConstants.DEBUG;
@@ -184,6 +188,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
     private final Context mContext;
     ConcurrentHashMap<Integer, SimData> mSimDatas = new ConcurrentHashMap<Integer, SimData>();
     HashMap<Integer, ServiceState> mServiceStates = new HashMap<Integer, ServiceState>();
+    HashMap<Integer, State> mProvisionStates = new HashMap<Integer, State>();
 
     private int mRingMode;
     private int mPhoneState;
@@ -334,6 +339,12 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
         }
     };
 
+    @Override
+    public void onProvisioningChanged(int slotId, boolean isProvisioned) {
+        mProvisionStates.put(slotId, isProvisioned ? State.UNKNOWN : State.NOT_READY);
+        handleSimSubscriptionInfoChanged();
+    }
+
     private OnSubscriptionsChangedListener mSubscriptionListener =
             new OnSubscriptionsChangedListener() {
         @Override
@@ -1393,6 +1404,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
                 cb.onBootCompleted();
             }
         }
+
+        TelephonyExtUtils.getInstance(mContext).addListener(this);
     }
 
     /**
@@ -1828,6 +1841,20 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
             Log.w(TAG, "Unknown sim state: " + simState);
             state = State.UNKNOWN;
         }
+
+        // Try to get provision-status from telephony extensions and override the state if valid
+        TelephonyExtUtils extTelephony = TelephonyExtUtils.getInstance(mContext);
+        if (extTelephony.hasService()) {
+            State extState = mProvisionStates.get(slotId);
+            if (extState == null) {
+                extState = extTelephony.isSlotProvisioned(slotId) ? State.UNKNOWN : State.NOT_READY;
+                mProvisionStates.put(slotId, extState);
+            }
+            if (extState != null && extState != State.UNKNOWN) {
+                state = extState;
+            }
+        }
+
         SimData data = mSimDatas.get(subId);
         final boolean changed;
         if (data == null) {
-- 
2.17.1

