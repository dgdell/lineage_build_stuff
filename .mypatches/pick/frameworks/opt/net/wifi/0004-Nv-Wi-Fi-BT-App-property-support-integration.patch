From ff37bf46cd5b9d2d8129844fc3e0902a9404ca23 Mon Sep 17 00:00:00 2001
From: Mohan Thadikamalla <mohant@nvidia.com>
Date: Mon, 17 Jul 2017 14:53:34 +0530
Subject: [PATCH 04/11] Nv Wi-Fi/BT App property support integration

feature: NvPropSupport
Bug 200316146

Wifi application property support

In order to optimize the wifi scan algorithms, wpa_supplicant needs to know
the state of the applications from Settings, BlakeController app, etc.
Those applications can notify their state changes to the supplicant using this
wifi application property.

Bug 1400711

Change-Id: I3e9f90080906b3224c7592636ea5db66813b8fc7
Reviewed-on: http://git-master/r/1212314

Send native commands through StateMachine

Relying on Wifi state while sending commands to native
is bad and can cause race conditions. Sending the commands
to native via state machine will allow state machine to
process the commands depending on the state always.

Bug 200046902
Bug 200052295
Bug 1573204

Change-Id: Ife14ab0191b4827a63c5bd860e0eefb181835d0b
Reviewed-on: http://git-master/r/593788

check if Wi-Fi is enabled before sending command

Some commands are directly passed to native layers without
checking Wi-Fi HAL connection to supplicant. This will
cause command timeouts and HAL shutdown.

Bug 200040197

Change-Id: Ifcd03b1973d274de7d5d46ce7d0c03e2183d925d
Reviewed-on: http://git-master/r/1212318
Reviewed-on: http://git-psac/r/10410
Reviewed-on: http://git-psac.nvidia.com/r/13449
GVS: Gerrit_Virtual_Submit
Reviewed-by: Bibhay Ranjan <bibhayr@nvidia.com>
Tested-by: Bibhay Ranjan <bibhayr@nvidia.com>
Reviewed-by: David Pearce <dpearce@nvidia.com>
Reviewed-on: https://git-master.nvidia.com/r/1552313
Reviewed-by: Niranjan Artal <nartal@nvidia.com>
Tested-by: Niranjan Artal <nartal@nvidia.com>
Reviewed-on: https://git-master.nvidia.com/r/1588841
Reviewed-by: Mohan Thadikamalla <mohant@nvidia.com>
---
 .../android/server/wifi/WifiServiceImpl.java  | 93 +++++++++++++++++++
 .../android/server/wifi/WifiStateMachine.java | 24 +++++
 2 files changed, 117 insertions(+)

diff --git a/service/java/com/android/server/wifi/WifiServiceImpl.java b/service/java/com/android/server/wifi/WifiServiceImpl.java
index c83f6c6bd..404a659c4 100644
--- a/service/java/com/android/server/wifi/WifiServiceImpl.java
+++ b/service/java/com/android/server/wifi/WifiServiceImpl.java
@@ -129,6 +129,9 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.HashMap;
+
+import vendor.nvidia.hardware.server.wifi.NvWifi;
 
 /**
  * WifiService handles remote WiFi operation requests by implementing
@@ -459,6 +462,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         mIfaceIpModes = new ConcurrentHashMap<>();
         mLocalOnlyHotspotRequests = new HashMap<>();
         enableVerboseLoggingInternal(getVerboseLoggingLevel());
+        mNvWifi = mWifiStateMachine.getNvWifi();
     }
 
     /**
@@ -2094,6 +2098,7 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         mWifiStateMachine.disableEphemeralNetwork(SSID);
     }
 
+
     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -2674,4 +2679,92 @@ public class WifiServiceImpl extends IWifiManager.Stub {
         restoreNetworks(wifiConfigurations);
         Slog.d(TAG, "Restored supplicant backup data");
     }
+
+    final NvWifi mNvWifi;
+    /**
+     * Wifi Application Property
+     */
+    private List<WifiAppPropOnDeath> mAppPropOnDeathList = new ArrayList<WifiAppPropOnDeath>();
+
+    class WifiAppProperty {
+        public String key;
+        public String value;
+
+        WifiAppProperty(String key, String value) {
+            this.key = key;
+            this.value = value;
+        }
+    }
+
+    class WifiAppPropOnDeath implements IBinder.DeathRecipient {
+        IBinder mBinder;
+        HashMap<String, String> mProperties = new HashMap<String, String>();
+
+        WifiAppPropOnDeath(IBinder binder) {
+            mBinder = binder;
+
+            try {
+                mBinder.linkToDeath(this, 0);
+            } catch (RemoteException e) {
+                binderDied();
+            }
+        }
+
+        void addProperty(String key, String value) {
+            mProperties.put(key, value);
+        }
+
+        void removeProperty(String key) {
+            mProperties.remove(key);
+        }
+
+        public void binderDied() {
+            synchronized(mAppPropOnDeathList) {
+                mAppPropOnDeathList.remove(this);
+                for(HashMap.Entry<String, String> entry : mProperties.entrySet()) {
+                    mNvWifi.setAppProperty(entry.getKey(), entry.getValue(), mWifiStateMachineChannel);
+
+                }
+                mProperties = null;
+                mBinder = null;
+            }
+        }
+    }
+
+    public int setAppPropertyOnDeath(IBinder binder, String key, String value) {
+        WifiAppPropOnDeath propOnDeath = null;
+        synchronized(mAppPropOnDeathList) {
+            for(WifiAppPropOnDeath tmpPropOnDeath : mAppPropOnDeathList) {
+                if(tmpPropOnDeath.mBinder == binder) {
+                    propOnDeath = tmpPropOnDeath;
+                    break;
+                }
+            }
+
+            if(value != null) {
+                // add or replace
+                if(propOnDeath == null) {
+                    propOnDeath = new WifiAppPropOnDeath(binder);
+                    mAppPropOnDeathList.add(propOnDeath);
+                }
+                if(propOnDeath != null) {
+                    propOnDeath.addProperty(key, value);
+                }
+            } else {
+                //  delete
+                if(propOnDeath != null) {
+                    propOnDeath.removeProperty(key);
+                }
+            }
+        }
+        return 0;
+    }
+
+    public String getAppProperty(String key) {
+        return mNvWifi.getAppProperty(key, mWifiStateMachineChannel);
+    }
+
+    public int setAppProperty(String key, String value) {
+        return mNvWifi.setAppProperty(key, value, mWifiStateMachineChannel);
+    }
 }
diff --git a/service/java/com/android/server/wifi/WifiStateMachine.java b/service/java/com/android/server/wifi/WifiStateMachine.java
index 44d6339c6..6dcfb5084 100644
--- a/service/java/com/android/server/wifi/WifiStateMachine.java
+++ b/service/java/com/android/server/wifi/WifiStateMachine.java
@@ -149,6 +149,8 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import vendor.nvidia.hardware.server.wifi.NvWifi;
+
 /**
  * TODO:
  * Deprecate WIFI_STATE_UNKNOWN
@@ -256,6 +258,7 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiRss
         sendMessage(CMD_VENDOR_HAL_HWBINDER_DEATH);
     };
     private boolean mIpReachabilityDisconnectEnabled = true;
+    public NvWifi mNvWifi;
 
     @Override
     public void onRssiThresholdBreached(byte curRssi) {
@@ -945,6 +948,11 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiRss
         mWifiDiagnostics = mWifiInjector.makeWifiDiagnostics(mWifiNative);
 
         mWifiInfo = new WifiInfo();
+        if (mNvWifi == null) {
+            // create one instance only
+            mNvWifi = new NvWifi(mContext, mInterfaceName, this,
+                    mWifiConfigManager, mWifiConnectivityManager);
+        }
         mSupplicantStateTracker =
                 mFacade.makeSupplicantStateTracker(context, mWifiConfigManager, getHandler());
 
@@ -4131,6 +4139,12 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiRss
                 case CMD_DIAGS_CONNECT_TIMEOUT:
                     mWifiDiagnostics.reportConnectionEvent(
                             (Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
+                case NvWifi.CMD_NV_GET_APP_PROP:
+                    replyToMessage(message, message.what, message.obj);
+                    break;
+                case NvWifi.CMD_NV_SET_APP_PROP:
+                    message.arg1 = -1;
+                    replyToMessage(message, message.what, message.arg1);
                     break;
                 case 0:
                     // We want to notice any empty messages (with what == 0) that might crop up.
@@ -4551,6 +4565,12 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiRss
                         loge("Failed to set TX power scenario");
                     }
                     break;
+                case NvWifi.CMD_NV_SET_APP_PROP:
+                    replyToMessage(message, message.what, mNvWifi.setProp(message));
+                    break;
+                case NvWifi.CMD_NV_GET_APP_PROP:
+                    replyToMessage(message, message.what, mNvWifi.getProp(message));
+                    break;
                 default:
                     return NOT_HANDLED;
             }
@@ -7346,4 +7366,8 @@ public class WifiStateMachine extends StateMachine implements WifiNative.WifiRss
         resultMsg.recycle();
         return result;
     }
+
+    public NvWifi getNvWifi() {
+        return mNvWifi;
+    }
 }
-- 
2.17.1

