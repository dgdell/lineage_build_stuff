From b8847c77ea5d32f90f6c8fb6887ac2d5ef16581b Mon Sep 17 00:00:00 2001
From: Mengjun Leng <mengju@codeaurora.org>
Date: Wed, 15 Mar 2017 11:03:45 +0800
Subject: [PATCH 3/5] Clean up Icc Refresh handling

1. When a SIM refresh is received of type INIT,
don't immediately start re-fetching the records, because
the app might not be ready. In this case, we could end up
broadcasting that all records are loaded pre-maturely.

On a refresh of the above type, the app will move out of the
ready state and back into the PIN state, if PIN is enabled.
Start reading the records only after the PIN has been verified
and the app has moved to the READY state.

2. When UiccController receives refresh of type INIT, it will
propagate it to the Card. The card will dispose the apps if required.
UiccController will also request card status on receiving
refresh to get the latest state.

This avoids having to make assumptions on the ordering of the
Unsols for Sim Refresh and card state changes. This also
ensures that after a refresh, the app state will move to ready
when it is truly ready.

3. Moved common implementation for refresh into IccRecords
for better code reuse.

Change-Id: I5650688719e22139d94fb525d4e8ea6b4b94566a
CRs-Fixed: 2020347
---
 .../internal/telephony/uicc/IccRecords.java   |  57 +++++---
 .../telephony/uicc/IsimUiccRecords.java       |  52 +-------
 .../internal/telephony/uicc/RuimRecords.java  |  48 +------
 .../internal/telephony/uicc/SIMRecords.java   |  48 +------
 .../telephony/uicc/UiccController.java        |  31 +++--
 .../telephony/uicc/IccRecordsTest.java        |  89 +++++++++++++
 .../telephony/uicc/IsimUiccRecordsTest.java   | 122 ++++++++++++++++++
 7 files changed, 288 insertions(+), 159 deletions(-)
 create mode 100644 tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java
 create mode 100644 tests/telephonytests/src/com/android/internal/telephony/uicc/IsimUiccRecordsTest.java

diff --git a/src/java/com/android/internal/telephony/uicc/IccRecords.java b/src/java/com/android/internal/telephony/uicc/IccRecords.java
index af26f5c7d..d845fb022 100644
--- a/src/java/com/android/internal/telephony/uicc/IccRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/IccRecords.java
@@ -128,6 +128,7 @@ public abstract class IccRecords extends Handler implements IccConstants {
     public static final int EVENT_SPN = 2; // Service Provider Name
 
     public static final int EVENT_GET_ICC_RECORD_DONE = 100;
+    public static final int EVENT_REFRESH = 31; // ICC refresh occurred
     protected static final int EVENT_APP_READY = 1;
     private static final int EVENT_AKA_AUTHENTICATE_DONE          = 90;
 
@@ -198,6 +199,7 @@ public abstract class IccRecords extends Handler implements IccConstants {
         mParentApp = app;
         mTelephonyManager = (TelephonyManager) mContext.getSystemService(
                 Context.TELEPHONY_SERVICE);
+        mCi.registerForIccRefresh(this, EVENT_REFRESH, null);
 
         mCarrierTestOverride = new CarrierTestOverride();
 
@@ -229,10 +231,14 @@ public abstract class IccRecords extends Handler implements IccConstants {
             mLock.notifyAll();
         }
 
+        mCi.unregisterForIccRefresh(this);
         mParentApp = null;
         mFh = null;
         mCi = null;
         mContext = null;
+        if (mAdnCache != null) {
+            mAdnCache.reset();
+        }
     }
 
     public abstract void onReady();
@@ -512,21 +518,6 @@ public abstract class IccRecords extends Handler implements IccConstants {
      */
     public abstract void onRefresh(boolean fileChanged, int[] fileList);
 
-    /**
-     * Called by subclasses (SimRecords and RuimRecords) whenever
-     * IccRefreshResponse.REFRESH_RESULT_INIT event received
-     */
-    protected void onIccRefreshInit() {
-        mAdnCache.reset();
-        mMncLength = UNINITIALIZED;
-        UiccCardApplication parentApp = mParentApp;
-        if ((parentApp != null) &&
-                (parentApp.getState() == AppState.APPSTATE_READY)) {
-            // This will cause files to be reread
-            sendMessage(obtainMessage(EVENT_APP_READY));
-        }
-    }
-
     public boolean getRecordsLoaded() {
         if (mRecordsToLoad == 0 && mRecordsRequested == true) {
             return true;
@@ -561,6 +552,16 @@ public abstract class IccRecords extends Handler implements IccConstants {
                 }
                 break;
 
+            case EVENT_REFRESH:
+                ar = (AsyncResult)msg.obj;
+                if (DBG) log("Card REFRESH occurred: ");
+                if (ar.exception == null) {
+                    handleRefresh((IccRefreshResponse)ar.result);
+                } else {
+                    loge("Icc refresh Exception: " + ar.exception);
+                }
+                break;
+
             case EVENT_AKA_AUTHENTICATE_DONE:
                 ar = (AsyncResult)msg.obj;
                 auth_rsp = null;
@@ -629,6 +630,32 @@ public abstract class IccRecords extends Handler implements IccConstants {
         return null;
     }
 
+    protected abstract void handleFileUpdate(int efid);
+
+    protected void handleRefresh(IccRefreshResponse refreshResponse){
+        if (refreshResponse == null) {
+            if (DBG) log("handleRefresh received without input");
+            return;
+        }
+
+        if (refreshResponse.aid != null &&
+                !refreshResponse.aid.equals(mParentApp.getAid())) {
+            // This is for different app. Ignore.
+            return;
+        }
+
+        switch (refreshResponse.refreshResult) {
+            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
+                if (DBG) log("handleRefresh with SIM_FILE_UPDATED");
+                handleFileUpdate(refreshResponse.efId);
+                break;
+            default:
+                // unknown refresh operation
+                if (DBG) log("handleRefresh with unknown operation");
+                break;
+        }
+    }
+
     protected abstract void onRecordLoaded();
 
     protected abstract void onAllRecordsLoaded();
diff --git a/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java b/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java
index 194d25997..58d511917 100644
--- a/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/IsimUiccRecords.java
@@ -120,14 +120,7 @@ public class IsimUiccRecords extends IccRecords implements IsimRecords {
                     break;
 
                 case EVENT_ISIM_REFRESH:
-                    ar = (AsyncResult)msg.obj;
-                    loge("ISim REFRESH(EVENT_ISIM_REFRESH) with exception: " + ar.exception);
-                    if (ar.exception == null) {
-                        Intent intent = new Intent(INTENT_ISIM_REFRESH);
-                        loge("send ISim REFRESH: " + INTENT_ISIM_REFRESH);
-                        mContext.sendBroadcast(intent);
-                        handleIsimRefresh((IccRefreshResponse)ar.result);
-                    }
+                    broadcastRefresh();
                     break;
 
                 case EVENT_ISIM_AUTHENTICATE_DONE:
@@ -305,7 +298,8 @@ public class IsimUiccRecords extends IccRecords implements IsimRecords {
                 new AsyncResult(null, null, null));
     }
 
-    private void handleFileUpdate(int efid) {
+    @Override
+    protected void handleFileUpdate(int efid) {
         switch (efid) {
             case EF_IMPI:
                 mFh.loadEFTransparent(EF_IMPI, obtainMessage(
@@ -342,42 +336,10 @@ public class IsimUiccRecords extends IccRecords implements IsimRecords {
         }
     }
 
-    private void handleIsimRefresh(IccRefreshResponse refreshResponse) {
-        if (refreshResponse == null) {
-            if (DBG) log("handleIsimRefresh received without input");
-            return;
-        }
-
-        if (!TextUtils.isEmpty(refreshResponse.aid)
-                && !refreshResponse.aid.equals(mParentApp.getAid())) {
-            // This is for different app. Ignore.
-            if (DBG) log("handleIsimRefresh received different app");
-            return;
-        }
-
-        switch (refreshResponse.refreshResult) {
-            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
-                if (DBG) log("handleIsimRefresh with REFRESH_RESULT_FILE_UPDATE");
-                handleFileUpdate(refreshResponse.efId);
-                break;
-
-            case IccRefreshResponse.REFRESH_RESULT_INIT:
-                if (DBG) log("handleIsimRefresh with REFRESH_RESULT_INIT");
-                // need to reload all files (that we care about)
-                // onIccRefreshInit();
-                fetchIsimRecords();
-                break;
-
-            case IccRefreshResponse.REFRESH_RESULT_RESET:
-                // Refresh reset is handled by the UiccCard object.
-                if (DBG) log("handleIsimRefresh with REFRESH_RESULT_RESET");
-                break;
-
-            default:
-                // unknown refresh operation
-                if (DBG) log("handleIsimRefresh with unknown operation");
-                break;
-        }
+    private void broadcastRefresh() {
+        Intent intent = new Intent(INTENT_ISIM_REFRESH);
+        log("send ISim REFRESH: " + INTENT_ISIM_REFRESH);
+        mContext.sendBroadcast(intent);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/uicc/RuimRecords.java b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
index b303ca8e8..1e7660167 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
@@ -96,8 +96,6 @@ public class RuimRecords extends IccRecords {
     private static final int EVENT_SMS_ON_RUIM = 21;
     private static final int EVENT_GET_SMS_DONE = 22;
 
-    private static final int EVENT_RUIM_REFRESH = 31;
-
     public RuimRecords(UiccCardApplication app, Context c, CommandsInterface ci) {
         super(app, c, ci);
 
@@ -109,7 +107,6 @@ public class RuimRecords extends IccRecords {
         mRecordsToLoad = 0;
 
         // NOTE the EVENT_SMS_ON_RUIM is not registered
-        mCi.registerForIccRefresh(this, EVENT_RUIM_REFRESH, null);
 
         // Start off by setting empty state
         resetRecords();
@@ -122,7 +119,6 @@ public class RuimRecords extends IccRecords {
     public void dispose() {
         if (DBG) log("Disposing RuimRecords " + this);
         //Unregister for all events
-        mCi.unregisterForIccRefresh(this);
         mParentApp.unregisterForReady(this);
         resetRecords();
         super.dispose();
@@ -693,14 +689,6 @@ public class RuimRecords extends IccRecords {
                 log("Event EVENT_GET_SST_DONE Received");
             break;
 
-            case EVENT_RUIM_REFRESH:
-                isRecordLoadResponse = false;
-                ar = (AsyncResult)msg.obj;
-                if (ar.exception == null) {
-                    handleRuimRefresh((IccRefreshResponse)ar.result);
-                }
-                break;
-
             default:
                 super.handleMessage(msg);   // IccRecords handles generic record load responses
 
@@ -911,38 +899,10 @@ public class RuimRecords extends IccRecords {
         return 0;
     }
 
-    private void handleRuimRefresh(IccRefreshResponse refreshResponse) {
-        if (refreshResponse == null) {
-            if (DBG) log("handleRuimRefresh received without input");
-            return;
-        }
-
-        if (!TextUtils.isEmpty(refreshResponse.aid)
-                && !refreshResponse.aid.equals(mParentApp.getAid())) {
-            // This is for different app. Ignore.
-            return;
-        }
-
-        switch (refreshResponse.refreshResult) {
-            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
-                if (DBG) log("handleRuimRefresh with SIM_REFRESH_FILE_UPDATED");
-                mAdnCache.reset();
-                fetchRuimRecords();
-                break;
-            case IccRefreshResponse.REFRESH_RESULT_INIT:
-                if (DBG) log("handleRuimRefresh with SIM_REFRESH_INIT");
-                // need to reload all files (that we care about)
-                onIccRefreshInit();
-                break;
-            case IccRefreshResponse.REFRESH_RESULT_RESET:
-                // Refresh reset is handled by the UiccCard object.
-                if (DBG) log("handleRuimRefresh with SIM_REFRESH_RESET");
-                break;
-            default:
-                // unknown refresh operation
-                if (DBG) log("handleRuimRefresh with unknown operation");
-                break;
-        }
+    @Override
+    protected void handleFileUpdate(int efid) {
+        mAdnCache.reset();
+        fetchRuimRecords();
     }
 
     public String getMdn() {
diff --git a/src/java/com/android/internal/telephony/uicc/SIMRecords.java b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
index fab7d93ec..972c34293 100755
--- a/src/java/com/android/internal/telephony/uicc/SIMRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
@@ -177,7 +177,7 @@ public class SIMRecords extends IccRecords {
     private static final int SYSTEM_EVENT_BASE = 0x100;
     private static final int EVENT_CARRIER_CONFIG_CHANGED = 1 + SYSTEM_EVENT_BASE;
     private static final int EVENT_APP_LOCKED = 2 + SYSTEM_EVENT_BASE;
-    private static final int EVENT_SIM_REFRESH = 3 + SYSTEM_EVENT_BASE;
+
 
     // Lookup table for carriers known to produce SIMs which incorrectly indicate MNC length.
 
@@ -220,7 +220,6 @@ public class SIMRecords extends IccRecords {
         mRecordsToLoad = 0;
 
         mCi.setOnSmsOnSim(this, EVENT_SMS_ON_SIM, null);
-        mCi.registerForIccRefresh(this, EVENT_SIM_REFRESH, null);
 
         // Start off by setting empty state
         resetRecords();
@@ -246,7 +245,6 @@ public class SIMRecords extends IccRecords {
     public void dispose() {
         if (DBG) log("Disposing SIMRecords this=" + this);
         //Unregister for all events
-        mCi.unregisterForIccRefresh(this);
         mCi.unSetOnSmsOnSim(this);
         mParentApp.unregisterForReady(this);
         mParentApp.unregisterForLocked(this);
@@ -1208,14 +1206,6 @@ public class SIMRecords extends IccRecords {
                         ((Message) ar.userObj).sendToTarget();
                     }
                     break;
-                case EVENT_SIM_REFRESH:
-                    isRecordLoadResponse = false;
-                    ar = (AsyncResult) msg.obj;
-                    if (DBG) log("Sim REFRESH with exception: " + ar.exception);
-                    if (ar.exception == null) {
-                        handleSimRefresh((IccRefreshResponse) ar.result);
-                    }
-                    break;
                 case EVENT_GET_CFIS_DONE:
                     isRecordLoadResponse = true;
 
@@ -1405,7 +1395,8 @@ public class SIMRecords extends IccRecords {
         }
     }
 
-    private void handleFileUpdate(int efid) {
+    @Override
+    protected void handleFileUpdate(int efid) {
         switch(efid) {
             case EF_MBDN:
                 mRecordsToLoad++;
@@ -1449,39 +1440,6 @@ public class SIMRecords extends IccRecords {
         }
     }
 
-    private void handleSimRefresh(IccRefreshResponse refreshResponse){
-        if (refreshResponse == null) {
-            if (DBG) log("handleSimRefresh received without input");
-            return;
-        }
-
-        if (!TextUtils.isEmpty(refreshResponse.aid)
-                && !refreshResponse.aid.equals(mParentApp.getAid())) {
-            // This is for different app. Ignore.
-            return;
-        }
-
-        switch (refreshResponse.refreshResult) {
-            case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
-                if (DBG) log("handleSimRefresh with SIM_FILE_UPDATED");
-                handleFileUpdate(refreshResponse.efId);
-                break;
-            case IccRefreshResponse.REFRESH_RESULT_INIT:
-                if (DBG) log("handleSimRefresh with SIM_REFRESH_INIT");
-                // need to reload all files (that we care about)
-                onIccRefreshInit();
-                break;
-            case IccRefreshResponse.REFRESH_RESULT_RESET:
-                // Refresh reset is handled by the UiccCard object.
-                if (DBG) log("handleSimRefresh with SIM_REFRESH_RESET");
-                break;
-            default:
-                // unknown refresh operation
-                if (DBG) log("handleSimRefresh with unknown operation");
-                break;
-        }
-    }
-
     /**
      * Dispatch 3GPP format message to registrant ({@code GsmCdmaPhone}) to pass to the 3GPP SMS
      * dispatcher for delivery.
diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index a948b7567..0e2b9692e 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -240,6 +240,7 @@ public class UiccController extends Handler {
                     break;
                 default:
                     Rlog.e(LOG_TAG, " Unknown Event " + msg.what);
+                    break;
             }
         }
     }
@@ -320,29 +321,39 @@ public class UiccController extends Handler {
         IccRefreshResponse resp = (IccRefreshResponse) ar.result;
         Rlog.d(LOG_TAG, "onSimRefresh: " + resp);
 
+        if (resp == null) {
+            Rlog.e(LOG_TAG, "onSimRefresh: received without input");
+            return;
+        }
+
         if (mUiccCards[index] == null) {
             Rlog.e(LOG_TAG,"onSimRefresh: refresh on null card : " + index);
             return;
         }
 
-        if (resp.refreshResult != IccRefreshResponse.REFRESH_RESULT_RESET) {
-          Rlog.d(LOG_TAG, "Ignoring non reset refresh: " + resp);
-          return;
+        Rlog.d(LOG_TAG, "Handling refresh: " + resp);
+        boolean changed = false;
+        switch(resp.refreshResult) {
+            case IccRefreshResponse.REFRESH_RESULT_RESET:
+            case IccRefreshResponse.REFRESH_RESULT_INIT:
+                 // Reset the required apps when we know about the refresh so that
+                 // anyone interested does not get stale state.
+                 changed = mUiccCards[index].resetAppWithAid(resp.aid);
+                 break;
+            default:
+                 return;
         }
 
-        Rlog.d(LOG_TAG, "Handling refresh reset: " + resp);
-
-        boolean changed = mUiccCards[index].resetAppWithAid(resp.aid);
-        if (changed) {
+        if (changed && resp.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
             boolean requirePowerOffOnSimRefreshReset = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_requireRadioPowerOffOnSimRefreshReset);
             if (requirePowerOffOnSimRefreshReset) {
                 mCis[index].setRadioPower(false, null);
-            } else {
-                mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
             }
-            mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
         }
+
+        // The card status could have changed. Get the latest state.
+        mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE));
     }
 
     private boolean isValidCardIndex(int index) {
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java
new file mode 100644
index 000000000..e89e7b90c
--- /dev/null
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java
@@ -0,0 +1,89 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.android.internal.telephony.uicc;
+
+import org.mockito.Mock;
+import static org.mockito.Mockito.*;
+import org.mockito.MockitoAnnotations;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import com.android.internal.telephony.TelephonyTest;
+
+import com.android.internal.telephony.CommandsInterface;
+import android.content.Context;
+import android.os.HandlerThread;
+
+public class IccRecordsTest extends TelephonyTest {
+
+    @Mock
+    private CommandsInterface mMockCI;
+
+    private IccRecords mIccRecords;
+
+    private class IccRecordsTestHandler extends HandlerThread {
+        private IccRecordsTestHandler(String name) {
+            super(name);
+        }
+
+        @Override
+        public void onLooperPrepared() {
+            mIccRecords = new SIMRecords(mUiccCardApplication3gpp, mContext, mMockCI);
+            setReady(true);
+        }
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp(this.getClass().getSimpleName());
+        mMockCI = mock(CommandsInterface.class);
+        new IccRecordsTestHandler(TAG).start();
+        waitUntilReady();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        super.tearDown();
+        mIccRecords.dispose();
+    }
+
+    @Test
+    public void testDisposeCallsUnregisterForIccRefresh() {
+        // verify called below when IccRecords object is created
+        verify(mMockCI).registerForIccRefresh(any(IccRecords.class),
+                    eq(IccRecords.EVENT_REFRESH), isNull());
+        mIccRecords.dispose();
+        // verify called within dispose
+        verify(mMockCI).unregisterForIccRefresh(any(IccRecords.class));
+
+    }
+
+
+}
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/IsimUiccRecordsTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/IsimUiccRecordsTest.java
new file mode 100644
index 000000000..a9b63793b
--- /dev/null
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/IsimUiccRecordsTest.java
@@ -0,0 +1,122 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.android.internal.telephony.uicc;
+
+import org.mockito.Mock;
+import static org.mockito.Mockito.*;
+import org.mockito.MockitoAnnotations;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import com.android.internal.telephony.TelephonyTest;
+import org.mockito.ArgumentCaptor;
+import static org.junit.Assert.*;
+import java.lang.reflect.Method;
+import java.lang.reflect.Field;
+import junit.framework.Assert;
+
+import com.android.internal.telephony.CommandsInterface;
+import android.content.Context;
+import android.content.Intent;
+import android.os.HandlerThread;
+import android.os.Message;
+
+public class IsimUiccRecordsTest extends TelephonyTest {
+
+    @Mock
+    private CommandsInterface mMockCI;
+
+    private IsimUiccRecords mIsimUiccRecords;
+
+    private class IsimUiccRecordsTestHandler extends HandlerThread {
+        private IsimUiccRecordsTestHandler(String name) {
+            super(name);
+        }
+
+        @Override
+        public void onLooperPrepared() {
+            mIsimUiccRecords = new IsimUiccRecords(mUiccCardApplication3gpp, mContext, mMockCI);
+            setReady(true);
+        }
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp(this.getClass().getSimpleName());
+        mMockCI = mock(CommandsInterface.class);
+        new IsimUiccRecordsTestHandler(TAG).start();
+        waitUntilReady();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        super.tearDown();
+        mIsimUiccRecords.dispose();
+
+    }
+
+    @Test
+    public void testBroadcastRefresh() {
+        Message msg = new Message();
+        msg.what = (Integer) getStaticField(IsimUiccRecords.class,
+            mIsimUiccRecords, "EVENT_ISIM_REFRESH");
+        mIsimUiccRecords.handleMessage(msg);
+        ArgumentCaptor<Intent> intentCapture = ArgumentCaptor.forClass(Intent.class);
+        verify(mContext).sendBroadcast(intentCapture.capture());
+
+        assertEquals(
+            ((Intent) intentCapture.getValue()).getAction(), IsimUiccRecords.INTENT_ISIM_REFRESH);
+    }
+
+    private Object invokeNonStaticMethod(Class clazz, Object caller, String method,
+                                            Class[] clsParams, Object[] params) {
+        try {
+            Method methodReflection = clazz.getDeclaredMethod(method, clsParams);
+            methodReflection.setAccessible(true);
+            return methodReflection.invoke(caller, params);
+        } catch (Exception e) {
+            Assert.fail(e.toString());
+            return null;
+        }
+    }
+
+    private Object getStaticField(Class clazz, Object caller, String field) {
+        try {
+            Field fieldReflection = clazz.getDeclaredField(field);
+            fieldReflection.setAccessible(true);
+            Object fieldValue = fieldReflection.get(caller);
+            return fieldValue;
+        } catch (Exception e) {
+            Assert.fail(e.toString());
+            return null;
+        }
+    }
+
+}
-- 
2.17.1

