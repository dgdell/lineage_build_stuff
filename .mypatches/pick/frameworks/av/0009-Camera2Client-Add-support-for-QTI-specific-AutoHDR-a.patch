From 8c26fe1afff3b271ef60a1cb0c672c3b1e56752a Mon Sep 17 00:00:00 2001
From: Arvind Kumar <arvindkk@codeaurora.org>
Date: Wed, 24 May 2017 12:36:11 +0530
Subject: [PATCH 09/20] Camera2Client: Add support for QTI specific AutoHDR and
 Histogram feature

Add support for QTI specific AutoHDR and Histogram feature in Camera2Client

Change-Id: I8931826b3abdc001751fbe87c599b76239e50e3f
---
 services/camera/libcameraservice/Android.mk   |   1 +
 .../libcameraservice/api1/Camera2Client.cpp   |   5 +
 .../api1/QTICamera2Client.cpp                 |  24 +++
 .../libcameraservice/api1/QTICamera2Client.h  |   1 +
 .../api1/qticlient2/FrameProcessor.cpp        |   5 +
 .../api1/qticlient2/FrameProcessor.h          |   5 +
 .../api1/qticlient2/Parameters.cpp            |   2 +-
 .../api1/qticlient2/QTICaptureSequencer.cpp   |   4 +-
 .../api1/qticlient2/QTIFrameProcessor.cpp     | 126 +++++++++++++
 .../api1/qticlient2/QTIFrameProcessor.h       |  41 +++++
 .../api1/qticlient2/QTIParameters.cpp         | 167 ++++++++++++++----
 .../api1/qticlient2/QTIParameters.h           |   8 +-
 12 files changed, 353 insertions(+), 36 deletions(-)
 create mode 100644 services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.cpp
 create mode 100644 services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.h

diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index affd87c12..74282ef88 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -56,6 +56,7 @@ LOCAL_SRC_FILES +=  \
     api1/qticlient2/Parameters.cpp \
     api1/qticlient2/QTIParameters.cpp \
     api1/qticlient2/FrameProcessor.cpp \
+    api1/qticlient2/QTIFrameProcessor.cpp \
     api1/qticlient2/StreamingProcessor.cpp \
     api1/qticlient2/JpegProcessor.cpp \
     api1/qticlient2/CallbackProcessor.cpp \
diff --git a/services/camera/libcameraservice/api1/Camera2Client.cpp b/services/camera/libcameraservice/api1/Camera2Client.cpp
index b52f6044d..61da676c7 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.cpp
+++ b/services/camera/libcameraservice/api1/Camera2Client.cpp
@@ -1622,9 +1622,14 @@ status_t Camera2Client::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
                     __FUNCTION__, cmd, arg1, arg2);
             return BAD_VALUE;
         default:
+#ifdef USE_QTI_CAMERA2CLIENT
+            SharedParameters::Lock l(mParameters);
+            return mQTICamera2Client->sendCommand(l.mParameters,cmd, arg1, arg2);
+#else
             ALOGE("%s: Unknown command %d (arguments %d, %d)",
                     __FUNCTION__, cmd, arg1, arg2);
             return BAD_VALUE;
+#endif
     }
 }
 
diff --git a/services/camera/libcameraservice/api1/QTICamera2Client.cpp b/services/camera/libcameraservice/api1/QTICamera2Client.cpp
index 769f921f2..f0953a519 100644
--- a/services/camera/libcameraservice/api1/QTICamera2Client.cpp
+++ b/services/camera/libcameraservice/api1/QTICamera2Client.cpp
@@ -322,5 +322,29 @@ void QTICamera2Client::stopPreviewForRestart(Parameters &params) {
     client->mZslProcessor->deleteStream();
 
 }
+
+status_t QTICamera2Client::sendCommand(Parameters &params,int32_t cmd, int32_t arg1, int32_t arg2) {
+    status_t res = OK;
+    switch (cmd) {
+        case CAMERA_CMD_METADATA_ON:
+            return OK;
+        case CAMERA_CMD_METADATA_OFF:
+            return OK;
+        case CAMERA_CMD_HISTOGRAM_ON:
+            params.qtiParams->histogramMode = 1;
+            break;
+        case CAMERA_CMD_HISTOGRAM_OFF:
+            params.qtiParams->histogramMode = 0;
+            break;
+        case CAMERA_CMD_HISTOGRAM_SEND_DATA:
+            return OK;
+        default:
+            ALOGE("%s: Unknown command %d (arguments %d, %d)",
+                    __FUNCTION__, cmd, arg1, arg2);
+            return BAD_VALUE;
+    }
+    return res;
+}
+
 } // namespace android
 
diff --git a/services/camera/libcameraservice/api1/QTICamera2Client.h b/services/camera/libcameraservice/api1/QTICamera2Client.h
index 22bd98711..49de2e0cb 100644
--- a/services/camera/libcameraservice/api1/QTICamera2Client.h
+++ b/services/camera/libcameraservice/api1/QTICamera2Client.h
@@ -46,6 +46,7 @@ public:
     status_t setParametersExtn(Parameters &params);
     status_t startHFRRecording(Parameters &params);
     void stopHFRRecording(Parameters &params);
+    status_t sendCommand(Parameters &params,int32_t cmd, int32_t arg1, int32_t arg2);
 
 private:
     void stopPreviewForRestart(Parameters &params);
diff --git a/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.cpp b/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.cpp
index 7b9e98d3d..3664ea26e 100644
--- a/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.cpp
@@ -57,6 +57,8 @@ FrameProcessor::FrameProcessor(wp<CameraDeviceBase> device,
         m3aState.afState = ANDROID_CONTROL_AF_STATE_INACTIVE;
         m3aState.awbState = ANDROID_CONTROL_AWB_STATE_INACTIVE;
     }
+
+    qtiFrameProcessor = new QTIFrameProcessor();
 }
 
 FrameProcessor::~FrameProcessor() {
@@ -71,6 +73,9 @@ bool FrameProcessor::processSingleFrame(CaptureResult &frame,
     }
 
     bool isPartialResult = false;
+
+    qtiFrameProcessor->processSingleFrameExtn(frame.mMetadata, client);
+
     if (mUsePartialResult) {
         isPartialResult = frame.mResultExtras.partialResultCount < mNumPartialResults;
     }
diff --git a/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.h b/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.h
index 62a4e91df..fafe022df 100644
--- a/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.h
+++ b/services/camera/libcameraservice/api1/qticlient2/FrameProcessor.h
@@ -24,6 +24,8 @@
 #include <utils/List.h>
 #include <camera/CameraMetadata.h>
 
+#include "QTIFrameProcessor.h"
+
 #include "common/FrameProcessorBase.h"
 
 struct camera_frame_metadata;
@@ -106,6 +108,9 @@ class FrameProcessor : public FrameProcessorBase {
     // several times.
     int32_t mLast3AFrameNumber;
 
+    sp<QTIFrameProcessor> qtiFrameProcessor;
+
+
     // Emit FaceDetection event to java if faces changed
     void callbackFaceDetection(const sp<Camera2Client>& client,
                                const camera_frame_metadata &metadata);
diff --git a/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp b/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp
index 89264a508..4f84adc0a 100644
--- a/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp
@@ -2560,7 +2560,7 @@ int Parameters::sceneModeStringToEnum(const char *sceneMode) {
             ANDROID_CONTROL_SCENE_MODE_BARCODE:
         !strcmp(sceneMode, CameraParameters::SCENE_MODE_HDR) ?
             ANDROID_CONTROL_SCENE_MODE_HDR:
-        -1;
+        QTIParameters::sceneModeStringToEnum(sceneMode);;
 }
 
 Parameters::Parameters::flashMode_t Parameters::flashModeStringToEnum(
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTICaptureSequencer.cpp b/services/camera/libcameraservice/api1/qticlient2/QTICaptureSequencer.cpp
index 12f394a05..3592237dc 100644
--- a/services/camera/libcameraservice/api1/qticlient2/QTICaptureSequencer.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/QTICaptureSequencer.cpp
@@ -91,7 +91,9 @@ status_t QTICaptureSequencer::startCapture(int msgType, bool& useQTISequencer) {
         // Set QTI capture sequencer for ZSL,
         // For AE bracketing,
         if ((mBurstCount > 1) ||
-                (lp.mParameters.allowZslMode)) {
+                (lp.mParameters.allowZslMode) ||
+                (lp.mParameters.qtiParams->autoHDREnabled &&
+                lp.mParameters.qtiParams->isHdrScene)) {
             useQTISequencer = true;
         }
     }
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.cpp b/services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.cpp
new file mode 100644
index 000000000..0dac9daae
--- /dev/null
+++ b/services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.cpp
@@ -0,0 +1,126 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ */
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Camera2-QTIFrameProcessor"
+#define ATRACE_TAG ATRACE_TAG_CAMERA
+#define LOG_NDEBUG 0
+
+#include <utils/Log.h>
+#include <utils/Trace.h>
+
+#include "QTIFrameProcessor.h"
+#include "api1/Camera2Client.h"
+
+namespace android {
+namespace camera2 {
+
+bool QTIFrameProcessor::processSingleFrameExtn(const CameraMetadata &metadata,
+        sp<Camera2Client> client) {
+
+    bool result = true;
+    status_t res = OK;
+    uint8_t enableHistogram = 0;
+    uint32_t tag = 0;
+    sp<MemoryHeapBase> mHeap;
+
+    camera_metadata_ro_entry_t entry;
+    SharedParameters::Lock l(client->getParameters());
+
+    sp<VendorTagDescriptor> vTags =
+        VendorTagDescriptor::getGlobalVendorTagDescriptor();
+    if ((nullptr == vTags.get()) || (0 >= vTags->getTagCount())) {
+        sp<VendorTagDescriptorCache> cache =
+                VendorTagDescriptorCache::getGlobalVendorTagCache();
+        if (cache.get()) {
+            cache->getVendorTagDescriptor(l.mParameters.qtiParams->vendorTagId, &vTags);
+        }
+    }
+
+    // Find if histogram enabled.
+    enableHistogram = l.mParameters.qtiParams->histogramMode;
+
+    if (enableHistogram) {
+        res = CameraMetadata::getTagFromName("org.codeaurora.qcamera3.histogram.stats",
+                vTags.get(), &tag);
+        if(res!=OK)
+        {
+            ALOGE("couldn't find org.codeaurora.qcamera3.histogram.stats %d",res);
+        }
+        else if(metadata.exists(tag)) {
+            entry = metadata.find(tag);
+            if (entry.count > 0) {
+                ALOGV("histogram count : %zu %d", entry.count,__LINE__);
+            }
+            const int32_t hist_size = l.mParameters.qtiParams->histogramBucketSize;
+            mHeap = new MemoryHeapBase(entry.count, 0, "histogram");
+            const sp<MemoryBase> &histogramData = new MemoryBase(mHeap, 0, entry.count);
+            void* temp = (void*)((uint8_t*)mHeap->getBase() + (0*hist_size));
+            memcpy(temp, &entry.data.i32[0*hist_size], hist_size*4);
+            Camera2Client::SharedCameraCallbacks::Lock lc(client->mSharedCameraCallbacks);
+            if (lc.mRemoteCallback != NULL) {
+                lc.mRemoteCallback->dataCallback(CAMERA_MSG_STATS_DATA,
+                                                            histogramData,
+                                                            NULL);
+            }
+
+        }
+    }
+    // Process auto Scene mode
+    if(l.mParameters.qtiParams->autoHDREnabled) {
+        sp<MemoryHeapBase> mFrameHeap =
+                new MemoryHeapBase(sizeof(int)*3, 0, "FrameProcessor::MetaData");
+        sp<MemoryBase> FrameBuffer = new MemoryBase(mFrameHeap, 0, sizeof(int)*3);
+
+        status_t res = OK;
+        uint32_t tag = 0;
+        int HdrData[3];
+
+        camera_metadata_ro_entry_t entry;
+        res = CameraMetadata::getTagFromName("org.codeaurora.qcamera3.stats.is_hdr_scene",
+                vTags.get(), &tag);
+        if (metadata.exists(tag)) {
+            entry = metadata.find(tag);
+            if (entry.count > 0) {
+                // A boolean value indicating if the scene is ideal for HDR capture
+                // 0-False/1-True
+                {
+                    l.mParameters.qtiParams->isHdrScene = entry.data.u8[0];
+
+                    HdrData[0] = CAMERA_META_DATA_HDR;
+                    HdrData[1] = sizeof(int)*3;
+                    HdrData[2] = l.mParameters.qtiParams->isHdrScene;
+                    void* captureMemory = mFrameHeap->getBase();
+                    memcpy(captureMemory, HdrData, sizeof(int)*3);
+
+                    Camera2Client::SharedCameraCallbacks::Lock ll(client->mSharedCameraCallbacks);
+                    if (ll.mRemoteCallback != NULL) {
+                        ll.mRemoteCallback->dataCallback(CAMERA_MSG_META_DATA,
+                                                        FrameBuffer,
+                                                        (camera_frame_metadata *)&metadata);
+                    }
+                }
+            }
+        }
+    }
+    return result;
+}
+
+
+}; // namespace camera2
+}; // namespace android
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.h b/services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.h
new file mode 100644
index 000000000..07555a730
--- /dev/null
+++ b/services/camera/libcameraservice/api1/qticlient2/QTIFrameProcessor.h
@@ -0,0 +1,41 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ */
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SERVERS_CAMERA_CAMERA2_QTIFRAMEPROCESSOR_H
+#define ANDROID_SERVERS_CAMERA_CAMERA2_QTIFRAMEPROCESSOR_H
+
+#include <camera/CameraMetadata.h>
+#include <utils/RefBase.h>
+
+namespace android {
+
+class Camera2Client;
+
+namespace camera2 {
+
+class QTIFrameProcessor: public virtual RefBase {
+    public:
+    bool processSingleFrameExtn(const CameraMetadata &metadata,
+            sp<Camera2Client> client);
+};
+
+}; //namespace camera2
+}; //namespace android
+
+#endif
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp
index 75aafa471..468e8ce1c 100644
--- a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp
@@ -180,6 +180,18 @@ const char KEY_QTI_SUPPORTED_HFR_SIZES[] = "hfr-size-values";
 // HDR need 1x frame(one non-HDR extra frame).
 const char KEY_QTI_SUPPORTED_HDR_NEED_1X[] = "hdr-need-1x-values";
 const char KEY_QTI_HDR_NEED_1X[] = "hdr-need-1x";
+// AUTO HDR
+const char KEY_QTI_AUTO_HDR_SUPPORTED[] = "auto-hdr-supported";
+const char KEY_QTI_AUTO_HDR_ENABLE [] = "auto-hdr-enable";
+const char VALUE_TRUE[] = "true";
+const char VALUE_FALSE[] = "false";
+
+//Histogram
+const char KEY_QTI_VENDOR_HISTOGRAM[] = "org.codeaurora.qcamera3.histogram.enable";
+const char KEY_QTI_HISTOGRAM_MODES[] = "histogram-values";
+const char KEY_QTI_HISTOGRAM[] = "histogram";
+const char HISTOGRAM_ENABLE[] = "enable";
+const char HISTOGRAM_DISABLE[] = "disable";
 
 // DIS
 const char KEY_QTI_SUPPORTED_DIS_MODES[] = "dis-values";
@@ -190,14 +202,14 @@ status_t QTIParameters::initialize(void *parametersParent,
     status_t res = OK;
 
     Parameters* ParentParams = (Parameters*)parametersParent;
-    mVendorTagId = manager->getProviderTagIdLocked(device->getId().string());
+    vendorTagId = manager->getProviderTagIdLocked(device->getId().string());
     sp<VendorTagDescriptor> vTags =
         VendorTagDescriptor::getGlobalVendorTagDescriptor();
     if ((nullptr == vTags.get()) || (0 >= vTags->getTagCount())) {
         sp<VendorTagDescriptorCache> cache =
                 VendorTagDescriptorCache::getGlobalVendorTagCache();
         if (cache.get()) {
-            cache->getVendorTagDescriptor(mVendorTagId, &vTags);
+            cache->getVendorTagDescriptor(vendorTagId, &vTags);
         }
     }
     uint32_t tag = 0;
@@ -517,6 +529,30 @@ status_t QTIParameters::initialize(void *parametersParent,
     // Default
     ParentParams->params.set(KEY_QTI_DIS, "disable");
 
+    // Support for auto HDR scene mode detection
+    String8 supportedAutoHDRValue(VALUE_FALSE);
+    //Default Auto Hdr is Enabled.
+    supportedAutoHDRValue = VALUE_TRUE;
+    ParentParams->params.set(KEY_QTI_AUTO_HDR_SUPPORTED, supportedAutoHDRValue);
+    //Default value
+    ParentParams->params.set(KEY_QTI_AUTO_HDR_ENABLE, "disable");
+    isHdrScene = false;
+
+    //Default histogram values
+    String8 availableHistogramModes;
+    availableHistogramModes += HISTOGRAM_ENABLE;
+    availableHistogramModes += ",";
+    availableHistogramModes += HISTOGRAM_DISABLE;
+    availableHistogramModes += ",";
+    ParentParams->params.set(KEY_QTI_HISTOGRAM_MODES,availableHistogramModes);
+    ParentParams->params.set(KEY_QTI_HISTOGRAM,HISTOGRAM_DISABLE);
+    tag=0;
+    res = CameraMetadata::getTagFromName("org.codeaurora.qcamera3.histogram.buckets", vTags.get(), &tag);
+    camera_metadata_ro_entry_t histogramBuckets = ParentParams->staticInfo(tag);
+    if (histogramBuckets.count > 0) {
+        histogramBucketSize = histogramBuckets.data.i32[0];
+    }
+
     return res;
 }
 
@@ -525,29 +561,9 @@ status_t QTIParameters::set(CameraParameters2& newParams, void *parametersParent
     char prop[PROPERTY_VALUE_MAX];
     Parameters* ParentParams = (Parameters*)parametersParent;
 
-    //Video-Hdr
-    const char *videoHdrMode = newParams.get(KEY_QTI_VIDEO_HDR);
-    int32_t vidHDR = 0;
-    if(videoHdrMode) {
-        if (!strcmp(videoHdrMode, VALUE_OFF)) {
-            vidHDR = 0;
-        } else {
-            vidHDR = 1;
-        }
-    }
-    //Sensor-HDR
-    const char *HdrMode = newParams.get(KEY_SNAPCAM_HDR_MODE);
-    int32_t sensHDR = 0;
-    if(HdrMode) {
-        if(!strcmp(HdrMode,"hdr-mode-sensor")) {
-            sensHDR = 1;
-        }
-        if(!strcmp(HdrMode,"hdr-mode-multiframe")) {
-            sensHDR = 0;
-        }
-    }
-    prevVideoHdr = videoHdr;
-    videoHdr = vidHDR|sensHDR;
+    //restore previously burst count
+    burstCount = 1;
+    newParams.set("num-snaps-per-shutter",burstCount);
 
     // ISO
     const char *isoMode = newParams.get(KEY_QTI_ISO_MODE);
@@ -577,6 +593,30 @@ status_t QTIParameters::set(CameraParameters2& newParams, void *parametersParent
         }
     }
 
+    //Video-Hdr
+    const char *videoHdrMode = newParams.get(KEY_QTI_VIDEO_HDR);
+    int32_t vidHDR = 0;
+    if(videoHdrMode) {
+        if (!strcmp(videoHdrMode, VALUE_OFF)) {
+            vidHDR = 0;
+        } else {
+            vidHDR = 1;
+        }
+    }
+    //Sensor-HDR
+    const char *HdrMode = newParams.get(KEY_SNAPCAM_HDR_MODE);
+    int32_t sensHDR = 0;
+    if(HdrMode) {
+        if(!strcmp(HdrMode,"hdr-mode-sensor")) {
+            sensHDR = 1;
+        }
+        if(!strcmp(HdrMode,"hdr-mode-multiframe")) {
+            sensHDR = 0;
+        }
+    }
+    prevVideoHdr = videoHdr;
+    videoHdr = vidHDR|sensHDR;
+
     //exposure time
     const char *str = newParams.get(KEY_QTI_EXPOSURE_TIME);
 
@@ -731,6 +771,21 @@ status_t QTIParameters::set(CameraParameters2& newParams, void *parametersParent
         ParentParams->qtiParams->hfrMode = false;
     }
 
+    // AUTO HDR
+    const char *qtiAutoHdrMode = newParams.get(KEY_QTI_AUTO_HDR_ENABLE);
+    autoHDREnabled = false;
+    if (qtiAutoHdrMode != NULL) {
+        if (!strcmp(qtiAutoHdrMode, "enable")) {
+           autoHDREnabled = true;
+        }
+    } else {
+        memset(prop, 0, sizeof(prop));
+        property_get("persist.camera.auto.hdr.enable", prop, "disable");
+        if (!strcmp(prop, "enable")) {
+            autoHDREnabled = true;
+        }
+   }
+
     //hdr_need_1x
     const char *Hdr1x = newParams.get(KEY_QTI_HDR_NEED_1X);
     const char *HdrSceneMode = newParams.get(CameraParameters::KEY_SCENE_MODE);
@@ -744,7 +799,8 @@ status_t QTIParameters::set(CameraParameters2& newParams, void *parametersParent
     } else {
         Hdr1xEnable = false;
     }
-    if(HdrSceneEnable && Hdr1xEnable ) {
+
+    if(Hdr1xEnable && (HdrSceneEnable||(isHdrScene && autoHDREnabled))) {
         burstCount = 2;
         newParams.set("num-snaps-per-shutter", String8::format("%d", burstCount));
     }
@@ -780,6 +836,12 @@ const char *QTIParameters::flashModeEnumToString(flashMode_t flashMode) {
     }
 }
 
+int QTIParameters::sceneModeStringToEnum(const char *sceneMode) {
+       return
+           !strcmp(sceneMode, "asd") ?
+               ANDROID_CONTROL_SCENE_MODE_FACE_PRIORITY :
+           -1;
+}
 
 int QTIParameters::wbModeStringToEnum(const char *wbMode) {
     return
@@ -809,7 +871,7 @@ status_t QTIParameters::updateRequest(CameraMetadata *request) const {
         sp<VendorTagDescriptorCache> cache =
                 VendorTagDescriptorCache::getGlobalVendorTagCache();
         if (cache.get()) {
-            cache->getVendorTagDescriptor(mVendorTagId, &vTags);
+            cache->getVendorTagDescriptor(vendorTagId, &vTags);
         }
     }
 
@@ -817,11 +879,18 @@ status_t QTIParameters::updateRequest(CameraMetadata *request) const {
        return BAD_VALUE;
     }
 
-    //Video-Hdr
-    res = CameraMetadata::getTagFromName(KEY_QTI_VENDOR_VIDEO_HDR_MODE, vTags.get(), &tag);
-    res = request->update(tag,&videoHdr, 1);
-    if (res != OK) {
-        return res;
+    if(autoHDREnabled) {
+        uint8_t reqControlMode = ANDROID_CONTROL_MODE_USE_SCENE_MODE;
+        res = request->update(ANDROID_CONTROL_MODE,
+              &reqControlMode, 1);
+        if (res != OK) return res;
+
+        uint8_t reqSceneMode = ANDROID_CONTROL_SCENE_MODE_FACE_PRIORITY;
+        res = request->update(ANDROID_CONTROL_SCENE_MODE,
+        &reqSceneMode, 1);
+        if (res != OK) {
+            return res;
+        }
     }
 
     if (isoValue != -1) {
@@ -849,6 +918,13 @@ status_t QTIParameters::updateRequest(CameraMetadata *request) const {
 
     }
 
+    //Video-Hdr
+    res = CameraMetadata::getTagFromName(KEY_QTI_VENDOR_VIDEO_HDR_MODE, vTags.get(), &tag);
+    res = request->update(tag,&videoHdr, 1);
+    if (res != OK) {
+        return res;
+    }
+
     if (exposureTime > 0) {
         int32_t selectPriority = 1; // 0 for iso, 1 for exp.
         res = CameraMetadata::getTagFromName(KEY_QTI_VENDOR_ISO_EXP_SELECT_PRIORITY,
@@ -916,6 +992,13 @@ status_t QTIParameters::updateRequest(CameraMetadata *request) const {
         if (res != OK) return res;
     }
 
+    //Histogram
+    res = CameraMetadata::getTagFromName(KEY_QTI_VENDOR_HISTOGRAM, vTags.get(), &tag);
+    res = request->update(tag, &histogramMode, 1);
+    if (res != OK) {
+        return res;
+    }
+
     return res;
 }
 
@@ -931,7 +1014,7 @@ status_t QTIParameters::updateRequestForQTICapture(Vector<CameraMetadata> *reque
     // Check if any Capture request settings need to be changed for QTI features
 
     // For HDR need one extra frame.
-    if(Hdr1xEnable && HdrSceneEnable){
+    if(Hdr1xEnable && (HdrSceneEnable||(isHdrScene && autoHDREnabled))){
         for (size_t i = 0; i < burstCount; i++) {
             CameraMetadata &request = requests->editItemAt(i);
             uint8_t reqSceneMode;
@@ -957,6 +1040,24 @@ status_t QTIParameters::updateRequestForQTICapture(Vector<CameraMetadata> *reque
             }
         }
     }
+    else {
+        if(autoHDREnabled && isHdrScene) {
+            CameraMetadata &request = requests->editItemAt(0);
+            uint8_t reqSceneMode;
+            uint8_t reqControlMode;
+            reqSceneMode = ANDROID_CONTROL_SCENE_MODE_HDR;
+            reqControlMode = ANDROID_CONTROL_MODE_USE_SCENE_MODE;
+
+            res = request.update(ANDROID_CONTROL_MODE, &reqControlMode, 1);
+            if (res != OK) {
+                return res;
+            }
+            res = request.update(ANDROID_CONTROL_SCENE_MODE, &reqSceneMode, 1);
+            if (res != OK) {
+                return res;
+            }
+        }
+    }
 
     // For AE bracketing
     if (aeBracketEnable) {
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h
index 6466ea8c9..109805996 100644
--- a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h
+++ b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h
@@ -96,19 +96,24 @@ private:
         FLASH_MODE_RED_EYE = ANDROID_CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE,
         FLASH_MODE_INVALID = -1
     } flashMode;
-    metadata_vendor_id_t mVendorTagId;
 
 public:
     int32_t videoHdr;
     int32_t prevVideoHdr;
+    uint8_t histogramMode;
+    int32_t histogramBucketSize;
+    bool isHdrScene;
+    bool autoHDREnabled;
     bool mNeedRestart;
     uint8_t burstCount;
+    uint8_t lastBurstCount;
     bool aeBracketEnable;
     bool hfrMode;
     int32_t hfrPreviewFpsRange[2];
     int32_t nonHfrPreviewFpsRange[2];
     bool Hdr1xEnable;
     bool HdrSceneEnable;
+    metadata_vendor_id_t vendorTagId;
     // Sets up default QTI parameters
     status_t initialize(void *parametersParent, sp<CameraDeviceBase> device, sp<CameraProviderManager> manager);
     // Validate and update camera parameters based on new settings
@@ -118,6 +123,7 @@ public:
     status_t updateRequestForQTICapture(Vector<CameraMetadata> *requests) const;
     static const char* wbModeEnumToString(uint8_t wbMode);
     static int wbModeStringToEnum(const char *wbMode);
+    static int sceneModeStringToEnum(const char *sceneMode);
 
 private:
     int32_t setContinuousISO(const char *isoValue, CameraParameters2& newParams);
-- 
2.17.1

