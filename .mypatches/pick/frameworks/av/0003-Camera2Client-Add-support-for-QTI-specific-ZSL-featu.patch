From 6f8074117591b23adc63a8a020f8a3b50f3c2e79 Mon Sep 17 00:00:00 2001
From: Sampath Vangaveti <sampathv@codeaurora.org>
Date: Thu, 13 Apr 2017 17:59:51 +0530
Subject: [PATCH 03/11] Camera2Client: Add support for QTI specific ZSL feature

Add support for QTI specific ZSL feature in Camera2Client.

Change-Id: I1c99ad004cf3264b8c009ed1b53a1ab7da56dab0
---
 services/camera/libcameraservice/Android.mk   |   1 +
 .../libcameraservice/api1/Camera2Client.cpp   |   9 ++
 .../libcameraservice/api1/Camera2Client.h     |  11 ++
 .../api1/QTICamera2Client.cpp                 | 110 ++++++++++++++++++
 .../libcameraservice/api1/QTICamera2Client.h  |  52 +++++++++
 .../api1/qticlient2/CaptureSequencer.cpp      |  17 ++-
 .../api1/qticlient2/Parameters.cpp            |   6 +-
 .../api1/qticlient2/QTIParameters.cpp         |  33 +++++-
 .../api1/qticlient2/QTIParameters.h           |   3 +-
 .../api1/qticlient2/ZslProcessor.cpp          |  23 +++-
 .../api1/qticlient2/ZslProcessor.h            |   4 +
 11 files changed, 254 insertions(+), 15 deletions(-)
 create mode 100644 services/camera/libcameraservice/api1/QTICamera2Client.cpp
 create mode 100644 services/camera/libcameraservice/api1/QTICamera2Client.h

diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index d14992d9c..75c9dac07 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -52,6 +52,7 @@ LOCAL_SRC_FILES :=  \
 #use QTI Camera2Client layer, if TARGET_USES_QTI_CAMERA2CLIENT is enabled.
 ifeq ($(TARGET_USES_QTI_CAMERA2CLIENT),true)
 LOCAL_SRC_FILES +=  \
+    api1/QTICamera2Client.cpp \
     api1/qticlient2/Parameters.cpp \
     api1/qticlient2/QTIParameters.cpp \
     api1/qticlient2/FrameProcessor.cpp \
diff --git a/services/camera/libcameraservice/api1/Camera2Client.cpp b/services/camera/libcameraservice/api1/Camera2Client.cpp
index 743aa905c..d9409c567 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.cpp
+++ b/services/camera/libcameraservice/api1/Camera2Client.cpp
@@ -35,6 +35,7 @@
 #include "api1/client2/CallbackProcessor.h"
 #include "api1/client2/ZslProcessor.h"
 #else
+#include "api1/QTICamera2Client.h"
 #include "api1/qticlient2/StreamingProcessor.h"
 #include "api1/qticlient2/JpegProcessor.h"
 #include "api1/qticlient2/CaptureSequencer.h"
@@ -125,6 +126,10 @@ status_t Camera2Client::initializeImpl(TProviderPtr providerPtr)
 
     String8 threadName;
 
+#ifdef USE_QTI_CAMERA2CLIENT
+    mQTICamera2Client = new QTICamera2Client(this);
+#endif
+
     mStreamingProcessor = new StreamingProcessor(this);
     threadName = String8::format("C2-%d-StreamProc",
             mCameraId);
@@ -1549,6 +1554,10 @@ status_t Camera2Client::setParameters(const String8& params) {
         mZslProcessor->clearZslQueue();
     }
 
+#ifdef USE_QTI_CAMERA2CLIENT
+    if ( (res = mQTICamera2Client->setParametersExtn(l.mParameters) ) != OK) return res;
+#endif
+
     res = updateRequests(l.mParameters);
 
     return res;
diff --git a/services/camera/libcameraservice/api1/Camera2Client.h b/services/camera/libcameraservice/api1/Camera2Client.h
index 905430e86..aa53c1b71 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.h
+++ b/services/camera/libcameraservice/api1/Camera2Client.h
@@ -35,6 +35,10 @@
 
 namespace android {
 
+#ifdef USE_QTI_CAMERA2CLIENT
+class QTICamera2Client;
+#endif
+
 namespace camera2 {
 
 class StreamingProcessor;
@@ -53,6 +57,10 @@ class IMemory;
 class Camera2Client :
         public Camera2ClientBase<CameraService::Client>
 {
+#ifdef USE_QTI_CAMERA2CLIENT
+friend class QTICamera2Client;
+#endif
+
 public:
     /**
      * ICamera interface (see ICamera for details)
@@ -217,6 +225,9 @@ private:
     sp<camera2::CaptureSequencer> mCaptureSequencer;
     sp<camera2::JpegProcessor> mJpegProcessor;
     sp<camera2::ZslProcessor> mZslProcessor;
+#ifdef USE_QTI_CAMERA2CLIENT
+    sp<QTICamera2Client> mQTICamera2Client;
+#endif
 
     /** Utility members */
     bool mLegacyMode;
diff --git a/services/camera/libcameraservice/api1/QTICamera2Client.cpp b/services/camera/libcameraservice/api1/QTICamera2Client.cpp
new file mode 100644
index 000000000..fd88869b0
--- /dev/null
+++ b/services/camera/libcameraservice/api1/QTICamera2Client.cpp
@@ -0,0 +1,110 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_TAG "QTICamera2Client"
+#define ATRACE_TAG ATRACE_TAG_CAMERA
+//#define LOG_NDEBUG 0
+
+#include <inttypes.h>
+#include <utils/Log.h>
+#include <utils/Trace.h>
+
+#include <cutils/properties.h>
+
+#include "api1/Camera2Client.h"
+#include "api1/QTICamera2Client.h"
+
+#include "api1/qticlient2/StreamingProcessor.h"
+#include "api1/qticlient2/JpegProcessor.h"
+#include "api1/qticlient2/CaptureSequencer.h"
+#include "api1/qticlient2/CallbackProcessor.h"
+#include "api1/qticlient2/ZslProcessor.h"
+
+
+#define ALOG1(...) ALOGD_IF(gLogLevel >= 1, __VA_ARGS__);
+#define ALOG2(...) ALOGD_IF(gLogLevel >= 2, __VA_ARGS__);
+
+namespace android {
+using namespace camera2;
+
+QTICamera2Client::QTICamera2Client(sp<Camera2Client> client):
+        mParentClient(client) {
+}
+
+QTICamera2Client::~QTICamera2Client() {
+    ALOGV("%s: Exit", __FUNCTION__);
+}
+
+status_t QTICamera2Client::setParametersExtn(Parameters &params) {
+    status_t res = OK;
+    sp<Camera2Client> client = mParentClient.promote();
+
+    // Check whether preview restart needed.
+    // Stop the preview, if there is a need for restart.
+    if (params.qtiParams->mNeedRestart) {
+        if (params.state >= Parameters::PREVIEW) {
+            stopPreviewExtn();
+            {
+                params.state = Parameters::STOPPED;
+            }
+        }
+        client->mStreamingProcessor->deletePreviewStream();
+        client->mStreamingProcessor->deleteRecordingStream();
+        client->mJpegProcessor->deleteStream();
+        client->mCallbackProcessor->deleteStream();
+        client->mZslProcessor->deleteStream();
+    }
+
+    return res;
+}
+
+status_t QTICamera2Client::stopPreviewExtn() {
+    status_t res = OK;
+    sp<Camera2Client> client = mParentClient.promote();
+    client->syncWithDevice();
+    res = client->stopStream();
+    if (res != OK) {
+        ALOGE("%s: Can't stop streaming: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+    }
+
+    res = client->mDevice->flush();
+    if (res != OK) {
+        ALOGE("%s: Unable to flush pending requests: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+    }
+
+    res = client->mDevice->waitUntilDrained();
+    if (res != OK) {
+        ALOGE("%s: Waiting to stop streaming failed: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+    }
+    return res;
+}
+} // namespace android
\ No newline at end of file
diff --git a/services/camera/libcameraservice/api1/QTICamera2Client.h b/services/camera/libcameraservice/api1/QTICamera2Client.h
new file mode 100644
index 000000000..a096ba4f6
--- /dev/null
+++ b/services/camera/libcameraservice/api1/QTICamera2Client.h
@@ -0,0 +1,52 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef ANDROID_SERVERS_CAMERA_QTICAMERA2CLIENT_H
+#define ANDROID_SERVERS_CAMERA_QTICAMERA2CLIENT_H
+
+namespace android {
+using namespace camera2;
+
+class Camera2Client;
+
+class QTICamera2Client: public virtual RefBase{
+private:
+    wp<Camera2Client> mParentClient;
+    status_t stopPreviewExtn();
+
+public:
+    QTICamera2Client(sp<Camera2Client> client);
+    ~QTICamera2Client();
+    status_t setParametersExtn(Parameters &params);
+
+};
+
+}; // namespace android
+
+#endif
diff --git a/services/camera/libcameraservice/api1/qticlient2/CaptureSequencer.cpp b/services/camera/libcameraservice/api1/qticlient2/CaptureSequencer.cpp
index 68988928e..d441de378 100644
--- a/services/camera/libcameraservice/api1/qticlient2/CaptureSequencer.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/CaptureSequencer.cpp
@@ -275,13 +275,18 @@ CaptureSequencer::CaptureState CaptureSequencer::manageDone(sp<Camera2Client> &c
                 res = INVALID_OPERATION;
                 break;
             case Parameters::STILL_CAPTURE:
-                res = client->getCameraDevice()->waitUntilDrained();
-                if (res != OK) {
-                    ALOGE("%s: Camera %d: Can't idle after still capture: "
-                            "%s (%d)", __FUNCTION__, client->getCameraId(),
-                            strerror(-res), res);
+                // No need to move the state to stop for ZSL
+                if (!l.mParameters.allowZslMode) {
+                    res = client->getCameraDevice()->waitUntilDrained();
+                    if (res != OK) {
+                        ALOGE("%s: Camera %d: Can't idle after still capture: "
+                                "%s (%d)", __FUNCTION__, client->getCameraId(),
+                                strerror(-res), res);
+                    }
+                    l.mParameters.state = Parameters::STOPPED;
+                } else {
+                    l.mParameters.state = Parameters::PREVIEW;
                 }
-                l.mParameters.state = Parameters::STOPPED;
                 break;
             case Parameters::VIDEO_SNAPSHOT:
                 l.mParameters.state = Parameters::RECORD;
diff --git a/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp b/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp
index 1852de8e3..89264a508 100644
--- a/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/Parameters.cpp
@@ -1974,7 +1974,7 @@ status_t Parameters::set(const String8& paramString) {
     }
 
     // QTI Parameters
-    qtiParams->set(newParams);
+    qtiParams->set(newParams, (void*)&validatedParams);
 
     /** Update internal parameters */
 
@@ -1999,7 +1999,7 @@ status_t Parameters::set(const String8& paramString) {
     // Need to flatten again in case of overrides
     paramsFlattened = newParams.flatten();
     params = newParams;
-
+#ifndef USE_QTI_CAMERA2CLIENT
     slowJpegMode = false;
     Size pictureSize = { pictureWidth, pictureHeight };
     int64_t minFrameDurationNs = getJpegStreamMinFrameDurationNs(pictureSize);
@@ -2012,7 +2012,7 @@ status_t Parameters::set(const String8& paramString) {
         allowZslMode = isZslReprocessPresent;
     }
     ALOGV("%s: allowZslMode: %d slowJpegMode %d", __FUNCTION__, allowZslMode, slowJpegMode);
-
+#endif
     return OK;
 }
 
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp
index 4c86f6061..ae6dd2c00 100644
--- a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.cpp
@@ -146,6 +146,8 @@ double maxExposureTime;
 const char minWbGain[] = "1.0";
 const char maxWbGain[] = "4.0";
 
+const char KEY_QTI_ZSL[] = "zsl";
+const char KEY_QTI_SUPPORTED_ZSL_MODES[] = "zsl-values";
 
 status_t QTIParameters::initialize(void *parametersParent,
         sp<CameraDeviceBase> device, sp<CameraProviderManager> manager) {
@@ -175,6 +177,9 @@ status_t QTIParameters::initialize(void *parametersParent,
     ParentParams->params.set(KEY_QTI_REDEYE_REDUCTION,
             "disable");
 
+    ParentParams->params.set(KEY_QTI_SUPPORTED_ZSL_MODES,
+            "on,off");
+
     ParentParams->params.set("num-snaps-per-shutter", 1);
 
     ParentParams->params.set("ae-bracket-hdr-values","Off,AE-Bracket");
@@ -373,9 +378,10 @@ status_t QTIParameters::initialize(void *parametersParent,
     return res;
 }
 
-status_t QTIParameters::set(CameraParameters2& newParams) {
+status_t QTIParameters::set(CameraParameters2& newParams, void *parametersParent) {
     status_t res = OK;
     char prop[PROPERTY_VALUE_MAX];
+    Parameters* ParentParams = (Parameters*)parametersParent;
 
     // ISO
     const char *isoMode = newParams.get(KEY_QTI_ISO_MODE);
@@ -487,6 +493,31 @@ status_t QTIParameters::set(CameraParameters2& newParams) {
         flashMode = (flashMode_t)Parameters::FLASH_MODE_INVALID;
     }
 
+    // ZSL
+    bool prevAllowZslMode = ParentParams->allowZslMode;
+    // Reset to FALSE, and check below only for true condition.
+    ParentParams->allowZslMode = false;
+    const char *qtiZslMode = newParams.get(KEY_QTI_ZSL);
+    if (qtiZslMode != NULL) {
+        if (!strcmp(qtiZslMode, VALUE_ON)) {
+            ParentParams->allowZslMode = true;
+        }
+    } else {
+        String8 defaultZslMode = String8::format("%d", prevAllowZslMode);
+        memset(prop, 0, sizeof(prop));
+        property_get("persist.camera.zsl.mode", prop, defaultZslMode.string());
+        ParentParams->allowZslMode = (bool)atoi(prop);
+    }
+    if (ParentParams->allowZslMode) {
+        newParams.set(KEY_QTI_ZSL, VALUE_ON);
+        ParentParams->slowJpegMode = false;
+    } else {
+        newParams.set(KEY_QTI_ZSL, VALUE_OFF);
+    }
+    mNeedRestart = (prevAllowZslMode != ParentParams->allowZslMode);
+    ALOGV("%s mNeedRestart = %d, prevAllowZslMode = %d, allowZslMode = %d",
+            __FUNCTION__, mNeedRestart, prevAllowZslMode, ParentParams->allowZslMode);
+
     return res;
 }
 
diff --git a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h
index d8e1f5c55..feca64b7d 100644
--- a/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h
+++ b/services/camera/libcameraservice/api1/qticlient2/QTIParameters.h
@@ -96,10 +96,11 @@ private:
     metadata_vendor_id_t mVendorTagId;
 
 public:
+    bool mNeedRestart;
     // Sets up default QTI parameters
     status_t initialize(void *parametersParent, sp<CameraDeviceBase> device, sp<CameraProviderManager> manager);
     // Validate and update camera parameters based on new settings
-    status_t set(CameraParameters2& newParams);
+    status_t set(CameraParameters2& newParams, void *parametersParent);
     // Update passed-in request for common parameters
     status_t updateRequest(CameraMetadata *request) const;
     static const char* wbModeEnumToString(uint8_t wbMode);
diff --git a/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.cpp b/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.cpp
index 0a234232f..6b4899f3d 100644
--- a/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.cpp
+++ b/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.cpp
@@ -138,7 +138,8 @@ ZslProcessor::ZslProcessor(
         mInputBuffer(nullptr),
         mProducer(nullptr),
         mInputProducer(nullptr),
-        mInputProducerSlot(-1) {
+        mInputProducerSlot(-1),
+        mBuffersToDetach(0) {
     // Initialize buffer queue and frame list based on pipeline max depth.
     size_t pipelineMaxDepth = kDefaultMaxPipelineDepth;
     if (client != 0) {
@@ -430,6 +431,11 @@ status_t ZslProcessor::updateRequestWithDefaultStillRequest(CameraMetadata &requ
 void ZslProcessor::notifyInputReleased() {
     Mutex::Autolock l(mInputMutex);
 
+    mBuffersToDetach++;
+    mBuffersToDetachSignal.signal();
+}
+
+void ZslProcessor::doNotifyInputReleasedLocked() {
     assert(nullptr != mInputBuffer.get());
     assert(nullptr != mInputProducer.get());
 
@@ -736,9 +742,18 @@ void ZslProcessor::dump(int fd, const Vector<String16>& /*args*/) const {
 }
 
 bool ZslProcessor::threadLoop() {
-    // TODO: remove dependency on thread. For now, shut thread down right
-    // away.
-    return false;
+    Mutex::Autolock l(mInputMutex);
+
+    if (mBuffersToDetach == 0) {
+        status_t res = mBuffersToDetachSignal.waitRelative(mInputMutex, kWaitDuration);
+        if (res == TIMED_OUT) return true;
+    }
+    while (mBuffersToDetach > 0) {
+        doNotifyInputReleasedLocked();
+        mBuffersToDetach--;
+    }
+
+    return true;
 }
 
 void ZslProcessor::dumpZslQueue(int fd) const {
diff --git a/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.h b/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.h
index 3ae009487..746bd49de 100644
--- a/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.h
+++ b/services/camera/libcameraservice/api1/qticlient2/ZslProcessor.h
@@ -142,6 +142,9 @@ class ZslProcessor :
     sp<IGraphicBufferProducer>               mInputProducer;
     int                                      mInputProducerSlot;
 
+    Condition                                mBuffersToDetachSignal;
+    int                                      mBuffersToDetach;
+
     virtual bool threadLoop();
 
     status_t clearZslQueueLocked();
@@ -156,6 +159,7 @@ class ZslProcessor :
         nsecs_t* actualTimestamp);
     status_t clearInputRingBufferLocked(nsecs_t* latestTimestamp);
     void notifyInputReleased();
+    void doNotifyInputReleasedLocked();
 
     bool isFixedFocusMode(uint8_t afMode) const;
 
-- 
2.17.1

