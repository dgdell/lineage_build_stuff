From 1bed4a7bb000f1429b4fa85295fad3dbdb4d9561 Mon Sep 17 00:00:00 2001
From: Roman Birg <roman@cyngn.com>
Date: Tue, 3 May 2016 11:54:28 -0700
Subject: [PATCH 15/25] soundtrigger: fill in default extras from dsp

Squash of:

Author: Roman Birg <roman@cyngn.com>
Date:   Tue May 3 11:54:28 2016 -0700
    soundtrigger: fill in default extras from dsp
    We seem to get an improper offset when getting the value from the DSP
    (offset 100, data size 1), when this happens, return a new phrase event
    with valid extras which are initialized to some default values.
    Change-Id: Ie041f78fec6bdbcd82286b54a7b7fb0c98c740f5
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Sam Mortimer <sam@mortimer.me.uk>
Date:   Fri Dec 9 13:36:25 2016 -0800
    soundtrigger: fix memory corruption
    Fixes hotword on angler.
    Change-Id: Ic15a617c0f79f03785feaddd2dfa6deb90842a06

Change-Id: Ie041f78fec6bdbcd82286b54a7b7fb0c98c740f5
---
 .../soundtrigger/SoundTriggerHwService.cpp    | 31 +++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/services/soundtrigger/SoundTriggerHwService.cpp b/services/soundtrigger/SoundTriggerHwService.cpp
index a7d6e839e..7debb2061 100644
--- a/services/soundtrigger/SoundTriggerHwService.cpp
+++ b/services/soundtrigger/SoundTriggerHwService.cpp
@@ -256,6 +256,37 @@ void SoundTriggerHwService::sendRecognitionEvent(struct sound_trigger_recognitio
     if (module == NULL) {
         return;
     }
+    struct sound_trigger_phrase_recognition_event newEvent;
+    if (event-> type == SOUND_MODEL_TYPE_KEYPHRASE && event->data_size != 0
+            && event->data_offset != sizeof(struct sound_trigger_phrase_recognition_event)) {
+        // set some defaults for the phrase if the recognition event won't be parsed properly
+        // TODO: read defaults from the config
+
+        memset(&newEvent, 0, sizeof(struct sound_trigger_phrase_recognition_event));
+
+        sp<Model> model = module->getModel(event->model);
+
+        newEvent.num_phrases = 1;
+        newEvent.phrase_extras[0].id = 100;
+        newEvent.phrase_extras[0].recognition_modes = RECOGNITION_MODE_VOICE_TRIGGER;
+        newEvent.phrase_extras[0].confidence_level = 100;
+        newEvent.phrase_extras[0].num_levels = 1;
+        newEvent.phrase_extras[0].levels[0].level = 100;
+        newEvent.phrase_extras[0].levels[0].user_id = 100;
+        newEvent.common.status = event->status;
+        newEvent.common.type = event->type;
+        newEvent.common.model = event->model;
+        newEvent.common.capture_available = event->capture_available;
+        newEvent.common.capture_session = event->capture_session;
+        newEvent.common.capture_delay_ms = event->capture_delay_ms;
+        newEvent.common.capture_preamble_ms = event->capture_preamble_ms;
+        newEvent.common.trigger_in_data = event->trigger_in_data;
+        newEvent.common.audio_config = event->audio_config;
+        newEvent.common.data_size = event->data_size;
+        newEvent.common.data_offset = sizeof(struct sound_trigger_phrase_recognition_event);
+
+        event = &newEvent.common;
+    }
     sp<IMemory> eventMemory = prepareRecognitionEvent(event);
     if (eventMemory == 0) {
         return;
-- 
2.17.1

