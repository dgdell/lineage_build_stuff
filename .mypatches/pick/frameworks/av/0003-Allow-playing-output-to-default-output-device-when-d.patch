From 77e2167c2d90c3fbc1e9924378b54588f1ef214a Mon Sep 17 00:00:00 2001
From: Nadav Bar <nadavbar@google.com>
Date: Wed, 18 Jul 2018 13:01:53 +0300
Subject: [PATCH 3/6] Allow playing output to default output device when during
 uplink playback

Change the current behavior of AudioPolicyManager during incall music playback to allow apps that want to play audio with AUDIO_STREAM_MUSIC to default device to route the audio to the default device chosen by the engine (and not the one forced by the ongoing incall music routing). The current behavior still playes the audio to the default output device, which will be set to the TELEPHONY_TX device whenever there is ongoing uplink playback. This change will only affect a case in which uplink playback is in progress and another app tries to play audio using the music stream at that time.

Test: Tested manually that the behavior described in the bug is fixed and that both apps can play audio to two different output devices.
Bug: 111467967.
Change-Id: I25bccb635ea436bb6827483732e53c49c4b27825
(cherry picked from commit b2f18166ff6a85305e8921a64c47f8cbff4575e2)
---
 .../managerdefault/AudioPolicyManager.cpp     | 20 ++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 5caeaf049..97e75bd67 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -861,6 +861,21 @@ status_t AudioPolicyManager::getOutputForAttr(const audio_attributes_t *attr,
         *flags = (audio_output_flags_t)(*flags | AUDIO_OUTPUT_FLAG_HW_AV_SYNC);
     }
 
+    // Set incall music only if device was explicitly set, and fallback to the device which is
+    // chosen by the engine if not.
+    // FIXME: provide a more generic approach which is not device specific and move this back
+    // to getOutputForDevice.
+    if (device == AUDIO_DEVICE_OUT_TELEPHONY_TX &&
+        *stream == AUDIO_STREAM_MUSIC &&
+        audio_is_linear_pcm(config->format) &&
+        isInCall()) {
+        if (*selectedDeviceId != AUDIO_PORT_HANDLE_NONE) {
+            *flags = (audio_output_flags_t)AUDIO_OUTPUT_FLAG_INCALL_MUSIC;
+        } else {
+            device = mEngine->getDeviceForStrategy(strategy);
+        }
+    }
+
     ALOGV("getOutputForAttr() device 0x%x, sampling rate %d, format %#x, channel mask %#x, "
           "flags %#x",
           device, config->sample_rate, config->format, config->channel_mask, *flags);
@@ -916,11 +931,6 @@ audio_io_handle_t AudioPolicyManager::getOutputForDevice(
         *flags = (audio_output_flags_t)(AUDIO_OUTPUT_FLAG_VOIP_RX |
                                        AUDIO_OUTPUT_FLAG_DIRECT);
         ALOGV("Set VoIP and Direct output flags for PCM format");
-    } else if (device == AUDIO_DEVICE_OUT_TELEPHONY_TX &&
-        stream == AUDIO_STREAM_MUSIC &&
-        audio_is_linear_pcm(config->format) &&
-        isInCall()) {
-        *flags = (audio_output_flags_t)AUDIO_OUTPUT_FLAG_INCALL_MUSIC;
     }
 
 
-- 
2.17.1

