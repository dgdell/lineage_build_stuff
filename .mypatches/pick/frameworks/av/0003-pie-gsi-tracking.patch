From 9caf94cc33f653f90009d8fc7e39048696ad2fdf Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Mon, 8 Oct 2018 11:13:01 +0200
Subject: [PATCH 3/4] pie-gsi-tracking

commit b08e6cd3baa8e50bfb1d219ec2aa87f2c6c62fdf
Merge: adf743ce2 26e73fb3c
Author: Treehugger Robot <treehugger-gerrit@google.com>
Date:   Sun Sep 23 17:25:22 2018 +0000

    Merge "Camera: consider all cameras in flash light control" into pie-gsi

commit 26e73fb3c40b250c536cab16c1fa626e70dbec76
Author: Yin-Chia Yeh <yinchiayeh@google.com>
Date:   Tue Aug 28 11:20:16 2018 -0700

    Camera: consider all cameras in flash light control

    A non-API1 compatible camera might still has flash
    unit and supports setTorchMode.

    Test: partner testing
    Change-Id: Ic8974afea13318624f35d17af4c4c238ee3fbf85
    (cherry picked from commit 98c72a87fc004936c6c59b2f38311d6362d34bfe)

commit adf743ce26bf82abce679cc5483b85c4c63ca281
Merge: f7f641dbc 3e769a19c
Author: Treehugger Robot <treehugger-gerrit@google.com>
Date:   Wed Sep 19 02:13:02 2018 +0000

    Merge "Camera3: Handle stream format override for shared output stream" into pie-gsi

commit 3e769a19c920838bae5c16285e829f817c6a4f1c
Author: Shuzhen Wang <shuzhenwang@google.com>
Date:   Mon Aug 27 11:39:53 2018 -0700

    Camera3: Handle stream format override for shared output stream

    If HAL overrides stream format, use the overridden format to configure
    the buffer queues.

    Bug: 113326269
    Test: Camera CTS, partner testing
    Merged-In: I6b198e8ebfeaeafbda530722d995a12f88f0b35a
    Change-Id: I6b198e8ebfeaeafbda530722d995a12f88f0b35a
    (cherry picked from 9d5c936d99e20bb9eafbcafaa3eac9e23b09643a)

commit f7f641dbc1af2182c9bec1689aed567949236ba7
Merge: 74784041f f15c508a1
Author: Treehugger Robot <treehugger-gerrit@google.com>
Date:   Mon Sep 17 16:00:58 2018 +0000

    Merge "Camera: extend getBuffer wait timeout" into pie-gsi

commit 74784041fae11a3befeafc3a5f817e1f6d9e8aba
Merge: 16c3e05ef a1bf10288
Author: Treehugger Robot <treehugger-gerrit@google.com>
Date:   Mon Sep 17 02:24:50 2018 +0000

    Merge "audio policy: fix getOutputFromId and getInputFromId" into pie-gsi

commit a1bf10288a935db4729cc93150671ad8793308a8
Author: Hochi Huang <hochi.huang@mediatek.com>
Date:   Wed Sep 5 22:03:19 2018 +0800

    audio policy: fix getOutputFromId and getInputFromId

    It should return NULL instead of the last descriptor handle
    if mismatching specific output/input id.

    Bug: 115474937
    Test: manual test.
    Change-Id: I37ff9622392f3fa3fbfd0c2a3362c704340bd72c
    (cherry picked from commit f731de72e9eff742fcb1f860321aa15fae7dccd9)

commit 16c3e05ef4af318c78f995665414b079f755a6dc
Merge: d41389c0c aedc886dc
Author: Android Merger <noreply-android-build-merger@google.com>
Date:   Sat Sep 15 05:18:03 2018 +0000

    Merge "Merge cherrypicks of [4647037, 4647038, 4647883, 4647039, 4647933, 4648530, 4648550, 4648551, 4648552, 4648553, 4646931, 4646932, 4646933, 4646934, 4648391, 4647976, 4647977, 4647978, 4647526, 4646972, 4646935, 4646936, 4646937, 4646938, 4646939, 4646940, 4646941, 4648392, 4647509, 4648630, 4648631, 4647934] into pi-release-2 am: 976d139bd0" into pie-gsi

commit aedc886dc8dda6c14949a68fd155a5067648c2de
Merge: d41389c0c 976d139bd
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Sep 14 22:17:57 2018 -0700

    Merge cherrypicks of [4647037, 4647038, 4647883, 4647039, 4647933, 4648530, 4648550, 4648551, 4648552, 4648553, 4646931, 4646932, 4646933, 4646934, 4648391, 4647976, 4647977, 4647978, 4647526, 4646972, 4646935, 4646936, 4646937, 4646938, 4646939, 4646940, 4646941, 4648392, 4647509, 4648630, 4648631, 4647934] into pi-release-2
    am: 976d139bd0

    Change-Id: Iaac010051d37a345c036e42322876cee85158896

commit f15c508a1b965fd9099ccc3bd33371b35bfd7114
Author: Yin-Chia Yeh <yinchiayeh@google.com>
Date:   Tue Sep 4 12:13:05 2018 -0700

    Camera: extend getBuffer wait timeout

    In extreme cases, HAL needs to wait until all inflight requests
    are fulfilled before it can return a buffer, so extend the
    getBuffer wait accordingly.

    Test: partner testing, smoke test Pixel
    Bug: 113660745
    Change-Id: I363098004e70b75e11651fe0f1c75efcfda970f4
    (cherry picked from commit b3a80b1c627035a05eda702e7f8ad6d18b7d54f5)

Change-Id: Ia209db6a56fc17cd60665ae3d68d014c1521fd5c
---
 .../src/AudioInputDescriptor.cpp                |  9 ++++-----
 .../src/AudioOutputDescriptor.cpp               |  7 +++----
 .../libcameraservice/CameraFlashlight.cpp       |  6 +++---
 .../libcameraservice/device3/Camera3Device.cpp  | 17 ++++++++++-------
 .../libcameraservice/device3/Camera3Device.h    |  1 +
 .../device3/Camera3SharedOutputStream.cpp       |  3 +--
 .../libcameraservice/device3/Camera3Stream.cpp  |  8 ++++++--
 .../libcameraservice/device3/Camera3Stream.h    |  1 +
 .../device3/Camera3StreamInterface.h            |  1 +
 .../device3/Camera3StreamSplitter.cpp           |  9 ++++++++-
 10 files changed, 38 insertions(+), 24 deletions(-)

diff --git a/services/audiopolicy/common/managerdefinitions/src/AudioInputDescriptor.cpp b/services/audiopolicy/common/managerdefinitions/src/AudioInputDescriptor.cpp
index 92332fb11..1e0640c83 100644
--- a/services/audiopolicy/common/managerdefinitions/src/AudioInputDescriptor.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/AudioInputDescriptor.cpp
@@ -313,14 +313,13 @@ bool AudioInputCollection::isSourceActive(audio_source_t source) const
 
 sp<AudioInputDescriptor> AudioInputCollection::getInputFromId(audio_port_handle_t id) const
 {
-    sp<AudioInputDescriptor> inputDesc = NULL;
     for (size_t i = 0; i < size(); i++) {
-        inputDesc = valueAt(i);
-        if (inputDesc->getId() == id) {
-            break;
+        const sp<AudioInputDescriptor> inputDescriptor = valueAt(i);
+        if (inputDescriptor->getId() == id) {
+            return inputDescriptor;
         }
     }
-    return inputDesc;
+    return NULL;
 }
 
 uint32_t AudioInputCollection::activeInputsCountOnDevices(audio_devices_t devices) const
diff --git a/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp b/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
index ab88b9adc..a71404757 100644
--- a/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
@@ -681,14 +681,13 @@ sp<SwAudioOutputDescriptor> SwAudioOutputCollection::getPrimaryOutput() const
 
 sp<SwAudioOutputDescriptor> SwAudioOutputCollection::getOutputFromId(audio_port_handle_t id) const
 {
-    sp<SwAudioOutputDescriptor> outputDesc = NULL;
     for (size_t i = 0; i < size(); i++) {
-        outputDesc = valueAt(i);
+        const sp<SwAudioOutputDescriptor> outputDesc = valueAt(i);
         if (outputDesc->getId() == id) {
-            break;
+            return outputDesc;
         }
     }
-    return outputDesc;
+    return NULL;
 }
 
 bool SwAudioOutputCollection::isAnyOutputActive(audio_stream_type_t streamToIgnore) const
diff --git a/services/camera/libcameraservice/CameraFlashlight.cpp b/services/camera/libcameraservice/CameraFlashlight.cpp
index 471c77db8..e629cdd79 100644
--- a/services/camera/libcameraservice/CameraFlashlight.cpp
+++ b/services/camera/libcameraservice/CameraFlashlight.cpp
@@ -125,7 +125,7 @@ status_t CameraFlashlight::findFlashUnits() {
     status_t res;
 
     std::vector<String8> cameraIds;
-    std::vector<std::string> ids = mProviderManager->getAPI1CompatibleCameraDeviceIds();
+    std::vector<std::string> ids = mProviderManager->getCameraDeviceIds();
     int numberOfCameras = static_cast<int>(ids.size());
     cameraIds.resize(numberOfCameras);
     // No module, must be provider
@@ -217,7 +217,7 @@ status_t CameraFlashlight::prepareDeviceOpen(const String8& cameraId) {
 
         if (mOpenedCameraIds.size() == 0) {
             // notify torch unavailable for all cameras with a flash
-            std::vector<std::string> ids = mProviderManager->getAPI1CompatibleCameraDeviceIds();
+            std::vector<std::string> ids = mProviderManager->getCameraDeviceIds();
             int numCameras = static_cast<int>(ids.size());
             for (int i = 0; i < numCameras; i++) {
                 String8 id8(ids[i].c_str());
@@ -263,7 +263,7 @@ status_t CameraFlashlight::deviceClosed(const String8& cameraId) {
 
     if (isBackwardCompatibleMode(cameraId)) {
         // notify torch available for all cameras with a flash
-        std::vector<std::string> ids = mProviderManager->getAPI1CompatibleCameraDeviceIds();
+        std::vector<std::string> ids = mProviderManager->getCameraDeviceIds();
         int numCameras = static_cast<int>(ids.size());
         for (int i = 0; i < numCameras; i++) {
             String8 id8(ids[i].c_str());
diff --git a/services/camera/libcameraservice/device3/Camera3Device.cpp b/services/camera/libcameraservice/device3/Camera3Device.cpp
index 543914e5a..4c5958df1 100644
--- a/services/camera/libcameraservice/device3/Camera3Device.cpp
+++ b/services/camera/libcameraservice/device3/Camera3Device.cpp
@@ -4825,6 +4825,15 @@ status_t Camera3Device::RequestThread::prepareHalRequests() {
                 captureRequest->mOutputStreams.size());
         halRequest->output_buffers = outputBuffers->array();
         std::set<String8> requestedPhysicalCameras;
+
+        sp<Camera3Device> parent = mParent.promote();
+        if (parent == NULL) {
+            // Should not happen, and nowhere to send errors to, so just log it
+            CLOGE("RequestThread: Parent is gone");
+            return INVALID_OPERATION;
+        }
+        nsecs_t waitDuration = kBaseGetBufferWait + parent->getExpectedInFlightDuration();
+
         for (size_t j = 0; j < captureRequest->mOutputStreams.size(); j++) {
             sp<Camera3OutputStreamInterface> outputStream = captureRequest->mOutputStreams.editItemAt(j);
 
@@ -4845,6 +4854,7 @@ status_t Camera3Device::RequestThread::prepareHalRequests() {
             }
 
             res = outputStream->getBuffer(&outputBuffers->editItemAt(j),
+                    waitDuration,
                     captureRequest->mOutputSurfaces[j]);
             if (res != OK) {
                 // Can't get output buffer from gralloc queue - this could be due to
@@ -4871,13 +4881,6 @@ status_t Camera3Device::RequestThread::prepareHalRequests() {
         totalNumBuffers += halRequest->num_output_buffers;
 
         // Log request in the in-flight queue
-        sp<Camera3Device> parent = mParent.promote();
-        if (parent == NULL) {
-            // Should not happen, and nowhere to send errors to, so just log it
-            CLOGE("RequestThread: Parent is gone");
-            return INVALID_OPERATION;
-        }
-
         // If this request list is for constrained high speed recording (not
         // preview), and the current request is not the last one in the batch,
         // do not send callback to the app.
diff --git a/services/camera/libcameraservice/device3/Camera3Device.h b/services/camera/libcameraservice/device3/Camera3Device.h
index d8fe19fa6..526fd1f1d 100644
--- a/services/camera/libcameraservice/device3/Camera3Device.h
+++ b/services/camera/libcameraservice/device3/Camera3Device.h
@@ -220,6 +220,7 @@ class Camera3Device :
     static const size_t        kInFlightWarnLimitHighSpeed = 256; // batch size 32 * pipe depth 8
     static const nsecs_t       kDefaultExpectedDuration = 100000000; // 100 ms
     static const nsecs_t       kMinInflightDuration = 5000000000; // 5 s
+    static const nsecs_t       kBaseGetBufferWait = 3000000000; // 3 sec.
     // SCHED_FIFO priority for request submission thread in HFR mode
     static const int           kRequestThreadPriority = 1;
 
diff --git a/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp b/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp
index 2bb9ff7a3..fb3ce4c61 100644
--- a/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp
@@ -60,9 +60,8 @@ status_t Camera3SharedOutputStream::connectStreamSplitterLocked() {
         }
     }
 
-    android::PixelFormat format = isFormatOverridden() ? getOriginalFormat() : getFormat();
     res = mStreamSplitter->connect(initialSurfaces, usage, mUsage, camera3_stream::max_buffers,
-            getWidth(), getHeight(), format, &mConsumer);
+            getWidth(), getHeight(), getFormat(), &mConsumer);
     if (res != OK) {
         ALOGE("%s: Failed to connect to stream splitter: %s(%d)",
                 __FUNCTION__, strerror(-res), res);
diff --git a/services/camera/libcameraservice/device3/Camera3Stream.cpp b/services/camera/libcameraservice/device3/Camera3Stream.cpp
index 1105b754f..87476612a 100644
--- a/services/camera/libcameraservice/device3/Camera3Stream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3Stream.cpp
@@ -569,6 +569,7 @@ status_t Camera3Stream::tearDown() {
 }
 
 status_t Camera3Stream::getBuffer(camera3_stream_buffer *buffer,
+        nsecs_t waitBufferTimeout,
         const std::vector<size_t>& surface_ids) {
     ATRACE_CALL();
     Mutex::Autolock l(mLock);
@@ -586,13 +587,16 @@ status_t Camera3Stream::getBuffer(camera3_stream_buffer *buffer,
         ALOGV("%s: Already dequeued max output buffers (%d), wait for next returned one.",
                         __FUNCTION__, camera3_stream::max_buffers);
         nsecs_t waitStart = systemTime(SYSTEM_TIME_MONOTONIC);
-        res = mOutputBufferReturnedSignal.waitRelative(mLock, kWaitForBufferDuration);
+        if (waitBufferTimeout < kWaitForBufferDuration) {
+            waitBufferTimeout = kWaitForBufferDuration;
+        }
+        res = mOutputBufferReturnedSignal.waitRelative(mLock, waitBufferTimeout);
         nsecs_t waitEnd = systemTime(SYSTEM_TIME_MONOTONIC);
         mBufferLimitLatency.add(waitStart, waitEnd);
         if (res != OK) {
             if (res == TIMED_OUT) {
                 ALOGE("%s: wait for output buffer return timed out after %lldms (max_buffers %d)",
-                        __FUNCTION__, kWaitForBufferDuration / 1000000LL,
+                        __FUNCTION__, waitBufferTimeout / 1000000LL,
                         camera3_stream::max_buffers);
             }
             return res;
diff --git a/services/camera/libcameraservice/device3/Camera3Stream.h b/services/camera/libcameraservice/device3/Camera3Stream.h
index a60cb5681..e6fb7f9f4 100644
--- a/services/camera/libcameraservice/device3/Camera3Stream.h
+++ b/services/camera/libcameraservice/device3/Camera3Stream.h
@@ -311,6 +311,7 @@ class Camera3Stream :
      *
      */
     status_t         getBuffer(camera3_stream_buffer *buffer,
+            nsecs_t waitBufferTimeout,
             const std::vector<size_t>& surface_ids = std::vector<size_t>());
 
     /**
diff --git a/services/camera/libcameraservice/device3/Camera3StreamInterface.h b/services/camera/libcameraservice/device3/Camera3StreamInterface.h
index 9ed718420..2dde1c325 100644
--- a/services/camera/libcameraservice/device3/Camera3StreamInterface.h
+++ b/services/camera/libcameraservice/device3/Camera3StreamInterface.h
@@ -237,6 +237,7 @@ class Camera3StreamInterface : public virtual RefBase {
      *
      */
     virtual status_t getBuffer(camera3_stream_buffer *buffer,
+            nsecs_t waitBufferTimeout,
             const std::vector<size_t>& surface_ids = std::vector<size_t>()) = 0;
 
     /**
diff --git a/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp b/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
index 59ac636bd..a0be60803 100644
--- a/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
+++ b/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
@@ -182,12 +182,19 @@ status_t Camera3StreamSplitter::addOutputLocked(size_t surfaceId, const sp<Surfa
         return BAD_VALUE;
     }
 
-  status_t res = native_window_set_buffers_dimensions(outputQueue.get(),
+    status_t res = native_window_set_buffers_dimensions(outputQueue.get(),
             mWidth, mHeight);
     if (res != NO_ERROR) {
         SP_LOGE("addOutput: failed to set buffer dimensions (%d)", res);
         return res;
     }
+    res = native_window_set_buffers_format(outputQueue.get(),
+            mFormat);
+    if (res != OK) {
+        ALOGE("%s: Unable to configure stream buffer format %#x for surfaceId %zu",
+                __FUNCTION__, mFormat, surfaceId);
+        return res;
+    }
 
     sp<IGraphicBufferProducer> gbp = outputQueue->getIGraphicBufferProducer();
     // Connect to the buffer producer
-- 
2.17.1

