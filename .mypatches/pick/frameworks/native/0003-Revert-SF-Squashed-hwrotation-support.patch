From dfccf70be37f8a05a7dae35b0b847ee61765d1dd Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Sun, 29 Jul 2018 17:13:48 +0300
Subject: [PATCH 3/7] Revert "SF: Squashed hwrotation support"

* This reverts commit a9fa1c9c19d6ac00aa0073ef23b7a1d95f8e0a90.
  Our current implementation is being replaced in the next patch
  by the upstream one, which is currently on the oreo-mr1-dev AOSP
  branch and will be included in a future release tag.

Change-Id: Icb9eb3e733f6a40acf6233adb11216914f5a3db5
---
 services/surfaceflinger/DisplayDevice.cpp     | 16 +--------------
 services/surfaceflinger/DisplayDevice.h       |  4 +---
 services/surfaceflinger/SurfaceFlinger.cpp    | 18 ++++-------------
 services/surfaceflinger/SurfaceFlinger.h      |  3 ---
 .../surfaceflinger/SurfaceFlinger_hwc1.cpp    | 20 ++++---------------
 5 files changed, 10 insertions(+), 51 deletions(-)

diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index 946f0b365..b28c9ba4c 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -183,10 +183,6 @@ DisplayDevice::DisplayDevice(
             break;
     }
 
-    // we store the value as orientation:
-    // 90 -> 1, 180 -> 2, 270 -> 3
-    mHardwareRotation = property_get_int32("ro.sf.hwrotation", 0) / 90;
-
     // initialize the display orientation transform.
     setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
 
@@ -487,12 +483,6 @@ status_t DisplayDevice::orientationToTransfrom(
         int orientation, int w, int h, Transform* tr)
 {
     uint32_t flags = 0;
-
-    if (mHardwareRotation && mType == DisplayType::DISPLAY_PRIMARY) {
-        orientation += mHardwareRotation;
-        orientation %= 4;
-    }
-
     switch (orientation) {
     case DisplayState::eOrientationDefault:
         flags = Transform::ROT_0;
@@ -548,11 +538,7 @@ void DisplayDevice::setProjection(int orientation,
     if (!frame.isValid()) {
         // the destination frame can be invalid if it has never been set,
         // in that case we assume the whole display frame.
-        if (mHardwareRotation == 1 || mHardwareRotation == 3) {
-            frame = Rect(h, w);
-        } else {
-            frame = Rect(w, h);
-        }
+        frame = Rect(w, h);
     }
 
     if (viewport.isEmpty()) {
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index c054feb1d..8636e2af7 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -245,7 +245,7 @@ private:
     /*
      * Transaction state
      */
-    status_t orientationToTransfrom(int orientation,
+    static status_t orientationToTransfrom(int orientation,
             int w, int h, Transform* tr);
 
     // The identifier of the active layer stack for this display. Several displays
@@ -267,8 +267,6 @@ private:
     int mPowerMode;
     // Current active config
     int mActiveConfig;
-    // Panel hardware rotation
-    int32_t mHardwareRotation;
 #ifdef USE_HWC2
     // current active color mode
     android_color_mode_t mActiveColorMode;
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index f3b2bd8f0..2dd3078e1 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -795,20 +795,10 @@ status_t SurfaceFlinger::getDisplayConfigs(const sp<IBinder>& display,
             info.orientation = 0;
         }
 
-        char value[PROPERTY_VALUE_MAX];
-        property_get("ro.sf.hwrotation", value, "0");
-        int additionalRot = atoi(value) / 90;
-        if ((type == DisplayDevice::DISPLAY_PRIMARY) && (additionalRot & DisplayState::eOrientationSwapMask)) {
-            info.h = hwConfig->getWidth();
-            info.w = hwConfig->getHeight();
-            info.xdpi = ydpi;
-            info.ydpi = xdpi;
-        } else {
-            info.w = hwConfig->getWidth();
-            info.h = hwConfig->getHeight();
-            info.xdpi = xdpi;
-            info.ydpi = ydpi;
-        }
+        info.w = hwConfig->getWidth();
+        info.h = hwConfig->getHeight();
+        info.xdpi = xdpi;
+        info.ydpi = ydpi;
         info.fps = 1e9 / hwConfig->getVsyncPeriod();
         info.appVsyncOffset = vsyncPhaseOffsetNs;
 
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 980fc1f70..99d4a1a63 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -629,9 +629,6 @@ private:
     void updateVrFlinger();
 #endif
 
-    // Panel hardware rotation
-    int32_t mHardwareRotation;
-
     /* ------------------------------------------------------------------------
      * Attributes
      */
diff --git a/services/surfaceflinger/SurfaceFlinger_hwc1.cpp b/services/surfaceflinger/SurfaceFlinger_hwc1.cpp
index ecc0e04bb..6343b086c 100644
--- a/services/surfaceflinger/SurfaceFlinger_hwc1.cpp
+++ b/services/surfaceflinger/SurfaceFlinger_hwc1.cpp
@@ -207,10 +207,6 @@ SurfaceFlinger::SurfaceFlinger()
     property_get("ro.sf.disable_triple_buffer", value, "1");
     mLayerTripleBufferingDisabled = atoi(value);
     ALOGI_IF(mLayerTripleBufferingDisabled, "Disabling Triple Buffering");
-
-    // we store the value as orientation:
-    // 90 -> 1, 180 -> 2, 270 -> 3
-    mHardwareRotation = property_get_int32("ro.sf.hwrotation", 0) / 90;
 }
 
 void SurfaceFlinger::onFirstRef()
@@ -731,18 +727,10 @@ status_t SurfaceFlinger::getDisplayConfigs(const sp<IBinder>& display,
             info.orientation = 0;
         }
 
-        if ((type == DisplayDevice::DISPLAY_PRIMARY) &&
-                (mHardwareRotation & DisplayState::eOrientationSwapMask)) {
-            info.h = hwConfig.width;
-            info.w = hwConfig.height;
-            info.xdpi = ydpi;
-            info.ydpi = xdpi;
-        } else {
-            info.w = hwConfig.width;
-            info.h = hwConfig.height;
-            info.xdpi = xdpi;
-            info.ydpi = ydpi;
-        }
+        info.w = hwConfig.width;
+        info.h = hwConfig.height;
+        info.xdpi = xdpi;
+        info.ydpi = ydpi;
         info.fps = float(1e9 / hwConfig.refresh);
         info.appVsyncOffset = vsyncPhaseOffsetNs;
 
-- 
2.17.1

