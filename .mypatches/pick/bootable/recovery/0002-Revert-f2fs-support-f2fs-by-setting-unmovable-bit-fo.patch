From 5ea69a0a9a29830856d2759c4eb84e12fd67305c Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Thu, 30 Aug 2018 21:06:02 +0200
Subject: [PATCH 2/4] Revert "f2fs: support f2fs by setting unmovable bit for
 package file"

* Replaced with upstream version

This reverts commit 848f227eea524a48208bdd4181f90fb63a31ed2b.

Change-Id: I5871d3da4594f7da44546a2979e72dd87434f821
---
 uncrypt/uncrypt.cpp | 26 ++++----------------------
 1 file changed, 4 insertions(+), 22 deletions(-)

diff --git a/uncrypt/uncrypt.cpp b/uncrypt/uncrypt.cpp
index bb43c2c4..645faadb 100644
--- a/uncrypt/uncrypt.cpp
+++ b/uncrypt/uncrypt.cpp
@@ -172,14 +172,10 @@ static struct fstab* read_fstab() {
     return fstab;
 }
 
-static const char* find_block_device(const char* path, bool* encryptable, bool* encrypted, bool *f2fs_fs) {
+static const char* find_block_device(const char* path, bool* encryptable, bool* encrypted) {
     // Look for a volume whose mount point is the prefix of path and
     // return its block device.  Set encrypted if it's currently
     // encrypted.
-
-    // ensure f2fs_fs is set to 0 first.
-    if (f2fs_fs)
-        *f2fs_fs = false;
     for (int i = 0; i < fstab->num_entries; ++i) {
         struct fstab_rec* v = &fstab->recs[i];
         if (!v->mount_point) {
@@ -196,8 +192,6 @@ static const char* find_block_device(const char* path, bool* encryptable, bool*
                     *encrypted = true;
                 }
             }
-            if (f2fs_fs && strcmp(v->fs_type, "f2fs") == 0)
-                *f2fs_fs = true;
             return v->blk_device;
         }
     }
@@ -250,7 +244,7 @@ static int retry_fibmap(const int fd, const char* name, int* block, const int he
 }
 
 static int produce_block_map(const char* path, const char* map_file, const char* blk_dev,
-                             bool encrypted, bool f2fs_fs, int socket) {
+                             bool encrypted, int socket) {
     std::string err;
     if (!android::base::RemoveFileIfExists(map_file, &err)) {
         LOG(ERROR) << "failed to remove the existing map file " << map_file << ": " << err;
@@ -313,17 +307,6 @@ static int produce_block_map(const char* path, const char* map_file, const char*
         }
     }
 
-#ifndef F2FS_IOC_SET_DONTMOVE
-#ifndef F2FS_IOCTL_MAGIC
-#define F2FS_IOCTL_MAGIC		0xf5
-#endif
-#define F2FS_IOC_SET_DONTMOVE		_IO(F2FS_IOCTL_MAGIC, 13)
-#endif
-    if (f2fs_fs && ioctl(fd, F2FS_IOC_SET_DONTMOVE) < 0) {
-        PLOG(ERROR) << "Failed to set non-movable file for f2fs: " << path << " on " << blk_dev;
-        return kUncryptIoctlError;
-    }
-
     off64_t pos = 0;
     int last_progress = 0;
     while (pos < sb.st_size) {
@@ -475,8 +458,7 @@ static int uncrypt(const char* input_path, const char* map_file, const int socke
 
     bool encryptable;
     bool encrypted;
-    bool f2fs_fs;
-    const char* blk_dev = find_block_device(path, &encryptable, &encrypted, &f2fs_fs);
+    const char* blk_dev = find_block_device(path, &encryptable, &encrypted);
     if (blk_dev == nullptr) {
         LOG(ERROR) << "failed to find block device for " << path;
         return kUncryptBlockDeviceFindError;
@@ -497,7 +479,7 @@ static int uncrypt(const char* input_path, const char* map_file, const int socke
     // and /sdcard we leave the file alone.
     if (strncmp(path, "/data/", 6) == 0) {
         LOG(INFO) << "writing block map " << map_file;
-        return produce_block_map(path, map_file, blk_dev, encrypted, f2fs_fs, socket);
+        return produce_block_map(path, map_file, blk_dev, encrypted, socket);
     }
 
     return 0;
-- 
2.17.1

