From 3e19f672ebe40c696624618630e15f232cba74f8 Mon Sep 17 00:00:00 2001
From: Yonghai Huang <yonghaih@codeaurora.org>
Date: Tue, 13 Feb 2018 16:13:10 +0800
Subject: [PATCH 07/10] libsuspend: Add property support for timeout of
 autosuspend

THe implementation to increase the delay time where system attempt to
suspend whenever suspend fails. The delay keeps on increasing for every
consecutive suspend failure. The aim of this feature is to prevent
device from entering suspend if they are active wakeup events happens on
the device in the absence of a wakelock.

The max delay timeout it today hard coded to 60 seconds and the value is
not optimized across different platforms. This value should ideally be
equal to the value where the power cost of attempting suspend matches to
the overhead of staying in CPU idle. This breakeven can vary based on
the chipset and the software that the oem add to the device. So we would
like to make the max timeout value to be configurable based on a
property.

Change-Id: I0ba1cf782f2915c51117bf592cfe43ca69f3b223
---
 libsuspend/autosuspend_wakeup_count.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/libsuspend/autosuspend_wakeup_count.c b/libsuspend/autosuspend_wakeup_count.c
index 2da204ae0..330152658 100644
--- a/libsuspend/autosuspend_wakeup_count.c
+++ b/libsuspend/autosuspend_wakeup_count.c
@@ -17,6 +17,7 @@
 #define LOG_TAG "libsuspend"
 //#define LOG_NDEBUG 0
 
+#include <cutils/properties.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <pthread.h>
@@ -37,6 +38,7 @@
 #define SYS_POWER_WAKEUP_COUNT "/sys/power/wakeup_count"
 
 #define BASE_SLEEP_TIME 100000
+#define POSSIBLE_MAX_SLEEP_TIME 60000000
 
 static int state_fd;
 static int wakeup_count_fd;
@@ -45,14 +47,15 @@ static sem_t suspend_lockout;
 static const char *sleep_state = "mem";
 static void (*wakeup_func)(bool success) = NULL;
 static int sleep_time = BASE_SLEEP_TIME;
+static int possible_max_sleep_time;
 
 static void update_sleep_time(bool success) {
     if (success) {
         sleep_time = BASE_SLEEP_TIME;
         return;
     }
-    // double sleep time after each failure up to one minute
-    sleep_time = MIN(sleep_time * 2, 60000000);
+    // double sleep time after each failure up to one minute by default
+    sleep_time = MIN(sleep_time * 2, possible_max_sleep_time);
 }
 
 static void *suspend_thread_func(void *arg __attribute__((unused)))
@@ -174,6 +177,12 @@ struct autosuspend_ops *autosuspend_wakeup_count_init(void)
     int ret;
     char buf[80];
 
+    possible_max_sleep_time = property_get_int32(
+            "sys.autosuspend.timeout", POSSIBLE_MAX_SLEEP_TIME);
+    if (possible_max_sleep_time != POSSIBLE_MAX_SLEEP_TIME) {
+        ALOGD("autosuspend timeout is %d\n", possible_max_sleep_time);
+    }
+
     state_fd = TEMP_FAILURE_RETRY(open(SYS_POWER_STATE, O_RDWR));
     if (state_fd < 0) {
         strerror_r(errno, buf, sizeof(buf));
-- 
2.17.1

