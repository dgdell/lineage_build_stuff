From 344e78482718e82dbda9d64112808f70c5b21425 Mon Sep 17 00:00:00 2001
From: Yonghai Huang <yonghaih@codeaurora.org>
Date: Tue, 13 Feb 2018 16:13:10 +0800
Subject: [PATCH 6/8] libsuspend: Add property support for timeout of
 autosuspend

THe implementation to increase the delay time where system attempt to
suspend whenever suspend fails. The delay keeps on increasing for every
consecutive suspend failure. The aim of this feature is to prevent
device from entering suspend if they are active wakeup events happens on
the device in the absence of a wakelock.

The max delay timeout it today hard coded to 60 seconds and the value is
not optimized across different platforms. This value should ideally be
equal to the value where the power cost of attempting suspend matches to
the overhead of staying in CPU idle. This breakeven can vary based on
the chipset and the software that the oem add to the device. So we would
like to make the max timeout value to be configurable based on a
property.

Change-Id: I0ba1cf782f2915c51117bf592cfe43ca69f3b223
---
 libsuspend/autosuspend_wakeup_count.c | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/libsuspend/autosuspend_wakeup_count.c b/libsuspend/autosuspend_wakeup_count.c
index 2da204ae0..89cc1648c 100644
--- a/libsuspend/autosuspend_wakeup_count.c
+++ b/libsuspend/autosuspend_wakeup_count.c
@@ -28,15 +28,16 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
-
+#include <cutils/properties.h>
 #include <log/log.h>
-
+#include <stdlib.h>
 #include "autosuspend_ops.h"
 
 #define SYS_POWER_STATE "/sys/power/state"
 #define SYS_POWER_WAKEUP_COUNT "/sys/power/wakeup_count"
 
 #define BASE_SLEEP_TIME 100000
+#define POSSIBLE_MAX_SLEEP_TIME 60000000
 
 static int state_fd;
 static int wakeup_count_fd;
@@ -45,6 +46,7 @@ static sem_t suspend_lockout;
 static const char *sleep_state = "mem";
 static void (*wakeup_func)(bool success) = NULL;
 static int sleep_time = BASE_SLEEP_TIME;
+static int possible_max_sleep_time = POSSIBLE_MAX_SLEEP_TIME;
 
 static void update_sleep_time(bool success) {
     if (success) {
@@ -52,7 +54,7 @@ static void update_sleep_time(bool success) {
         return;
     }
     // double sleep time after each failure up to one minute
-    sleep_time = MIN(sleep_time * 2, 60000000);
+    sleep_time = MIN(sleep_time * 2, possible_max_sleep_time);
 }
 
 static void *suspend_thread_func(void *arg __attribute__((unused)))
@@ -173,6 +175,13 @@ struct autosuspend_ops *autosuspend_wakeup_count_init(void)
 {
     int ret;
     char buf[80];
+    char timeout_str[PROPERTY_VALUE_MAX];
+
+    if (property_get("sys.autosuspend.timeout", timeout_str, NULL))
+    {
+        possible_max_sleep_time = atoi(timeout_str);
+        ALOGI("autosuspend timeout is %d\n", possible_max_sleep_time);
+    }
 
     state_fd = TEMP_FAILURE_RETRY(open(SYS_POWER_STATE, O_RDWR));
     if (state_fd < 0) {
-- 
2.17.1

