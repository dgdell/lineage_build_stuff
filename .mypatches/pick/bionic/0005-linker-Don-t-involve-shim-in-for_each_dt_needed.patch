From dc1be31f864648c0193070305b12be5f7c6199fd Mon Sep 17 00:00:00 2001
From: Nich <nctrenco@gmail.com>
Date: Thu, 21 Jun 2018 01:58:10 +0800
Subject: [PATCH 5/5] linker: Don't involve shim in for_each_dt_needed

for_each_dt_needed may have other usages that shouldn't involve the
shim, for example, the unloading of soinfos.

Change-Id: Id38de183d90c3f707767bdca032a5ea2bc82fde8
---
 linker/linker.cpp      |  9 ++++++---
 linker/linker.h        | 19 +++++++++++++++++++
 linker/linker_main.cpp |  6 ++++++
 linker/linker_soinfo.h | 22 ----------------------
 4 files changed, 31 insertions(+), 25 deletions(-)

diff --git a/linker/linker.cpp b/linker/linker.cpp
index e836ec1c6..fb7995db7 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -1172,9 +1172,6 @@ const char* fix_dt_needed(const char* dt_needed, const char* sopath __unused) {
 
 template<typename F>
 static void for_each_dt_needed(const ElfReader& elf_reader, F action) {
-#ifdef LD_SHIM_LIBS
-  for_each_matching_shim(elf_reader.name(), action);
-#endif
   for (const ElfW(Dyn)* d = elf_reader.dynamic(); d->d_tag != DT_NULL; ++d) {
     if (d->d_tag == DT_NEEDED) {
       action(fix_dt_needed(elf_reader.get_string(d->d_un.d_val), elf_reader.name()));
@@ -1360,6 +1357,12 @@ static bool load_library(android_namespace_t* ns,
     }
   }
 
+#ifdef LD_SHIM_LIBS
+  for_each_matching_shim(realpath.c_str(), [&](const char* name) {
+    load_tasks->push_back(LoadTask::create(name, si, ns, task->get_readers_map()));
+  });
+#endif
+
   for_each_dt_needed(task->get_elf_reader(), [&](const char* name) {
     load_tasks->push_back(LoadTask::create(name, si, ns, task->get_readers_map()));
   });
diff --git a/linker/linker.h b/linker/linker.h
index a14537398..8ca2aef2c 100644
--- a/linker/linker.h
+++ b/linker/linker.h
@@ -43,6 +43,10 @@
 #include "linker_logger.h"
 #include "linker_soinfo.h"
 
+#ifdef LD_SHIM_LIBS
+#include "linker_debug.h"
+#endif
+
 #include <string>
 #include <vector>
 
@@ -105,7 +109,22 @@ soinfo* get_libdl_info(const char* linker_path, const link_map& linker_map);
 soinfo* find_containing_library(const void* p);
 
 #ifdef LD_SHIM_LIBS
+typedef std::pair<std::string, std::string> ShimDescriptor;
 void parse_LD_SHIM_LIBS(const char* path);
+void shim_matching_pairs(const char *const path,
+                         std::vector<const ShimDescriptor *>* matched_pairs);
+
+template<typename F>
+void for_each_matching_shim(const char *const path, F action) {
+  if (path == nullptr) return;
+  std::vector<const ShimDescriptor *> matched_pairs;
+  INFO("Finding shim libs for \"%s\"\n", path);
+  shim_matching_pairs(path, &matched_pairs);
+  for (const auto& one_pair : matched_pairs) {
+    INFO("Injecting shim lib \"%s\" as needed for %s", one_pair->second.c_str(), path);
+    action(one_pair->second.c_str());
+  }
+}
 #endif
 
 void do_android_get_LD_LIBRARY_PATH(char*, size_t);
diff --git a/linker/linker_main.cpp b/linker/linker_main.cpp
index 61a06695c..7e74ae745 100644
--- a/linker/linker_main.cpp
+++ b/linker/linker_main.cpp
@@ -367,6 +367,12 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args) {
     ++ld_preloads_count;
   }
 
+#ifdef LD_SHIM_LIBS
+  for_each_matching_shim(si->get_realpath(), [&](const char* name) {
+    needed_library_name_list.push_back(name);
+  });
+#endif
+
   for_each_dt_needed(si, [&](const char* name) {
     needed_library_name_list.push_back(name);
   });
diff --git a/linker/linker_soinfo.h b/linker/linker_soinfo.h
index 6eb7b787a..29b5c2be1 100644
--- a/linker/linker_soinfo.h
+++ b/linker/linker_soinfo.h
@@ -33,7 +33,6 @@
 
 #include <string>
 
-#include "linker_debug.h"
 #include "linker_namespaces.h"
 
 #define FLAG_LINKED           0x00000001
@@ -344,31 +343,10 @@ struct soinfo {
 // This function is used by dlvsym() to calculate hash of sym_ver
 uint32_t calculate_elf_hash(const char* name);
 
-#ifdef LD_SHIM_LIBS
-typedef std::pair<std::string, std::string> ShimDescriptor;
-void shim_matching_pairs(const char *const path,
-                         std::vector<const ShimDescriptor *>* matched_pairs);
-
-template<typename F>
-void for_each_matching_shim(const char *const path, F action) {
-  if (path == nullptr) return;
-  std::vector<const ShimDescriptor *> matched_pairs;
-  INFO("Finding shim libs for \"%s\"\n", path);
-  shim_matching_pairs(path, &matched_pairs);
-  for (const auto& one_pair : matched_pairs) {
-    INFO("Injecting shim lib \"%s\" as needed for %s", one_pair->second.c_str(), path);
-    action(one_pair->second.c_str());
-  }
-}
-#endif
-
 const char* fix_dt_needed(const char* dt_needed, const char* sopath);
 
 template<typename F>
 void for_each_dt_needed(const soinfo* si, F action) {
-#ifdef LD_SHIM_LIBS
-  for_each_matching_shim(si->get_realpath(), action);
-#endif
   for (const ElfW(Dyn)* d = si->dynamic; d->d_tag != DT_NULL; ++d) {
     if (d->d_tag == DT_NEEDED) {
       action(fix_dt_needed(si->get_string(d->d_un.d_val), si->get_realpath()));
-- 
2.17.1

