From d10fc42d07d024dcdc25e2acd288dff12c4e15b0 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Thu, 7 Jun 2018 19:59:41 +0300
Subject: [PATCH 15/16] extract_utils: cleanup in extract() function

* Create retrieve() function for easier copying from adb/disk image
* Create src_file() function to mirror behavior of target_file()
* Strip target_args from target_file and src_file at callee instead
  of at caller
* Fix spec destination not being searched (badly fixed by
  "c982836 extract_utils: Fix makefile generation issues")

Change-Id: Ic40fb4dc93541d8b3f33fde586b773199cf4ded2
Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 build/tools/extract_utils.sh | 188 ++++++++++++++++++++++-------------
 1 file changed, 118 insertions(+), 70 deletions(-)

diff --git a/build/tools/extract_utils.sh b/build/tools/extract_utils.sh
index 67705d5c..38532242 100644
--- a/build/tools/extract_utils.sh
+++ b/build/tools/extract_utils.sh
@@ -100,6 +100,31 @@ function setup_vendor() {
     fi
 }
 
+#
+# src_file:
+#
+# $1: colon delimited list
+#
+# Returns source filename without args
+#
+function src_file() {
+    local LINE="$1"
+    local SPLIT=(${LINE//:/ })
+    local ARGS=$(target_args ${LINE})
+    if [ "${#SPLIT[@]}" -gt "1" ]; then
+        # The ${LINE} spec actually has a src:dst format
+        if [[ "${SPLIT[0]}" =~ .*/.* ]]; then
+            _src="${SPLIT[0]}"
+        fi
+    fi
+    # The ${LINE} spec doesn't have a : delimiter
+    if [ -z "${_src+x}" ]; then
+        _src="${SPLIT[0]}"
+    fi
+    # Remove target_args suffix, if present
+    echo "${_src%;${ARGS}}"
+}
+
 #
 # target_file:
 #
@@ -110,14 +135,19 @@ function setup_vendor() {
 function target_file() {
     local LINE="$1"
     local SPLIT=(${LINE//:/ })
-    local COUNT=${#SPLIT[@]}
-    if [ "$COUNT" -gt "1" ]; then
+    local ARGS=$(target_args ${LINE})
+    if [ "${#SPLIT[@]}" -gt "1" ]; then
+        # The ${LINE} spec actually has a src:dst format
         if [[ "${SPLIT[1]}" =~ .*/.* ]]; then
-            printf '%s\n' "${SPLIT[1]}"
-            return 0
+            _dst="${SPLIT[1]}"
         fi
     fi
-    printf '%s\n' "${SPLIT[0]}"
+    # The ${LINE} spec doesn't have a : delimiter
+    if [ -z "${_dst+x}" ]; then
+        _dst="${SPLIT[0]}"
+    fi
+    # Remove target_args suffix, if present
+    echo "${_dst%;${ARGS}}"
 }
 
 #
@@ -219,7 +249,7 @@ function write_product_copy_files() {
             LINEEND=""
         fi
 
-        TARGET=$(echo $(target_file "$FILE") | sed 's/\;.*//')
+        TARGET=$(target_file "$FILE")
         if [ "$TREBLE_COMPAT" == "true" ] || [ "$TREBLE_COMPAT" == "1" ]; then
             if prefix_match_file "vendor/" $TARGET ; then
                 local OUTTARGET=$(truncate_file $TARGET)
@@ -267,7 +297,7 @@ function write_packages() {
     local SRC=
 
     for P in "${FILELIST[@]}"; do
-        FILE=$(echo $(target_file "$P") | sed 's/\;.*//')
+        FILE=$(target_file "$P")
         ARGS=$(target_args "$P")
 
         BASENAME=$(basename "$FILE")
@@ -873,6 +903,22 @@ function fix_xml() {
     mv "$TEMP_XML" "$XML"
 }
 
+function retrieve() {
+    local _dst="$1"
+    local _src="$2"
+    local _medium="$3"
+
+    case ${_medium} in
+    adb)
+        adb pull "${_src}" "${_dst}"
+        ;;
+    *)
+        # ${_medium} is path to a disk image
+        cp -f "${_medium}${_src}" "${_dst}" 2>/dev/null
+        ;;
+    esac
+}
+
 #
 # extract:
 #
@@ -892,9 +938,6 @@ function extract() {
         parse_file_list "$1" "$3"
     fi
 
-    # Allow failing, so we can try $DEST and/or $FILE
-    set +e
-
     local FILELIST=( ${PRODUCT_COPY_FILES_LIST[@]} ${PRODUCT_PACKAGES_LIST[@]} )
     local HASHLIST=( ${PRODUCT_COPY_FILES_HASHES[@]} ${PRODUCT_PACKAGES_HASHES[@]} )
     local COUNT=${#FILELIST[@]}
@@ -955,43 +998,47 @@ function extract() {
 
     for (( i=1; i<COUNT+1; i++ )); do
 
-        local FROM=$(echo $(target_file "${FILELIST[$i-1]}") | sed 's/\;.*//')
-        local ARGS=$(target_args "${FILELIST[$i-1]}")
-        local SPLIT=(${FILELIST[$i-1]//:/ })
-        local FILE=$(echo "${SPLIT[0]#-}" | sed 's/\;.*//')
-        local OUTPUT_DIR="$OUTPUT_ROOT"
-        local TMP_DIR="$OUTPUT_TMP"
-        local TARGET=
-
-        if [ "$ARGS" = "rootfs" ]; then
-            TARGET="$FROM"
-            OUTPUT_DIR="$OUTPUT_DIR/rootfs"
-            TMP_DIR="$TMP_DIR/rootfs"
-        else
-            TARGET="system/$FROM"
-            FILE="system/$FILE"
-        fi
+        local _spec_src_file=$(src_file "${FILELIST[$i-1]}")
+        local _spec_dst_file=$(target_file "${FILELIST[$i-1]}")
+        local _spec_args=$(target_args "${FILELIST[$i-1]}")
+        local _output_dir=
+        local _dst_file=
+        local _src_file=
+        local _tmp_dir=
+
+        case ${_spec_args} in
+        rootfs)
+            _output_dir="${OUTPUT_ROOT}/rootfs"
+            _tmp_dir="${OUTPUT_TMP}/rootfs"
+            _src_file="/${_spec_src_file}"
+            _dst_file="/${_spec_dst_file}"
+            ;;
+        *)
+            _output_dir="${OUTPUT_ROOT}"
+            _tmp_dir="${OUTPUT_TMP}"
+            _src_file="/system/${_spec_src_file}"
+            _dst_file="/system/${_spec_dst_file}"
+            ;;
+        esac
 
         if [ "$SRC" = "adb" ]; then
-            printf '  - %s .. ' "/$TARGET"
+            printf '  - %s .. ' "${_dst_file}"
         else
-            printf '  - %s \n' "/$TARGET"
+            printf '  - %s \n' "${_dst_file}"
         fi
 
-        local DIR=$(dirname "$FROM")
-        if [ ! -d "$OUTPUT_DIR/$DIR" ]; then
-            mkdir -p "$OUTPUT_DIR/$DIR"
-        fi
-        local DEST="$OUTPUT_DIR/$FROM"
+        # Strip the file path in the vendor repo of "system", if present
+        local _vendor_repo_file="${_output_dir}${_dst_file#/system}"
+        mkdir -p $(dirname "${_vendor_repo_file}")
 
         # Check pinned files
         local HASH="${HASHLIST[$i-1]}"
         local KEEP=""
         if [ "$DISABLE_PINNING" != "1" ] && [ ! -z "$HASH" ] && [ "$HASH" != "x" ]; then
-            if [ -f "$DEST" ]; then
-                local PINNED="$DEST"
+            if [ -f "${_vendor_repo_file}" ]; then
+                local PINNED="${_vendor_repo_file}"
             else
-                local PINNED="$TMP_DIR/$FROM"
+                local PINNED="${_tmp_dir}${_dst_file#/system}"
             fi
             if [ -f "$PINNED" ]; then
                 if [ "$(uname)" == "Darwin" ]; then
@@ -1001,8 +1048,8 @@ function extract() {
                 fi
                 if [ "$TMP_HASH" = "$HASH" ]; then
                     KEEP="1"
-                    if [ ! -f "$DEST" ]; then
-                        cp -p "$PINNED" "$DEST"
+                    if [ ! -f "${_vendor_repo_file}" ]; then
+                        cp -p "$PINNED" "${_vendor_repo_file}"
                     fi
                 fi
             fi
@@ -1010,52 +1057,53 @@ function extract() {
 
         if [ "$KEEP" = "1" ]; then
             printf '    + (keeping pinned file with hash %s)\n' "$HASH"
-        elif [ "$SRC" = "adb" ]; then
-            # Try Lineage target first
-            adb pull "/$TARGET" "$DEST"
-            # if file does not exist try OEM target
-            if [ "$?" != "0" ]; then
-                adb pull "/$FILE" "$DEST"
-            fi
         else
-            # Try Lineage target first
-            if [ -f "$SRC/$TARGET" ]; then
-                cp "$SRC/$TARGET" "$DEST"
-            # if file does not exist try OEM target
-            elif [ -f "$SRC/$FILE" ]; then
-                cp "$SRC/$FILE" "$DEST"
-            else
+            found=false
+            # Try Lineage target first.
+            # Also try to search for files stripped of
+            # the "/system" prefix, if we're actually extracting
+            # from a system image.
+            for candidate in "${_dst_file}" "${_dst_file#/system}" "${_src_file}" "${_src_file#/system}"; do
+                retrieve ${_vendor_repo_file} ${candidate} ${SRC} && {
+                    found=true
+                    break
+                }
+            done
+            case ${found} in
+            false)
                 printf '    !! file not found in source\n'
-            fi
+                ;;
+            esac
         fi
 
         if [ "$?" == "0" ]; then
             # Deodex apk|jar if that's the case
-            if [[ "$FULLY_DEODEXED" -ne "1" && "$DEST" =~ .(apk|jar)$ ]]; then
-                oat2dex "$DEST" "$FILE" "$SRC"
+            if [[ "$FULLY_DEODEXED" -ne "1" && "${_vendor_repo_file}" =~ .(apk|jar)$ ]]; then
+                oat2dex "${_vendor_repo_file}" "${_src_file}" "$SRC"
                 if [ -f "$TMPDIR/classes.dex" ]; then
-                    zip -gjq "$DEST" "$TMPDIR/classes.*"
-                    rm "$TMPDIR/classes.*"
-                    printf '    (updated %s from odex files)\n' "/$FILE"
+                    zip -gjq "${_vendor_repo_file}" "$TMPDIR/classes.dex"
+                    rm "$TMPDIR/classes.dex"
+                    echo "    (updated ${_src_file} from odex files)"
                 fi
-            elif [[ "$DEST" =~ .xml$ ]]; then
-                fix_xml "$DEST"
+            elif [[ "${_vendor_repo_file}" =~ .xml$ ]]; then
+                fix_xml "${_vendor_repo_file}"
             fi
         fi
 
-        if [ -f "$DEST" ]; then
-            local TYPE="${DIR##*/}"
-            if [ "$TYPE" = "bin" -o "$TYPE" = "sbin" ]; then
-                chmod 755 "$DEST"
-            else
-                chmod 644 "$DEST"
-            fi
+        if [ -f "${_vendor_repo_file}" ]; then
+            local _dir=$(dirname "${_vendor_repo_file}")
+            local _type="${_dir##*/}"
+            case ${_type} in
+            bin | sbin)
+                chmod 755 "${_vendor_repo_file}"
+                ;;
+            *)
+                chmod 644 "${_vendor_repo_file}"
+                ;;
+            esac
         fi
 
     done
-
-    # Don't allow failing
-    set -e
 }
 
 #
-- 
2.17.1

