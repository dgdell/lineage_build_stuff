From 6cc104740f14eb7c98f9989584a1ae634f8f9992 Mon Sep 17 00:00:00 2001
From: Michael W <baddaemon87@gmail.com>
Date: Tue, 5 Jun 2018 19:28:43 +0200
Subject: [PATCH 07/10] lineage-sdk: Introduce TelephonyExtUtils

Change-Id: Ifdd18dd6e89e23c5b804c3454ee8473a5920b562
---
 Android.mk                                    |   4 +-
 .../internal/util/TelephonyExtUtils.java      | 236 ++++++++++++++++++
 2 files changed, 239 insertions(+), 1 deletion(-)
 create mode 100644 sdk/src/java/org/lineageos/internal/util/TelephonyExtUtils.java

diff --git a/Android.mk b/Android.mk
index 532b891..c292034 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
 # Copyright (C) 2015 The CyanogenMod Project
-# Copyright (C) 2017 The LineageOS Project
+# Copyright (C) 2017-2018 The LineageOS Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -46,6 +46,7 @@ lineage_sdk_LOCAL_JAVA_LIBRARIES := \
 
 LOCAL_JAVA_LIBRARIES := \
     services \
+    telephony-ext \
     org.lineageos.hardware \
     $(lineage_sdk_LOCAL_JAVA_LIBRARIES)
 
@@ -194,6 +195,7 @@ LOCAL_INTERMEDIATE_SOURCES := \
     $(lineage_sdk_LOCAL_INTERMEDIATE_SOURCES)
 
 LOCAL_JAVA_LIBRARIES := \
+    telephony-ext \
     $(lineage_sdk_LOCAL_JAVA_LIBRARIES)
 
 $(full_target): $(lineage_framework_built) $(gen)
diff --git a/sdk/src/java/org/lineageos/internal/util/TelephonyExtUtils.java b/sdk/src/java/org/lineageos/internal/util/TelephonyExtUtils.java
new file mode 100644
index 0000000..5e497d7
--- /dev/null
+++ b/sdk/src/java/org/lineageos/internal/util/TelephonyExtUtils.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.internal.util;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+import com.android.internal.telephony.PhoneConstants;
+
+import org.codeaurora.internal.IExtTelephony;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class TelephonyExtUtils {
+    private static final String TAG = "TelephonyExtUtils";
+
+    public static final String ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED =
+            "org.codeaurora.intent.action.ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED";
+
+    public static final String EXTRA_NEW_PROVISION_STATE = "newProvisionState";
+
+    // These are the list of possible values that
+    // IExtTelephony.getCurrentUiccCardProvisioningStatus() can return
+    public static final int NOT_PROVISIONED = 0;
+    public static final int PROVISIONED = 1;
+    public static final int INVALID_STATE = -1;
+    public static final int CARD_NOT_PRESENT = -2;
+
+    private static boolean sNoServiceAvailable;
+    private static IExtTelephony sExtTelephony;
+
+    private static BroadcastReceiver sReceiver;
+
+    private static List<ProvisioningChangedListener> sListeners =
+            new ArrayList<ProvisioningChangedListener>();
+
+    private TelephonyExtUtils() {
+        // This class is not supposed to be instantiated
+    }
+
+    /**
+     * Determines whether the ITelephonyExt service is available on the device
+     * Any result of the methods in this class are only valid if this method returns true
+     *
+     * @return true on success
+     */
+    public static boolean hasService(Context context) {
+        return getService(context) != null;
+    }
+
+    /**
+     * Determines whether the SIM associated with the given SubscriptionId is provisioned
+     *
+     * @return true if the SIM associated with the given subId is provisioned
+     */
+    public static boolean isSubProvisioned(int subId) {
+        return isSlotProvisioned(SubscriptionManager.getSlotIndex(subId));
+    }
+
+    /**
+     * Determines whether the given is provisioned
+     *
+     * @return true if the SIM is provisioned
+     */
+    public static boolean isSlotProvisioned(int slotId) {
+        return getCurrentUiccCardProvisioningStatus(slotId) == PROVISIONED;
+    }
+
+    /**
+     * Get the current provisioning status for a given SIM slot
+     *
+     * @return The provisioning status from the extension or INVALID_STATE if not possible
+     */
+    public static int getCurrentUiccCardProvisioningStatus(int slotId) {
+        int provisioningStatus;
+
+        if (slotId == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
+            return INVALID_STATE;
+        }
+
+        try {
+            provisioningStatus = sExtTelephony.getCurrentUiccCardProvisioningStatus(slotId);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "Failed to get provisioning status for slotId: "
+                    + slotId + "! Exception: " + ex);
+            provisioningStatus = INVALID_STATE;
+        }
+
+        return provisioningStatus;
+    }
+
+    /**
+     * Activate the SIM card with the given slotId
+     *
+     * @return The result of the activation or -1
+     */
+    public static int activateUiccCard(int slotId) {
+        int result = -1;
+
+        try {
+            result = sExtTelephony.activateUiccCard(slotId);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "Activating sub failed " + result + " phoneId " + slotId);
+        }
+
+        return result;
+    }
+
+    /**
+     * Deactivate the SIM card with the given slotId
+     *
+     * @return The result of the deactivation or -1
+     */
+    public static int deactivateUiccCard(int slotId) {
+        int result = -1;
+
+        try {
+            result = sExtTelephony.deactivateUiccCard(slotId);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "Deactivating sub failed " + result + " phoneId " + slotId);
+        }
+
+        return result;
+    }
+
+    /**
+     * Add a ProvisioningChangedListener to get notified in case of provisioning changes
+     */
+    public static void addListener(ProvisioningChangedListener listener) {
+        if (listener != null) {
+            sListeners.add(listener);
+        }
+    }
+
+    /**
+     *  Remove a ProvisioningChangedListener to not get notified of provisioning changes anymore
+     */
+    public static void removeListener(ProvisioningChangedListener listener) {
+        if (listener != null) {
+            sListeners.remove(listener);
+        }
+    }
+
+    /**
+     * Notify all registered listeners about provisioning changes
+     */
+    private static void notifyListeners(int slotId, boolean provisioned) {
+        for (ProvisioningChangedListener listener : sListeners) {
+            if (listener != null) {
+                listener.onProvisioningChanged(slotId, provisioned);
+            }
+        }
+    }
+
+    /**
+     * Helper method to get an already instantiated service or instantiate it
+     *
+     * @return a valid service instance or null
+     */
+    private static IExtTelephony getService(Context context) {
+        // We already tried to get the service but weren't successfull, so just return null here
+        if (sNoServiceAvailable) {
+            Log.w(TAG, "Already tried to get a service without success, returning!");
+            return null;
+        }
+
+        // Instead of getting a new service instance, return an already existing one here
+        if (sExtTelephony != null) {
+            return sExtTelephony;
+        }
+
+        try {
+            sExtTelephony = IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
+            registerListener(context);
+        } catch (NoClassDefFoundError ex) {
+            // Ignore, device does not ship with telephony-ext
+            Log.e(TAG, "Failed to get telephony extension service! Exception: " + ex);
+        }
+
+        sNoServiceAvailable = (sExtTelephony == null);
+        return sExtTelephony;
+    }
+
+    /**
+     * Register a broadcast receiver to get informed about provision status changes
+     */
+    private static void registerListener(Context context) {
+        sReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                final String action = intent.getAction();
+                if (ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED.equals(action)) {
+                    int slotId = intent.getIntExtra(PhoneConstants.PHONE_KEY,
+                            SubscriptionManager.INVALID_SIM_SLOT_INDEX);
+                    boolean provisioned = intent.getIntExtra(EXTRA_NEW_PROVISION_STATE,
+                            NOT_PROVISIONED) == PROVISIONED;
+                    Log.d(TAG, "Received ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED on slotId: "
+                            + slotId + ", sub provisioned " + provisioned);
+                    notifyListeners(slotId, provisioned);
+                }
+            }
+        };
+
+        IntentFilter intentFilter = new IntentFilter(ACTION_UICC_MANUAL_PROVISION_STATUS_CHANGED);
+        context.registerReceiver(sReceiver, intentFilter);
+    }
+
+    /**
+     * Interface definition so we can register callbacks to get the provisioning status when
+     * it changes
+     */
+    public interface ProvisioningChangedListener {
+        public void onProvisioningChanged(int slotId, boolean isProvisioned);
+    }
+}
-- 
2.17.1

