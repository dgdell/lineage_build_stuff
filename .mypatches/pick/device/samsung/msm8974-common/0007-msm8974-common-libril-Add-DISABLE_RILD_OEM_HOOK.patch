From 082090e820cf841e2faf0d12b8154df4256223ab Mon Sep 17 00:00:00 2001
From: Steven Moreland <smoreland@google.com>
Date: Tue, 20 Mar 2018 11:20:05 -0700
Subject: [PATCH 07/16] msm8974-common: libril: Add DISABLE_RILD_OEM_HOOK.

OEM hook is deprecated, so adding a way to disable it to
this radio implementation.

Bug: 75322118
Test: boot device w/ DISABLE_RILD_OEM_HOOK works, lshal
Change-Id: Ie7ade48476d2c330df608e9cc8dab805f84dd81d
---
 ril/libril/Android.mk      |  4 ++++
 ril/libril/ril_service.cpp | 21 ++++++++++++++++++---
 2 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/ril/libril/Android.mk b/ril/libril/Android.mk
index 625075e..a0078f6 100644
--- a/ril/libril/Android.mk
+++ b/ril/libril/Android.mk
@@ -38,6 +38,10 @@ ifeq ($(SIM_COUNT), 2)
     LOCAL_CFLAGS += -DANDROID_SIM_COUNT_2
 endif
 
+ifneq ($(DISABLE_RILD_OEM_HOOK),)
+    LOCAL_CFLAGS += -DOEM_HOOK_DISABLED
+endif
+
 LOCAL_C_INCLUDES += external/nanopb-c
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
 LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/../include
diff --git a/ril/libril/ril_service.cpp b/ril/libril/ril_service.cpp
index e838d54..bb22723 100644
--- a/ril/libril/ril_service.cpp
+++ b/ril/libril/ril_service.cpp
@@ -67,6 +67,12 @@ using android::sp;
 #define CALL_ONSTATEREQUEST(a) s_vendorFunctions->onStateRequest()
 #endif
 
+#ifdef OEM_HOOK_DISABLED
+constexpr bool kOemHookEnabled = false;
+#else
+constexpr bool kOemHookEnabled = true;
+#endif
+
 RIL_RadioFunctions *s_vendorFunctions = NULL;
 static CommandInfo *s_commands;
 
@@ -6737,6 +6743,8 @@ int radio::sendRequestRawResponse(int slotId,
    RLOGD("sendRequestRawResponse: serial %d", serial);
 #endif
 
+    if (!kOemHookEnabled) return 0;
+
     if (oemHookService[slotId]->mOemHookResponse != NULL) {
         RadioResponseInfo responseInfo = {};
         populateResponseInfo(responseInfo, serial, responseType, e);
@@ -6766,6 +6774,8 @@ int radio::sendRequestStringsResponse(int slotId,
     RLOGD("sendRequestStringsResponse: serial %d", serial);
 #endif
 
+    if (!kOemHookEnabled) return 0;
+
     if (oemHookService[slotId]->mOemHookResponse != NULL) {
         RadioResponseInfo responseInfo = {};
         populateResponseInfo(responseInfo, serial, responseType, e);
@@ -8607,6 +8617,8 @@ int radio::keepaliveStatusInd(int slotId,
 int radio::oemHookRawInd(int slotId,
                          int indicationType, int token, RIL_Errno e, void *response,
                          size_t responseLen) {
+    if (!kOemHookEnabled) return 0;
+
     if (oemHookService[slotId] != NULL && oemHookService[slotId]->mOemHookIndication != NULL) {
         if (response == NULL || responseLen == 0) {
             RLOGE("oemHookRawInd: invalid response");
@@ -8656,12 +8668,15 @@ void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands
 
         radioService[i] = new RadioImpl;
         radioService[i]->mSlotId = i;
-        oemHookService[i] = new OemHookImpl;
-        oemHookService[i]->mSlotId = i;
         RLOGD("registerService: starting android::hardware::radio::V1_1::IRadio %s",
                 serviceNames[i]);
         android::status_t status = radioService[i]->registerAsService(serviceNames[i]);
-        status = oemHookService[i]->registerAsService(serviceNames[i]);
+
+        if (kOemHookEnabled) {
+            oemHookService[i] = new OemHookImpl;
+            oemHookService[i]->mSlotId = i;
+            status = oemHookService[i]->registerAsService(serviceNames[i]);
+        }
 
         ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
         assert(ret == 0);
-- 
2.17.1

