From 7b585e6eb653540c4134d6015a780ff89faafa94 Mon Sep 17 00:00:00 2001
From: Amit Mahajan <amitmahajan@google.com>
Date: Fri, 23 Feb 2018 17:12:15 -0800
Subject: [PATCH 06/15] msm8974-common: libril: Store the system time when NITZ
 is received.

If cached value for NITZ is used, the time at which it was
received needs to be cached too.

Test: Basic telephony sanity
Bug: 72283604
Change-Id: I8f443171c4583e3eab9be7973d7714ae6c7ab6af
---
 ril/libril/ril.cpp         | 23 +++++++++++++++++++++--
 ril/libril/ril_service.cpp | 13 ++++++++++---
 ril/libril/ril_service.h   |  2 ++
 3 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/ril/libril/ril.cpp b/ril/libril/ril.cpp
index 8ea5f27..2b36513 100644
--- a/ril/libril/ril.cpp
+++ b/ril/libril/ril.cpp
@@ -287,6 +287,13 @@ static void resendLastNITZTimeData(RIL_SOCKET_ID socket_id) {
         int responseType = (s_callbacks.version >= 13)
                            ? RESPONSE_UNSOLICITED_ACK_EXP
                            : RESPONSE_UNSOLICITED;
+        // acquire read lock for the service before calling nitzTimeReceivedInd() since it reads
+        // nitzTimeReceived in ril_service
+        pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(
+                (int) socket_id);
+        int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
+        assert(rwlockRet == 0);
+
         int ret = radio::nitzTimeReceivedInd(
             (int)socket_id, responseType, 0,
             RIL_E_SUCCESS, s_lastNITZTimeData, s_lastNITZTimeDataSize);
@@ -294,6 +301,9 @@ static void resendLastNITZTimeData(RIL_SOCKET_ID socket_id) {
             free(s_lastNITZTimeData);
             s_lastNITZTimeData = NULL;
         }
+
+        rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
+        assert(rwlockRet == 0);
     }
 }
 
@@ -774,8 +784,17 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     }
 
     pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock((int) soc_id);
-    int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-    assert(rwlockRet == 0);
+    int rwlockRet;
+
+    if (unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
+        // get a write lock in caes of NITZ since setNitzTimeReceived() is called
+        rwlockRet = pthread_rwlock_wrlock(radioServiceRwlockPtr);
+        assert(rwlockRet == 0);
+        radio::setNitzTimeReceived((int) soc_id, android::elapsedRealtime());
+    } else {
+        rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
+        assert(rwlockRet == 0);
+    }
 
     if (s_unsolResponses[unsolResponseIndex].responseFunction) {
         ret = s_unsolResponses[unsolResponseIndex].responseFunction(
diff --git a/ril/libril/ril_service.cpp b/ril/libril/ril_service.cpp
index e5acc60..e838d54 100644
--- a/ril/libril/ril_service.cpp
+++ b/ril/libril/ril_service.cpp
@@ -76,12 +76,14 @@ struct OemHookImpl;
 #if (SIM_COUNT >= 2)
 sp<RadioImpl> radioService[SIM_COUNT];
 sp<OemHookImpl> oemHookService[SIM_COUNT];
+int64_t nitzTimeReceived[SIM_COUNT];
 // counter used for synchronization. It is incremented every time response callbacks are updated.
 volatile int32_t mCounterRadio[SIM_COUNT];
 volatile int32_t mCounterOemHook[SIM_COUNT];
 #else
 sp<RadioImpl> radioService[1];
 sp<OemHookImpl> oemHookService[1];
+int64_t nitzTimeReceived[1];
 // counter used for synchronization. It is incremented every time response callbacks are updated.
 volatile int32_t mCounterRadio[1];
 volatile int32_t mCounterOemHook[1];
@@ -7006,7 +7008,6 @@ int radio::nitzTimeReceivedInd(int slotId,
             return 0;
         }
         hidl_string nitzTime;
-        int64_t timeReceived = android::elapsedRealtime();
         char *resp = strndup((char *) response, responseLen);
         char *tmp = resp;
 
@@ -7026,10 +7027,11 @@ int radio::nitzTimeReceivedInd(int slotId,
         memsetAndFreeStrings(1, resp);
 #if VDBG
         RLOGD("nitzTimeReceivedInd: nitzTime %s receivedTime %" PRId64, nitzTime.c_str(),
-                timeReceived);
+                nitzTimeReceived[slotId]);
 #endif
         Return<void> retStatus = radioService[slotId]->mRadioIndication->nitzTimeReceived(
-                convertIntToRadioIndicationType(indicationType), nitzTime, timeReceived);
+                convertIntToRadioIndicationType(indicationType), nitzTime,
+                nitzTimeReceived[slotId]);
         radioService[slotId]->checkReturnStatus(retStatus);
     } else {
         RLOGE("nitzTimeReceivedInd: radioService[%d]->mRadioIndication == NULL", slotId);
@@ -8688,3 +8690,8 @@ pthread_rwlock_t * radio::getRadioServiceRwlock(int slotId) {
 
     return radioServiceRwlockPtr;
 }
+
+// should acquire write lock for the corresponding service before calling this
+void radio::setNitzTimeReceived(int slotId, long timeReceived) {
+    nitzTimeReceived[slotId] = timeReceived;
+}
diff --git a/ril/libril/ril_service.h b/ril/libril/ril_service.h
index 2240e2a..870b644 100644
--- a/ril/libril/ril_service.h
+++ b/ril/libril/ril_service.h
@@ -743,6 +743,8 @@ int carrierInfoForImsiEncryption(int slotId,
 
 pthread_rwlock_t * getRadioServiceRwlock(int slotId);
 
+void setNitzTimeReceived(int slotId, long timeReceived);
+
 }   // namespace radio
 
 #endif  // RIL_SERVICE_H
-- 
2.17.1

