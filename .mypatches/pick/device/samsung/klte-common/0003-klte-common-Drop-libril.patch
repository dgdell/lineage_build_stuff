From 8d63e11ba0882e0626985d9e9517ffa52a7fe7fd Mon Sep 17 00:00:00 2001
From: "Kevin F. Haggerty" <haggertk@lineageos.org>
Date: Fri, 26 Jan 2018 21:07:26 -0700
Subject: [PATCH 3/5] klte-common: Drop libril

* We're going to use the shared version from msm8974-common now

Change-Id: Ie4e6336209a5fb6881cd52807082ea2acffd1c8c
---
 include/libril/ril_ex.h          |   49 -
 include/telephony/ril_cdma_sms.h |  806 ----
 libril/Android.mk                |   50 -
 libril/MODULE_LICENSE_APACHE2    |    0
 libril/NOTICE                    |  190 -
 libril/RilSapSocket.cpp          |  290 --
 libril/RilSapSocket.h            |  200 -
 libril/RilSocket.h               |   70 -
 libril/ril.cpp                   | 1268 ------
 libril/rilSocketQueue.h          |  167 -
 libril/ril_commands.h            |  162 -
 libril/ril_event.cpp             |  384 --
 libril/ril_event.h               |   52 -
 libril/ril_internal.h            |   98 -
 libril/ril_service.cpp           | 8704 --------------------------------------
 libril/ril_service.h             |  748 ----
 libril/ril_unsol_commands.h      |   66 -
 libril/sap_service.cpp           |  965 -----
 libril/sap_service.h             |   33 -
 19 files changed, 14302 deletions(-)
 delete mode 100644 include/libril/ril_ex.h
 delete mode 100644 include/telephony/ril_cdma_sms.h
 delete mode 100644 libril/Android.mk
 delete mode 100644 libril/MODULE_LICENSE_APACHE2
 delete mode 100644 libril/NOTICE
 delete mode 100644 libril/RilSapSocket.cpp
 delete mode 100644 libril/RilSapSocket.h
 delete mode 100644 libril/RilSocket.h
 delete mode 100644 libril/ril.cpp
 delete mode 100644 libril/rilSocketQueue.h
 delete mode 100644 libril/ril_commands.h
 delete mode 100644 libril/ril_event.cpp
 delete mode 100644 libril/ril_event.h
 delete mode 100644 libril/ril_internal.h
 delete mode 100644 libril/ril_service.cpp
 delete mode 100644 libril/ril_service.h
 delete mode 100644 libril/ril_unsol_commands.h
 delete mode 100644 libril/sap_service.cpp
 delete mode 100644 libril/sap_service.h

diff --git a/include/libril/ril_ex.h b/include/libril/ril_ex.h
deleted file mode 100644
index 757bcf9..0000000
--- a/include/libril/ril_ex.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef RIL_EX_H_INCLUDED
-#define RIL_EX_H_INCLUDED
-
-#include <telephony/ril.h>
-#include <telephony/record_stream.h>
-
-#define NUM_ELEMS_SOCKET(a)     (sizeof (a) / sizeof (a)[0])
-
-struct ril_event;
-
-void rilEventAddWakeup_helper(struct ril_event *ev);
-int blockingWrite_helper(int fd, void* data, size_t len);
-
-enum SocketWakeType {DONT_WAKE, WAKE_PARTIAL};
-
-typedef enum {
-    RIL_TELEPHONY_SOCKET,
-    RIL_SAP_SOCKET
-} RIL_SOCKET_TYPE;
-
-typedef struct SocketListenParam {
-    RIL_SOCKET_ID socket_id;
-    int fdListen;
-    int fdCommand;
-    const char* processName;
-    struct ril_event* commands_event;
-    struct ril_event* listen_event;
-    void (*processCommandsCallback)(int fd, short flags, void *param);
-    RecordStream *p_rs;
-    RIL_SOCKET_TYPE type;
-} SocketListenParam;
-
-#endif
diff --git a/include/telephony/ril_cdma_sms.h b/include/telephony/ril_cdma_sms.h
deleted file mode 100644
index bcf6b30..0000000
--- a/include/telephony/ril_cdma_sms.h
+++ /dev/null
@@ -1,806 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * ISSUES:
- *
- */
-
-/**
- * TODO
- *
- *
- */
-
-
-#ifndef ANDROID_RIL_CDMA_SMS_H
-#define ANDROID_RIL_CDMA_SMS_H 1
-
-#include <stdlib.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Used by RIL_REQUEST_CDMA_SEND_SMS and RIL_UNSOL_RESPONSE_CDMA_NEW_SMS */
-
-#define RIL_CDMA_SMS_ADDRESS_MAX     36
-#define RIL_CDMA_SMS_SUBADDRESS_MAX  36
-#define RIL_CDMA_SMS_BEARER_DATA_MAX 255
-
-typedef enum {
-    RIL_CDMA_SMS_DIGIT_MODE_4_BIT = 0,     /* DTMF digits */
-    RIL_CDMA_SMS_DIGIT_MODE_8_BIT = 1,
-    RIL_CDMA_SMS_DIGIT_MODE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_DigitMode;
-
-typedef enum {
-    RIL_CDMA_SMS_NUMBER_MODE_NOT_DATA_NETWORK = 0,
-    RIL_CDMA_SMS_NUMBER_MODE_DATA_NETWORK     = 1,
-    RIL_CDMA_SMS_NUMBER_MODE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_NumberMode;
-
-typedef enum {
-    RIL_CDMA_SMS_NUMBER_TYPE_UNKNOWN                   = 0,
-    RIL_CDMA_SMS_NUMBER_TYPE_INTERNATIONAL_OR_DATA_IP  = 1,
-      /* INTERNATIONAL is used when number mode is not data network address.
-       * DATA_IP is used when the number mode is data network address
-       */
-    RIL_CDMA_SMS_NUMBER_TYPE_NATIONAL_OR_INTERNET_MAIL = 2,
-      /* NATIONAL is used when the number mode is not data network address.
-       * INTERNET_MAIL is used when the number mode is data network address.
-       * For INTERNET_MAIL, in the address data "digits", each byte contains
-       * an ASCII character. Examples are "x@y.com,a@b.com - ref TIA/EIA-637A 3.4.3.3
-       */
-    RIL_CDMA_SMS_NUMBER_TYPE_NETWORK                   = 3,
-    RIL_CDMA_SMS_NUMBER_TYPE_SUBSCRIBER                = 4,
-    RIL_CDMA_SMS_NUMBER_TYPE_ALPHANUMERIC              = 5,
-      /* GSM SMS: address value is GSM 7-bit chars */
-    RIL_CDMA_SMS_NUMBER_TYPE_ABBREVIATED               = 6,
-    RIL_CDMA_SMS_NUMBER_TYPE_RESERVED_7                = 7,
-    RIL_CDMA_SMS_NUMBER_TYPE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_NumberType;
-
-typedef enum {
-    RIL_CDMA_SMS_NUMBER_PLAN_UNKNOWN     = 0,
-    RIL_CDMA_SMS_NUMBER_PLAN_TELEPHONY   = 1,      /* CCITT E.164 and E.163, including ISDN plan */
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_2  = 2,
-    RIL_CDMA_SMS_NUMBER_PLAN_DATA        = 3,      /* CCITT X.121 */
-    RIL_CDMA_SMS_NUMBER_PLAN_TELEX       = 4,      /* CCITT F.69 */
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_5  = 5,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_6  = 6,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_7  = 7,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_8  = 8,
-    RIL_CDMA_SMS_NUMBER_PLAN_PRIVATE     = 9,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_10 = 10,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_11 = 11,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_12 = 12,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_13 = 13,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_14 = 14,
-    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_15 = 15,
-    RIL_CDMA_SMS_NUMBER_PLAN_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_NumberPlan;
-
-typedef struct {
-    RIL_CDMA_SMS_DigitMode digit_mode;
-      /* Indicates 4-bit or 8-bit */
-    RIL_CDMA_SMS_NumberMode number_mode;
-      /* Used only when digitMode is 8-bit */
-    RIL_CDMA_SMS_NumberType number_type;
-      /* Used only when digitMode is 8-bit.
-       * To specify an international address, use the following:
-       * digitMode = RIL_CDMA_SMS_DIGIT_MODE_8_BIT
-       * numberMode = RIL_CDMA_SMS_NOT_DATA_NETWORK
-       * numberType = RIL_CDMA_SMS_NUMBER_TYPE_INTERNATIONAL_OR_DATA_IP
-       * numberPlan = RIL_CDMA_SMS_NUMBER_PLAN_TELEPHONY
-       * numberOfDigits = number of digits
-       * digits = ASCII digits, e.g. '1', '2', '3'3, '4', and '5'
-       */
-    RIL_CDMA_SMS_NumberPlan number_plan;
-      /* Used only when digitMode is 8-bit */
-    unsigned char number_of_digits;
-    unsigned char digits[ RIL_CDMA_SMS_ADDRESS_MAX ];
-      /* Each byte in this array represnts a 40bit or 8-bit digit of address data */
-} RIL_CDMA_SMS_Address;
-
-typedef enum {
-    RIL_CDMA_SMS_SUBADDRESS_TYPE_NSAP           = 0,    /* CCITT X.213 or ISO 8348 AD2 */
-    RIL_CDMA_SMS_SUBADDRESS_TYPE_USER_SPECIFIED = 1,    /* e.g. X.25 */
-    RIL_CDMA_SMS_SUBADDRESS_TYPE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_SubaddressType;
-
-typedef struct {
-    RIL_CDMA_SMS_SubaddressType subaddressType;
-    /* 1 means the last byte's lower 4 bits should be ignored */
-    unsigned char odd;
-    unsigned char number_of_digits;
-    /* Each byte respresents a 8-bit digit of subaddress data */
-    unsigned char digits[ RIL_CDMA_SMS_SUBADDRESS_MAX ];
-} RIL_CDMA_SMS_Subaddress;
-
-typedef struct {
-    int uTeleserviceID;
-    unsigned char bIsServicePresent;
-    int uServicecategory;
-    RIL_CDMA_SMS_Address sAddress;
-    RIL_CDMA_SMS_Subaddress sSubAddress;
-    int uBearerDataLen;
-    unsigned char aBearerData[ RIL_CDMA_SMS_BEARER_DATA_MAX ];
-} RIL_CDMA_SMS_Message;
-
-/* Used by RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE */
-
-typedef enum {
-    RIL_CDMA_SMS_NO_ERROR       = 0,
-    RIL_CDMA_SMS_ERROR          = 1,
-    RIL_CDMA_SMS_ERROR_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_ErrorClass;
-
-typedef struct {
-    RIL_CDMA_SMS_ErrorClass uErrorClass;
-    int uSMSCauseCode;  /* As defined in N.S00005, 6.5.2.125.
-                           Currently, only 35 (resource shortage) and
-                           39 (other terminal problem) are reported. */
-} RIL_CDMA_SMS_Ack;
-
-/* Used by RIL_REQUEST_CDMA_SMS_GET_BROADCAST_CONFIG and
-   RIL_REQUEST_CDMA_SMS_SET_BROADCAST_CONFIG */
-
-typedef struct {
-    int service_category;
-    int language;
-    unsigned char selected;
-} RIL_CDMA_BroadcastSmsConfigInfo;
-
-/* Used by RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM */
-
-typedef struct {
-    int status;     /* Status of message.  See TS 27.005 3.1, "<stat>": */
-                  /*      0 = "REC UNREAD"    */
-                  /*      1 = "REC READ"      */
-                  /*      2 = "STO UNSENT"    */
-                  /*      3 = "STO SENT"      */
-
-    RIL_CDMA_SMS_Message message;
-} RIL_CDMA_SMS_WriteArgs;
-
-
-/* Used by RIL_REQUEST_ENCODE_CDMA_SMS and RIL_REQUEST_DECODE_CDMA_SMS*/
-
-#define RIL_CDMA_SMS_UDH_MAX_SND_SIZE           128
-#define RIL_CDMA_SMS_UDH_EO_DATA_SEGMENT_MAX    131 /* 140 - 3 - 6 */
-#define RIL_CDMA_SMS_MAX_UD_HEADERS         7
-#define RIL_CDMA_SMS_USER_DATA_MAX     229
-#define RIL_CDMA_SMS_ADDRESS_MAX            36
-#define RIL_CDMA_SMS_UDH_LARGE_PIC_SIZE     128
-#define RIL_CDMA_SMS_UDH_SMALL_PIC_SIZE     32
-#define RIL_CDMA_SMS_UDH_VAR_PIC_SIZE       134
-#define RIL_CDMA_SMS_UDH_ANIM_NUM_BITMAPS   4
-#define RIL_CDMA_SMS_UDH_LARGE_BITMAP_SIZE  32
-#define RIL_CDMA_SMS_UDH_SMALL_BITMAP_SIZE  8
-#define RIL_CDMA_SMS_UDH_OTHER_SIZE         226
-#define RIL_CDMA_SMS_IP_ADDRESS_SIZE        4
-
-/* ------------------- */
-/* ---- User Data ---- */
-/* ------------------- */
-typedef enum {
-    RIL_CDMA_SMS_UDH_CONCAT_8         = 0x00,
-    RIL_CDMA_SMS_UDH_SPECIAL_SM,
-    /* 02 - 03    Reserved */
-    RIL_CDMA_SMS_UDH_PORT_8           = 0x04,
-    RIL_CDMA_SMS_UDH_PORT_16,
-    RIL_CDMA_SMS_UDH_SMSC_CONTROL,
-    RIL_CDMA_SMS_UDH_SOURCE,
-    RIL_CDMA_SMS_UDH_CONCAT_16,
-    RIL_CDMA_SMS_UDH_WCMP,
-    RIL_CDMA_SMS_UDH_TEXT_FORMATING,
-    RIL_CDMA_SMS_UDH_PRE_DEF_SOUND,
-    RIL_CDMA_SMS_UDH_USER_DEF_SOUND,
-    RIL_CDMA_SMS_UDH_PRE_DEF_ANIM,
-    RIL_CDMA_SMS_UDH_LARGE_ANIM,
-    RIL_CDMA_SMS_UDH_SMALL_ANIM,
-    RIL_CDMA_SMS_UDH_LARGE_PICTURE,
-    RIL_CDMA_SMS_UDH_SMALL_PICTURE,
-    RIL_CDMA_SMS_UDH_VAR_PICTURE,
-
-    RIL_CDMA_SMS_UDH_USER_PROMPT      = 0x13,
-    RIL_CDMA_SMS_UDH_EXTENDED_OBJECT  = 0x14,
-
-    /* 15 - 1F    Reserved for future EMS */
-
-    RIL_CDMA_SMS_UDH_RFC822           = 0x20,
-
-    /*  21 - 6F    Reserved for future use */
-    /*  70 - 7f    Reserved for (U)SIM Toolkit Security Headers */
-    /*  80 - 9F    SME to SME specific use */
-    /*  A0 - BF    Reserved for future use */
-    /*  C0 - DF    SC specific use */
-    /*  E0 - FF    Reserved for future use */
-
-    RIL_CDMA_SMS_UDH_OTHER            = 0xFFFF, /* For unsupported or proprietary headers */
-    RIL_CDMA_SMS_UDH_ID_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
-
-} RIL_CDMA_SMS_UdhId;
-
-typedef struct {
-    /*indicates the reference number for a particular concatenated short message. */
-    /*it is constant for every short message which makes up a particular concatenated short message*/
-    unsigned char       msg_ref;
-
-    /*indicates the total number of short messages within the concatenated short message.
-     The value shall start at 1 and remain constant for every
-     short message which makes up the concatenated short message.
-     if it is 0 then the receiving entity shall ignore the whole Information Element*/
-    unsigned char       total_sm;
-
-    /*
-     * it indicates the sequence number of a particular short message within the concatenated short
-     * message. The value shall start at 1 and increment by one for every short message sent
-     * within the concatenated short message. If the value is zero or the value is
-     * greater than the value in octet 2 then the receiving
-     * entity shall ignore the whole Information Element.
-     */
-    unsigned char      seq_num;
-} RIL_CDMA_SMS_UdhConcat8;
-
-/* GW message waiting actions
-*/
-typedef enum {
-    RIL_CDMA_SMS_GW_MSG_WAITING_NONE,
-    RIL_CDMA_SMS_GW_MSG_WAITING_DISCARD,
-    RIL_CDMA_SMS_GW_MSG_WAITING_STORE,
-    RIL_CDMA_SMS_GW_MSG_WAITING_NONE_1111,
-    RIL_CDMA_SMS_GW_MSG_WAITING_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_GWMsgWaiting;
-
-/* GW message waiting types
-*/
-typedef enum {
-    RIL_CDMA_SMS_GW_MSG_WAITING_VOICEMAIL,
-    RIL_CDMA_SMS_GW_MSG_WAITING_FAX,
-    RIL_CDMA_SMS_GW_MSG_WAITING_EMAIL,
-    RIL_CDMA_SMS_GW_MSG_WAITING_OTHER,
-    RIL_CDMA_SMS_GW_MSG_WAITING_KIND_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_GWMsgWaitingKind;
-
-typedef struct {
-    RIL_CDMA_SMS_GWMsgWaiting                 msg_waiting;
-    RIL_CDMA_SMS_GWMsgWaitingKind             msg_waiting_kind;
-
-    /*it indicates the number of messages of the type specified in Octet 1 waiting.*/
-    unsigned char                             message_count;
-} RIL_CDMA_SMS_UdhSpecialSM;
-
-typedef struct {
-    unsigned char  dest_port;
-    unsigned char  orig_port;
-} RIL_CDMA_SMS_UdhWap8;
-
-typedef struct {
-    unsigned short  dest_port;
-    unsigned short  orig_port;
-} RIL_CDMA_SMS_UdhWap16;
-
-typedef struct {
-    unsigned short      msg_ref;
-    unsigned char       total_sm;
-    unsigned char       seq_num;
-
-} RIL_CDMA_SMS_UdhConcat16;
-
-typedef enum {
-    RIL_CDMA_SMS_UDH_LEFT_ALIGNMENT = 0,
-    RIL_CDMA_SMS_UDH_CENTER_ALIGNMENT,
-    RIL_CDMA_SMS_UDH_RIGHT_ALIGNMENT,
-    RIL_CDMA_SMS_UDH_DEFAULT_ALIGNMENT,
-    RIL_CDMA_SMS_UDH_MAX_ALIGNMENT,
-    RIL_CDMA_SMS_UDH_ALIGNMENT_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_UdhAlignment;
-
-typedef enum {
-    RIL_CDMA_SMS_UDH_FONT_NORMAL = 0,
-    RIL_CDMA_SMS_UDH_FONT_LARGE,
-    RIL_CDMA_SMS_UDH_FONT_SMALL,
-    RIL_CDMA_SMS_UDH_FONT_RESERVED,
-    RIL_CDMA_SMS_UDH_FONT_MAX,
-    RIL_CDMA_SMS_UDH_FONT_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_UdhFontSize;
-
-typedef enum {
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BLACK          = 0x0,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_GREY      = 0x1,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_RED       = 0x2,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_YELLOW    = 0x3,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_GREEN     = 0x4,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_CYAN      = 0x5,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_BLUE      = 0x6,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_MAGENTA   = 0x7,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_GREY           = 0x8,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_WHITE          = 0x9,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_RED     = 0xA,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_YELLOW  = 0xB,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_GREEN   = 0xC,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_CYAN    = 0xD,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_BLUE    = 0xE,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_MAGENTA = 0xF,
-    RIL_CDMA_SMS_UDH_TEXT_COLOR_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_UdhTextColor;
-
-typedef struct {
-    unsigned char              start_position;
-    unsigned char              text_formatting_length;
-    RIL_CDMA_SMS_UdhAlignment  alignment_type ;       /*bit 0 and  bit 1*/
-    RIL_CDMA_SMS_UdhFontSize   font_size ;            /*bit 3 and  bit 2*/
-    unsigned char              style_bold;            /*bit 4 */
-    unsigned char              style_italic;          /*bit 5  */
-    unsigned char              style_underlined;      /*bit 6 */
-    unsigned char              style_strikethrough;   /*bit 7 */
-
-    /* if FALSE, ignore the following color information */
-    unsigned char              is_color_present;
-    RIL_CDMA_SMS_UdhTextColor  text_color_foreground;
-    RIL_CDMA_SMS_UdhTextColor  text_color_background;
-
-} RIL_CDMA_SMS_UdhTextFormating;
-
-/* Predefined sound
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       snd_number;
-} RIL_CDMA_SMS_UdhPreDefSound;
-
-/* User Defined sound
-*/
-typedef struct {
-    unsigned char       data_length;
-    unsigned char       position;
-    unsigned char       user_def_sound[RIL_CDMA_SMS_UDH_MAX_SND_SIZE];
-} RIL_CDMA_SMS_UdhUserDefSound;
-
-/* Large picture
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       data[RIL_CDMA_SMS_UDH_LARGE_PIC_SIZE];
-} RIL_CDMA_SMS_UdhLargePictureData;
-
-/* Small picture
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       data[RIL_CDMA_SMS_UDH_SMALL_PIC_SIZE];
-} RIL_CDMA_SMS_UdhSmallPictureData;
-
-/* Variable length picture
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       width;    /* Number of pixels - Should be a mutliple of 8 */
-    unsigned char       height;
-    unsigned char       data[RIL_CDMA_SMS_UDH_VAR_PIC_SIZE];
-} RIL_CDMA_SMS_UdhVarPicture;
-
-/* Predefined animation
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       animation_number;
-} RIL_CDMA_SMS_UdhPreDefAnim;
-
-/* Large animation
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       data[RIL_CDMA_SMS_UDH_ANIM_NUM_BITMAPS][RIL_CDMA_SMS_UDH_LARGE_BITMAP_SIZE];
-} RIL_CDMA_SMS_UdhLargeAnim;
-
-/* Small animation
-*/
-typedef struct {
-    unsigned char       position;
-    unsigned char       data[RIL_CDMA_SMS_UDH_ANIM_NUM_BITMAPS][RIL_CDMA_SMS_UDH_SMALL_BITMAP_SIZE];
-} RIL_CDMA_SMS_UdhSmallAnim;
-
-/* User Prompt Indicator UDH
-*/
-typedef struct {
-    unsigned char       number_of_objects;
-    /* Number of objects of the same kind that follow this header which will
-    ** be stitched together by the applications. For example, 5 small pictures
-    ** are to be stitched together horizontally, or 6 iMelody tones are to be
-    ** connected together with intermediate iMelody header and footer ignored.
-    ** Allowed objects to be stitched:
-    **   - Images (small, large, variable)
-    **   - User defined sounds
-    */
-} RIL_CDMA_SMS_UdhUserPrompt;
-
-typedef struct {
-    unsigned char         length;
-
-    unsigned char         data[RIL_CDMA_SMS_UDH_EO_DATA_SEGMENT_MAX];
-    /* RIL_CDMA_SMS_UDH_EO_VCARD: See http://www.imc.org/pdi/vcard-21.doc for payload */
-    /* RIL_CDMA_SMS_UDH_EO_VCALENDAR: See http://www.imc.org/pdi/vcal-10.doc */
-    /* Or: Unsupported/proprietary extended objects */
-
-} RIL_CDMA_SMS_UdhEoContent;
-
-/* Extended Object UDH
-*/
-/* Extended Object IDs/types
-*/
-typedef enum {
-    RIL_CDMA_SMS_UDH_EO_VCARD                   = 0x09,
-    RIL_CDMA_SMS_UDH_EO_VCALENDAR               = 0x0A,
-    RIL_CDMA_SMS_UDH_EO_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
-} RIL_CDMA_SMS_UdhEoId;
-
-typedef struct {
-    /* Extended objects are to be used together with 16-bit concatenation
-    ** UDH. The max number of segments supported for E.O. is 8 at least.
-    */
-    RIL_CDMA_SMS_UdhEoContent    content;
-
-    unsigned char                                 first_segment;
-    /* The following fields are only present in the first segment of a
-    ** concatenated SMS message.
-    */
-   unsigned char                                   reference;
-    /* Identify those extended object segments which should be linked together
-    */
-   unsigned short                                  length;
-    /* Length of the whole extended object data
-    */
-    unsigned char                                   control;
-    RIL_CDMA_SMS_UdhEoId                    type;
-    unsigned short                                  position;
-    /* Absolute position of the E.O. in the whole text after concatenation,
-    ** starting from 1.
-    */
-} RIL_CDMA_SMS_UdhEo;
-
-typedef struct {
-    RIL_CDMA_SMS_UdhId  header_id;
-    unsigned char               header_length;
-    unsigned char              data[RIL_CDMA_SMS_UDH_OTHER_SIZE];
-} RIL_CDMA_SMS_UdhOther;
-
-typedef struct {
-    unsigned char        header_length;
-} RIL_CDMA_SMS_UdhRfc822;
-
-typedef struct {
-    RIL_CDMA_SMS_UdhId                header_id;
-
-    union {
-        RIL_CDMA_SMS_UdhConcat8             concat_8;       // 00
-
-        RIL_CDMA_SMS_UdhSpecialSM           special_sm;     // 01
-        RIL_CDMA_SMS_UdhWap8                wap_8;          // 04
-        RIL_CDMA_SMS_UdhWap16               wap_16;         // 05
-        RIL_CDMA_SMS_UdhConcat16            concat_16;      // 08
-        RIL_CDMA_SMS_UdhTextFormating       text_formating; // 0a
-        RIL_CDMA_SMS_UdhPreDefSound         pre_def_sound;  // 0b
-        RIL_CDMA_SMS_UdhUserDefSound        user_def_sound; // 0c
-        RIL_CDMA_SMS_UdhPreDefAnim          pre_def_anim;   // 0d
-        RIL_CDMA_SMS_UdhLargeAnim           large_anim;     // 0e
-        RIL_CDMA_SMS_UdhSmallAnim           small_anim;     // 0f
-        RIL_CDMA_SMS_UdhLargePictureData    large_picture;  // 10
-        RIL_CDMA_SMS_UdhSmallPictureData    small_picture;  // 11
-        RIL_CDMA_SMS_UdhVarPicture          var_picture;    // 12
-
-        RIL_CDMA_SMS_UdhUserPrompt          user_prompt;    // 13
-        RIL_CDMA_SMS_UdhEo                  eo;             // 14
-
-        RIL_CDMA_SMS_UdhRfc822              rfc822;         // 20
-        RIL_CDMA_SMS_UdhOther               other;
-
-    }u;
-} RIL_CDMA_SMS_Udh;
-
-/* ----------------------------- */
-/* -- User data encoding type -- */
-/* ----------------------------- */
-typedef enum {
-    RIL_CDMA_SMS_ENCODING_OCTET        = 0,    /* 8-bit */
-    RIL_CDMA_SMS_ENCODING_IS91EP,              /* varies */
-    RIL_CDMA_SMS_ENCODING_ASCII,               /* 7-bit */
-    RIL_CDMA_SMS_ENCODING_IA5,                 /* 7-bit */
-    RIL_CDMA_SMS_ENCODING_UNICODE,             /* 16-bit */
-    RIL_CDMA_SMS_ENCODING_SHIFT_JIS,           /* 8 or 16-bit */
-    RIL_CDMA_SMS_ENCODING_KOREAN,              /* 8 or 16-bit */
-    RIL_CDMA_SMS_ENCODING_LATIN_HEBREW,        /* 8-bit */
-    RIL_CDMA_SMS_ENCODING_LATIN,               /* 8-bit */
-    RIL_CDMA_SMS_ENCODING_GSM_7_BIT_DEFAULT,   /* 7-bit */
-    RIL_CDMA_SMS_ENCODING_MAX32        = 0x10000000
-
-} RIL_CDMA_SMS_UserDataEncoding;
-
-/* ------------------------ */
-/* -- IS-91 EP data type -- */
-/* ------------------------ */
-typedef enum {
-    RIL_CDMA_SMS_IS91EP_VOICE_MAIL         = 0x82,
-    RIL_CDMA_SMS_IS91EP_SHORT_MESSAGE_FULL = 0x83,
-    RIL_CDMA_SMS_IS91EP_CLI_ORDER          = 0x84,
-    RIL_CDMA_SMS_IS91EP_SHORT_MESSAGE      = 0x85,
-    RIL_CDMA_SMS_IS91EP_MAX32              = 0x10000000
-
-} RIL_CDMA_SMS_IS91EPType;
-
-typedef struct {
-    /* NOTE: If message_id.udh_present == TRUE:
-    **       'num_headers' is the number of User Data Headers (UDHs),
-    **       and 'headers' include all those headers.
-    */
-    unsigned char                              num_headers;
-    RIL_CDMA_SMS_Udh                     headers[RIL_CDMA_SMS_MAX_UD_HEADERS];
-
-    RIL_CDMA_SMS_UserDataEncoding      encoding;
-    RIL_CDMA_SMS_IS91EPType             is91ep_type;
-
-    /*----------------------------------------------------------------------
-     'data_len' indicates the valid number of bytes in the 'data' array.
-
-     'padding_bits' (0-7) indicates how many bits in the last byte of 'data'
-     are invalid bits. This parameter is only used for Mobile-Originated
-     messages. There is no way for the API to tell how many padding bits
-     exist in the received message. Instead, the application can find out how
-     many padding bits exist in the user data when decoding the user data.
-
-     'data' has the raw bits of the user data field of the SMS message.
-     The client software should decode the raw user data according to its
-     supported encoding types and languages.
-
-     EXCEPTION 1: CMT-91 user data raw bits are first translated into BD fields
-     (e.g. num_messages, callback, etc.) The translated user data field in
-     VMN and Short Message is in the form of ASCII characters, each occupying
-     a byte in the resulted 'data'.
-
-     EXCEPTION 2: GSM 7-bit Default characters are decoded so that each byte
-     has one 7-bit GSM character.
-
-     'number_of_digits' is the number of digits/characters (7, 8, 16, or
-     whatever bits) in the raw user data, which can be used by the client
-     when decoding the user data according to the encoding type and language.
-    -------------------------------------------------------------------------*/
-    unsigned char                                data_len;
-    unsigned char                                padding_bits;
-    unsigned char                                data[ RIL_CDMA_SMS_USER_DATA_MAX ];
-    unsigned char                                number_of_digits;
-
-} RIL_CDMA_SMS_CdmaUserData;
-
-/* -------------------- */
-/* ---- Message Id ---- */
-/* -------------------- */
-typedef enum {
-    RIL_CDMA_SMS_BD_TYPE_RESERVED_0     = 0,
-    RIL_CDMA_SMS_BD_TYPE_DELIVER,       /* MT only */
-    RIL_CDMA_SMS_BD_TYPE_SUBMIT,        /* MO only */
-    RIL_CDMA_SMS_BD_TYPE_CANCELLATION,  /* MO only */
-    RIL_CDMA_SMS_BD_TYPE_DELIVERY_ACK,  /* MT only */
-    RIL_CDMA_SMS_BD_TYPE_USER_ACK,      /* MT & MO */
-    RIL_CDMA_SMS_BD_TYPE_READ_ACK,      /* MT & MO */
-    RIL_CDMA_SMS_BD_TYPE_MAX32          = 0x10000000
-
-} RIL_CDMA_SMS_BdMessageType;
-
-typedef unsigned int  RIL_CDMA_SMS_MessageNumber;
-
-typedef struct {
-    RIL_CDMA_SMS_BdMessageType   type;
-    RIL_CDMA_SMS_MessageNumber      id_number;
-    unsigned char                      udh_present;
-    /* NOTE: if FEATURE_SMS_UDH is not defined,
-    ** udh_present should be ignored.
-    */
-} RIL_CDMA_SMS_MessageId;
-
-typedef unsigned char           RIL_CDMA_SMS_UserResponse;
-
-/* ------------------- */
-/* ---- Timestamp ---- */
-/* ------------------- */
-typedef struct {
-    /* If 'year' is between 96 and 99, the actual year is 1900 + 'year';
-       if 'year' is between 00 and 95, the actual year is 2000 + 'year'.
-       NOTE: Each field has two BCD digits and byte arrangement is <MSB, ... ,LSB>
-    */
-    unsigned char      year;        /* 0x00-0x99 */
-    unsigned char      month;       /* 0x01-0x12 */
-    unsigned char      day;         /* 0x01-0x31 */
-    unsigned char      hour;        /* 0x00-0x23 */
-    unsigned char      minute;      /* 0x00-0x59 */
-    unsigned char      second;      /* 0x00-0x59 */
-    signed char      timezone;    /* +/-, [-48,+48] number of 15 minutes - GW only */
-} RIL_CDMA_SMS_Timestamp;
-
-/* ------------------ */
-/* ---- Priority ---- */
-/* ------------------ */
-typedef enum {
-    RIL_CDMA_SMS_PRIORITY_NORMAL      = 0,
-    RIL_CDMA_SMS_PRIORITY_INTERACTIVE,
-    RIL_CDMA_SMS_PRIORITY_URGENT,
-    RIL_CDMA_SMS_PRIORITY_EMERGENCY,
-    RIL_CDMA_SMS_PRIORITY_MAX32       = 0x10000000
-
-} RIL_CDMA_SMS_Priority;
-
-/* ----------------- */
-/* ---- Privacy ---- */
-/* ----------------- */
-typedef enum {
-    RIL_CDMA_SMS_PRIVACY_NORMAL      = 0,
-    RIL_CDMA_SMS_PRIVACY_RESTRICTED,
-    RIL_CDMA_SMS_PRIVACY_CONFIDENTIAL,
-    RIL_CDMA_SMS_PRIVACY_SECRET,
-    RIL_CDMA_SMS_PRIVACY_MAX32       = 0x10000000
-
-} RIL_CDMA_SMS_Privacy;
-
-/* ---------------------- */
-/* ---- Reply option ---- */
-/* ---------------------- */
-typedef struct {
-    /* whether user ack is requested
-    */
-    unsigned char          user_ack_requested;
-
-    /* whether delivery ack is requested.
-       Should be FALSE for incoming messages.
-    */
-    unsigned char          delivery_ack_requested;
-
-    /* Message originator requests the receiving phone to send back a READ_ACK
-    ** message automatically when the user reads the received message.
-    */
-    unsigned char          read_ack_requested;
-
-} RIL_CDMA_SMS_ReplyOption;
-
-typedef enum {
-    RIL_CDMA_SMS_ALERT_MODE_DEFAULT         = 0,
-    RIL_CDMA_SMS_ALERT_MODE_LOW_PRIORITY    = 1,
-    RIL_CDMA_SMS_ALERT_MODE_MEDIUM_PRIORITY = 2,
-    RIL_CDMA_SMS_ALERT_MODE_HIGH_PRIORITY   = 3,
-
-    /* For pre-IS637A implementations, alert_mode only has values of True/False:
-    */
-    RIL_CDMA_SMS_ALERT_MODE_OFF   = 0,
-    RIL_CDMA_SMS_ALERT_MODE_ON    = 1
-
-} RIL_CDMA_SMS_AlertMode;
-
-/* ------------------ */
-/* ---- Language ---- */
-/* ------------------ */
-typedef enum {
-    RIL_CDMA_SMS_LANGUAGE_UNSPECIFIED = 0,
-    RIL_CDMA_SMS_LANGUAGE_ENGLISH,
-    RIL_CDMA_SMS_LANGUAGE_FRENCH,
-    RIL_CDMA_SMS_LANGUAGE_SPANISH,
-    RIL_CDMA_SMS_LANGUAGE_JAPANESE,
-    RIL_CDMA_SMS_LANGUAGE_KOREAN,
-    RIL_CDMA_SMS_LANGUAGE_CHINESE,
-    RIL_CDMA_SMS_LANGUAGE_HEBREW,
-    RIL_CDMA_SMS_LANGUAGE_MAX32       = 0x10000000
-
-} RIL_CDMA_SMS_Language;
-
-/* ---------------------------------- */
-/* ---------- Display Mode ---------- */
-/* ---------------------------------- */
-typedef enum {
-    RIL_CDMA_SMS_DISPLAY_MODE_IMMEDIATE   = 0,
-    RIL_CDMA_SMS_DISPLAY_MODE_DEFAULT     = 1,
-    RIL_CDMA_SMS_DISPLAY_MODE_USER_INVOKE = 2,
-    RIL_CDMA_SMS_DISPLAY_MODE_RESERVED    = 3
-} RIL_CDMA_SMS_DisplayMode;
-
-/* IS-637B parameters/fields
-*/
-
-/* ---------------------------------- */
-/* ---------- Delivery Status ------- */
-/* ---------------------------------- */
-typedef enum {
-    RIL_CDMA_SMS_DELIVERY_STATUS_ACCEPTED              = 0,    /* ERROR_CLASS_NONE */
-    RIL_CDMA_SMS_DELIVERY_STATUS_DEPOSITED_TO_INTERNET = 1,    /* ERROR_CLASS_NONE */
-    RIL_CDMA_SMS_DELIVERY_STATUS_DELIVERED             = 2,    /* ERROR_CLASS_NONE */
-    RIL_CDMA_SMS_DELIVERY_STATUS_CANCELLED             = 3,    /* ERROR_CLASS_NONE */
-
-    RIL_CDMA_SMS_DELIVERY_STATUS_NETWORK_CONGESTION  = 4,    /* ERROR_CLASS_TEMP & PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_NETWORK_ERROR       = 5,    /* ERROR_CLASS_TEMP & PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_CANCEL_FAILED       = 6,    /* ERROR_CLASS_PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_BLOCKED_DESTINATION = 7,    /* ERROR_CLASS_PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_TEXT_TOO_LONG       = 8,    /* ERROR_CLASS_PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_DUPLICATE_MESSAGE   = 9,    /* ERROR_CLASS_PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_INVALID_DESTINATION = 10,   /* ERROR_CLASS_PERM */
-    RIL_CDMA_SMS_DELIVERY_STATUS_MESSAGE_EXPIRED     = 13,   /* ERROR_CLASS_PERM */
-
-    RIL_CDMA_SMS_DELIVERY_STATUS_UNKNOWN_ERROR       = 0x1F  /* ERROR_CLASS_PERM */
-
-    /* All the other values are reserved */
-
-} RIL_CDMA_SMS_DeliveryStatusE;
-
-typedef struct {
-    RIL_CDMA_SMS_ErrorClass       error_class;
-    RIL_CDMA_SMS_DeliveryStatusE   status;
-} RIL_CDMA_SMS_DeliveryStatus;
-
-typedef struct {
-    unsigned char               address[RIL_CDMA_SMS_IP_ADDRESS_SIZE];
-    unsigned char             is_valid;
-} RIL_CDMA_SMS_IpAddress;
-
-/* This special parameter captures any unrecognized/proprietary parameters
-*/
-typedef struct {
-    unsigned char                         input_other_len;
-    unsigned char                         desired_other_len; /* used during decoding */
-    unsigned char                         * other_data;
-} RIL_CDMA_SMS_OtherParm;
-
-typedef struct {
-    /* the mask indicates which fields are present in this message */
-    unsigned int                        mask;
-
-    RIL_CDMA_SMS_MessageId         message_id;
-    RIL_CDMA_SMS_CdmaUserData     user_data;
-    RIL_CDMA_SMS_UserResponse        user_response;
-    RIL_CDMA_SMS_Timestamp          mc_time;
-    RIL_CDMA_SMS_Timestamp          validity_absolute;
-    RIL_CDMA_SMS_Timestamp          validity_relative;
-    RIL_CDMA_SMS_Timestamp          deferred_absolute;
-    RIL_CDMA_SMS_Timestamp          deferred_relative;
-    RIL_CDMA_SMS_Priority           priority;
-    RIL_CDMA_SMS_Privacy            privacy;
-    RIL_CDMA_SMS_ReplyOption       reply_option;
-    unsigned char                         num_messages;  /* the actual value; not BCDs */
-    RIL_CDMA_SMS_AlertMode         alert_mode;
-     /* For pre-IS-637A implementations, alert_mode is either Off or On. */
-    RIL_CDMA_SMS_Language           language;
-    RIL_CDMA_SMS_Address            callback;
-    RIL_CDMA_SMS_DisplayMode       display_mode;
-
-    RIL_CDMA_SMS_DeliveryStatus    delivery_status;
-    unsigned int                        deposit_index;
-
-    RIL_CDMA_SMS_IpAddress         ip_address;
-    unsigned char                         rsn_no_notify;
-
-    /* See function comments of wms_ts_decode() and
-    ** wms_ts_decode_cdma_bd_with_other() for details regarding 'other' parameters
-    */
-    RIL_CDMA_SMS_OtherParm         other;
-
-} RIL_CDMA_SMS_ClientBd;
-
-typedef struct {
-    unsigned char length;   /* length, in bytes, of the encoded SMS message */
-    unsigned char * data;   /* the encoded SMS message (max 255 bytes) */
-} RIL_CDMA_Encoded_SMS;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*ANDROID_RIL_CDMA_SMS_H*/
diff --git a/libril/Android.mk b/libril/Android.mk
deleted file mode 100644
index 2a22171..0000000
--- a/libril/Android.mk
+++ /dev/null
@@ -1,50 +0,0 @@
-# Copyright 2006 The Android Open Source Project
-
-ifeq ($(BOARD_PROVIDES_LIBRIL),true)
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_VENDOR_MODULE := true
-
-LOCAL_SRC_FILES:= \
-    ril.cpp \
-    ril_event.cpp\
-    RilSapSocket.cpp \
-    ril_service.cpp \
-    sap_service.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-    liblog \
-    libutils \
-    libcutils \
-    libhardware_legacy \
-    librilutils \
-    android.hardware.radio@1.0 \
-    android.hardware.radio@1.1 \
-    android.hardware.radio.deprecated@1.0 \
-    libhidlbase  \
-    libhidltransport \
-    libhwbinder
-
-LOCAL_STATIC_LIBRARIES := \
-    libprotobuf-c-nano-enable_malloc \
-
-LOCAL_CFLAGS += -Wall -Wextra -Wno-unused-parameter -Werror
-
-ifeq ($(SIM_COUNT), 2)
-    LOCAL_CFLAGS += -DANDROID_MULTI_SIM -DDSDA_RILD1
-    LOCAL_CFLAGS += -DANDROID_SIM_COUNT_2
-endif
-
-LOCAL_C_INCLUDES += external/nanopb-c
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
-LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/../include
-
-LOCAL_MODULE:= libril
-LOCAL_CLANG := true
-LOCAL_SANITIZE := integer
-
-include $(BUILD_SHARED_LIBRARY)
-
-endif # BOARD_PROVIDES_LIBRIL
diff --git a/libril/MODULE_LICENSE_APACHE2 b/libril/MODULE_LICENSE_APACHE2
deleted file mode 100644
index e69de29..0000000
diff --git a/libril/NOTICE b/libril/NOTICE
deleted file mode 100644
index c5b1efa..0000000
--- a/libril/NOTICE
+++ /dev/null
@@ -1,190 +0,0 @@
-
-   Copyright (c) 2005-2008, The Android Open Source Project
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
diff --git a/libril/RilSapSocket.cpp b/libril/RilSapSocket.cpp
deleted file mode 100644
index cf99773..0000000
--- a/libril/RilSapSocket.cpp
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#define __STDC_LIMIT_MACROS
-#include <stdint.h>
-#define RIL_SHLIB
-#include "telephony/ril.h"
-#include "RilSapSocket.h"
-#include "pb_decode.h"
-#include "pb_encode.h"
-#undef LOG_TAG
-#define LOG_TAG "RIL_UIM_SOCKET"
-#include <utils/Log.h>
-#include <arpa/inet.h>
-#include <errno.h>
-#include <sap_service.h>
-
-static RilSapSocket::RilSapSocketList *head = NULL;
-
-extern "C" void
-RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
-        const struct timeval *relativeTime);
-
-struct RIL_Env RilSapSocket::uimRilEnv = {
-        .OnRequestComplete = RilSapSocket::sOnRequestComplete,
-        .OnUnsolicitedResponse = RilSapSocket::sOnUnsolicitedResponse,
-        .RequestTimedCallback = RIL_requestTimedCallback
-};
-
-void RilSapSocket::sOnRequestComplete (RIL_Token t,
-        RIL_Errno e,
-        void *response,
-        size_t responselen) {
-    RilSapSocket *sap_socket;
-    SapSocketRequest *request = (SapSocketRequest*) t;
-
-    RLOGD("Socket id:%d", request->socketId);
-
-    sap_socket = getSocketById(request->socketId);
-
-    if (sap_socket) {
-        sap_socket->onRequestComplete(t,e,response,responselen);
-    } else {
-        RLOGE("Invalid socket id");
-        if (request->curr->payload) {
-            free(request->curr->payload);
-        }
-        free(request->curr);
-        free(request);
-    }
-}
-
-#if defined(ANDROID_MULTI_SIM)
-void RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,
-        const void *data,
-        size_t datalen,
-        RIL_SOCKET_ID socketId) {
-    RilSapSocket *sap_socket = getSocketById(socketId);
-    if (sap_socket) {
-        sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);
-    }
-}
-#else
-void RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,
-       const void *data,
-       size_t datalen) {
-    RilSapSocket *sap_socket = getSocketById(RIL_SOCKET_1);
-    if(sap_socket){
-        sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);
-    }
-}
-#endif
-
-void RilSapSocket::printList() {
-    RilSapSocketList *current = head;
-    RLOGD("Printing socket list");
-    while(NULL != current) {
-        RLOGD("SocketName:%s",current->socket->name);
-        RLOGD("Socket id:%d",current->socket->id);
-        current = current->next;
-    }
-}
-
-RilSapSocket *RilSapSocket::getSocketById(RIL_SOCKET_ID socketId) {
-    RilSapSocket *sap_socket;
-    RilSapSocketList *current = head;
-
-    RLOGD("Entered getSocketById");
-    printList();
-
-    while(NULL != current) {
-        if(socketId == current->socket->id) {
-            sap_socket = current->socket;
-            return sap_socket;
-        }
-        current = current->next;
-    }
-    return NULL;
-}
-
-void RilSapSocket::initSapSocket(const char *socketName,
-        RIL_RadioFunctions *uimFuncs) {
-
-    if (strcmp(socketName, RIL1_SERVICE_NAME) == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_1, uimFuncs);
-        }
-    }
-
-#if (SIM_COUNT >= 2)
-    if (strcmp(socketName, RIL2_SERVICE_NAME) == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_2, uimFuncs);
-        }
-    }
-#endif
-
-#if (SIM_COUNT >= 3)
-    if (strcmp(socketName, RIL3_SERVICE_NAME) == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_3, uimFuncs);
-        }
-    }
-#endif
-
-#if (SIM_COUNT >= 4)
-    if (strcmp(socketName, RIL4_SERVICE_NAME) == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_4, uimFuncs);
-        }
-    }
-#endif
-}
-
-void RilSapSocket::addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,
-        RIL_RadioFunctions *uimFuncs) {
-    RilSapSocket* socket = NULL;
-    RilSapSocketList *current;
-
-    if(!SocketExists(socketName)) {
-        socket = new RilSapSocket(socketName, socketid, uimFuncs);
-        RilSapSocketList* listItem = (RilSapSocketList*)malloc(sizeof(RilSapSocketList));
-        if (!listItem) {
-            RLOGE("addSocketToList: OOM");
-            delete socket;
-            return;
-        }
-        listItem->socket = socket;
-        listItem->next = NULL;
-
-        RLOGD("Adding socket with id: %d", socket->id);
-
-        if(NULL == head) {
-            head = listItem;
-            head->next = NULL;
-        }
-        else {
-            current = head;
-            while(NULL != current->next) {
-                current = current->next;
-            }
-            current->next = listItem;
-        }
-    }
-}
-
-bool RilSapSocket::SocketExists(const char *socketName) {
-    RilSapSocketList* current = head;
-
-    while(NULL != current) {
-        if(strcmp(current->socket->name, socketName) == 0) {
-            return true;
-        }
-        current = current->next;
-    }
-    return false;
-}
-
-RilSapSocket::RilSapSocket(const char *socketName,
-        RIL_SOCKET_ID socketId,
-        RIL_RadioFunctions *inputUimFuncs):
-        RilSocket(socketName, socketId) {
-    if (inputUimFuncs) {
-        uimFuncs = inputUimFuncs;
-    }
-}
-
-void RilSapSocket::dispatchRequest(MsgHeader *req) {
-    // SapSocketRequest will be deallocated in onRequestComplete()
-    SapSocketRequest* currRequest=(SapSocketRequest*)malloc(sizeof(SapSocketRequest));
-    if (!currRequest) {
-        RLOGE("dispatchRequest: OOM");
-        // Free MsgHeader allocated in pushRecord()
-        free(req);
-        return;
-    }
-    currRequest->token = req->token;
-    currRequest->curr = req;
-    currRequest->p_next = NULL;
-    currRequest->socketId = id;
-
-    pendingResponseQueue.enqueue(currRequest);
-
-    if (uimFuncs) {
-        RLOGI("RilSapSocket::dispatchRequest [%d] > SAP REQUEST type: %d. id: %d. error: %d, \
-                token 0x%p",
-                req->token,
-                req->type,
-                req->id,
-                req->error,
-                currRequest );
-
-#if defined(ANDROID_MULTI_SIM)
-        uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest, id);
-#else
-        uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest);
-#endif
-    }
-}
-
-void RilSapSocket::onRequestComplete(RIL_Token t, RIL_Errno e, void *response,
-        size_t response_len) {
-    SapSocketRequest* request= (SapSocketRequest*)t;
-    MsgHeader *hdr = request->curr;
-
-    MsgHeader rsp;
-    rsp.token = request->curr->token;
-    rsp.type = MsgType_RESPONSE;
-    rsp.id = request->curr->id;
-    rsp.error = (Error)e;
-    rsp.payload = (pb_bytes_array_t *)calloc(1, sizeof(pb_bytes_array_t) + response_len);
-    if (!rsp.payload) {
-        RLOGE("onRequestComplete: OOM");
-    } else {
-        if (response && response_len > 0) {
-            memcpy(rsp.payload->bytes, response, response_len);
-            rsp.payload->size = response_len;
-        } else {
-            rsp.payload->size = 0;
-        }
-
-        RLOGE("RilSapSocket::onRequestComplete: Token:%d, MessageId:%d ril token 0x%p",
-                hdr->token, hdr->id, t);
-
-        sap::processResponse(&rsp, this);
-        free(rsp.payload);
-    }
-
-    // Deallocate SapSocketRequest
-    if(!pendingResponseQueue.checkAndDequeue(hdr->id, hdr->token)) {
-        RLOGE("Token:%d, MessageId:%d", hdr->token, hdr->id);
-        RLOGE ("RilSapSocket::onRequestComplete: invalid Token or Message Id");
-    }
-
-    // Deallocate MsgHeader
-    free(hdr);
-}
-
-void RilSapSocket::onUnsolicitedResponse(int unsolResponse, void *data, size_t datalen) {
-    if (data && datalen > 0) {
-        pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,
-                sizeof(pb_bytes_array_t) + datalen);
-        if (!payload) {
-            RLOGE("onUnsolicitedResponse: OOM");
-            return;
-        }
-        memcpy(payload->bytes, data, datalen);
-        payload->size = datalen;
-        MsgHeader rsp;
-        rsp.payload = payload;
-        rsp.type = MsgType_UNSOL_RESPONSE;
-        rsp.id = (MsgId)unsolResponse;
-        rsp.error = Error_RIL_E_SUCCESS;
-        sap::processUnsolResponse(&rsp, this);
-        free(payload);
-    }
-}
\ No newline at end of file
diff --git a/libril/RilSapSocket.h b/libril/RilSapSocket.h
deleted file mode 100644
index 8c8c4bc..0000000
--- a/libril/RilSapSocket.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef RIL_UIM_SOCKET_H_INCLUDED
-#define RIL_UIM_SOCKET_H_INCLUDED
-#define RIL_SHLIB
-#include "telephony/ril.h"
-#include "RilSocket.h"
-#include <hardware/ril/librilutils/proto/sap-api.pb.h>
-
-/**
- * RilSapSocket is a derived class, derived from the RilSocket abstract
- * class, representing sockets for communication between bluetooth SAP module and
- * the ril daemon.
- * <p>
- * This class performs the following functions :
- * <ul>
- *     <li>Initialize the socket.
- *     <li>Process the requests coming on the socket.
- *     <li>Provide handlers for Unsolicited and request responses.
- *     <li>Request and pending response queue handling.
- * </ul>
- */
-class RilSapSocket : public RilSocket {
-    /**
-     * Place holder for the radio functions returned by the initialization
-     * function. Currenty only onRequest handler is being used.
-     */
-    RIL_RadioFunctions* uimFuncs;
-
-    /**
-     * Wrapper struct for handling the requests in the queue.
-     */
-    typedef struct SapSocketRequest {
-        int token;
-        MsgHeader* curr;
-        struct SapSocketRequest* p_next;
-        RIL_SOCKET_ID socketId;
-    } SapSocketRequest;
-
-    /**
-     * Queue for requests that are pending dispatch.
-     */
-    Ril_queue<SapSocketRequest> dispatchQueue;
-
-    /**
-     * Queue for requests that are dispatched but are pending response
-     */
-    Ril_queue<SapSocketRequest> pendingResponseQueue;
-
-    public:
-        /**
-         * Initialize the socket and add the socket to the list.
-         *
-         * @param Name of the socket.
-         * @param Radio functions to be used by the socket.
-         */
-        static void initSapSocket(const char *socketName,
-        RIL_RadioFunctions *uimFuncs);
-
-        /**
-         * Ril envoronment variable that holds the request and
-         * unsol response handlers.
-         */
-        static struct RIL_Env uimRilEnv;
-
-        /**
-         * Function to print the socket list.
-         */
-        static void printList();
-
-        /**
-         * Dispatches the request to the lower layers.
-         * It calls the on request function.
-         *
-         * @param request The request message.
-         */
-        void dispatchRequest(MsgHeader *request);
-
-        /**
-         * Class method to get the socket from the socket list.
-         *
-         * @param socketId Socket id.
-         * @return the sap socket.
-         */
-        static RilSapSocket* getSocketById(RIL_SOCKET_ID socketId);
-
-        /**
-         * Datatype to handle the socket list.
-         */
-        typedef struct RilSapSocketList {
-            RilSapSocket* socket;
-            RilSapSocketList *next;
-        } RilSapSocketList;
-
-    protected:
-        /**
-         * Socket handler to be called when a request has
-         * been completed.
-         *
-         * @param Token associated with the request.
-         * @param Error, if any, while processing the request.
-         * @param The response payload.
-         * @param Response payload length.
-         */
-        void onRequestComplete(RIL_Token t,RIL_Errno e,
-        void *response, size_t response_len);
-
-        /**
-         * Socket handler to be called when there is an
-         * unsolicited response.
-         *
-         * @param Message id.
-         * @param Response data.
-         * @param Response data length.
-         */
-        void onUnsolicitedResponse(int unsolResponse,
-        void *data, size_t datalen);
-
-        /**
-         * Class method to add the sap socket to the list of sockets.
-         * Does nothing if the socket is already present in the list.
-         * Otherwise, calls the constructor of the parent class(To startlistening)
-         * and add socket to the socket list.
-         */
-        static void addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,
-        RIL_RadioFunctions *uimFuncs);
-
-        /**
-         * Check if a socket of the given name exists in the socket list.
-         *
-         * @param Socket name.
-         * @return true if exists, false otherwise.
-         */
-        static bool SocketExists(const char *socketName);
-
-    private:
-        /**
-         * Constructor.
-         *
-         * @param Socket name.
-         * @param Socket id.
-         * @param Radio functions.
-         */
-        RilSapSocket(const char *socketName,
-        RIL_SOCKET_ID socketId,
-        RIL_RadioFunctions *inputUimFuncs);
-
-        /**
-         * Class method that selects the socket on which the onRequestComplete
-         * is called.
-         *
-         * @param Token associated with the request.
-         * @param Error, if any, while processing the request.
-         * @param The response payload.
-         * @param Response payload length.
-         */
-        static void sOnRequestComplete(RIL_Token t,
-        RIL_Errno e, void *response, size_t responselen);
-
-#if defined(ANDROID_MULTI_SIM)
-        /**
-         * Class method that selects the socket on which the onUnsolicitedResponse
-         * is called.
-         *
-         * @param Message id.
-         * @param Response data.
-         * @param Response data length.
-         * @param Socket id.
-         */
-        static void sOnUnsolicitedResponse(int unsolResponse, const void *data,
-        size_t datalen, RIL_SOCKET_ID socket_id);
-#else
-        /**
-         * Class method that selects the socket on which the onUnsolicitedResponse
-         * is called.
-         *
-         * @param Message id.
-         * @param Response data.
-         * @param Response data length.
-         */
-        static void sOnUnsolicitedResponse(int unsolResponse, const void *data,
-        size_t datalen);
-#endif
-};
-
-#endif /*RIL_UIM_SOCKET_H_INCLUDED*/
diff --git a/libril/RilSocket.h b/libril/RilSocket.h
deleted file mode 100644
index 53b00c9..0000000
--- a/libril/RilSocket.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef RIL_SOCKET_H_INCLUDED
-#define RIL_SOCKET_H_INCLUDED
-#include <libril/ril_ex.h>
-#include "rilSocketQueue.h"
-#include <ril_event.h>
-
-/**
- * Abstract socket class representing sockets in rild.
- * <p>
- * This class performs the following functions :
- * <ul>
- *     <li> Start socket listen.
- *     <li> Handle socket listen and command callbacks.
- * </ul>
- */
-class RilSocket {
-    protected:
-
-        /**
-         * Socket name.
-         */
-        const char* name;
-
-        /**
-         * Socket id.
-         */
-        RIL_SOCKET_ID id;
-
-    public:
-
-        /**
-         * Constructor.
-         *
-         * @param Socket name.
-         * @param Socket id.
-         */
-        RilSocket(const char* socketName, RIL_SOCKET_ID socketId) {
-            name = socketName;
-            id = socketId;
-        }
-
-        /**
-         * Get socket id.
-         *
-         * @return RIL_SOCKET_ID socket id.
-         */
-        RIL_SOCKET_ID getSocketId(void) {
-            return id;
-        }
-
-        virtual ~RilSocket(){}
-};
-
-#endif
diff --git a/libril/ril.cpp b/libril/ril.cpp
deleted file mode 100644
index f9b4b61..0000000
--- a/libril/ril.cpp
+++ /dev/null
@@ -1,1268 +0,0 @@
-/* //device/libs/telephony/ril.cpp
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#define LOG_TAG "RILC"
-
-#include <hardware_legacy/power.h>
-#include <telephony/ril.h>
-#include <telephony/ril_cdma_sms.h>
-#include <cutils/sockets.h>
-#include <cutils/jstring.h>
-#include <telephony/record_stream.h>
-#include <utils/Log.h>
-#include <utils/SystemClock.h>
-#include <pthread.h>
-#include <cutils/jstring.h>
-#include <sys/types.h>
-#include <sys/limits.h>
-#include <sys/system_properties.h>
-#include <pwd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <time.h>
-#include <errno.h>
-#include <assert.h>
-#include <ctype.h>
-#include <sys/un.h>
-#include <assert.h>
-#include <netinet/in.h>
-#include <cutils/properties.h>
-#include <RilSapSocket.h>
-#include <ril_service.h>
-#include <sap_service.h>
-
-extern "C" void
-RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen);
-
-extern "C" void
-RIL_onRequestAck(RIL_Token t);
-namespace android {
-
-#define PHONE_PROCESS "radio"
-#define BLUETOOTH_PROCESS "bluetooth"
-
-#define ANDROID_WAKE_LOCK_NAME "radio-interface"
-
-#define ANDROID_WAKE_LOCK_SECS 0
-#define ANDROID_WAKE_LOCK_USECS 200000
-
-#define PROPERTY_RIL_IMPL "gsm.version.ril-impl"
-
-// match with constant in RIL.java
-#define MAX_COMMAND_BYTES (8 * 1024)
-
-// Basically: memset buffers that the client library
-// shouldn't be using anymore in an attempt to find
-// memory usage issues sooner.
-#define MEMSET_FREED 1
-
-#define NUM_ELEMS(a)     (sizeof (a) / sizeof (a)[0])
-
-/* Negative values for private RIL errno's */
-#define RIL_ERRNO_INVALID_RESPONSE (-1)
-#define RIL_ERRNO_NO_MEMORY (-12)
-
-// request, response, and unsolicited msg print macro
-#define PRINTBUF_SIZE 8096
-
-enum WakeType {DONT_WAKE, WAKE_PARTIAL};
-
-typedef struct {
-    int requestNumber;
-    int (*responseFunction) (int slotId, int responseType, int token,
-            RIL_Errno e, void *response, size_t responselen);
-    WakeType wakeType;
-} UnsolResponseInfo;
-
-typedef struct UserCallbackInfo {
-    RIL_TimedCallback p_callback;
-    void *userParam;
-    struct ril_event event;
-    struct UserCallbackInfo *p_next;
-} UserCallbackInfo;
-
-extern "C" const char * failCauseToString(RIL_Errno);
-extern "C" const char * callStateToString(RIL_CallState);
-extern "C" const char * radioStateToString(RIL_RadioState);
-extern "C" const char * rilSocketIdToString(RIL_SOCKET_ID socket_id);
-
-extern "C"
-char ril_service_name_base[MAX_SERVICE_NAME_LENGTH] = RIL_SERVICE_NAME_BASE;
-extern "C"
-char ril_service_name[MAX_SERVICE_NAME_LENGTH] = RIL1_SERVICE_NAME;
-/*******************************************************************/
-
-RIL_RadioFunctions s_callbacks = {0, NULL, NULL, NULL, NULL, NULL};
-static int s_registerCalled = 0;
-
-static pthread_t s_tid_dispatch;
-static int s_started = 0;
-
-static int s_fdWakeupRead;
-static int s_fdWakeupWrite;
-
-int s_wakelock_count = 0;
-
-static struct ril_event s_wakeupfd_event;
-
-static pthread_mutex_t s_pendingRequestsMutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t s_wakeLockCountMutex = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests = NULL;
-
-#if (SIM_COUNT >= 2)
-static pthread_mutex_t s_pendingRequestsMutex_socket2  = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests_socket2          = NULL;
-#endif
-
-#if (SIM_COUNT >= 3)
-static pthread_mutex_t s_pendingRequestsMutex_socket3  = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests_socket3          = NULL;
-#endif
-
-#if (SIM_COUNT >= 4)
-static pthread_mutex_t s_pendingRequestsMutex_socket4  = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests_socket4          = NULL;
-#endif
-
-static const struct timeval TIMEVAL_WAKE_TIMEOUT = {ANDROID_WAKE_LOCK_SECS,ANDROID_WAKE_LOCK_USECS};
-
-
-static pthread_mutex_t s_startupMutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t s_startupCond = PTHREAD_COND_INITIALIZER;
-
-static UserCallbackInfo *s_last_wake_timeout_info = NULL;
-
-static void *s_lastNITZTimeData = NULL;
-static size_t s_lastNITZTimeDataSize;
-
-#if RILC_LOG
-    static char printBuf[PRINTBUF_SIZE];
-#endif
-
-/*******************************************************************/
-static void grabPartialWakeLock();
-void releaseWakeLock();
-static void wakeTimeoutCallback(void *);
-
-#ifdef RIL_SHLIB
-#if defined(ANDROID_MULTI_SIM)
-extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen, RIL_SOCKET_ID socket_id);
-#else
-extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen);
-#endif
-#endif
-
-#if defined(ANDROID_MULTI_SIM)
-#define RIL_UNSOL_RESPONSE(a, b, c, d) RIL_onUnsolicitedResponse((a), (b), (c), (d))
-#else
-#define RIL_UNSOL_RESPONSE(a, b, c, d) RIL_onUnsolicitedResponse((a), (b), (c))
-#endif
-
-static UserCallbackInfo * internalRequestTimedCallback
-    (RIL_TimedCallback callback, void *param,
-        const struct timeval *relativeTime);
-
-/** Index == requestNumber */
-static CommandInfo s_commands[] = {
-#include "ril_commands.h"
-};
-
-static UnsolResponseInfo s_unsolResponses[] = {
-#include "ril_unsol_commands.h"
-};
-
-static CommandInfo s_commands_v[] = {
-#include "ril_commands_vendor.h"
-};
-
-static UnsolResponseInfo s_unsolResponses_v[] = {
-#include "ril_unsol_commands_vendor.h"
-};
-
-char * RIL_getServiceName() {
-    return ril_service_name;
-}
-
-extern "C"
-void RIL_setServiceName(const char * s) {
-    strncpy(ril_service_name, s, MAX_SERVICE_NAME_LENGTH);
-}
-
-RequestInfo *
-addRequestToList(int serial, int slotId, int request) {
-    RequestInfo *pRI;
-    int ret;
-    RIL_SOCKET_ID socket_id = (RIL_SOCKET_ID) slotId;
-    /* Hook for current context */
-    /* pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
-    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
-    /* pendingRequestsHook refer to &s_pendingRequests */
-    RequestInfo**    pendingRequestsHook = &s_pendingRequests;
-
-#if (SIM_COUNT >= 2)
-    if (socket_id == RIL_SOCKET_2) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
-        pendingRequestsHook = &s_pendingRequests_socket2;
-    }
-#if (SIM_COUNT >= 3)
-    else if (socket_id == RIL_SOCKET_3) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
-        pendingRequestsHook = &s_pendingRequests_socket3;
-    }
-#endif
-#if (SIM_COUNT >= 4)
-    else if (socket_id == RIL_SOCKET_4) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
-        pendingRequestsHook = &s_pendingRequests_socket4;
-    }
-#endif
-#endif
-
-    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
-    if (pRI == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(request));
-        return NULL;
-    }
-
-    pRI->token = serial;
-    pRI->socket_id = socket_id;
-
-    /* Hack to include Samsung requests */
-    if (request > SAMSUNG_REQUEST_BASE) {
-        pRI->pCI = &(s_commands_v[request - SAMSUNG_REQUEST_BASE]);
-    } else {
-        pRI->pCI = &(s_commands[request]);
-    }
-
-    ret = pthread_mutex_lock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-    pRI->p_next = *pendingRequestsHook;
-    *pendingRequestsHook = pRI;
-
-    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-    return pRI;
-}
-
-static void triggerEvLoop() {
-    int ret;
-    if (!pthread_equal(pthread_self(), s_tid_dispatch)) {
-        /* trigger event loop to wakeup. No reason to do this,
-         * if we're in the event loop thread */
-         do {
-            ret = write (s_fdWakeupWrite, " ", 1);
-         } while (ret < 0 && errno == EINTR);
-    }
-}
-
-static void rilEventAddWakeup(struct ril_event *ev) {
-    ril_event_add(ev);
-    triggerEvLoop();
-}
-
-/**
- * A write on the wakeup fd is done just to pop us out of select()
- * We empty the buffer here and then ril_event will reset the timers on the
- * way back down
- */
-static void processWakeupCallback(int fd, short flags, void *param) {
-    char buff[16];
-    int ret;
-
-    RLOGV("processWakeupCallback");
-
-    /* empty our wakeup socket out */
-    do {
-        ret = read(s_fdWakeupRead, &buff, sizeof(buff));
-    } while (ret > 0 || (ret < 0 && errno == EINTR));
-}
-
-static void resendLastNITZTimeData(RIL_SOCKET_ID socket_id) {
-    if (s_lastNITZTimeData != NULL) {
-        int responseType = (s_callbacks.version >= 13)
-                           ? RESPONSE_UNSOLICITED_ACK_EXP
-                           : RESPONSE_UNSOLICITED;
-        int ret = radio::nitzTimeReceivedInd(
-            (int)socket_id, responseType, 0,
-            RIL_E_SUCCESS, s_lastNITZTimeData, s_lastNITZTimeDataSize);
-        if (ret == 0) {
-            free(s_lastNITZTimeData);
-            s_lastNITZTimeData = NULL;
-        }
-    }
-}
-
-void onNewCommandConnect(RIL_SOCKET_ID socket_id) {
-    // Inform we are connected and the ril version
-    int rilVer = s_callbacks.version;
-    RIL_UNSOL_RESPONSE(RIL_UNSOL_RIL_CONNECTED,
-                                    &rilVer, sizeof(rilVer), socket_id);
-
-    // implicit radio state changed
-    RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
-                                    NULL, 0, socket_id);
-
-    // Send last NITZ time data, in case it was missed
-    if (s_lastNITZTimeData != NULL) {
-        resendLastNITZTimeData(socket_id);
-    }
-
-    // Get version string
-    if (s_callbacks.getVersion != NULL) {
-        const char *version;
-        version = s_callbacks.getVersion();
-        RLOGI("RIL Daemon version: %s\n", version);
-
-        property_set(PROPERTY_RIL_IMPL, version);
-    } else {
-        RLOGI("RIL Daemon version: unavailable\n");
-        property_set(PROPERTY_RIL_IMPL, "unavailable");
-    }
-
-}
-
-static void userTimerCallback (int fd, short flags, void *param) {
-    UserCallbackInfo *p_info;
-
-    p_info = (UserCallbackInfo *)param;
-
-    p_info->p_callback(p_info->userParam);
-
-
-    // FIXME generalize this...there should be a cancel mechanism
-    if (s_last_wake_timeout_info != NULL && s_last_wake_timeout_info == p_info) {
-        s_last_wake_timeout_info = NULL;
-    }
-
-    free(p_info);
-}
-
-
-static void *
-eventLoop(void *param) {
-    int ret;
-    int filedes[2];
-
-    ril_event_init();
-
-    pthread_mutex_lock(&s_startupMutex);
-
-    s_started = 1;
-    pthread_cond_broadcast(&s_startupCond);
-
-    pthread_mutex_unlock(&s_startupMutex);
-
-    ret = pipe(filedes);
-
-    if (ret < 0) {
-        RLOGE("Error in pipe() errno:%d", errno);
-        return NULL;
-    }
-
-    s_fdWakeupRead = filedes[0];
-    s_fdWakeupWrite = filedes[1];
-
-    fcntl(s_fdWakeupRead, F_SETFL, O_NONBLOCK);
-
-    ril_event_set (&s_wakeupfd_event, s_fdWakeupRead, true,
-                processWakeupCallback, NULL);
-
-    rilEventAddWakeup (&s_wakeupfd_event);
-
-    // Only returns on error
-    ril_event_loop();
-    RLOGE ("error in event_loop_base errno:%d", errno);
-    // kill self to restart on error
-    kill(0, SIGKILL);
-
-    return NULL;
-}
-
-extern "C" void
-RIL_startEventLoop(void) {
-    /* spin up eventLoop thread and wait for it to get started */
-    s_started = 0;
-    pthread_mutex_lock(&s_startupMutex);
-
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    int result = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);
-    if (result != 0) {
-        RLOGE("Failed to create dispatch thread: %s", strerror(result));
-        goto done;
-    }
-
-    while (s_started == 0) {
-        pthread_cond_wait(&s_startupCond, &s_startupMutex);
-    }
-
-done:
-    pthread_mutex_unlock(&s_startupMutex);
-}
-
-// Used for testing purpose only.
-extern "C" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
-    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
-}
-
-extern "C" void
-RIL_register (const RIL_RadioFunctions *callbacks) {
-    RLOGI("SIM_COUNT: %d", SIM_COUNT);
-
-    if (callbacks == NULL) {
-        RLOGE("RIL_register: RIL_RadioFunctions * null");
-        return;
-    }
-    if (callbacks->version < RIL_VERSION_MIN) {
-        RLOGE("RIL_register: version %d is to old, min version is %d",
-             callbacks->version, RIL_VERSION_MIN);
-        return;
-    }
-
-    RLOGE("RIL_register: RIL version %d", callbacks->version);
-
-    if (s_registerCalled > 0) {
-        RLOGE("RIL_register has been called more than once. "
-                "Subsequent call ignored");
-        return;
-    }
-
-    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
-
-    s_registerCalled = 1;
-
-    RLOGI("s_registerCalled flag set, %d", s_started);
-    // Little self-check
-
-    for (int i = 0; i < (int)NUM_ELEMS(s_commands); i++) {
-        assert(i == s_commands[i].requestNumber);
-    }
-
-    for (int i = 0; i < (int)NUM_ELEMS(s_commands_v); i++) {
-        assert(i + SAMSUNG_REQUEST_BASE
-                == s_commands_v[i].requestNumber);
-    }
-
-    for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses); i++) {
-        assert(i + RIL_UNSOL_RESPONSE_BASE
-                == s_unsolResponses[i].requestNumber);
-    }
-
-    for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses_v); i++) {
-        assert(i + SAMSUNG_UNSOL_BASE
-                == s_unsolResponses_v[i].requestNumber);
-    }
-
-    radio::registerService(&s_callbacks, s_commands);
-    RLOGI("RILHIDL called registerService");
-
-}
-
-extern "C" void
-RIL_register_socket (RIL_RadioFunctions *(*Init)(const struct RIL_Env *, int, char **),
-        RIL_SOCKET_TYPE socketType, int argc, char **argv) {
-
-    RIL_RadioFunctions* UimFuncs = NULL;
-
-    if(Init) {
-        UimFuncs = Init(&RilSapSocket::uimRilEnv, argc, argv);
-
-        switch(socketType) {
-            case RIL_SAP_SOCKET:
-                RilSapSocket::initSapSocket(RIL1_SERVICE_NAME, UimFuncs);
-
-#if (SIM_COUNT >= 2)
-                RilSapSocket::initSapSocket(RIL2_SERVICE_NAME, UimFuncs);
-#endif
-
-#if (SIM_COUNT >= 3)
-                RilSapSocket::initSapSocket(RIL3_SERVICE_NAME, UimFuncs);
-#endif
-
-#if (SIM_COUNT >= 4)
-                RilSapSocket::initSapSocket(RIL4_SERVICE_NAME, UimFuncs);
-#endif
-                break;
-            default:;
-        }
-
-        RLOGI("RIL_register_socket: calling registerService");
-        sap::registerService(UimFuncs);
-    }
-}
-
-// Check and remove RequestInfo if its a response and not just ack sent back
-static int
-checkAndDequeueRequestInfoIfAck(struct RequestInfo *pRI, bool isAck) {
-    int ret = 0;
-    /* Hook for current context
-       pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
-    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
-    /* pendingRequestsHook refer to &s_pendingRequests */
-    RequestInfo ** pendingRequestsHook = &s_pendingRequests;
-
-    if (pRI == NULL) {
-        return 0;
-    }
-
-#if (SIM_COUNT >= 2)
-    if (pRI->socket_id == RIL_SOCKET_2) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
-        pendingRequestsHook = &s_pendingRequests_socket2;
-    }
-#if (SIM_COUNT >= 3)
-        if (pRI->socket_id == RIL_SOCKET_3) {
-            pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
-            pendingRequestsHook = &s_pendingRequests_socket3;
-        }
-#endif
-#if (SIM_COUNT >= 4)
-    if (pRI->socket_id == RIL_SOCKET_4) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
-        pendingRequestsHook = &s_pendingRequests_socket4;
-    }
-#endif
-#endif
-    pthread_mutex_lock(pendingRequestsMutexHook);
-
-    for(RequestInfo **ppCur = pendingRequestsHook
-        ; *ppCur != NULL
-        ; ppCur = &((*ppCur)->p_next)
-    ) {
-        if (pRI == *ppCur) {
-            ret = 1;
-            if (isAck) { // Async ack
-                if (pRI->wasAckSent == 1) {
-                    RLOGD("Ack was already sent for %s", requestToString(pRI->pCI->requestNumber));
-                } else {
-                    pRI->wasAckSent = 1;
-                }
-            } else {
-                *ppCur = (*ppCur)->p_next;
-            }
-            break;
-        }
-    }
-
-    pthread_mutex_unlock(pendingRequestsMutexHook);
-
-    return ret;
-}
-
-extern "C" void
-RIL_onRequestAck(RIL_Token t) {
-    RequestInfo *pRI;
-
-    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
-
-    pRI = (RequestInfo *)t;
-
-    if (!checkAndDequeueRequestInfoIfAck(pRI, true)) {
-        RLOGE ("RIL_onRequestAck: invalid RIL_Token");
-        return;
-    }
-
-    socket_id = pRI->socket_id;
-
-#if VDBG
-    RLOGD("Request Ack, %s", rilSocketIdToString(socket_id));
-#endif
-
-    appendPrintBuf("Ack [%04d]< %s", pRI->token, requestToString(pRI->pCI->requestNumber));
-
-    if (pRI->cancelled == 0) {
-        pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(
-                (int) socket_id);
-        int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-
-        radio::acknowledgeRequest((int) socket_id, pRI->token);
-
-        rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-    }
-}
-extern "C" void
-RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen) {
-    RequestInfo *pRI;
-    int ret;
-    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
-
-    pRI = (RequestInfo *)t;
-
-    if (!checkAndDequeueRequestInfoIfAck(pRI, false)) {
-        RLOGE ("RIL_onRequestComplete: invalid RIL_Token");
-        return;
-    }
-
-    socket_id = pRI->socket_id;
-#if VDBG
-    RLOGD("RequestComplete, %s", rilSocketIdToString(socket_id));
-#endif
-
-    if (pRI->local > 0) {
-        // Locally issued command...void only!
-        // response does not go back up the command socket
-        RLOGD("C[locl]< %s", requestToString(pRI->pCI->requestNumber));
-
-        free(pRI);
-        return;
-    }
-
-    appendPrintBuf("[%04d]< %s",
-        pRI->token, requestToString(pRI->pCI->requestNumber));
-
-    if (pRI->cancelled == 0) {
-        int responseType;
-        if (s_callbacks.version >= 13 && pRI->wasAckSent == 1) {
-            // If ack was already sent, then this call is an asynchronous response. So we need to
-            // send id indicating that we expect an ack from RIL.java as we acquire wakelock here.
-            responseType = RESPONSE_SOLICITED_ACK_EXP;
-            grabPartialWakeLock();
-        } else {
-            responseType = RESPONSE_SOLICITED;
-        }
-
-        // there is a response payload, no matter success or not.
-#if VDBG
-        RLOGE ("Calling responseFunction() for token %d", pRI->token);
-#endif
-
-        pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock((int) socket_id);
-        int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-
-        ret = pRI->pCI->responseFunction((int) socket_id,
-                responseType, pRI->token, e, response, responselen);
-
-        rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-    }
-    free(pRI);
-}
-
-static void
-grabPartialWakeLock() {
-    if (s_callbacks.version >= 13) {
-        int ret;
-        ret = pthread_mutex_lock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-        acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
-
-        UserCallbackInfo *p_info =
-                internalRequestTimedCallback(wakeTimeoutCallback, NULL, &TIMEVAL_WAKE_TIMEOUT);
-        if (p_info == NULL) {
-            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-        } else {
-            s_wakelock_count++;
-            if (s_last_wake_timeout_info != NULL) {
-                s_last_wake_timeout_info->userParam = (void *)1;
-            }
-            s_last_wake_timeout_info = p_info;
-        }
-        ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-    } else {
-        acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
-    }
-}
-
-void
-releaseWakeLock() {
-    if (s_callbacks.version >= 13) {
-        int ret;
-        ret = pthread_mutex_lock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-
-        if (s_wakelock_count > 1) {
-            s_wakelock_count--;
-        } else {
-            s_wakelock_count = 0;
-            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-            if (s_last_wake_timeout_info != NULL) {
-                s_last_wake_timeout_info->userParam = (void *)1;
-            }
-        }
-
-        ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-    } else {
-        release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-    }
-}
-
-/**
- * Timer callback to put us back to sleep before the default timeout
- */
-static void
-wakeTimeoutCallback (void *param) {
-    // We're using "param != NULL" as a cancellation mechanism
-    if (s_callbacks.version >= 13) {
-        if (param == NULL) {
-            int ret;
-            ret = pthread_mutex_lock(&s_wakeLockCountMutex);
-            assert(ret == 0);
-            s_wakelock_count = 0;
-            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-            ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
-            assert(ret == 0);
-        }
-    } else {
-        if (param == NULL) {
-            releaseWakeLock();
-        }
-    }
-}
-
-#if defined(ANDROID_MULTI_SIM)
-extern "C"
-void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen, RIL_SOCKET_ID socket_id)
-#else
-extern "C"
-void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen)
-#endif
-{
-    int unsolResponseIndex;
-    int ret;
-    bool shouldScheduleTimeout = false;
-    RIL_SOCKET_ID soc_id = RIL_SOCKET_1;
-    UnsolResponseInfo *pRI = NULL;
-    int32_t pRI_elements;
-
-#if defined(ANDROID_MULTI_SIM)
-    soc_id = socket_id;
-#endif
-
-
-    if (s_registerCalled == 0) {
-        // Ignore RIL_onUnsolicitedResponse before RIL_register
-        RLOGW("RIL_onUnsolicitedResponse called before RIL_register");
-        return;
-    }
-
-    unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
-    pRI = s_unsolResponses;
-
-    /* Hack to include Samsung responses */
-    if (unsolResponse > SAMSUNG_UNSOL_BASE) {
-        unsolResponseIndex = unsolResponse - SAMSUNG_UNSOL_BASE;
-        pRI = s_unsolResponses_v;
-    }
-
-    pRI_elements = pRI == s_unsolResponses
-            ? (int32_t)NUM_ELEMS(s_unsolResponses) : (int32_t)NUM_ELEMS(s_unsolResponses_v);
-
-    if (unsolResponseIndex >= 0 && unsolResponseIndex < pRI_elements) {
-        pRI = &pRI[unsolResponseIndex];
-    } else {
-        pRI = NULL;
-    }
-
-    if (pRI == NULL || pRI->responseFunction == NULL) {
-        RLOGE("unsupported unsolicited response code %d", unsolResponse);
-        return;
-    }
-
-    // Grab a wake lock if needed for this reponse,
-    // as we exit we'll either release it immediately
-    // or set a timer to release it later.
-    switch (pRI->wakeType) {
-        case WAKE_PARTIAL:
-            grabPartialWakeLock();
-            shouldScheduleTimeout = true;
-        break;
-
-        case DONT_WAKE:
-        default:
-            // No wake lock is grabed so don't set timeout
-            shouldScheduleTimeout = false;
-            break;
-    }
-
-    appendPrintBuf("[UNSL]< %s", requestToString(unsolResponse));
-
-    int responseType;
-    if (s_callbacks.version >= 13
-                && pRI->wakeType == WAKE_PARTIAL) {
-        responseType = RESPONSE_UNSOLICITED_ACK_EXP;
-    } else {
-        responseType = RESPONSE_UNSOLICITED;
-    }
-
-    pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock((int) soc_id);
-    int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-    assert(rwlockRet == 0);
-
-    ret = pRI->responseFunction(
-            (int) soc_id, responseType, 0, RIL_E_SUCCESS, const_cast<void*>(data),
-            datalen);
-
-    rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
-    assert(rwlockRet == 0);
-
-    if (s_callbacks.version < 13) {
-        if (shouldScheduleTimeout) {
-            UserCallbackInfo *p_info = internalRequestTimedCallback(wakeTimeoutCallback, NULL,
-                    &TIMEVAL_WAKE_TIMEOUT);
-
-            if (p_info == NULL) {
-                goto error_exit;
-            } else {
-                // Cancel the previous request
-                if (s_last_wake_timeout_info != NULL) {
-                    s_last_wake_timeout_info->userParam = (void *)1;
-                }
-                s_last_wake_timeout_info = p_info;
-            }
-        }
-    }
-
-#if VDBG
-    RLOGI("%s UNSOLICITED: %s length:%zu", rilSocketIdToString(soc_id),
-            requestToString(unsolResponse), datalen);
-#endif
-
-    if (ret != 0 && unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
-        // Unfortunately, NITZ time is not poll/update like everything
-        // else in the system. So, if the upstream client isn't connected,
-        // keep a copy of the last NITZ response (with receive time noted
-        // above) around so we can deliver it when it is connected
-
-        if (s_lastNITZTimeData != NULL) {
-            free(s_lastNITZTimeData);
-            s_lastNITZTimeData = NULL;
-        }
-
-        s_lastNITZTimeData = calloc(datalen, 1);
-        if (s_lastNITZTimeData == NULL) {
-            RLOGE("Memory allocation failed in RIL_onUnsolicitedResponse");
-            goto error_exit;
-        }
-        s_lastNITZTimeDataSize = datalen;
-        memcpy(s_lastNITZTimeData, data, datalen);
-    }
-
-    // Normal exit
-    return;
-
-error_exit:
-    if (shouldScheduleTimeout) {
-        releaseWakeLock();
-    }
-}
-
-/** FIXME generalize this if you track UserCAllbackInfo, clear it
-    when the callback occurs
-*/
-static UserCallbackInfo *
-internalRequestTimedCallback (RIL_TimedCallback callback, void *param,
-                                const struct timeval *relativeTime)
-{
-    struct timeval myRelativeTime;
-    UserCallbackInfo *p_info;
-
-    p_info = (UserCallbackInfo *) calloc(1, sizeof(UserCallbackInfo));
-    if (p_info == NULL) {
-        RLOGE("Memory allocation failed in internalRequestTimedCallback");
-        return p_info;
-
-    }
-
-    p_info->p_callback = callback;
-    p_info->userParam = param;
-
-    if (relativeTime == NULL) {
-        /* treat null parameter as a 0 relative time */
-        memset (&myRelativeTime, 0, sizeof(myRelativeTime));
-    } else {
-        /* FIXME I think event_add's tv param is really const anyway */
-        memcpy (&myRelativeTime, relativeTime, sizeof(myRelativeTime));
-    }
-
-    ril_event_set(&(p_info->event), -1, false, userTimerCallback, p_info);
-
-    ril_timer_add(&(p_info->event), &myRelativeTime);
-
-    triggerEvLoop();
-    return p_info;
-}
-
-
-extern "C" void
-RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
-                                const struct timeval *relativeTime) {
-    internalRequestTimedCallback (callback, param, relativeTime);
-}
-
-const char *
-failCauseToString(RIL_Errno e) {
-    switch(e) {
-        case RIL_E_SUCCESS: return "E_SUCCESS";
-        case RIL_E_RADIO_NOT_AVAILABLE: return "E_RADIO_NOT_AVAILABLE";
-        case RIL_E_GENERIC_FAILURE: return "E_GENERIC_FAILURE";
-        case RIL_E_PASSWORD_INCORRECT: return "E_PASSWORD_INCORRECT";
-        case RIL_E_SIM_PIN2: return "E_SIM_PIN2";
-        case RIL_E_SIM_PUK2: return "E_SIM_PUK2";
-        case RIL_E_REQUEST_NOT_SUPPORTED: return "E_REQUEST_NOT_SUPPORTED";
-        case RIL_E_CANCELLED: return "E_CANCELLED";
-        case RIL_E_OP_NOT_ALLOWED_DURING_VOICE_CALL: return "E_OP_NOT_ALLOWED_DURING_VOICE_CALL";
-        case RIL_E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW: return "E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW";
-        case RIL_E_SMS_SEND_FAIL_RETRY: return "E_SMS_SEND_FAIL_RETRY";
-        case RIL_E_SIM_ABSENT:return "E_SIM_ABSENT";
-        case RIL_E_ILLEGAL_SIM_OR_ME:return "E_ILLEGAL_SIM_OR_ME";
-#ifdef FEATURE_MULTIMODE_ANDROID
-        case RIL_E_SUBSCRIPTION_NOT_AVAILABLE:return "E_SUBSCRIPTION_NOT_AVAILABLE";
-        case RIL_E_MODE_NOT_SUPPORTED:return "E_MODE_NOT_SUPPORTED";
-#endif
-        case RIL_E_FDN_CHECK_FAILURE: return "E_FDN_CHECK_FAILURE";
-        case RIL_E_MISSING_RESOURCE: return "E_MISSING_RESOURCE";
-        case RIL_E_NO_SUCH_ELEMENT: return "E_NO_SUCH_ELEMENT";
-        case RIL_E_DIAL_MODIFIED_TO_USSD: return "E_DIAL_MODIFIED_TO_USSD";
-        case RIL_E_DIAL_MODIFIED_TO_SS: return "E_DIAL_MODIFIED_TO_SS";
-        case RIL_E_DIAL_MODIFIED_TO_DIAL: return "E_DIAL_MODIFIED_TO_DIAL";
-        case RIL_E_USSD_MODIFIED_TO_DIAL: return "E_USSD_MODIFIED_TO_DIAL";
-        case RIL_E_USSD_MODIFIED_TO_SS: return "E_USSD_MODIFIED_TO_SS";
-        case RIL_E_USSD_MODIFIED_TO_USSD: return "E_USSD_MODIFIED_TO_USSD";
-        case RIL_E_SS_MODIFIED_TO_DIAL: return "E_SS_MODIFIED_TO_DIAL";
-        case RIL_E_SS_MODIFIED_TO_USSD: return "E_SS_MODIFIED_TO_USSD";
-        case RIL_E_SUBSCRIPTION_NOT_SUPPORTED: return "E_SUBSCRIPTION_NOT_SUPPORTED";
-        case RIL_E_SS_MODIFIED_TO_SS: return "E_SS_MODIFIED_TO_SS";
-        case RIL_E_LCE_NOT_SUPPORTED: return "E_LCE_NOT_SUPPORTED";
-        case RIL_E_NO_MEMORY: return "E_NO_MEMORY";
-        case RIL_E_INTERNAL_ERR: return "E_INTERNAL_ERR";
-        case RIL_E_SYSTEM_ERR: return "E_SYSTEM_ERR";
-        case RIL_E_MODEM_ERR: return "E_MODEM_ERR";
-        case RIL_E_INVALID_STATE: return "E_INVALID_STATE";
-        case RIL_E_NO_RESOURCES: return "E_NO_RESOURCES";
-        case RIL_E_SIM_ERR: return "E_SIM_ERR";
-        case RIL_E_INVALID_ARGUMENTS: return "E_INVALID_ARGUMENTS";
-        case RIL_E_INVALID_SIM_STATE: return "E_INVALID_SIM_STATE";
-        case RIL_E_INVALID_MODEM_STATE: return "E_INVALID_MODEM_STATE";
-        case RIL_E_INVALID_CALL_ID: return "E_INVALID_CALL_ID";
-        case RIL_E_NO_SMS_TO_ACK: return "E_NO_SMS_TO_ACK";
-        case RIL_E_NETWORK_ERR: return "E_NETWORK_ERR";
-        case RIL_E_REQUEST_RATE_LIMITED: return "E_REQUEST_RATE_LIMITED";
-        case RIL_E_SIM_BUSY: return "E_SIM_BUSY";
-        case RIL_E_SIM_FULL: return "E_SIM_FULL";
-        case RIL_E_NETWORK_REJECT: return "E_NETWORK_REJECT";
-        case RIL_E_OPERATION_NOT_ALLOWED: return "E_OPERATION_NOT_ALLOWED";
-        case RIL_E_EMPTY_RECORD: return "E_EMPTY_RECORD";
-        case RIL_E_INVALID_SMS_FORMAT: return "E_INVALID_SMS_FORMAT";
-        case RIL_E_ENCODING_ERR: return "E_ENCODING_ERR";
-        case RIL_E_INVALID_SMSC_ADDRESS: return "E_INVALID_SMSC_ADDRESS";
-        case RIL_E_NO_SUCH_ENTRY: return "E_NO_SUCH_ENTRY";
-        case RIL_E_NETWORK_NOT_READY: return "E_NETWORK_NOT_READY";
-        case RIL_E_NOT_PROVISIONED: return "E_NOT_PROVISIONED";
-        case RIL_E_NO_SUBSCRIPTION: return "E_NO_SUBSCRIPTION";
-        case RIL_E_NO_NETWORK_FOUND: return "E_NO_NETWORK_FOUND";
-        case RIL_E_DEVICE_IN_USE: return "E_DEVICE_IN_USE";
-        case RIL_E_ABORTED: return "E_ABORTED";
-        case RIL_E_INVALID_RESPONSE: return "INVALID_RESPONSE";
-        case RIL_E_OEM_ERROR_1: return "E_OEM_ERROR_1";
-        case RIL_E_OEM_ERROR_2: return "E_OEM_ERROR_2";
-        case RIL_E_OEM_ERROR_3: return "E_OEM_ERROR_3";
-        case RIL_E_OEM_ERROR_4: return "E_OEM_ERROR_4";
-        case RIL_E_OEM_ERROR_5: return "E_OEM_ERROR_5";
-        case RIL_E_OEM_ERROR_6: return "E_OEM_ERROR_6";
-        case RIL_E_OEM_ERROR_7: return "E_OEM_ERROR_7";
-        case RIL_E_OEM_ERROR_8: return "E_OEM_ERROR_8";
-        case RIL_E_OEM_ERROR_9: return "E_OEM_ERROR_9";
-        case RIL_E_OEM_ERROR_10: return "E_OEM_ERROR_10";
-        case RIL_E_OEM_ERROR_11: return "E_OEM_ERROR_11";
-        case RIL_E_OEM_ERROR_12: return "E_OEM_ERROR_12";
-        case RIL_E_OEM_ERROR_13: return "E_OEM_ERROR_13";
-        case RIL_E_OEM_ERROR_14: return "E_OEM_ERROR_14";
-        case RIL_E_OEM_ERROR_15: return "E_OEM_ERROR_15";
-        case RIL_E_OEM_ERROR_16: return "E_OEM_ERROR_16";
-        case RIL_E_OEM_ERROR_17: return "E_OEM_ERROR_17";
-        case RIL_E_OEM_ERROR_18: return "E_OEM_ERROR_18";
-        case RIL_E_OEM_ERROR_19: return "E_OEM_ERROR_19";
-        case RIL_E_OEM_ERROR_20: return "E_OEM_ERROR_20";
-        case RIL_E_OEM_ERROR_21: return "E_OEM_ERROR_21";
-        case RIL_E_OEM_ERROR_22: return "E_OEM_ERROR_22";
-        case RIL_E_OEM_ERROR_23: return "E_OEM_ERROR_23";
-        case RIL_E_OEM_ERROR_24: return "E_OEM_ERROR_24";
-        case RIL_E_OEM_ERROR_25: return "E_OEM_ERROR_25";
-        default: return "<unknown error>";
-    }
-}
-
-const char *
-radioStateToString(RIL_RadioState s) {
-    switch(s) {
-        case RADIO_STATE_OFF: return "RADIO_OFF";
-        case RADIO_STATE_UNAVAILABLE: return "RADIO_UNAVAILABLE";
-        case RADIO_STATE_ON:return"RADIO_ON";
-        default: return "<unknown state>";
-    }
-}
-
-const char *
-callStateToString(RIL_CallState s) {
-    switch(s) {
-        case RIL_CALL_ACTIVE : return "ACTIVE";
-        case RIL_CALL_HOLDING: return "HOLDING";
-        case RIL_CALL_DIALING: return "DIALING";
-        case RIL_CALL_ALERTING: return "ALERTING";
-        case RIL_CALL_INCOMING: return "INCOMING";
-        case RIL_CALL_WAITING: return "WAITING";
-        default: return "<unknown state>";
-    }
-}
-
-const char *
-requestToString(int request) {
-/*
- cat libs/telephony/ril_commands.h \
- | egrep "^ *{RIL_" \
- | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
-
-
- cat libs/telephony/ril_unsol_commands.h \
- | egrep "^ *{RIL_" \
- | sed -re 's/\{RIL_([^,]+),([^}]+).+/case RIL_\1: return "\1";/'
-
-*/
-    switch(request) {
-        case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
-        case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
-        case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
-        case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
-        case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
-        case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
-        case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
-        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: return "ENTER_NETWORK_DEPERSONALIZATION";
-        case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
-        case RIL_REQUEST_DIAL: return "DIAL";
-        case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
-        case RIL_REQUEST_HANGUP: return "HANGUP";
-        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
-        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
-        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: return "SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
-        case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
-        case RIL_REQUEST_UDUB: return "UDUB";
-        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
-        case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
-        case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "VOICE_REGISTRATION_STATE";
-        case RIL_REQUEST_DATA_REGISTRATION_STATE: return "DATA_REGISTRATION_STATE";
-        case RIL_REQUEST_OPERATOR: return "OPERATOR";
-        case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
-        case RIL_REQUEST_DTMF: return "DTMF";
-        case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
-        case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
-        case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
-        case RIL_REQUEST_SIM_IO: return "SIM_IO";
-        case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
-        case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
-        case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
-        case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
-        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
-        case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
-        case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
-        case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
-        case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
-        case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
-        case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
-        case RIL_REQUEST_ANSWER: return "ANSWER";
-        case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
-        case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
-        case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
-        case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
-        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
-        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
-        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
-        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: return "QUERY_AVAILABLE_NETWORKS";
-        case RIL_REQUEST_DTMF_START: return "DTMF_START";
-        case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
-        case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
-        case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
-        case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
-        case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
-        case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
-        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
-        case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
-        case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
-        case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
-        case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
-        case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
-        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: return "SET_SUPP_SVC_NOTIFICATION";
-        case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
-        case RIL_REQUEST_DELETE_SMS_ON_SIM: return "DELETE_SMS_ON_SIM";
-        case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
-        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
-        case RIL_REQUEST_STK_GET_PROFILE: return "STK_GET_PROFILE";
-        case RIL_REQUEST_STK_SET_PROFILE: return "STK_SET_PROFILE";
-        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "STK_SEND_ENVELOPE_COMMAND";
-        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: return "STK_SEND_TERMINAL_RESPONSE";
-        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: return "STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
-        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "EXPLICIT_CALL_TRANSFER";
-        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: return "SET_PREFERRED_NETWORK_TYPE";
-        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: return "GET_PREFERRED_NETWORK_TYPE";
-        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "GET_NEIGHBORING_CELL_IDS";
-        case RIL_REQUEST_SET_LOCATION_UPDATES: return "SET_LOCATION_UPDATES";
-        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: return "CDMA_SET_SUBSCRIPTION_SOURCE";
-        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: return "CDMA_SET_ROAMING_PREFERENCE";
-        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: return "CDMA_QUERY_ROAMING_PREFERENCE";
-        case RIL_REQUEST_SET_TTY_MODE: return "SET_TTY_MODE";
-        case RIL_REQUEST_QUERY_TTY_MODE: return "QUERY_TTY_MODE";
-        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: return "CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
-        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: return "CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
-        case RIL_REQUEST_CDMA_FLASH: return "CDMA_FLASH";
-        case RIL_REQUEST_CDMA_BURST_DTMF: return "CDMA_BURST_DTMF";
-        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: return "CDMA_VALIDATE_AND_WRITE_AKEY";
-        case RIL_REQUEST_CDMA_SEND_SMS: return "CDMA_SEND_SMS";
-        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: return "CDMA_SMS_ACKNOWLEDGE";
-        case RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG: return "GSM_GET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG: return "GSM_SET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION: return "GSM_SMS_BROADCAST_ACTIVATION";
-        case RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG: return "CDMA_GET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG: return "CDMA_SET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION: return "CDMA_SMS_BROADCAST_ACTIVATION";
-        case RIL_REQUEST_CDMA_SUBSCRIPTION: return "CDMA_SUBSCRIPTION";
-        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "CDMA_WRITE_SMS_TO_RUIM";
-        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "CDMA_DELETE_SMS_ON_RUIM";
-        case RIL_REQUEST_DEVICE_IDENTITY: return "DEVICE_IDENTITY";
-        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: return "EXIT_EMERGENCY_CALLBACK_MODE";
-        case RIL_REQUEST_GET_SMSC_ADDRESS: return "GET_SMSC_ADDRESS";
-        case RIL_REQUEST_SET_SMSC_ADDRESS: return "SET_SMSC_ADDRESS";
-        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: return "REPORT_SMS_MEMORY_STATUS";
-        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: return "REPORT_STK_SERVICE_IS_RUNNING";
-        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: return "CDMA_GET_SUBSCRIPTION_SOURCE";
-        case RIL_REQUEST_ISIM_AUTHENTICATION: return "ISIM_AUTHENTICATION";
-        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: return "ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
-        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: return "STK_SEND_ENVELOPE_WITH_STATUS";
-        case RIL_REQUEST_VOICE_RADIO_TECH: return "VOICE_RADIO_TECH";
-        case RIL_REQUEST_GET_CELL_INFO_LIST: return "GET_CELL_INFO_LIST";
-        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: return "SET_UNSOL_CELL_INFO_LIST_RATE";
-        case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "SET_INITIAL_ATTACH_APN";
-        case RIL_REQUEST_IMS_REGISTRATION_STATE: return "IMS_REGISTRATION_STATE";
-        case RIL_REQUEST_IMS_SEND_SMS: return "IMS_SEND_SMS";
-        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "SIM_TRANSMIT_APDU_BASIC";
-        case RIL_REQUEST_SIM_OPEN_CHANNEL: return "SIM_OPEN_CHANNEL";
-        case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "SIM_CLOSE_CHANNEL";
-        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: return "SIM_TRANSMIT_APDU_CHANNEL";
-        case RIL_REQUEST_NV_READ_ITEM: return "NV_READ_ITEM";
-        case RIL_REQUEST_NV_WRITE_ITEM: return "NV_WRITE_ITEM";
-        case RIL_REQUEST_NV_WRITE_CDMA_PRL: return "NV_WRITE_CDMA_PRL";
-        case RIL_REQUEST_NV_RESET_CONFIG: return "NV_RESET_CONFIG";
-        case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "SET_UICC_SUBSCRIPTION";
-        case RIL_REQUEST_ALLOW_DATA: return "ALLOW_DATA";
-        case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
-        case RIL_REQUEST_SIM_AUTHENTICATION: return "SIM_AUTHENTICATION";
-        case RIL_REQUEST_GET_DC_RT_INFO: return "GET_DC_RT_INFO";
-        case RIL_REQUEST_SET_DC_RT_INFO_RATE: return "SET_DC_RT_INFO_RATE";
-        case RIL_REQUEST_SET_DATA_PROFILE: return "SET_DATA_PROFILE";
-        case RIL_REQUEST_SHUTDOWN: return "SHUTDOWN";
-        case RIL_REQUEST_GET_RADIO_CAPABILITY: return "GET_RADIO_CAPABILITY";
-        case RIL_REQUEST_SET_RADIO_CAPABILITY: return "SET_RADIO_CAPABILITY";
-        case RIL_REQUEST_START_LCE: return "START_LCE";
-        case RIL_REQUEST_STOP_LCE: return "STOP_LCE";
-        case RIL_REQUEST_PULL_LCEDATA: return "PULL_LCEDATA";
-        case RIL_REQUEST_GET_ACTIVITY_INFO: return "GET_ACTIVITY_INFO";
-        case RIL_REQUEST_SET_CARRIER_RESTRICTIONS: return "SET_CARRIER_RESTRICTIONS";
-        case RIL_REQUEST_GET_CARRIER_RESTRICTIONS: return "GET_CARRIER_RESTRICTIONS";
-        case RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION: return "SET_CARRIER_INFO_IMSI_ENCRYPTION";
-        case RIL_RESPONSE_ACKNOWLEDGEMENT: return "RESPONSE_ACKNOWLEDGEMENT";
-        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
-        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
-        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
-        case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
-        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
-        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
-        case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
-        case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST";
-        case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
-        case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
-        case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
-        case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
-        case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
-        case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
-        case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
-        case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
-        case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FULL";
-        case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
-        case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
-        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
-        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_RESPONSE_CDMA_NEW_SMS";
-        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
-        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
-        case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
-        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
-        case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
-        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
-        case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
-        case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
-        case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
-        case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
-        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED";
-        case RIL_UNSOL_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
-        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
-        case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
-        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
-        case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
-        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
-        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: return "UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
-        case RIL_UNSOL_SRVCC_STATE_NOTIFY: return "UNSOL_SRVCC_STATE_NOTIFY";
-        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "UNSOL_HARDWARE_CONFIG_CHANGED";
-        case RIL_UNSOL_DC_RT_INFO_CHANGED: return "UNSOL_DC_RT_INFO_CHANGED";
-        case RIL_UNSOL_RADIO_CAPABILITY: return "UNSOL_RADIO_CAPABILITY";
-        case RIL_UNSOL_MODEM_RESTART: return "UNSOL_MODEM_RESTART";
-        case RIL_UNSOL_CARRIER_INFO_IMSI_ENCRYPTION: return "UNSOL_CARRIER_INFO_IMSI_ENCRYPTION";
-        case RIL_UNSOL_ON_SS: return "UNSOL_ON_SS";
-        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
-        case RIL_UNSOL_LCEDATA_RECV: return "UNSOL_LCEDATA_RECV";
-        case RIL_UNSOL_PCO_DATA: return "UNSOL_PCO_DATA";
-        default: return "<unknown request>";
-    }
-}
-
-const char *
-rilSocketIdToString(RIL_SOCKET_ID socket_id)
-{
-    switch(socket_id) {
-        case RIL_SOCKET_1:
-            return "RIL_SOCKET_1";
-#if (SIM_COUNT >= 2)
-        case RIL_SOCKET_2:
-            return "RIL_SOCKET_2";
-#endif
-#if (SIM_COUNT >= 3)
-        case RIL_SOCKET_3:
-            return "RIL_SOCKET_3";
-#endif
-#if (SIM_COUNT >= 4)
-        case RIL_SOCKET_4:
-            return "RIL_SOCKET_4";
-#endif
-        default:
-            return "not a valid RIL";
-    }
-}
-
-} /* namespace android */
diff --git a/libril/rilSocketQueue.h b/libril/rilSocketQueue.h
deleted file mode 100644
index eaa5155..0000000
--- a/libril/rilSocketQueue.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#include "pb_decode.h"
-#include <pthread.h>
-#include <hardware/ril/librilutils/proto/sap-api.pb.h>
-#include <utils/Log.h>
-
-using namespace std;
-
-/**
- * Template queue class to handling requests for a rild socket.
- * <p>
- * This class performs the following functions :
- * <ul>
- *     <li>Enqueue.
- *     <li>Dequeue.
- *     <li>Check and dequeue.
- * </ul>
- */
-
-template <typename T>
-class Ril_queue {
-
-   /**
-     * Mutex attribute used in queue mutex initialization.
-     */
-    pthread_mutexattr_t attr;
-
-   /**
-     * Queue mutex variable for synchronized queue access.
-     */
-    pthread_mutex_t mutex_instance;
-
-   /**
-     * Condition to be waited on for dequeuing.
-     */
-    pthread_cond_t cond;
-
-   /**
-     * Front of the queue.
-     */
-    T *front;
-
-    public:
-
-       /**
-         * Remove the first element of the queue.
-         *
-         * @return first element of the queue.
-         */
-        T* dequeue(void);
-
-       /**
-         * Add a request to the front of the queue.
-         *
-         * @param Request to be added.
-         */
-        void enqueue(T* request);
-
-       /**
-         * Check if the queue is empty.
-         */
-        int empty(void);
-
-       /**
-         * Check and remove an element with a particular message id and token.
-         *
-         * @param Request message id.
-         * @param Request token.
-         */
-        int checkAndDequeue( MsgId id, int token);
-
-       /**
-         * Queue constructor.
-         */
-        Ril_queue(void);
-};
-
-template <typename T>
-Ril_queue<T>::Ril_queue(void) {
-    pthread_mutexattr_init(&attr);
-    pthread_mutex_init(&mutex_instance, &attr);
-    cond = PTHREAD_COND_INITIALIZER;
-    front = NULL;
-}
-
-template <typename T>
-T* Ril_queue<T>::dequeue(void) {
-    T* temp = NULL;
-
-    pthread_mutex_lock(&mutex_instance);
-    while(empty()) {
-        pthread_cond_wait(&cond, &mutex_instance);
-    }
-    temp = this->front;
-    if(NULL != this->front->p_next) {
-        this->front = this->front->p_next;
-    } else {
-        this->front = NULL;
-    }
-    pthread_mutex_unlock(&mutex_instance);
-
-    return temp;
-}
-
-template <typename T>
-void Ril_queue<T>::enqueue(T* request) {
-
-    pthread_mutex_lock(&mutex_instance);
-
-    if(NULL == this->front) {
-        this->front = request;
-        request->p_next = NULL;
-    } else {
-        request->p_next = this->front;
-        this->front = request;
-    }
-    pthread_cond_broadcast(&cond);
-    pthread_mutex_unlock(&mutex_instance);
-}
-
-template <typename T>
-int Ril_queue<T>::checkAndDequeue(MsgId id, int token) {
-    int ret = 0;
-    T* temp;
-
-    pthread_mutex_lock(&mutex_instance);
-
-    for(T **ppCur = &(this->front); *ppCur != NULL; ppCur = &((*ppCur)->p_next)) {
-        if (token == (*ppCur)->token && id == (*ppCur)->curr->id) {
-            ret = 1;
-            temp = *ppCur;
-            *ppCur = (*ppCur)->p_next;
-            free(temp);
-            break;
-        }
-    }
-
-    pthread_mutex_unlock(&mutex_instance);
-
-    return ret;
-}
-
-
-template <typename T>
-int Ril_queue<T>::empty(void) {
-
-    if(this->front == NULL) {
-        return 1;
-    } else {
-        return 0;
-    }
-}
diff --git a/libril/ril_commands.h b/libril/ril_commands.h
deleted file mode 100644
index 94c2a26..0000000
--- a/libril/ril_commands.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/* //device/libs/telephony/ril_commands.h
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-    {0, NULL},                   //none
-    {RIL_REQUEST_GET_SIM_STATUS, radio::getIccCardStatusResponse},
-    {RIL_REQUEST_ENTER_SIM_PIN, radio::supplyIccPinForAppResponse},
-    {RIL_REQUEST_ENTER_SIM_PUK, radio::supplyIccPukForAppResponse},
-    {RIL_REQUEST_ENTER_SIM_PIN2, radio::supplyIccPin2ForAppResponse},
-    {RIL_REQUEST_ENTER_SIM_PUK2, radio::supplyIccPuk2ForAppResponse},
-    {RIL_REQUEST_CHANGE_SIM_PIN, radio::changeIccPinForAppResponse},
-    {RIL_REQUEST_CHANGE_SIM_PIN2, radio::changeIccPin2ForAppResponse},
-    {RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, radio::supplyNetworkDepersonalizationResponse},
-    {RIL_REQUEST_GET_CURRENT_CALLS, radio::getCurrentCallsResponse},
-    {RIL_REQUEST_DIAL, radio::dialResponse},
-    {RIL_REQUEST_GET_IMSI, radio::getIMSIForAppResponse},
-    {RIL_REQUEST_HANGUP, radio::hangupConnectionResponse},
-    {RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, radio::hangupWaitingOrBackgroundResponse},
-    {RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, radio::hangupForegroundResumeBackgroundResponse},
-    {RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, radio::switchWaitingOrHoldingAndActiveResponse},
-    {RIL_REQUEST_CONFERENCE, radio::conferenceResponse},
-    {RIL_REQUEST_UDUB, radio::rejectCallResponse},
-    {RIL_REQUEST_LAST_CALL_FAIL_CAUSE, radio::getLastCallFailCauseResponse},
-    {RIL_REQUEST_SIGNAL_STRENGTH, radio::getSignalStrengthResponse},
-    {RIL_REQUEST_VOICE_REGISTRATION_STATE, radio::getVoiceRegistrationStateResponse},
-    {RIL_REQUEST_DATA_REGISTRATION_STATE, radio::getDataRegistrationStateResponse},
-    {RIL_REQUEST_OPERATOR, radio::getOperatorResponse},
-    {RIL_REQUEST_RADIO_POWER, radio::setRadioPowerResponse},
-    {RIL_REQUEST_DTMF, radio::sendDtmfResponse},
-    {RIL_REQUEST_SEND_SMS, radio::sendSmsResponse},
-    {RIL_REQUEST_SEND_SMS_EXPECT_MORE, radio::sendSMSExpectMoreResponse},
-    {RIL_REQUEST_SETUP_DATA_CALL, radio::setupDataCallResponse},
-    {RIL_REQUEST_SIM_IO, radio::iccIOForAppResponse},
-    {RIL_REQUEST_SEND_USSD, radio::sendUssdResponse},
-    {RIL_REQUEST_CANCEL_USSD, radio::cancelPendingUssdResponse},
-    {RIL_REQUEST_GET_CLIR, radio::getClirResponse},
-    {RIL_REQUEST_SET_CLIR, radio::setClirResponse},
-    {RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, radio::getCallForwardStatusResponse},
-    {RIL_REQUEST_SET_CALL_FORWARD, radio::setCallForwardResponse},
-    {RIL_REQUEST_QUERY_CALL_WAITING, radio::getCallWaitingResponse},
-    {RIL_REQUEST_SET_CALL_WAITING, radio::setCallWaitingResponse},
-    {RIL_REQUEST_SMS_ACKNOWLEDGE, radio::acknowledgeLastIncomingGsmSmsResponse},
-    {RIL_REQUEST_GET_IMEI, NULL},
-    {RIL_REQUEST_GET_IMEISV, NULL},
-    {RIL_REQUEST_ANSWER, radio::acceptCallResponse},
-    {RIL_REQUEST_DEACTIVATE_DATA_CALL, radio::deactivateDataCallResponse},
-    {RIL_REQUEST_QUERY_FACILITY_LOCK, radio::getFacilityLockForAppResponse},
-    {RIL_REQUEST_SET_FACILITY_LOCK, radio::setFacilityLockForAppResponse},
-    {RIL_REQUEST_CHANGE_BARRING_PASSWORD, radio::setBarringPasswordResponse},
-    {RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, radio::getNetworkSelectionModeResponse},
-    {RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, radio::setNetworkSelectionModeAutomaticResponse},
-    {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, radio::setNetworkSelectionModeManualResponse},
-    {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , radio::getAvailableNetworksResponse},
-    {RIL_REQUEST_DTMF_START, radio::startDtmfResponse},
-    {RIL_REQUEST_DTMF_STOP, radio::stopDtmfResponse},
-    {RIL_REQUEST_BASEBAND_VERSION, radio::getBasebandVersionResponse},
-    {RIL_REQUEST_SEPARATE_CONNECTION, radio::separateConnectionResponse},
-    {RIL_REQUEST_SET_MUTE, radio::setMuteResponse},
-    {RIL_REQUEST_GET_MUTE, radio::getMuteResponse},
-    {RIL_REQUEST_QUERY_CLIP, radio::getClipResponse},
-    {RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE, NULL},
-    {RIL_REQUEST_DATA_CALL_LIST, radio::getDataCallListResponse},
-    {RIL_REQUEST_RESET_RADIO, NULL},
-    {RIL_REQUEST_OEM_HOOK_RAW, radio::sendRequestRawResponse},
-    {RIL_REQUEST_OEM_HOOK_STRINGS, radio::sendRequestStringsResponse},
-    {RIL_REQUEST_SCREEN_STATE, radio::sendDeviceStateResponse},   // Note the response function is different.
-    {RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, radio::setSuppServiceNotificationsResponse},
-    {RIL_REQUEST_WRITE_SMS_TO_SIM, radio::writeSmsToSimResponse},
-    {RIL_REQUEST_DELETE_SMS_ON_SIM, radio::deleteSmsOnSimResponse},
-    {RIL_REQUEST_SET_BAND_MODE, radio::setBandModeResponse},
-    {RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, radio::getAvailableBandModesResponse},
-    {RIL_REQUEST_STK_GET_PROFILE, NULL},
-    {RIL_REQUEST_STK_SET_PROFILE, NULL},
-    {RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, radio::sendEnvelopeResponse},
-    {RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, radio::sendTerminalResponseToSimResponse},
-    {RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, radio::handleStkCallSetupRequestFromSimResponse},
-    {RIL_REQUEST_EXPLICIT_CALL_TRANSFER, radio::explicitCallTransferResponse},
-    {RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, radio::setPreferredNetworkTypeResponse},
-    {RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, radio::getPreferredNetworkTypeResponse},
-    {RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, radio::getNeighboringCidsResponse},
-    {RIL_REQUEST_SET_LOCATION_UPDATES, radio::setLocationUpdatesResponse},
-    {RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, radio::setCdmaSubscriptionSourceResponse},
-    {RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, radio::setCdmaRoamingPreferenceResponse},
-    {RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, radio::getCdmaRoamingPreferenceResponse},
-    {RIL_REQUEST_SET_TTY_MODE, radio::setTTYModeResponse},
-    {RIL_REQUEST_QUERY_TTY_MODE, radio::getTTYModeResponse},
-    {RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, radio::setPreferredVoicePrivacyResponse},
-    {RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, radio::getPreferredVoicePrivacyResponse},
-    {RIL_REQUEST_CDMA_FLASH, radio::sendCDMAFeatureCodeResponse},
-    {RIL_REQUEST_CDMA_BURST_DTMF, radio::sendBurstDtmfResponse},
-    {RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY, NULL},
-    {RIL_REQUEST_CDMA_SEND_SMS, radio::sendCdmaSmsResponse},
-    {RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, radio::acknowledgeLastIncomingCdmaSmsResponse},
-    {RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG, radio::getGsmBroadcastConfigResponse},
-    {RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG, radio::setGsmBroadcastConfigResponse},
-    {RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION, radio::setGsmBroadcastActivationResponse},
-    {RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG, radio::getCdmaBroadcastConfigResponse},
-    {RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG, radio::setCdmaBroadcastConfigResponse},
-    {RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION, radio::setCdmaBroadcastActivationResponse},
-    {RIL_REQUEST_CDMA_SUBSCRIPTION, radio::getCDMASubscriptionResponse},
-    {RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, radio::writeSmsToRuimResponse},
-    {RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, radio::deleteSmsOnRuimResponse},
-    {RIL_REQUEST_DEVICE_IDENTITY, radio::getDeviceIdentityResponse},
-    {RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, radio::exitEmergencyCallbackModeResponse},
-    {RIL_REQUEST_GET_SMSC_ADDRESS, radio::getSmscAddressResponse},
-    {RIL_REQUEST_SET_SMSC_ADDRESS, radio::setSmscAddressResponse},
-    {RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, radio::reportSmsMemoryStatusResponse},
-    {RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, radio::reportStkServiceIsRunningResponse},
-    {RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, radio::getCdmaSubscriptionSourceResponse},
-    {RIL_REQUEST_ISIM_AUTHENTICATION, radio::requestIsimAuthenticationResponse},
-    {RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, radio::acknowledgeIncomingGsmSmsWithPduResponse},
-    {RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, radio::sendEnvelopeWithStatusResponse},
-    {RIL_REQUEST_VOICE_RADIO_TECH, radio::getVoiceRadioTechnologyResponse},
-    {RIL_REQUEST_GET_CELL_INFO_LIST, radio::getCellInfoListResponse},
-    {RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, radio::setCellInfoListRateResponse},
-    {RIL_REQUEST_SET_INITIAL_ATTACH_APN, radio::setInitialAttachApnResponse},
-    {RIL_REQUEST_IMS_REGISTRATION_STATE, radio::getImsRegistrationStateResponse},
-    {RIL_REQUEST_IMS_SEND_SMS, radio::sendImsSmsResponse},
-    {RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, radio::iccTransmitApduBasicChannelResponse},
-    {RIL_REQUEST_SIM_OPEN_CHANNEL, radio::iccOpenLogicalChannelResponse},
-    {RIL_REQUEST_SIM_CLOSE_CHANNEL, radio::iccCloseLogicalChannelResponse},
-    {RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, radio::iccTransmitApduLogicalChannelResponse},
-    {RIL_REQUEST_NV_READ_ITEM, radio::nvReadItemResponse},
-    {RIL_REQUEST_NV_WRITE_ITEM, radio::nvWriteItemResponse},
-    {RIL_REQUEST_NV_WRITE_CDMA_PRL, radio::nvWriteCdmaPrlResponse},
-    {RIL_REQUEST_NV_RESET_CONFIG, radio::nvResetConfigResponse},
-    {RIL_REQUEST_SET_UICC_SUBSCRIPTION, radio::setUiccSubscriptionResponse},
-    {RIL_REQUEST_ALLOW_DATA, radio::setDataAllowedResponse},
-    {RIL_REQUEST_GET_HARDWARE_CONFIG, radio::getHardwareConfigResponse},
-    {RIL_REQUEST_SIM_AUTHENTICATION, radio::requestIccSimAuthenticationResponse},
-    {RIL_REQUEST_GET_DC_RT_INFO, NULL},
-    {RIL_REQUEST_SET_DC_RT_INFO_RATE, NULL},
-    {RIL_REQUEST_SET_DATA_PROFILE, radio::setDataProfileResponse},
-    {RIL_REQUEST_SHUTDOWN, radio::requestShutdownResponse},
-    {RIL_REQUEST_GET_RADIO_CAPABILITY, radio::getRadioCapabilityResponse},
-    {RIL_REQUEST_SET_RADIO_CAPABILITY, radio::setRadioCapabilityResponse},
-    {RIL_REQUEST_START_LCE, radio::startLceServiceResponse},
-    {RIL_REQUEST_STOP_LCE, radio::stopLceServiceResponse},
-    {RIL_REQUEST_PULL_LCEDATA, radio::pullLceDataResponse},
-    {RIL_REQUEST_GET_ACTIVITY_INFO, radio::getModemActivityInfoResponse},
-    {RIL_REQUEST_SET_CARRIER_RESTRICTIONS, radio::setAllowedCarriersResponse},
-    {RIL_REQUEST_GET_CARRIER_RESTRICTIONS, radio::getAllowedCarriersResponse},
-    {RIL_REQUEST_SEND_DEVICE_STATE, radio::sendDeviceStateResponse},
-    {RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER, radio::setIndicationFilterResponse},
-    {RIL_REQUEST_SET_SIM_CARD_POWER, radio::setSimCardPowerResponse},
-    {RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION, radio::setCarrierInfoForImsiEncryptionResponse},
-    {RIL_REQUEST_START_NETWORK_SCAN, radio::startNetworkScanResponse},
-    {RIL_REQUEST_STOP_NETWORK_SCAN, radio::stopNetworkScanResponse},
-    {RIL_REQUEST_START_KEEPALIVE, radio::startKeepaliveResponse},
-    {RIL_REQUEST_STOP_KEEPALIVE, radio::stopKeepaliveResponse},
diff --git a/libril/ril_event.cpp b/libril/ril_event.cpp
deleted file mode 100644
index 84b8b72..0000000
--- a/libril/ril_event.cpp
+++ /dev/null
@@ -1,384 +0,0 @@
-/* //device/libs/telephony/ril_event.cpp
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#define LOG_TAG "RILC"
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <utils/Log.h>
-#include <ril_event.h>
-#include <string.h>
-#include <sys/time.h>
-#include <time.h>
-
-#include <pthread.h>
-static pthread_mutex_t listMutex;
-#define MUTEX_ACQUIRE() pthread_mutex_lock(&listMutex)
-#define MUTEX_RELEASE() pthread_mutex_unlock(&listMutex)
-#define MUTEX_INIT() pthread_mutex_init(&listMutex, NULL)
-#define MUTEX_DESTROY() pthread_mutex_destroy(&listMutex)
-
-#ifndef timeradd
-#define timeradd(tvp, uvp, vvp)						\
-	do {								\
-		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
-		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;       \
-		if ((vvp)->tv_usec >= 1000000) {			\
-			(vvp)->tv_sec++;				\
-			(vvp)->tv_usec -= 1000000;			\
-		}							\
-	} while (0)
-#endif
-
-#ifndef timercmp
-#define timercmp(a, b, op)               \
-        ((a)->tv_sec == (b)->tv_sec      \
-        ? (a)->tv_usec op (b)->tv_usec   \
-        : (a)->tv_sec op (b)->tv_sec)
-#endif
-
-#ifndef timersub
-#define timersub(a, b, res)                           \
-    do {                                              \
-        (res)->tv_sec = (a)->tv_sec - (b)->tv_sec;    \
-        (res)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
-        if ((res)->tv_usec < 0) {                     \
-            (res)->tv_usec += 1000000;                \
-            (res)->tv_sec -= 1;                       \
-        }                                             \
-    } while(0);
-#endif
-
-static fd_set readFds;
-static int nfds = 0;
-
-static struct ril_event * watch_table[MAX_FD_EVENTS];
-static struct ril_event timer_list;
-static struct ril_event pending_list;
-
-#define DEBUG 0
-
-#if DEBUG
-#define dlog(x...) RLOGD( x )
-static void dump_event(struct ril_event * ev)
-{
-    dlog("~~~~ Event %x ~~~~", (unsigned int)ev);
-    dlog("     next    = %x", (unsigned int)ev->next);
-    dlog("     prev    = %x", (unsigned int)ev->prev);
-    dlog("     fd      = %d", ev->fd);
-    dlog("     pers    = %d", ev->persist);
-    dlog("     timeout = %ds + %dus", (int)ev->timeout.tv_sec, (int)ev->timeout.tv_usec);
-    dlog("     func    = %x", (unsigned int)ev->func);
-    dlog("     param   = %x", (unsigned int)ev->param);
-    dlog("~~~~~~~~~~~~~~~~~~");
-}
-#else
-#define dlog(x...) do {} while(0)
-#define dump_event(x) do {} while(0)
-#endif
-
-static void getNow(struct timeval * tv)
-{
-    struct timespec ts;
-    clock_gettime(CLOCK_MONOTONIC, &ts);
-    tv->tv_sec = ts.tv_sec;
-    tv->tv_usec = ts.tv_nsec/1000;
-}
-
-static void init_list(struct ril_event * list)
-{
-    memset(list, 0, sizeof(struct ril_event));
-    list->next = list;
-    list->prev = list;
-    list->fd = -1;
-}
-
-static void addToList(struct ril_event * ev, struct ril_event * list)
-{
-    ev->next = list;
-    ev->prev = list->prev;
-    ev->prev->next = ev;
-    list->prev = ev;
-    dump_event(ev);
-}
-
-static void removeFromList(struct ril_event * ev)
-{
-    dlog("~~~~ +removeFromList ~~~~");
-    dump_event(ev);
-
-    ev->next->prev = ev->prev;
-    ev->prev->next = ev->next;
-    ev->next = NULL;
-    ev->prev = NULL;
-    dlog("~~~~ -removeFromList ~~~~");
-}
-
-
-static void removeWatch(struct ril_event * ev, int index)
-{
-    dlog("~~~~ +removeWatch ~~~~");
-    watch_table[index] = NULL;
-    ev->index = -1;
-
-    FD_CLR(ev->fd, &readFds);
-
-    if (ev->fd+1 == nfds) {
-        int n = 0;
-
-        for (int i = 0; i < MAX_FD_EVENTS; i++) {
-            struct ril_event * rev = watch_table[i];
-
-            if ((rev != NULL) && (rev->fd > n)) {
-                n = rev->fd;
-            }
-        }
-        nfds = n + 1;
-        dlog("~~~~ nfds = %d ~~~~", nfds);
-    }
-    dlog("~~~~ -removeWatch ~~~~");
-}
-
-static void processTimeouts()
-{
-    dlog("~~~~ +processTimeouts ~~~~");
-    MUTEX_ACQUIRE();
-    struct timeval now;
-    struct ril_event * tev = timer_list.next;
-    struct ril_event * next;
-
-    getNow(&now);
-    // walk list, see if now >= ev->timeout for any events
-
-    dlog("~~~~ Looking for timers <= %ds + %dus ~~~~", (int)now.tv_sec, (int)now.tv_usec);
-    while ((tev != &timer_list) && (timercmp(&now, &tev->timeout, >))) {
-        // Timer expired
-        dlog("~~~~ firing timer ~~~~");
-        next = tev->next;
-        removeFromList(tev);
-        addToList(tev, &pending_list);
-        tev = next;
-    }
-    MUTEX_RELEASE();
-    dlog("~~~~ -processTimeouts ~~~~");
-}
-
-static void processReadReadies(fd_set * rfds, int n)
-{
-    dlog("~~~~ +processReadReadies (%d) ~~~~", n);
-    MUTEX_ACQUIRE();
-
-    for (int i = 0; (i < MAX_FD_EVENTS) && (n > 0); i++) {
-        struct ril_event * rev = watch_table[i];
-        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
-            addToList(rev, &pending_list);
-            if (rev->persist == false) {
-                removeWatch(rev, i);
-            }
-            n--;
-        }
-    }
-
-    MUTEX_RELEASE();
-    dlog("~~~~ -processReadReadies (%d) ~~~~", n);
-}
-
-static void firePending()
-{
-    dlog("~~~~ +firePending ~~~~");
-    struct ril_event * ev = pending_list.next;
-    while (ev != &pending_list) {
-        struct ril_event * next = ev->next;
-        removeFromList(ev);
-        ev->func(ev->fd, 0, ev->param);
-        ev = next;
-    }
-    dlog("~~~~ -firePending ~~~~");
-}
-
-static int calcNextTimeout(struct timeval * tv)
-{
-    struct ril_event * tev = timer_list.next;
-    struct timeval now;
-
-    getNow(&now);
-
-    // Sorted list, so calc based on first node
-    if (tev == &timer_list) {
-        // no pending timers
-        return -1;
-    }
-
-    dlog("~~~~ now = %ds + %dus ~~~~", (int)now.tv_sec, (int)now.tv_usec);
-    dlog("~~~~ next = %ds + %dus ~~~~",
-            (int)tev->timeout.tv_sec, (int)tev->timeout.tv_usec);
-    if (timercmp(&tev->timeout, &now, >)) {
-        timersub(&tev->timeout, &now, tv);
-    } else {
-        // timer already expired.
-        tv->tv_sec = tv->tv_usec = 0;
-    }
-    return 0;
-}
-
-// Initialize internal data structs
-void ril_event_init()
-{
-    MUTEX_INIT();
-
-    FD_ZERO(&readFds);
-    init_list(&timer_list);
-    init_list(&pending_list);
-    memset(watch_table, 0, sizeof(watch_table));
-}
-
-// Initialize an event
-void ril_event_set(struct ril_event * ev, int fd, bool persist, ril_event_cb func, void * param)
-{
-    dlog("~~~~ ril_event_set %x ~~~~", (unsigned int)ev);
-    memset(ev, 0, sizeof(struct ril_event));
-    ev->fd = fd;
-    ev->index = -1;
-    ev->persist = persist;
-    ev->func = func;
-    ev->param = param;
-    fcntl(fd, F_SETFL, O_NONBLOCK);
-}
-
-// Add event to watch list
-void ril_event_add(struct ril_event * ev)
-{
-    dlog("~~~~ +ril_event_add ~~~~");
-    MUTEX_ACQUIRE();
-    for (int i = 0; i < MAX_FD_EVENTS; i++) {
-        if (watch_table[i] == NULL) {
-            watch_table[i] = ev;
-            ev->index = i;
-            dlog("~~~~ added at %d ~~~~", i);
-            dump_event(ev);
-            FD_SET(ev->fd, &readFds);
-            if (ev->fd >= nfds) nfds = ev->fd+1;
-            dlog("~~~~ nfds = %d ~~~~", nfds);
-            break;
-        }
-    }
-    MUTEX_RELEASE();
-    dlog("~~~~ -ril_event_add ~~~~");
-}
-
-// Add timer event
-void ril_timer_add(struct ril_event * ev, struct timeval * tv)
-{
-    dlog("~~~~ +ril_timer_add ~~~~");
-    MUTEX_ACQUIRE();
-
-    struct ril_event * list;
-    if (tv != NULL) {
-        // add to timer list
-        list = timer_list.next;
-        ev->fd = -1; // make sure fd is invalid
-
-        struct timeval now;
-        getNow(&now);
-        timeradd(&now, tv, &ev->timeout);
-
-        // keep list sorted
-        while (timercmp(&list->timeout, &ev->timeout, < )
-                && (list != &timer_list)) {
-            list = list->next;
-        }
-        // list now points to the first event older than ev
-        addToList(ev, list);
-    }
-
-    MUTEX_RELEASE();
-    dlog("~~~~ -ril_timer_add ~~~~");
-}
-
-// Remove event from watch or timer list
-void ril_event_del(struct ril_event * ev)
-{
-    dlog("~~~~ +ril_event_del ~~~~");
-    MUTEX_ACQUIRE();
-
-    if (ev->index < 0 || ev->index >= MAX_FD_EVENTS) {
-        MUTEX_RELEASE();
-        return;
-    }
-
-    removeWatch(ev, ev->index);
-
-    MUTEX_RELEASE();
-    dlog("~~~~ -ril_event_del ~~~~");
-}
-
-#if DEBUG
-static void printReadies(fd_set * rfds)
-{
-    for (int i = 0; (i < MAX_FD_EVENTS); i++) {
-        struct ril_event * rev = watch_table[i];
-        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
-          dlog("DON: fd=%d is ready", rev->fd);
-        }
-    }
-}
-#else
-#define printReadies(rfds) do {} while(0)
-#endif
-
-void ril_event_loop()
-{
-    int n;
-    fd_set rfds;
-    struct timeval tv;
-    struct timeval * ptv;
-
-
-    for (;;) {
-
-        // make local copy of read fd_set
-        memcpy(&rfds, &readFds, sizeof(fd_set));
-        if (-1 == calcNextTimeout(&tv)) {
-            // no pending timers; block indefinitely
-            dlog("~~~~ no timers; blocking indefinitely ~~~~");
-            ptv = NULL;
-        } else {
-            dlog("~~~~ blocking for %ds + %dus ~~~~", (int)tv.tv_sec, (int)tv.tv_usec);
-            ptv = &tv;
-        }
-        printReadies(&rfds);
-        n = select(nfds, &rfds, NULL, NULL, ptv);
-        printReadies(&rfds);
-        dlog("~~~~ %d events fired ~~~~", n);
-        if (n < 0) {
-            if (errno == EINTR) continue;
-
-            RLOGE("ril_event: select error (%d)", errno);
-            // bail?
-            return;
-        }
-
-        // Check for timeouts
-        processTimeouts();
-        // Check for read-ready
-        processReadReadies(&rfds, n);
-        // Fire away
-        firePending();
-    }
-}
diff --git a/libril/ril_event.h b/libril/ril_event.h
deleted file mode 100644
index 7ba231b..0000000
--- a/libril/ril_event.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* //device/libs/telephony/ril_event.h
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-// Max number of fd's we watch at any one time.  Increase if necessary.
-#define MAX_FD_EVENTS 8
-
-typedef void (*ril_event_cb)(int fd, short events, void *userdata);
-
-struct ril_event {
-    struct ril_event *next;
-    struct ril_event *prev;
-
-    int fd;
-    int index;
-    bool persist;
-    struct timeval timeout;
-    ril_event_cb func;
-    void *param;
-};
-
-// Initialize internal data structs
-void ril_event_init();
-
-// Initialize an event
-void ril_event_set(struct ril_event * ev, int fd, bool persist, ril_event_cb func, void * param);
-
-// Add event to watch list
-void ril_event_add(struct ril_event * ev);
-
-// Add timer event
-void ril_timer_add(struct ril_event * ev, struct timeval * tv);
-
-// Remove event from watch list
-void ril_event_del(struct ril_event * ev);
-
-// Event loop
-void ril_event_loop();
-
diff --git a/libril/ril_internal.h b/libril/ril_internal.h
deleted file mode 100644
index 350791b..0000000
--- a/libril/ril_internal.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (c) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_RIL_INTERNAL_H
-#define ANDROID_RIL_INTERNAL_H
-
-namespace android {
-
-#define RIL_SERVICE_NAME_BASE "slot"
-#define RIL1_SERVICE_NAME "slot1"
-#define RIL2_SERVICE_NAME "slot2"
-#define RIL3_SERVICE_NAME "slot3"
-#define RIL4_SERVICE_NAME "slot4"
-
-/* Constants for response types */
-#define RESPONSE_SOLICITED 0
-#define RESPONSE_UNSOLICITED 1
-#define RESPONSE_SOLICITED_ACK 2
-#define RESPONSE_SOLICITED_ACK_EXP 3
-#define RESPONSE_UNSOLICITED_ACK_EXP 4
-
-// Enable verbose logging
-#define VDBG 0
-
-#define MIN(a,b) ((a)<(b) ? (a) : (b))
-
-// Enable RILC log
-#define RILC_LOG 0
-
-#if RILC_LOG
-    #define startRequest           sprintf(printBuf, "(")
-    #define closeRequest           sprintf(printBuf, "%s)", printBuf)
-    #define printRequest(token, req)           \
-            RLOGD("[%04d]> %s %s", token, requestToString(req), printBuf)
-
-    #define startResponse           sprintf(printBuf, "%s {", printBuf)
-    #define closeResponse           sprintf(printBuf, "%s}", printBuf)
-    #define printResponse           RLOGD("%s", printBuf)
-
-    #define clearPrintBuf           printBuf[0] = 0
-    #define removeLastChar          printBuf[strlen(printBuf)-1] = 0
-    #define appendPrintBuf(x...)    snprintf(printBuf, PRINTBUF_SIZE, x)
-#else
-    #define startRequest
-    #define closeRequest
-    #define printRequest(token, req)
-    #define startResponse
-    #define closeResponse
-    #define printResponse
-    #define clearPrintBuf
-    #define removeLastChar
-    #define appendPrintBuf(x...)
-#endif
-
-typedef struct CommandInfo CommandInfo;
-
-extern "C" const char * requestToString(int request);
-
-typedef struct RequestInfo {
-    int32_t token;      //this is not RIL_Token
-    CommandInfo *pCI;
-    struct RequestInfo *p_next;
-    char cancelled;
-    char local;         // responses to local commands do not go back to command process
-    RIL_SOCKET_ID socket_id;
-    int wasAckSent;    // Indicates whether an ack was sent earlier
-} RequestInfo;
-
-typedef struct CommandInfo {
-    int requestNumber;
-    int(*responseFunction) (int slotId, int responseType, int token,
-            RIL_Errno e, void *response, size_t responselen);
-} CommandInfo;
-
-RequestInfo * addRequestToList(int serial, int slotId, int request);
-
-char * RIL_getServiceName();
-
-void releaseWakeLock();
-
-void onNewCommandConnect(RIL_SOCKET_ID socket_id);
-
-}   // namespace android
-
-#endif //ANDROID_RIL_INTERNAL_H
diff --git a/libril/ril_service.cpp b/libril/ril_service.cpp
deleted file mode 100644
index 495c3e0..0000000
--- a/libril/ril_service.cpp
+++ /dev/null
@@ -1,8704 +0,0 @@
-/*
- * Copyright (c) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "RILC"
-
-#include <android/hardware/radio/1.1/IRadio.h>
-#include <android/hardware/radio/1.1/IRadioResponse.h>
-#include <android/hardware/radio/1.1/IRadioIndication.h>
-#include <android/hardware/radio/1.1/types.h>
-
-#include <android/hardware/radio/deprecated/1.0/IOemHook.h>
-
-#include <hwbinder/IPCThreadState.h>
-#include <hwbinder/ProcessState.h>
-#include <ril_service.h>
-#include <hidl/HidlTransportSupport.h>
-#include <utils/SystemClock.h>
-#include <inttypes.h>
-#include <cutils/properties.h>
-
-#define INVALID_HEX_CHAR 16
-
-using namespace android::hardware::radio;
-using namespace android::hardware::radio::V1_0;
-using namespace android::hardware::radio::deprecated::V1_0;
-using ::android::hardware::configureRpcThreadpool;
-using ::android::hardware::joinRpcThreadpool;
-using ::android::hardware::Return;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::hidl_array;
-using ::android::hardware::Void;
-using android::CommandInfo;
-using android::RequestInfo;
-using android::requestToString;
-using android::sp;
-
-#define BOOL_TO_INT(x) (x ? 1 : 0)
-#define ATOI_NULL_HANDLED(x) (x ? atoi(x) : -1)
-#define ATOI_NULL_HANDLED_DEF(x, defaultVal) (x ? atoi(x) : defaultVal)
-
-#if defined(ANDROID_MULTI_SIM)
-#define CALL_ONREQUEST(a, b, c, d, e) \
-        s_vendorFunctions->onRequest((a), (b), (c), (d), ((RIL_SOCKET_ID)(e)))
-#define CALL_ONSTATEREQUEST(a) s_vendorFunctions->onStateRequest((RIL_SOCKET_ID)(a))
-#else
-#define CALL_ONREQUEST(a, b, c, d, e) s_vendorFunctions->onRequest((a), (b), (c), (d))
-#define CALL_ONSTATEREQUEST(a) s_vendorFunctions->onStateRequest()
-#endif
-
-RIL_RadioFunctions *s_vendorFunctions = NULL;
-static CommandInfo *s_commands;
-
-struct RadioImpl;
-struct OemHookImpl;
-
-#if (SIM_COUNT >= 2)
-sp<RadioImpl> radioService[SIM_COUNT];
-sp<OemHookImpl> oemHookService[SIM_COUNT];
-// counter used for synchronization. It is incremented every time response callbacks are updated.
-volatile int32_t mCounterRadio[SIM_COUNT];
-volatile int32_t mCounterOemHook[SIM_COUNT];
-#else
-sp<RadioImpl> radioService[1];
-sp<OemHookImpl> oemHookService[1];
-// counter used for synchronization. It is incremented every time response callbacks are updated.
-volatile int32_t mCounterRadio[1];
-volatile int32_t mCounterOemHook[1];
-#endif
-
-static pthread_rwlock_t radioServiceRwlock = PTHREAD_RWLOCK_INITIALIZER;
-
-#if (SIM_COUNT >= 2)
-static pthread_rwlock_t radioServiceRwlock2 = PTHREAD_RWLOCK_INITIALIZER;
-#if (SIM_COUNT >= 3)
-static pthread_rwlock_t radioServiceRwlock3 = PTHREAD_RWLOCK_INITIALIZER;
-#if (SIM_COUNT >= 4)
-static pthread_rwlock_t radioServiceRwlock4 = PTHREAD_RWLOCK_INITIALIZER;
-#endif
-#endif
-#endif
-
-void convertRilHardwareConfigListToHal(void *response, size_t responseLen,
-        hidl_vec<HardwareConfig>& records);
-
-void convertRilRadioCapabilityToHal(void *response, size_t responseLen, RadioCapability& rc);
-
-void convertRilLceDataInfoToHal(void *response, size_t responseLen, LceDataInfo& lce);
-
-void convertRilSignalStrengthToHal(void *response, size_t responseLen,
-        SignalStrength& signalStrength);
-
-void convertRilDataCallToHal(RIL_Data_Call_Response_v6 *dcResponse,
-        SetupDataCallResult& dcResult);
-
-void convertRilDataCallToHal(RIL_Data_Call_Response_v9 *dcResponse,
-        SetupDataCallResult& dcResult);
-
-void convertRilDataCallToHal(RIL_Data_Call_Response_v11 *dcResponse,
-        SetupDataCallResult& dcResult);
-
-void convertRilDataCallListToHal(void *response, size_t responseLen,
-        hidl_vec<SetupDataCallResult>& dcResultList);
-
-void convertRilCellInfoListToHal(void *response, size_t responseLen, hidl_vec<CellInfo>& records);
-
-struct RadioImpl : public V1_1::IRadio {
-    int32_t mSlotId;
-    sp<IRadioResponse> mRadioResponse;
-    sp<IRadioIndication> mRadioIndication;
-    sp<V1_1::IRadioResponse> mRadioResponseV1_1;
-    sp<V1_1::IRadioIndication> mRadioIndicationV1_1;
-
-    Return<void> setResponseFunctions(
-            const ::android::sp<IRadioResponse>& radioResponse,
-            const ::android::sp<IRadioIndication>& radioIndication);
-
-    Return<void> getIccCardStatus(int32_t serial);
-
-    Return<void> supplyIccPinForApp(int32_t serial, const hidl_string& pin,
-            const hidl_string& aid);
-
-    Return<void> supplyIccPukForApp(int32_t serial, const hidl_string& puk,
-            const hidl_string& pin, const hidl_string& aid);
-
-    Return<void> supplyIccPin2ForApp(int32_t serial,
-            const hidl_string& pin2,
-            const hidl_string& aid);
-
-    Return<void> supplyIccPuk2ForApp(int32_t serial, const hidl_string& puk2,
-            const hidl_string& pin2, const hidl_string& aid);
-
-    Return<void> changeIccPinForApp(int32_t serial, const hidl_string& oldPin,
-            const hidl_string& newPin, const hidl_string& aid);
-
-    Return<void> changeIccPin2ForApp(int32_t serial, const hidl_string& oldPin2,
-            const hidl_string& newPin2, const hidl_string& aid);
-
-    Return<void> supplyNetworkDepersonalization(int32_t serial, const hidl_string& netPin);
-
-    Return<void> getCurrentCalls(int32_t serial);
-
-    Return<void> dial(int32_t serial, const Dial& dialInfo);
-
-    Return<void> getImsiForApp(int32_t serial,
-            const ::android::hardware::hidl_string& aid);
-
-    Return<void> hangup(int32_t serial, int32_t gsmIndex);
-
-    Return<void> hangupWaitingOrBackground(int32_t serial);
-
-    Return<void> hangupForegroundResumeBackground(int32_t serial);
-
-    Return<void> switchWaitingOrHoldingAndActive(int32_t serial);
-
-    Return<void> conference(int32_t serial);
-
-    Return<void> rejectCall(int32_t serial);
-
-    Return<void> getLastCallFailCause(int32_t serial);
-
-    Return<void> getSignalStrength(int32_t serial);
-
-    Return<void> getVoiceRegistrationState(int32_t serial);
-
-    Return<void> getDataRegistrationState(int32_t serial);
-
-    Return<void> getOperator(int32_t serial);
-
-    Return<void> setRadioPower(int32_t serial, bool on);
-
-    Return<void> sendDtmf(int32_t serial,
-            const ::android::hardware::hidl_string& s);
-
-    Return<void> sendSms(int32_t serial, const GsmSmsMessage& message);
-
-    Return<void> sendSMSExpectMore(int32_t serial, const GsmSmsMessage& message);
-
-    Return<void> setupDataCall(int32_t serial,
-            RadioTechnology radioTechnology,
-            const DataProfileInfo& profileInfo,
-            bool modemCognitive,
-            bool roamingAllowed,
-            bool isRoaming);
-
-    Return<void> iccIOForApp(int32_t serial,
-            const IccIo& iccIo);
-
-    Return<void> sendUssd(int32_t serial,
-            const ::android::hardware::hidl_string& ussd);
-
-    Return<void> cancelPendingUssd(int32_t serial);
-
-    Return<void> getClir(int32_t serial);
-
-    Return<void> setClir(int32_t serial, int32_t status);
-
-    Return<void> getCallForwardStatus(int32_t serial,
-            const CallForwardInfo& callInfo);
-
-    Return<void> setCallForward(int32_t serial,
-            const CallForwardInfo& callInfo);
-
-    Return<void> getCallWaiting(int32_t serial, int32_t serviceClass);
-
-    Return<void> setCallWaiting(int32_t serial, bool enable, int32_t serviceClass);
-
-    Return<void> acknowledgeLastIncomingGsmSms(int32_t serial,
-            bool success, SmsAcknowledgeFailCause cause);
-
-    Return<void> acceptCall(int32_t serial);
-
-    Return<void> deactivateDataCall(int32_t serial,
-            int32_t cid, bool reasonRadioShutDown);
-
-    Return<void> getFacilityLockForApp(int32_t serial,
-            const ::android::hardware::hidl_string& facility,
-            const ::android::hardware::hidl_string& password,
-            int32_t serviceClass,
-            const ::android::hardware::hidl_string& appId);
-
-    Return<void> setFacilityLockForApp(int32_t serial,
-            const ::android::hardware::hidl_string& facility,
-            bool lockState,
-            const ::android::hardware::hidl_string& password,
-            int32_t serviceClass,
-            const ::android::hardware::hidl_string& appId);
-
-    Return<void> setBarringPassword(int32_t serial,
-            const ::android::hardware::hidl_string& facility,
-            const ::android::hardware::hidl_string& oldPassword,
-            const ::android::hardware::hidl_string& newPassword);
-
-    Return<void> getNetworkSelectionMode(int32_t serial);
-
-    Return<void> setNetworkSelectionModeAutomatic(int32_t serial);
-
-    Return<void> setNetworkSelectionModeManual(int32_t serial,
-            const ::android::hardware::hidl_string& operatorNumeric);
-
-    Return<void> getAvailableNetworks(int32_t serial);
-
-    Return<void> startNetworkScan(int32_t serial, const V1_1::NetworkScanRequest& request);
-
-    Return<void> stopNetworkScan(int32_t serial);
-
-    Return<void> startDtmf(int32_t serial,
-            const ::android::hardware::hidl_string& s);
-
-    Return<void> stopDtmf(int32_t serial);
-
-    Return<void> getBasebandVersion(int32_t serial);
-
-    Return<void> separateConnection(int32_t serial, int32_t gsmIndex);
-
-    Return<void> setMute(int32_t serial, bool enable);
-
-    Return<void> getMute(int32_t serial);
-
-    Return<void> getClip(int32_t serial);
-
-    Return<void> getDataCallList(int32_t serial);
-
-    Return<void> setSuppServiceNotifications(int32_t serial, bool enable);
-
-    Return<void> writeSmsToSim(int32_t serial,
-            const SmsWriteArgs& smsWriteArgs);
-
-    Return<void> deleteSmsOnSim(int32_t serial, int32_t index);
-
-    Return<void> setBandMode(int32_t serial, RadioBandMode mode);
-
-    Return<void> getAvailableBandModes(int32_t serial);
-
-    Return<void> sendEnvelope(int32_t serial,
-            const ::android::hardware::hidl_string& command);
-
-    Return<void> sendTerminalResponseToSim(int32_t serial,
-            const ::android::hardware::hidl_string& commandResponse);
-
-    Return<void> handleStkCallSetupRequestFromSim(int32_t serial, bool accept);
-
-    Return<void> explicitCallTransfer(int32_t serial);
-
-    Return<void> setPreferredNetworkType(int32_t serial, PreferredNetworkType nwType);
-
-    Return<void> getPreferredNetworkType(int32_t serial);
-
-    Return<void> getNeighboringCids(int32_t serial);
-
-    Return<void> setLocationUpdates(int32_t serial, bool enable);
-
-    Return<void> setCdmaSubscriptionSource(int32_t serial,
-            CdmaSubscriptionSource cdmaSub);
-
-    Return<void> setCdmaRoamingPreference(int32_t serial, CdmaRoamingType type);
-
-    Return<void> getCdmaRoamingPreference(int32_t serial);
-
-    Return<void> setTTYMode(int32_t serial, TtyMode mode);
-
-    Return<void> getTTYMode(int32_t serial);
-
-    Return<void> setPreferredVoicePrivacy(int32_t serial, bool enable);
-
-    Return<void> getPreferredVoicePrivacy(int32_t serial);
-
-    Return<void> sendCDMAFeatureCode(int32_t serial,
-            const ::android::hardware::hidl_string& featureCode);
-
-    Return<void> sendBurstDtmf(int32_t serial,
-            const ::android::hardware::hidl_string& dtmf,
-            int32_t on,
-            int32_t off);
-
-    Return<void> sendCdmaSms(int32_t serial, const CdmaSmsMessage& sms);
-
-    Return<void> acknowledgeLastIncomingCdmaSms(int32_t serial,
-            const CdmaSmsAck& smsAck);
-
-    Return<void> getGsmBroadcastConfig(int32_t serial);
-
-    Return<void> setGsmBroadcastConfig(int32_t serial,
-            const hidl_vec<GsmBroadcastSmsConfigInfo>& configInfo);
-
-    Return<void> setGsmBroadcastActivation(int32_t serial, bool activate);
-
-    Return<void> getCdmaBroadcastConfig(int32_t serial);
-
-    Return<void> setCdmaBroadcastConfig(int32_t serial,
-            const hidl_vec<CdmaBroadcastSmsConfigInfo>& configInfo);
-
-    Return<void> setCdmaBroadcastActivation(int32_t serial, bool activate);
-
-    Return<void> getCDMASubscription(int32_t serial);
-
-    Return<void> writeSmsToRuim(int32_t serial, const CdmaSmsWriteArgs& cdmaSms);
-
-    Return<void> deleteSmsOnRuim(int32_t serial, int32_t index);
-
-    Return<void> getDeviceIdentity(int32_t serial);
-
-    Return<void> exitEmergencyCallbackMode(int32_t serial);
-
-    Return<void> getSmscAddress(int32_t serial);
-
-    Return<void> setSmscAddress(int32_t serial,
-            const ::android::hardware::hidl_string& smsc);
-
-    Return<void> reportSmsMemoryStatus(int32_t serial, bool available);
-
-    Return<void> reportStkServiceIsRunning(int32_t serial);
-
-    Return<void> getCdmaSubscriptionSource(int32_t serial);
-
-    Return<void> requestIsimAuthentication(int32_t serial,
-            const ::android::hardware::hidl_string& challenge);
-
-    Return<void> acknowledgeIncomingGsmSmsWithPdu(int32_t serial,
-            bool success,
-            const ::android::hardware::hidl_string& ackPdu);
-
-    Return<void> sendEnvelopeWithStatus(int32_t serial,
-            const ::android::hardware::hidl_string& contents);
-
-    Return<void> getVoiceRadioTechnology(int32_t serial);
-
-    Return<void> getCellInfoList(int32_t serial);
-
-    Return<void> setCellInfoListRate(int32_t serial, int32_t rate);
-
-    Return<void> setInitialAttachApn(int32_t serial, const DataProfileInfo& dataProfileInfo,
-            bool modemCognitive, bool isRoaming);
-
-    Return<void> getImsRegistrationState(int32_t serial);
-
-    Return<void> sendImsSms(int32_t serial, const ImsSmsMessage& message);
-
-    Return<void> iccTransmitApduBasicChannel(int32_t serial, const SimApdu& message);
-
-    Return<void> iccOpenLogicalChannel(int32_t serial,
-            const ::android::hardware::hidl_string& aid, int32_t p2);
-
-    Return<void> iccCloseLogicalChannel(int32_t serial, int32_t channelId);
-
-    Return<void> iccTransmitApduLogicalChannel(int32_t serial, const SimApdu& message);
-
-    Return<void> nvReadItem(int32_t serial, NvItem itemId);
-
-    Return<void> nvWriteItem(int32_t serial, const NvWriteItem& item);
-
-    Return<void> nvWriteCdmaPrl(int32_t serial,
-            const ::android::hardware::hidl_vec<uint8_t>& prl);
-
-    Return<void> nvResetConfig(int32_t serial, ResetNvType resetType);
-
-    Return<void> setUiccSubscription(int32_t serial, const SelectUiccSub& uiccSub);
-
-    Return<void> setDataAllowed(int32_t serial, bool allow);
-
-    Return<void> getHardwareConfig(int32_t serial);
-
-    Return<void> requestIccSimAuthentication(int32_t serial,
-            int32_t authContext,
-            const ::android::hardware::hidl_string& authData,
-            const ::android::hardware::hidl_string& aid);
-
-    Return<void> setDataProfile(int32_t serial,
-            const ::android::hardware::hidl_vec<DataProfileInfo>& profiles, bool isRoaming);
-
-    Return<void> requestShutdown(int32_t serial);
-
-    Return<void> getRadioCapability(int32_t serial);
-
-    Return<void> setRadioCapability(int32_t serial, const RadioCapability& rc);
-
-    Return<void> startLceService(int32_t serial, int32_t reportInterval, bool pullMode);
-
-    Return<void> stopLceService(int32_t serial);
-
-    Return<void> pullLceData(int32_t serial);
-
-    Return<void> getModemActivityInfo(int32_t serial);
-
-    Return<void> setAllowedCarriers(int32_t serial,
-            bool allAllowed,
-            const CarrierRestrictions& carriers);
-
-    Return<void> getAllowedCarriers(int32_t serial);
-
-    Return<void> sendDeviceState(int32_t serial, DeviceStateType deviceStateType, bool state);
-
-    Return<void> setIndicationFilter(int32_t serial, int32_t indicationFilter);
-
-    Return<void> startKeepalive(int32_t serial, const V1_1::KeepaliveRequest& keepalive);
-
-    Return<void> stopKeepalive(int32_t serial, int32_t sessionHandle);
-
-    Return<void> setSimCardPower(int32_t serial, bool powerUp);
-    Return<void> setSimCardPower_1_1(int32_t serial,
-            const V1_1::CardPowerState state);
-
-    Return<void> responseAcknowledgement();
-
-    Return<void> setCarrierInfoForImsiEncryption(int32_t serial,
-            const V1_1::ImsiEncryptionInfo& message);
-
-    void checkReturnStatus(Return<void>& ret);
-};
-
-struct OemHookImpl : public IOemHook {
-    int32_t mSlotId;
-    sp<IOemHookResponse> mOemHookResponse;
-    sp<IOemHookIndication> mOemHookIndication;
-
-    Return<void> setResponseFunctions(
-            const ::android::sp<IOemHookResponse>& oemHookResponse,
-            const ::android::sp<IOemHookIndication>& oemHookIndication);
-
-    Return<void> sendRequestRaw(int32_t serial,
-            const ::android::hardware::hidl_vec<uint8_t>& data);
-
-    Return<void> sendRequestStrings(int32_t serial,
-            const ::android::hardware::hidl_vec<::android::hardware::hidl_string>& data);
-};
-
-void memsetAndFreeStrings(int numPointers, ...) {
-    va_list ap;
-    va_start(ap, numPointers);
-    for (int i = 0; i < numPointers; i++) {
-        char *ptr = va_arg(ap, char *);
-        if (ptr) {
-#ifdef MEMSET_FREED
-#define MAX_STRING_LENGTH 4096
-            memset(ptr, 0, strnlen(ptr, MAX_STRING_LENGTH));
-#endif
-            free(ptr);
-        }
-    }
-    va_end(ap);
-}
-
-void sendErrorResponse(RequestInfo *pRI, RIL_Errno err) {
-    pRI->pCI->responseFunction((int) pRI->socket_id,
-            (int) RadioResponseType::SOLICITED, pRI->token, err, NULL, 0);
-}
-
-/**
- * Copies over src to dest. If memory allocation fails, responseFunction() is called for the
- * request with error RIL_E_NO_MEMORY.
- * Returns true on success, and false on failure.
- */
-bool copyHidlStringToRil(char **dest, const hidl_string &src, RequestInfo *pRI) {
-    size_t len = src.size();
-    if (len == 0 &&
-        (pRI->pCI->requestNumber != RIL_REQUEST_ENTER_SIM_PIN) &&
-        (pRI->pCI->requestNumber != RIL_REQUEST_ENTER_SIM_PUK) &&
-        (pRI->pCI->requestNumber != RIL_REQUEST_ENTER_SIM_PIN2) &&
-        (pRI->pCI->requestNumber != RIL_REQUEST_ENTER_SIM_PUK2)) {
-        *dest = NULL;
-        return true;
-    }
-    *dest = (char *) calloc(len + 1, sizeof(char));
-    if (*dest == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-        return false;
-    }
-    strncpy(*dest, src.c_str(), len + 1);
-    return true;
-}
-
-hidl_string convertCharPtrToHidlString(const char *ptr) {
-    hidl_string ret;
-    if (ptr != NULL) {
-        // TODO: replace this with strnlen
-        ret.setToExternal(ptr, strlen(ptr));
-    }
-    return ret;
-}
-
-bool dispatchVoid(int serial, int slotId, int request) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-    CALL_ONREQUEST(request, NULL, 0, pRI, slotId);
-    return true;
-}
-
-bool dispatchString(int serial, int slotId, int request, const char * str) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    char *pString;
-    if (!copyHidlStringToRil(&pString, str, pRI)) {
-        return false;
-    }
-
-    CALL_ONREQUEST(request, pString, sizeof(char *), pRI, slotId);
-
-    memsetAndFreeStrings(1, pString);
-    return true;
-}
-
-bool dispatchStrings(int serial, int slotId, int request, int countStrings, ...) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    char **pStrings;
-    pStrings = (char **)calloc(countStrings, sizeof(char *));
-    if (pStrings == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(request));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-        return false;
-    }
-    va_list ap;
-    va_start(ap, countStrings);
-    for (int i = 0; i < countStrings; i++) {
-        const char* str = va_arg(ap, const char *);
-        if (!copyHidlStringToRil(&pStrings[i], hidl_string(str), pRI)) {
-            va_end(ap);
-            for (int j = 0; j < i; j++) {
-                memsetAndFreeStrings(1, pStrings[j]);
-            }
-            free(pStrings);
-            return false;
-        }
-    }
-    va_end(ap);
-
-    CALL_ONREQUEST(request, pStrings, countStrings * sizeof(char *), pRI, slotId);
-
-    if (pStrings != NULL) {
-        for (int i = 0 ; i < countStrings ; i++) {
-            memsetAndFreeStrings(1, pStrings[i]);
-        }
-
-#ifdef MEMSET_FREED
-        memset(pStrings, 0, countStrings * sizeof(char *));
-#endif
-        free(pStrings);
-    }
-    return true;
-}
-
-bool dispatchStrings(int serial, int slotId, int request, const hidl_vec<hidl_string>& data) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    int countStrings = data.size();
-    char **pStrings;
-    pStrings = (char **)calloc(countStrings, sizeof(char *));
-    if (pStrings == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(request));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-        return false;
-    }
-
-    for (int i = 0; i < countStrings; i++) {
-        if (!copyHidlStringToRil(&pStrings[i], data[i], pRI)) {
-            for (int j = 0; j < i; j++) {
-                memsetAndFreeStrings(1, pStrings[j]);
-            }
-            free(pStrings);
-            return false;
-        }
-    }
-
-    CALL_ONREQUEST(request, pStrings, countStrings * sizeof(char *), pRI, slotId);
-
-    if (pStrings != NULL) {
-        for (int i = 0 ; i < countStrings ; i++) {
-            memsetAndFreeStrings(1, pStrings[i]);
-        }
-
-#ifdef MEMSET_FREED
-        memset(pStrings, 0, countStrings * sizeof(char *));
-#endif
-        free(pStrings);
-    }
-    return true;
-}
-
-bool dispatchInts(int serial, int slotId, int request, int countInts, ...) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    int *pInts = (int *)calloc(countInts, sizeof(int));
-
-    if (pInts == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(request));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-        return false;
-    }
-    va_list ap;
-    va_start(ap, countInts);
-    for (int i = 0; i < countInts; i++) {
-        pInts[i] = va_arg(ap, int);
-    }
-    va_end(ap);
-
-    CALL_ONREQUEST(request, pInts, countInts * sizeof(int), pRI, slotId);
-
-    if (pInts != NULL) {
-#ifdef MEMSET_FREED
-        memset(pInts, 0, countInts * sizeof(int));
-#endif
-        free(pInts);
-    }
-    return true;
-}
-
-bool dispatchCallForwardStatus(int serial, int slotId, int request,
-                              const CallForwardInfo& callInfo) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    RIL_CallForwardInfo cf;
-    cf.status = (int) callInfo.status;
-    cf.reason = callInfo.reason;
-    cf.serviceClass = callInfo.serviceClass;
-    cf.toa = callInfo.toa;
-    cf.timeSeconds = callInfo.timeSeconds;
-
-    if (!copyHidlStringToRil(&cf.number, callInfo.number, pRI)) {
-        return false;
-    }
-
-    CALL_ONREQUEST(request, &cf, sizeof(cf), pRI, slotId);
-
-    memsetAndFreeStrings(1, cf.number);
-
-    return true;
-}
-
-bool dispatchRaw(int serial, int slotId, int request, const hidl_vec<uint8_t>& rawBytes) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    const uint8_t *uData = rawBytes.data();
-
-    CALL_ONREQUEST(request, (void *) uData, rawBytes.size(), pRI, slotId);
-
-    return true;
-}
-
-bool dispatchIccApdu(int serial, int slotId, int request, const SimApdu& message) {
-    RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
-    if (pRI == NULL) {
-        return false;
-    }
-
-    RIL_SIM_APDU apdu = {};
-
-    apdu.sessionid = message.sessionId;
-    apdu.cla = message.cla;
-    apdu.instruction = message.instruction;
-    apdu.p1 = message.p1;
-    apdu.p2 = message.p2;
-    apdu.p3 = message.p3;
-
-    if (!copyHidlStringToRil(&apdu.data, message.data, pRI)) {
-        return false;
-    }
-
-    CALL_ONREQUEST(request, &apdu, sizeof(apdu), pRI, slotId);
-
-    memsetAndFreeStrings(1, apdu.data);
-
-    return true;
-}
-
-void checkReturnStatus(int32_t slotId, Return<void>& ret, bool isRadioService) {
-    if (ret.isOk() == false) {
-        RLOGE("checkReturnStatus: unable to call response/indication callback");
-        // Remote process hosting the callbacks must be dead. Reset the callback objects;
-        // there's no other recovery to be done here. When the client process is back up, it will
-        // call setResponseFunctions()
-
-        // Caller should already hold rdlock, release that first
-        // note the current counter to avoid overwriting updates made by another thread before
-        // write lock is acquired.
-        int counter = isRadioService ? mCounterRadio[slotId] : mCounterOemHook[slotId];
-        pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(slotId);
-        int ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
-        assert(ret == 0);
-
-        // acquire wrlock
-        ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
-        assert(ret == 0);
-
-        // make sure the counter value has not changed
-        if (counter == (isRadioService ? mCounterRadio[slotId] : mCounterOemHook[slotId])) {
-            if (isRadioService) {
-                radioService[slotId]->mRadioResponse = NULL;
-                radioService[slotId]->mRadioIndication = NULL;
-                radioService[slotId]->mRadioResponseV1_1 = NULL;
-                radioService[slotId]->mRadioIndicationV1_1 = NULL;
-            } else {
-                oemHookService[slotId]->mOemHookResponse = NULL;
-                oemHookService[slotId]->mOemHookIndication = NULL;
-            }
-            isRadioService ? mCounterRadio[slotId]++ : mCounterOemHook[slotId]++;
-        } else {
-            RLOGE("checkReturnStatus: not resetting responseFunctions as they likely "
-                    "got updated on another thread");
-        }
-
-        // release wrlock
-        ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
-        assert(ret == 0);
-
-        // Reacquire rdlock
-        ret = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-        assert(ret == 0);
-    }
-}
-
-void RadioImpl::checkReturnStatus(Return<void>& ret) {
-    ::checkReturnStatus(mSlotId, ret, true);
-}
-
-Return<void> RadioImpl::setResponseFunctions(
-        const ::android::sp<IRadioResponse>& radioResponseParam,
-        const ::android::sp<IRadioIndication>& radioIndicationParam) {
-    RLOGD("setResponseFunctions");
-
-    pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(mSlotId);
-    int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
-    assert(ret == 0);
-
-    mRadioResponse = radioResponseParam;
-    mRadioIndication = radioIndicationParam;
-    mRadioResponseV1_1 = V1_1::IRadioResponse::castFrom(mRadioResponse).withDefault(nullptr);
-    mRadioIndicationV1_1 = V1_1::IRadioIndication::castFrom(mRadioIndication).withDefault(nullptr);
-    if (mRadioResponseV1_1 == nullptr || mRadioIndicationV1_1 == nullptr) {
-        mRadioResponseV1_1 = nullptr;
-        mRadioIndicationV1_1 = nullptr;
-    }
-
-    mCounterRadio[mSlotId]++;
-
-    ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
-    assert(ret == 0);
-
-    // client is connected. Send initial indications.
-    android::onNewCommandConnect((RIL_SOCKET_ID) mSlotId);
-
-    return Void();
-}
-
-Return<void> RadioImpl::getIccCardStatus(int32_t serial) {
-#if VDBG
-    RLOGD("getIccCardStatus: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_SIM_STATUS);
-    return Void();
-}
-
-Return<void> RadioImpl::supplyIccPinForApp(int32_t serial, const hidl_string& pin,
-        const hidl_string& aid) {
-#if VDBG
-    RLOGD("supplyIccPinForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PIN,
-            2, pin.c_str(), aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::supplyIccPukForApp(int32_t serial, const hidl_string& puk,
-                                           const hidl_string& pin, const hidl_string& aid) {
-#if VDBG
-    RLOGD("supplyIccPukForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PUK,
-            3, puk.c_str(), pin.c_str(), aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::supplyIccPin2ForApp(int32_t serial, const hidl_string& pin2,
-                                            const hidl_string& aid) {
-#if VDBG
-    RLOGD("supplyIccPin2ForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PIN2,
-            2, pin2.c_str(), aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::supplyIccPuk2ForApp(int32_t serial, const hidl_string& puk2,
-                                            const hidl_string& pin2, const hidl_string& aid) {
-#if VDBG
-    RLOGD("supplyIccPuk2ForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PUK2,
-            3, puk2.c_str(), pin2.c_str(), aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::changeIccPinForApp(int32_t serial, const hidl_string& oldPin,
-                                           const hidl_string& newPin, const hidl_string& aid) {
-#if VDBG
-    RLOGD("changeIccPinForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_SIM_PIN,
-            3, oldPin.c_str(), newPin.c_str(), aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::changeIccPin2ForApp(int32_t serial, const hidl_string& oldPin2,
-                                            const hidl_string& newPin2, const hidl_string& aid) {
-#if VDBG
-    RLOGD("changeIccPin2ForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_SIM_PIN2,
-            3, oldPin2.c_str(), newPin2.c_str(), aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::supplyNetworkDepersonalization(int32_t serial,
-                                                       const hidl_string& netPin) {
-#if VDBG
-    RLOGD("supplyNetworkDepersonalization: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION,
-            1, netPin.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::getCurrentCalls(int32_t serial) {
-#if VDBG
-    RLOGD("getCurrentCalls: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CURRENT_CALLS);
-    return Void();
-}
-
-Return<void> RadioImpl::dial(int32_t serial, const Dial& dialInfo) {
-#if VDBG
-    RLOGD("dial: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_DIAL);
-    if (pRI == NULL) {
-        return Void();
-    }
-    RIL_Dial dial = {};
-    RIL_UUS_Info uusInfo = {};
-    int32_t sizeOfDial = sizeof(dial);
-
-    if (!copyHidlStringToRil(&dial.address, dialInfo.address, pRI)) {
-        return Void();
-    }
-    dial.clir = (int) dialInfo.clir;
-
-    if (dialInfo.uusInfo.size() != 0) {
-        uusInfo.uusType = (RIL_UUS_Type) dialInfo.uusInfo[0].uusType;
-        uusInfo.uusDcs = (RIL_UUS_DCS) dialInfo.uusInfo[0].uusDcs;
-
-        if (dialInfo.uusInfo[0].uusData.size() == 0) {
-            uusInfo.uusData = NULL;
-            uusInfo.uusLength = 0;
-        } else {
-            if (!copyHidlStringToRil(&uusInfo.uusData, dialInfo.uusInfo[0].uusData, pRI)) {
-                memsetAndFreeStrings(1, dial.address);
-                return Void();
-            }
-            uusInfo.uusLength = dialInfo.uusInfo[0].uusData.size();
-        }
-
-        dial.uusInfo = &uusInfo;
-    }
-
-    CALL_ONREQUEST(RIL_REQUEST_DIAL, &dial, sizeOfDial, pRI, mSlotId);
-
-    memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
-
-    return Void();
-}
-
-Return<void> RadioImpl::getImsiForApp(int32_t serial, const hidl_string& aid) {
-#if VDBG
-    RLOGD("getImsiForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_GET_IMSI,
-            1, aid.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::hangup(int32_t serial, int32_t gsmIndex) {
-#if VDBG
-    RLOGD("hangup: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_HANGUP, 1, gsmIndex);
-    return Void();
-}
-
-Return<void> RadioImpl::hangupWaitingOrBackground(int32_t serial) {
-#if VDBG
-    RLOGD("hangupWaitingOrBackground: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND);
-    return Void();
-}
-
-Return<void> RadioImpl::hangupForegroundResumeBackground(int32_t serial) {
-#if VDBG
-    RLOGD("hangupForegroundResumeBackground: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND);
-    return Void();
-}
-
-Return<void> RadioImpl::switchWaitingOrHoldingAndActive(int32_t serial) {
-#if VDBG
-    RLOGD("switchWaitingOrHoldingAndActive: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE);
-    return Void();
-}
-
-Return<void> RadioImpl::conference(int32_t serial) {
-#if VDBG
-    RLOGD("conference: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CONFERENCE);
-    return Void();
-}
-
-Return<void> RadioImpl::rejectCall(int32_t serial) {
-#if VDBG
-    RLOGD("rejectCall: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_UDUB);
-    return Void();
-}
-
-Return<void> RadioImpl::getLastCallFailCause(int32_t serial) {
-#if VDBG
-    RLOGD("getLastCallFailCause: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_LAST_CALL_FAIL_CAUSE);
-    return Void();
-}
-
-Return<void> RadioImpl::getSignalStrength(int32_t serial) {
-#if VDBG
-    RLOGD("getSignalStrength: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_SIGNAL_STRENGTH);
-    return Void();
-}
-
-Return<void> RadioImpl::getVoiceRegistrationState(int32_t serial) {
-#if VDBG
-    RLOGD("getVoiceRegistrationState: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_VOICE_REGISTRATION_STATE);
-    return Void();
-}
-
-Return<void> RadioImpl::getDataRegistrationState(int32_t serial) {
-#if VDBG
-    RLOGD("getDataRegistrationState: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_DATA_REGISTRATION_STATE);
-    return Void();
-}
-
-Return<void> RadioImpl::getOperator(int32_t serial) {
-#if VDBG
-    RLOGD("getOperator: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_OPERATOR);
-    return Void();
-}
-
-Return<void> RadioImpl::setRadioPower(int32_t serial, bool on) {
-    RLOGD("setRadioPower: serial %d on %d", serial, on);
-    dispatchInts(serial, mSlotId, RIL_REQUEST_RADIO_POWER, 1, BOOL_TO_INT(on));
-    return Void();
-}
-
-Return<void> RadioImpl::sendDtmf(int32_t serial, const hidl_string& s) {
-#if VDBG
-    RLOGD("sendDtmf: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_DTMF, s.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::sendSms(int32_t serial, const GsmSmsMessage& message) {
-#if VDBG
-    RLOGD("sendSms: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS,
-            2, message.smscPdu.c_str(), message.pdu.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::sendSMSExpectMore(int32_t serial, const GsmSmsMessage& message) {
-#if VDBG
-    RLOGD("sendSMSExpectMore: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS_EXPECT_MORE,
-            2, message.smscPdu.c_str(), message.pdu.c_str());
-    return Void();
-}
-
-static bool convertMvnoTypeToString(MvnoType type, char *&str) {
-    switch (type) {
-        case MvnoType::IMSI:
-            str = (char *)"imsi";
-            return true;
-        case MvnoType::GID:
-            str = (char *)"gid";
-            return true;
-        case MvnoType::SPN:
-            str = (char *)"spn";
-            return true;
-        case MvnoType::NONE:
-            str = (char *)"";
-            return true;
-    }
-    return false;
-}
-
-Return<void> RadioImpl::setupDataCall(int32_t serial, RadioTechnology radioTechnology,
-                                      const DataProfileInfo& dataProfileInfo, bool modemCognitive,
-                                      bool roamingAllowed, bool isRoaming) {
-
-#if VDBG
-    RLOGD("setupDataCall: serial %d", serial);
-#endif
-
-    if (s_vendorFunctions->version >= 4 && s_vendorFunctions->version <= 14) {
-        const hidl_string &protocol =
-                (isRoaming ? dataProfileInfo.roamingProtocol : dataProfileInfo.protocol);
-        dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, 7,
-            std::to_string((int) radioTechnology + 2).c_str(),
-            std::to_string((int) dataProfileInfo.profileId).c_str(),
-            dataProfileInfo.apn.c_str(),
-            dataProfileInfo.user.c_str(),
-            dataProfileInfo.password.c_str(),
-            std::to_string((int) dataProfileInfo.authType).c_str(),
-            protocol.c_str());
-    } else if (s_vendorFunctions->version >= 15) {
-        char *mvnoTypeStr = NULL;
-        if (!convertMvnoTypeToString(dataProfileInfo.mvnoType, mvnoTypeStr)) {
-            RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-                    RIL_REQUEST_SETUP_DATA_CALL);
-            if (pRI != NULL) {
-                sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-            }
-            return Void();
-        }
-        dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, 15,
-            std::to_string((int) radioTechnology + 2).c_str(),
-            std::to_string((int) dataProfileInfo.profileId).c_str(),
-            dataProfileInfo.apn.c_str(),
-            dataProfileInfo.user.c_str(),
-            dataProfileInfo.password.c_str(),
-            std::to_string((int) dataProfileInfo.authType).c_str(),
-            dataProfileInfo.protocol.c_str(),
-            dataProfileInfo.roamingProtocol.c_str(),
-            std::to_string(dataProfileInfo.supportedApnTypesBitmap).c_str(),
-            std::to_string(dataProfileInfo.bearerBitmap).c_str(),
-            modemCognitive ? "1" : "0",
-            std::to_string(dataProfileInfo.mtu).c_str(),
-            mvnoTypeStr,
-            dataProfileInfo.mvnoMatchData.c_str(),
-            roamingAllowed ? "1" : "0");
-    } else {
-        RLOGE("Unsupported RIL version %d, min version expected 4", s_vendorFunctions->version);
-        RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-                RIL_REQUEST_SETUP_DATA_CALL);
-        if (pRI != NULL) {
-            sendErrorResponse(pRI, RIL_E_REQUEST_NOT_SUPPORTED);
-        }
-    }
-    return Void();
-}
-
-Return<void> RadioImpl::iccIOForApp(int32_t serial, const IccIo& iccIo) {
-#if VDBG
-    RLOGD("iccIOForApp: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SIM_IO);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_SIM_IO_v6 rilIccIo = {};
-    rilIccIo.command = iccIo.command;
-    rilIccIo.fileid = iccIo.fileId;
-    if (!copyHidlStringToRil(&rilIccIo.path, iccIo.path, pRI)) {
-        return Void();
-    }
-
-    rilIccIo.p1 = iccIo.p1;
-    rilIccIo.p2 = iccIo.p2;
-    rilIccIo.p3 = iccIo.p3;
-
-    if (!copyHidlStringToRil(&rilIccIo.data, iccIo.data, pRI)) {
-        memsetAndFreeStrings(1, rilIccIo.path);
-        return Void();
-    }
-
-    if (!copyHidlStringToRil(&rilIccIo.pin2, iccIo.pin2, pRI)) {
-        memsetAndFreeStrings(2, rilIccIo.path, rilIccIo.data);
-        return Void();
-    }
-
-    if (!copyHidlStringToRil(&rilIccIo.aidPtr, iccIo.aid, pRI)) {
-        memsetAndFreeStrings(3, rilIccIo.path, rilIccIo.data, rilIccIo.pin2);
-        return Void();
-    }
-
-    CALL_ONREQUEST(RIL_REQUEST_SIM_IO, &rilIccIo, sizeof(rilIccIo), pRI, mSlotId);
-
-    memsetAndFreeStrings(4, rilIccIo.path, rilIccIo.data, rilIccIo.pin2, rilIccIo.aidPtr);
-
-    return Void();
-}
-
-Return<void> RadioImpl::sendUssd(int32_t serial, const hidl_string& ussd) {
-#if VDBG
-    RLOGD("sendUssd: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_SEND_USSD, ussd.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::cancelPendingUssd(int32_t serial) {
-#if VDBG
-    RLOGD("cancelPendingUssd: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CANCEL_USSD);
-    return Void();
-}
-
-Return<void> RadioImpl::getClir(int32_t serial) {
-#if VDBG
-    RLOGD("getClir: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CLIR);
-    return Void();
-}
-
-Return<void> RadioImpl::setClir(int32_t serial, int32_t status) {
-#if VDBG
-    RLOGD("setClir: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_CLIR, 1, status);
-    return Void();
-}
-
-Return<void> RadioImpl::getCallForwardStatus(int32_t serial, const CallForwardInfo& callInfo) {
-#if VDBG
-    RLOGD("getCallForwardStatus: serial %d", serial);
-#endif
-    dispatchCallForwardStatus(serial, mSlotId, RIL_REQUEST_QUERY_CALL_FORWARD_STATUS,
-            callInfo);
-    return Void();
-}
-
-Return<void> RadioImpl::setCallForward(int32_t serial, const CallForwardInfo& callInfo) {
-#if VDBG
-    RLOGD("setCallForward: serial %d", serial);
-#endif
-    dispatchCallForwardStatus(serial, mSlotId, RIL_REQUEST_SET_CALL_FORWARD,
-            callInfo);
-    return Void();
-}
-
-Return<void> RadioImpl::getCallWaiting(int32_t serial, int32_t serviceClass) {
-#if VDBG
-    RLOGD("getCallWaiting: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_QUERY_CALL_WAITING, 1, serviceClass);
-    return Void();
-}
-
-Return<void> RadioImpl::setCallWaiting(int32_t serial, bool enable, int32_t serviceClass) {
-#if VDBG
-    RLOGD("setCallWaiting: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_CALL_WAITING, 2, BOOL_TO_INT(enable),
-            serviceClass);
-    return Void();
-}
-
-Return<void> RadioImpl::acknowledgeLastIncomingGsmSms(int32_t serial,
-                                                      bool success, SmsAcknowledgeFailCause cause) {
-#if VDBG
-    RLOGD("acknowledgeLastIncomingGsmSms: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SMS_ACKNOWLEDGE, 2, BOOL_TO_INT(success),
-            cause);
-    return Void();
-}
-
-Return<void> RadioImpl::acceptCall(int32_t serial) {
-#if VDBG
-    RLOGD("acceptCall: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_ANSWER);
-    return Void();
-}
-
-Return<void> RadioImpl::deactivateDataCall(int32_t serial,
-                                           int32_t cid, bool reasonRadioShutDown) {
-#if VDBG
-    RLOGD("deactivateDataCall: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_DEACTIVATE_DATA_CALL,
-            2, (std::to_string(cid)).c_str(), reasonRadioShutDown ? "1" : "0");
-    return Void();
-}
-
-Return<void> RadioImpl::getFacilityLockForApp(int32_t serial, const hidl_string& facility,
-                                              const hidl_string& password, int32_t serviceClass,
-                                              const hidl_string& appId) {
-#if VDBG
-    RLOGD("getFacilityLockForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_QUERY_FACILITY_LOCK,
-            4, facility.c_str(), password.c_str(),
-            (std::to_string(serviceClass)).c_str(), appId.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::setFacilityLockForApp(int32_t serial, const hidl_string& facility,
-                                              bool lockState, const hidl_string& password,
-                                              int32_t serviceClass, const hidl_string& appId) {
-#if VDBG
-    RLOGD("setFacilityLockForApp: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_SET_FACILITY_LOCK,
-            5, facility.c_str(), lockState ? "1" : "0", password.c_str(),
-            (std::to_string(serviceClass)).c_str(), appId.c_str() );
-    return Void();
-}
-
-Return<void> RadioImpl::setBarringPassword(int32_t serial, const hidl_string& facility,
-                                           const hidl_string& oldPassword,
-                                           const hidl_string& newPassword) {
-#if VDBG
-    RLOGD("setBarringPassword: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_BARRING_PASSWORD,
-            3, facility.c_str(), oldPassword.c_str(), newPassword.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::getNetworkSelectionMode(int32_t serial) {
-#if VDBG
-    RLOGD("getNetworkSelectionMode: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE);
-    return Void();
-}
-
-Return<void> RadioImpl::setNetworkSelectionModeAutomatic(int32_t serial) {
-#if VDBG
-    RLOGD("setNetworkSelectionModeAutomatic: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC);
-    return Void();
-}
-
-Return<void> RadioImpl::setNetworkSelectionModeManual(int32_t serial,
-                                                      const hidl_string& operatorNumeric) {
-#if VDBG
-    RLOGD("setNetworkSelectionModeManual: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
-            operatorNumeric.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::getAvailableNetworks(int32_t serial) {
-#if VDBG
-    RLOGD("getAvailableNetworks: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_QUERY_AVAILABLE_NETWORKS);
-    return Void();
-}
-
-Return<void> RadioImpl::startNetworkScan(int32_t serial, const V1_1::NetworkScanRequest& request) {
-#if VDBG
-    RLOGD("startNetworkScan: serial %d", serial);
-#endif
-
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_START_NETWORK_SCAN);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    if (request.specifiers.size() > MAX_RADIO_ACCESS_NETWORKS) {
-        sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-        return Void();
-    }
-
-    RIL_NetworkScanRequest scan_request = {};
-
-    scan_request.type = (RIL_ScanType) request.type;
-    scan_request.interval = request.interval;
-    scan_request.specifiers_length = request.specifiers.size();
-    for (size_t i = 0; i < request.specifiers.size(); ++i) {
-        if (request.specifiers[i].geranBands.size() > MAX_BANDS ||
-            request.specifiers[i].utranBands.size() > MAX_BANDS ||
-            request.specifiers[i].eutranBands.size() > MAX_BANDS ||
-            request.specifiers[i].channels.size() > MAX_CHANNELS) {
-            sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-            return Void();
-        }
-        const V1_1::RadioAccessSpecifier& ras_from =
-                request.specifiers[i];
-        RIL_RadioAccessSpecifier& ras_to = scan_request.specifiers[i];
-
-        ras_to.radio_access_network = (RIL_RadioAccessNetworks) ras_from.radioAccessNetwork;
-        ras_to.channels_length = ras_from.channels.size();
-
-        std::copy(ras_from.channels.begin(), ras_from.channels.end(), ras_to.channels);
-        const std::vector<uint32_t> * bands = nullptr;
-        switch (request.specifiers[i].radioAccessNetwork) {
-            case V1_1::RadioAccessNetworks::GERAN:
-                ras_to.bands_length = ras_from.geranBands.size();
-                bands = (std::vector<uint32_t> *) &ras_from.geranBands;
-                break;
-            case V1_1::RadioAccessNetworks::UTRAN:
-                ras_to.bands_length = ras_from.utranBands.size();
-                bands = (std::vector<uint32_t> *) &ras_from.utranBands;
-                break;
-            case V1_1::RadioAccessNetworks::EUTRAN:
-                ras_to.bands_length = ras_from.eutranBands.size();
-                bands = (std::vector<uint32_t> *) &ras_from.eutranBands;
-                break;
-            default:
-                sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-                return Void();
-        }
-        // safe to copy to geran_bands because it's a union member
-        for (size_t idx = 0; idx < ras_to.bands_length; ++idx) {
-            ras_to.bands.geran_bands[idx] = (RIL_GeranBands) (*bands)[idx];
-        }
-    }
-
-    CALL_ONREQUEST(RIL_REQUEST_START_NETWORK_SCAN, &scan_request, sizeof(scan_request), pRI,
-            mSlotId);
-
-    return Void();
-}
-
-Return<void> RadioImpl::stopNetworkScan(int32_t serial) {
-#if VDBG
-    RLOGD("stopNetworkScan: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_STOP_NETWORK_SCAN);
-    return Void();
-}
-
-Return<void> RadioImpl::startDtmf(int32_t serial, const hidl_string& s) {
-#if VDBG
-    RLOGD("startDtmf: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_DTMF_START,
-            s.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::stopDtmf(int32_t serial) {
-#if VDBG
-    RLOGD("stopDtmf: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_DTMF_STOP);
-    return Void();
-}
-
-Return<void> RadioImpl::getBasebandVersion(int32_t serial) {
-#if VDBG
-    RLOGD("getBasebandVersion: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_BASEBAND_VERSION);
-    return Void();
-}
-
-Return<void> RadioImpl::separateConnection(int32_t serial, int32_t gsmIndex) {
-#if VDBG
-    RLOGD("separateConnection: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SEPARATE_CONNECTION, 1, gsmIndex);
-    return Void();
-}
-
-Return<void> RadioImpl::setMute(int32_t serial, bool enable) {
-#if VDBG
-    RLOGD("setMute: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_MUTE, 1, BOOL_TO_INT(enable));
-    return Void();
-}
-
-Return<void> RadioImpl::getMute(int32_t serial) {
-#if VDBG
-    RLOGD("getMute: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_MUTE);
-    return Void();
-}
-
-Return<void> RadioImpl::getClip(int32_t serial) {
-#if VDBG
-    RLOGD("getClip: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_QUERY_CLIP);
-    return Void();
-}
-
-Return<void> RadioImpl::getDataCallList(int32_t serial) {
-#if VDBG
-    RLOGD("getDataCallList: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_DATA_CALL_LIST);
-    return Void();
-}
-
-Return<void> RadioImpl::setSuppServiceNotifications(int32_t serial, bool enable) {
-#if VDBG
-    RLOGD("setSuppServiceNotifications: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, 1,
-            BOOL_TO_INT(enable));
-    return Void();
-}
-
-Return<void> RadioImpl::writeSmsToSim(int32_t serial, const SmsWriteArgs& smsWriteArgs) {
-#if VDBG
-    RLOGD("writeSmsToSim: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_WRITE_SMS_TO_SIM);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_SMS_WriteArgs args;
-    args.status = (int) smsWriteArgs.status;
-
-    if (!copyHidlStringToRil(&args.pdu, smsWriteArgs.pdu, pRI)) {
-        return Void();
-    }
-
-    if (!copyHidlStringToRil(&args.smsc, smsWriteArgs.smsc, pRI)) {
-        memsetAndFreeStrings(1, args.pdu);
-        return Void();
-    }
-
-    CALL_ONREQUEST(RIL_REQUEST_WRITE_SMS_TO_SIM, &args, sizeof(args), pRI, mSlotId);
-
-    memsetAndFreeStrings(2, args.smsc, args.pdu);
-
-    return Void();
-}
-
-Return<void> RadioImpl::deleteSmsOnSim(int32_t serial, int32_t index) {
-#if VDBG
-    RLOGD("deleteSmsOnSim: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_DELETE_SMS_ON_SIM, 1, index);
-    return Void();
-}
-
-Return<void> RadioImpl::setBandMode(int32_t serial, RadioBandMode mode) {
-#if VDBG
-    RLOGD("setBandMode: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_BAND_MODE, 1, mode);
-    return Void();
-}
-
-Return<void> RadioImpl::getAvailableBandModes(int32_t serial) {
-#if VDBG
-    RLOGD("getAvailableBandModes: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE);
-    return Void();
-}
-
-Return<void> RadioImpl::sendEnvelope(int32_t serial, const hidl_string& command) {
-#if VDBG
-    RLOGD("sendEnvelope: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND,
-            command.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::sendTerminalResponseToSim(int32_t serial,
-                                                  const hidl_string& commandResponse) {
-#if VDBG
-    RLOGD("sendTerminalResponseToSim: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE,
-            commandResponse.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::handleStkCallSetupRequestFromSim(int32_t serial, bool accept) {
-#if VDBG
-    RLOGD("handleStkCallSetupRequestFromSim: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM,
-            1, BOOL_TO_INT(accept));
-    return Void();
-}
-
-Return<void> RadioImpl::explicitCallTransfer(int32_t serial) {
-#if VDBG
-    RLOGD("explicitCallTransfer: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_EXPLICIT_CALL_TRANSFER);
-    return Void();
-}
-
-Return<void> RadioImpl::setPreferredNetworkType(int32_t serial, PreferredNetworkType nwType) {
-#if VDBG
-    RLOGD("setPreferredNetworkType: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, 1, nwType);
-    return Void();
-}
-
-Return<void> RadioImpl::getPreferredNetworkType(int32_t serial) {
-#if VDBG
-    RLOGD("getPreferredNetworkType: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE);
-    return Void();
-}
-
-Return<void> RadioImpl::getNeighboringCids(int32_t serial) {
-#if VDBG
-    RLOGD("getNeighboringCids: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_NEIGHBORING_CELL_IDS);
-    return Void();
-}
-
-Return<void> RadioImpl::setLocationUpdates(int32_t serial, bool enable) {
-#if VDBG
-    RLOGD("setLocationUpdates: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_LOCATION_UPDATES, 1, BOOL_TO_INT(enable));
-    return Void();
-}
-
-Return<void> RadioImpl::setCdmaSubscriptionSource(int32_t serial, CdmaSubscriptionSource cdmaSub) {
-#if VDBG
-    RLOGD("setCdmaSubscriptionSource: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, 1, cdmaSub);
-    return Void();
-}
-
-Return<void> RadioImpl::setCdmaRoamingPreference(int32_t serial, CdmaRoamingType type) {
-#if VDBG
-    RLOGD("setCdmaRoamingPreference: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, 1, type);
-    return Void();
-}
-
-Return<void> RadioImpl::getCdmaRoamingPreference(int32_t serial) {
-#if VDBG
-    RLOGD("getCdmaRoamingPreference: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE);
-    return Void();
-}
-
-Return<void> RadioImpl::setTTYMode(int32_t serial, TtyMode mode) {
-#if VDBG
-    RLOGD("setTTYMode: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_TTY_MODE, 1, mode);
-    return Void();
-}
-
-Return<void> RadioImpl::getTTYMode(int32_t serial) {
-#if VDBG
-    RLOGD("getTTYMode: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_QUERY_TTY_MODE);
-    return Void();
-}
-
-Return<void> RadioImpl::setPreferredVoicePrivacy(int32_t serial, bool enable) {
-#if VDBG
-    RLOGD("setPreferredVoicePrivacy: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE,
-            1, BOOL_TO_INT(enable));
-    return Void();
-}
-
-Return<void> RadioImpl::getPreferredVoicePrivacy(int32_t serial) {
-#if VDBG
-    RLOGD("getPreferredVoicePrivacy: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE);
-    return Void();
-}
-
-Return<void> RadioImpl::sendCDMAFeatureCode(int32_t serial, const hidl_string& featureCode) {
-#if VDBG
-    RLOGD("sendCDMAFeatureCode: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_CDMA_FLASH,
-            featureCode.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::sendBurstDtmf(int32_t serial, const hidl_string& dtmf, int32_t on,
-                                      int32_t off) {
-#if VDBG
-    RLOGD("sendBurstDtmf: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CDMA_BURST_DTMF,
-            3, dtmf.c_str(), (std::to_string(on)).c_str(),
-            (std::to_string(off)).c_str());
-    return Void();
-}
-
-void constructCdmaSms(RIL_CDMA_SMS_Message &rcsm, const CdmaSmsMessage& sms) {
-    rcsm.uTeleserviceID = sms.teleserviceId;
-    rcsm.bIsServicePresent = BOOL_TO_INT(sms.isServicePresent);
-    rcsm.uServicecategory = sms.serviceCategory;
-    rcsm.sAddress.digit_mode = (RIL_CDMA_SMS_DigitMode) sms.address.digitMode;
-    rcsm.sAddress.number_mode = (RIL_CDMA_SMS_NumberMode) sms.address.numberMode;
-    rcsm.sAddress.number_type = (RIL_CDMA_SMS_NumberType) sms.address.numberType;
-    rcsm.sAddress.number_plan = (RIL_CDMA_SMS_NumberPlan) sms.address.numberPlan;
-
-    rcsm.sAddress.number_of_digits = sms.address.digits.size();
-    int digitLimit= MIN((rcsm.sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
-    for (int i = 0; i < digitLimit; i++) {
-        rcsm.sAddress.digits[i] = sms.address.digits[i];
-    }
-
-    rcsm.sSubAddress.subaddressType = (RIL_CDMA_SMS_SubaddressType) sms.subAddress.subaddressType;
-    rcsm.sSubAddress.odd = BOOL_TO_INT(sms.subAddress.odd);
-
-    rcsm.sSubAddress.number_of_digits = sms.subAddress.digits.size();
-    digitLimit= MIN((rcsm.sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
-    for (int i = 0; i < digitLimit; i++) {
-        rcsm.sSubAddress.digits[i] = sms.subAddress.digits[i];
-    }
-
-    rcsm.uBearerDataLen = sms.bearerData.size();
-    digitLimit= MIN((rcsm.uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
-    for (int i = 0; i < digitLimit; i++) {
-        rcsm.aBearerData[i] = sms.bearerData[i];
-    }
-}
-
-Return<void> RadioImpl::sendCdmaSms(int32_t serial, const CdmaSmsMessage& sms) {
-#if VDBG
-    RLOGD("sendCdmaSms: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_CDMA_SEND_SMS);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_CDMA_SMS_Message rcsm = {};
-    constructCdmaSms(rcsm, sms);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::acknowledgeLastIncomingCdmaSms(int32_t serial, const CdmaSmsAck& smsAck) {
-#if VDBG
-    RLOGD("acknowledgeLastIncomingCdmaSms: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_CDMA_SMS_Ack rcsa = {};
-
-    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) smsAck.errorClass;
-    rcsa.uSMSCauseCode = smsAck.smsCauseCode;
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::getGsmBroadcastConfig(int32_t serial) {
-#if VDBG
-    RLOGD("getGsmBroadcastConfig: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG);
-    return Void();
-}
-
-Return<void> RadioImpl::setGsmBroadcastConfig(int32_t serial,
-                                              const hidl_vec<GsmBroadcastSmsConfigInfo>&
-                                              configInfo) {
-#if VDBG
-    RLOGD("setGsmBroadcastConfig: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-            RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    int num = configInfo.size();
-    RIL_GSM_BroadcastSmsConfigInfo gsmBci[num];
-    RIL_GSM_BroadcastSmsConfigInfo *gsmBciPtrs[num];
-
-    for (int i = 0 ; i < num ; i++ ) {
-        gsmBciPtrs[i] = &gsmBci[i];
-        gsmBci[i].fromServiceId = configInfo[i].fromServiceId;
-        gsmBci[i].toServiceId = configInfo[i].toServiceId;
-        gsmBci[i].fromCodeScheme = configInfo[i].fromCodeScheme;
-        gsmBci[i].toCodeScheme = configInfo[i].toCodeScheme;
-        gsmBci[i].selected = BOOL_TO_INT(configInfo[i].selected);
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, gsmBciPtrs,
-            num * sizeof(RIL_GSM_BroadcastSmsConfigInfo *), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::setGsmBroadcastActivation(int32_t serial, bool activate) {
-#if VDBG
-    RLOGD("setGsmBroadcastActivation: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION,
-            1, BOOL_TO_INT(!activate));
-    return Void();
-}
-
-Return<void> RadioImpl::getCdmaBroadcastConfig(int32_t serial) {
-#if VDBG
-    RLOGD("getCdmaBroadcastConfig: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG);
-    return Void();
-}
-
-Return<void> RadioImpl::setCdmaBroadcastConfig(int32_t serial,
-                                               const hidl_vec<CdmaBroadcastSmsConfigInfo>&
-                                               configInfo) {
-#if VDBG
-    RLOGD("setCdmaBroadcastConfig: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-            RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    int num = configInfo.size();
-    RIL_CDMA_BroadcastSmsConfigInfo cdmaBci[num];
-    RIL_CDMA_BroadcastSmsConfigInfo *cdmaBciPtrs[num];
-
-    for (int i = 0 ; i < num ; i++ ) {
-        cdmaBciPtrs[i] = &cdmaBci[i];
-        cdmaBci[i].service_category = configInfo[i].serviceCategory;
-        cdmaBci[i].language = configInfo[i].language;
-        cdmaBci[i].selected = BOOL_TO_INT(configInfo[i].selected);
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, cdmaBciPtrs,
-            num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo *), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::setCdmaBroadcastActivation(int32_t serial, bool activate) {
-#if VDBG
-    RLOGD("setCdmaBroadcastActivation: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION,
-            1, BOOL_TO_INT(!activate));
-    return Void();
-}
-
-Return<void> RadioImpl::getCDMASubscription(int32_t serial) {
-#if VDBG
-    RLOGD("getCDMASubscription: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CDMA_SUBSCRIPTION);
-    return Void();
-}
-
-Return<void> RadioImpl::writeSmsToRuim(int32_t serial, const CdmaSmsWriteArgs& cdmaSms) {
-#if VDBG
-    RLOGD("writeSmsToRuim: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-            RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_CDMA_SMS_WriteArgs rcsw = {};
-    rcsw.status = (int) cdmaSms.status;
-    constructCdmaSms(rcsw.message, cdmaSms.message);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsw, sizeof(rcsw), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::deleteSmsOnRuim(int32_t serial, int32_t index) {
-#if VDBG
-    RLOGD("deleteSmsOnRuim: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, 1, index);
-    return Void();
-}
-
-Return<void> RadioImpl::getDeviceIdentity(int32_t serial) {
-#if VDBG
-    RLOGD("getDeviceIdentity: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_DEVICE_IDENTITY);
-    return Void();
-}
-
-Return<void> RadioImpl::exitEmergencyCallbackMode(int32_t serial) {
-#if VDBG
-    RLOGD("exitEmergencyCallbackMode: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE);
-    return Void();
-}
-
-Return<void> RadioImpl::getSmscAddress(int32_t serial) {
-#if VDBG
-    RLOGD("getSmscAddress: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_SMSC_ADDRESS);
-    return Void();
-}
-
-Return<void> RadioImpl::setSmscAddress(int32_t serial, const hidl_string& smsc) {
-#if VDBG
-    RLOGD("setSmscAddress: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_SET_SMSC_ADDRESS,
-            smsc.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::reportSmsMemoryStatus(int32_t serial, bool available) {
-#if VDBG
-    RLOGD("reportSmsMemoryStatus: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, 1,
-            BOOL_TO_INT(available));
-    return Void();
-}
-
-Return<void> RadioImpl::reportStkServiceIsRunning(int32_t serial) {
-#if VDBG
-    RLOGD("reportStkServiceIsRunning: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING);
-    return Void();
-}
-
-Return<void> RadioImpl::getCdmaSubscriptionSource(int32_t serial) {
-#if VDBG
-    RLOGD("getCdmaSubscriptionSource: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE);
-    return Void();
-}
-
-Return<void> RadioImpl::requestIsimAuthentication(int32_t serial, const hidl_string& challenge) {
-#if VDBG
-    RLOGD("requestIsimAuthentication: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_ISIM_AUTHENTICATION,
-            challenge.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool success,
-                                                         const hidl_string& ackPdu) {
-#if VDBG
-    RLOGD("acknowledgeIncomingGsmSmsWithPdu: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU,
-            2, success ? "1" : "0", ackPdu.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::sendEnvelopeWithStatus(int32_t serial, const hidl_string& contents) {
-#if VDBG
-    RLOGD("sendEnvelopeWithStatus: serial %d", serial);
-#endif
-    dispatchString(serial, mSlotId, RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS,
-            contents.c_str());
-    return Void();
-}
-
-Return<void> RadioImpl::getVoiceRadioTechnology(int32_t serial) {
-#if VDBG
-    RLOGD("getVoiceRadioTechnology: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_VOICE_RADIO_TECH);
-    return Void();
-}
-
-Return<void> RadioImpl::getCellInfoList(int32_t serial) {
-#if VDBG
-    RLOGD("getCellInfoList: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CELL_INFO_LIST);
-    return Void();
-}
-
-Return<void> RadioImpl::setCellInfoListRate(int32_t serial, int32_t rate) {
-#if VDBG
-    RLOGD("setCellInfoListRate: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, 1, rate);
-    return Void();
-}
-
-Return<void> RadioImpl::setInitialAttachApn(int32_t serial, const DataProfileInfo& dataProfileInfo,
-                                            bool modemCognitive, bool isRoaming) {
-#if VDBG
-    RLOGD("setInitialAttachApn: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-            RIL_REQUEST_SET_INITIAL_ATTACH_APN);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    if (s_vendorFunctions->version <= 14) {
-        RIL_InitialAttachApn iaa = {};
-
-        if (dataProfileInfo.apn.size() == 0) {
-            iaa.apn = (char *) calloc(1, sizeof(char));
-            if (iaa.apn == NULL) {
-                RLOGE("Memory allocation failed for request %s",
-                        requestToString(pRI->pCI->requestNumber));
-                sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-                return Void();
-            }
-            iaa.apn[0] = '\0';
-        } else {
-            if (!copyHidlStringToRil(&iaa.apn, dataProfileInfo.apn, pRI)) {
-                return Void();
-            }
-        }
-
-        const hidl_string &protocol =
-                (isRoaming ? dataProfileInfo.roamingProtocol : dataProfileInfo.protocol);
-
-        if (!copyHidlStringToRil(&iaa.protocol, protocol, pRI)) {
-            memsetAndFreeStrings(1, iaa.apn);
-            return Void();
-        }
-        iaa.authtype = (int) dataProfileInfo.authType;
-        if (!copyHidlStringToRil(&iaa.username, dataProfileInfo.user, pRI)) {
-            memsetAndFreeStrings(2, iaa.apn, iaa.protocol);
-            return Void();
-        }
-        if (!copyHidlStringToRil(&iaa.password, dataProfileInfo.password, pRI)) {
-            memsetAndFreeStrings(3, iaa.apn, iaa.protocol, iaa.username);
-            return Void();
-        }
-
-        CALL_ONREQUEST(RIL_REQUEST_SET_INITIAL_ATTACH_APN, &iaa, sizeof(iaa), pRI, mSlotId);
-
-        memsetAndFreeStrings(4, iaa.apn, iaa.protocol, iaa.username, iaa.password);
-    } else {
-        RIL_InitialAttachApn_v15 iaa = {};
-
-        if (dataProfileInfo.apn.size() == 0) {
-            iaa.apn = (char *) calloc(1, sizeof(char));
-            if (iaa.apn == NULL) {
-                RLOGE("Memory allocation failed for request %s",
-                        requestToString(pRI->pCI->requestNumber));
-                sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-                return Void();
-            }
-            iaa.apn[0] = '\0';
-        } else {
-            if (!copyHidlStringToRil(&iaa.apn, dataProfileInfo.apn, pRI)) {
-                return Void();
-            }
-        }
-
-        if (!copyHidlStringToRil(&iaa.protocol, dataProfileInfo.protocol, pRI)) {
-            memsetAndFreeStrings(1, iaa.apn);
-            return Void();
-        }
-        if (!copyHidlStringToRil(&iaa.roamingProtocol, dataProfileInfo.roamingProtocol, pRI)) {
-            memsetAndFreeStrings(2, iaa.apn, iaa.protocol);
-            return Void();
-        }
-        iaa.authtype = (int) dataProfileInfo.authType;
-        if (!copyHidlStringToRil(&iaa.username, dataProfileInfo.user, pRI)) {
-            memsetAndFreeStrings(3, iaa.apn, iaa.protocol, iaa.roamingProtocol);
-            return Void();
-        }
-        if (!copyHidlStringToRil(&iaa.password, dataProfileInfo.password, pRI)) {
-            memsetAndFreeStrings(4, iaa.apn, iaa.protocol, iaa.roamingProtocol, iaa.username);
-            return Void();
-        }
-        iaa.supportedTypesBitmask = dataProfileInfo.supportedApnTypesBitmap;
-        iaa.bearerBitmask = dataProfileInfo.bearerBitmap;
-        iaa.modemCognitive = BOOL_TO_INT(modemCognitive);
-        iaa.mtu = dataProfileInfo.mtu;
-
-        if (!convertMvnoTypeToString(dataProfileInfo.mvnoType, iaa.mvnoType)) {
-            sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-            memsetAndFreeStrings(5, iaa.apn, iaa.protocol, iaa.roamingProtocol, iaa.username,
-                    iaa.password);
-            return Void();
-        }
-
-        if (!copyHidlStringToRil(&iaa.mvnoMatchData, dataProfileInfo.mvnoMatchData, pRI)) {
-            memsetAndFreeStrings(5, iaa.apn, iaa.protocol, iaa.roamingProtocol, iaa.username,
-                    iaa.password);
-            return Void();
-        }
-
-        CALL_ONREQUEST(RIL_REQUEST_SET_INITIAL_ATTACH_APN, &iaa, sizeof(iaa), pRI, mSlotId);
-
-        memsetAndFreeStrings(6, iaa.apn, iaa.protocol, iaa.roamingProtocol, iaa.username,
-                iaa.password, iaa.mvnoMatchData);
-    }
-
-    return Void();
-}
-
-Return<void> RadioImpl::getImsRegistrationState(int32_t serial) {
-#if VDBG
-    RLOGD("getImsRegistrationState: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_IMS_REGISTRATION_STATE);
-    return Void();
-}
-
-bool dispatchImsGsmSms(const ImsSmsMessage& message, RequestInfo *pRI) {
-    RIL_IMS_SMS_Message rism = {};
-    char **pStrings;
-    int countStrings = 2;
-    int dataLen = sizeof(char *) * countStrings;
-
-    rism.tech = RADIO_TECH_3GPP;
-    rism.retry = BOOL_TO_INT(message.retry);
-    rism.messageRef = message.messageRef;
-
-    if (message.gsmMessage.size() != 1) {
-        RLOGE("dispatchImsGsmSms: Invalid len %s", requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-        return false;
-    }
-
-    pStrings = (char **)calloc(countStrings, sizeof(char *));
-    if (pStrings == NULL) {
-        RLOGE("dispatchImsGsmSms: Memory allocation failed for request %s",
-                requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-        return false;
-    }
-
-    if (!copyHidlStringToRil(&pStrings[0], message.gsmMessage[0].smscPdu, pRI)) {
-#ifdef MEMSET_FREED
-        memset(pStrings, 0, dataLen);
-#endif
-        free(pStrings);
-        return false;
-    }
-
-    if (!copyHidlStringToRil(&pStrings[1], message.gsmMessage[0].pdu, pRI)) {
-        memsetAndFreeStrings(1, pStrings[0]);
-#ifdef MEMSET_FREED
-        memset(pStrings, 0, dataLen);
-#endif
-        free(pStrings);
-        return false;
-    }
-
-    rism.message.gsmMessage = pStrings;
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rism, sizeof(RIL_RadioTechnologyFamily) +
-            sizeof(uint8_t) + sizeof(int32_t) + dataLen, pRI, pRI->socket_id);
-
-    for (int i = 0 ; i < countStrings ; i++) {
-        memsetAndFreeStrings(1, pStrings[i]);
-    }
-
-#ifdef MEMSET_FREED
-    memset(pStrings, 0, dataLen);
-#endif
-    free(pStrings);
-
-    return true;
-}
-
-struct ImsCdmaSms {
-    RIL_IMS_SMS_Message imsSms;
-    RIL_CDMA_SMS_Message cdmaSms;
-};
-
-bool dispatchImsCdmaSms(const ImsSmsMessage& message, RequestInfo *pRI) {
-    ImsCdmaSms temp = {};
-
-    if (message.cdmaMessage.size() != 1) {
-        RLOGE("dispatchImsCdmaSms: Invalid len %s", requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-        return false;
-    }
-
-    temp.imsSms.tech = RADIO_TECH_3GPP2;
-    temp.imsSms.retry = BOOL_TO_INT(message.retry);
-    temp.imsSms.messageRef = message.messageRef;
-    temp.imsSms.message.cdmaMessage = &temp.cdmaSms;
-
-    constructCdmaSms(temp.cdmaSms, message.cdmaMessage[0]);
-
-    // Vendor code expects payload length to include actual msg payload
-    // (sizeof(RIL_CDMA_SMS_Message)) instead of (RIL_CDMA_SMS_Message *) + size of other fields in
-    // RIL_IMS_SMS_Message
-    int payloadLen = sizeof(RIL_RadioTechnologyFamily) + sizeof(uint8_t) + sizeof(int32_t)
-            + sizeof(RIL_CDMA_SMS_Message);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &temp.imsSms, payloadLen, pRI, pRI->socket_id);
-
-    return true;
-}
-
-Return<void> RadioImpl::sendImsSms(int32_t serial, const ImsSmsMessage& message) {
-#if VDBG
-    RLOGD("sendImsSms: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_IMS_SEND_SMS);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_RadioTechnologyFamily format = (RIL_RadioTechnologyFamily) message.tech;
-
-    if (RADIO_TECH_3GPP == format) {
-        dispatchImsGsmSms(message, pRI);
-    } else if (RADIO_TECH_3GPP2 == format) {
-        dispatchImsCdmaSms(message, pRI);
-    } else {
-        RLOGE("sendImsSms: Invalid radio tech %s",
-                requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-    }
-    return Void();
-}
-
-Return<void> RadioImpl::iccTransmitApduBasicChannel(int32_t serial, const SimApdu& message) {
-#if VDBG
-    RLOGD("iccTransmitApduBasicChannel: serial %d", serial);
-#endif
-    dispatchIccApdu(serial, mSlotId, RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, message);
-    return Void();
-}
-
-Return<void> RadioImpl::iccOpenLogicalChannel(int32_t serial, const hidl_string& aid, int32_t p2) {
-#if VDBG
-    RLOGD("iccOpenLogicalChannel: serial %d", serial);
-#endif
-    if (s_vendorFunctions->version < 15) {
-        dispatchString(serial, mSlotId, RIL_REQUEST_SIM_OPEN_CHANNEL, aid.c_str());
-    } else {
-        RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SIM_OPEN_CHANNEL);
-        if (pRI == NULL) {
-            return Void();
-        }
-
-        RIL_OpenChannelParams params = {};
-
-        params.p2 = p2;
-
-        if (!copyHidlStringToRil(&params.aidPtr, aid, pRI)) {
-            return Void();
-        }
-
-        CALL_ONREQUEST(pRI->pCI->requestNumber, &params, sizeof(params), pRI, mSlotId);
-
-        memsetAndFreeStrings(1, params.aidPtr);
-    }
-    return Void();
-}
-
-Return<void> RadioImpl::iccCloseLogicalChannel(int32_t serial, int32_t channelId) {
-#if VDBG
-    RLOGD("iccCloseLogicalChannel: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SIM_CLOSE_CHANNEL, 1, channelId);
-    return Void();
-}
-
-Return<void> RadioImpl::iccTransmitApduLogicalChannel(int32_t serial, const SimApdu& message) {
-#if VDBG
-    RLOGD("iccTransmitApduLogicalChannel: serial %d", serial);
-#endif
-    dispatchIccApdu(serial, mSlotId, RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, message);
-    return Void();
-}
-
-Return<void> RadioImpl::nvReadItem(int32_t serial, NvItem itemId) {
-#if VDBG
-    RLOGD("nvReadItem: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_NV_READ_ITEM);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_NV_ReadItem nvri = {};
-    nvri.itemID = (RIL_NV_Item) itemId;
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvri, sizeof(nvri), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::nvWriteItem(int32_t serial, const NvWriteItem& item) {
-#if VDBG
-    RLOGD("nvWriteItem: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_NV_WRITE_ITEM);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_NV_WriteItem nvwi = {};
-
-    nvwi.itemID = (RIL_NV_Item) item.itemId;
-
-    if (!copyHidlStringToRil(&nvwi.value, item.value, pRI)) {
-        return Void();
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvwi, sizeof(nvwi), pRI, mSlotId);
-
-    memsetAndFreeStrings(1, nvwi.value);
-    return Void();
-}
-
-Return<void> RadioImpl::nvWriteCdmaPrl(int32_t serial, const hidl_vec<uint8_t>& prl) {
-#if VDBG
-    RLOGD("nvWriteCdmaPrl: serial %d", serial);
-#endif
-    dispatchRaw(serial, mSlotId, RIL_REQUEST_NV_WRITE_CDMA_PRL, prl);
-    return Void();
-}
-
-Return<void> RadioImpl::nvResetConfig(int32_t serial, ResetNvType resetType) {
-    int rilResetType = -1;
-#if VDBG
-    RLOGD("nvResetConfig: serial %d", serial);
-#endif
-    /* Convert ResetNvType to RIL.h values
-     * RIL_REQUEST_NV_RESET_CONFIG
-     * 1 - reload all NV items
-     * 2 - erase NV reset (SCRTN)
-     * 3 - factory reset (RTN)
-     */
-    switch(resetType) {
-      case ResetNvType::RELOAD:
-        rilResetType = 1;
-        break;
-      case ResetNvType::ERASE:
-        rilResetType = 2;
-        break;
-      case ResetNvType::FACTORY_RESET:
-        rilResetType = 3;
-        break;
-    }
-    dispatchInts(serial, mSlotId, RIL_REQUEST_NV_RESET_CONFIG, 1, rilResetType);
-    return Void();
-}
-
-Return<void> RadioImpl::setUiccSubscription(int32_t serial, const SelectUiccSub& uiccSub) {
-#if VDBG
-    RLOGD("setUiccSubscription: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-            RIL_REQUEST_SET_UICC_SUBSCRIPTION);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_SelectUiccSub rilUiccSub = {};
-
-    rilUiccSub.slot = uiccSub.slot;
-    rilUiccSub.app_index = uiccSub.appIndex;
-    rilUiccSub.sub_type = (RIL_SubscriptionType) uiccSub.subType;
-    rilUiccSub.act_status = (RIL_UiccSubActStatus) uiccSub.actStatus;
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rilUiccSub, sizeof(rilUiccSub), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::setDataAllowed(int32_t serial, bool allow) {
-#if VDBG
-    RLOGD("setDataAllowed: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_ALLOW_DATA, 1, BOOL_TO_INT(allow));
-    return Void();
-}
-
-Return<void> RadioImpl::getHardwareConfig(int32_t serial) {
-#if VDBG
-    RLOGD("getHardwareConfig: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_HARDWARE_CONFIG);
-    return Void();
-}
-
-Return<void> RadioImpl::requestIccSimAuthentication(int32_t serial, int32_t authContext,
-        const hidl_string& authData, const hidl_string& aid) {
-#if VDBG
-    RLOGD("requestIccSimAuthentication: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SIM_AUTHENTICATION);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_SimAuthentication pf = {};
-
-    pf.authContext = authContext;
-
-    if (!copyHidlStringToRil(&pf.authData, authData, pRI)) {
-        return Void();
-    }
-
-    if (!copyHidlStringToRil(&pf.aid, aid, pRI)) {
-        memsetAndFreeStrings(1, pf.authData);
-        return Void();
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, mSlotId);
-
-    memsetAndFreeStrings(2, pf.authData, pf.aid);
-    return Void();
-}
-
-/**
- * @param numProfiles number of data profile
- * @param dataProfiles the pointer to the actual data profiles. The acceptable type is
-          RIL_DataProfileInfo or RIL_DataProfileInfo_v15.
- * @param dataProfilePtrs the pointer to the pointers that point to each data profile structure
- * @param numfields number of string-type member in the data profile structure
- * @param ... the variadic parameters are pointers to each string-type member
- **/
-template <typename T>
-void freeSetDataProfileData(int numProfiles, T *dataProfiles, T **dataProfilePtrs,
-                            int numfields, ...) {
-    va_list args;
-    va_start(args, numfields);
-
-    // Iterate through each string-type field that need to be free.
-    for (int i = 0; i < numfields; i++) {
-        // Iterate through each data profile and free that specific string-type field.
-        // The type 'char *T::*' is a type of pointer to a 'char *' member inside T structure.
-        char *T::*ptr = va_arg(args, char *T::*);
-        for (int j = 0; j < numProfiles; j++) {
-            memsetAndFreeStrings(1, dataProfiles[j].*ptr);
-        }
-    }
-
-    va_end(args);
-
-#ifdef MEMSET_FREED
-    memset(dataProfiles, 0, numProfiles * sizeof(T));
-    memset(dataProfilePtrs, 0, numProfiles * sizeof(T *));
-#endif
-    free(dataProfiles);
-    free(dataProfilePtrs);
-}
-
-Return<void> RadioImpl::setDataProfile(int32_t serial, const hidl_vec<DataProfileInfo>& profiles,
-                                       bool isRoaming) {
-#if VDBG
-    RLOGD("setDataProfile: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SET_DATA_PROFILE);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    size_t num = profiles.size();
-    bool success = false;
-
-    if (s_vendorFunctions->version <= 14) {
-
-        RIL_DataProfileInfo *dataProfiles =
-            (RIL_DataProfileInfo *) calloc(num, sizeof(RIL_DataProfileInfo));
-
-        if (dataProfiles == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-            return Void();
-        }
-
-        RIL_DataProfileInfo **dataProfilePtrs =
-            (RIL_DataProfileInfo **) calloc(num, sizeof(RIL_DataProfileInfo *));
-        if (dataProfilePtrs == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            free(dataProfiles);
-            sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-            return Void();
-        }
-
-        for (size_t i = 0; i < num; i++) {
-            dataProfilePtrs[i] = &dataProfiles[i];
-
-            success = copyHidlStringToRil(&dataProfiles[i].apn, profiles[i].apn, pRI);
-
-            const hidl_string &protocol =
-                    (isRoaming ? profiles[i].roamingProtocol : profiles[i].protocol);
-
-            if (success && !copyHidlStringToRil(&dataProfiles[i].protocol, protocol, pRI)) {
-                success = false;
-            }
-
-            if (success && !copyHidlStringToRil(&dataProfiles[i].user, profiles[i].user, pRI)) {
-                success = false;
-            }
-            if (success && !copyHidlStringToRil(&dataProfiles[i].password, profiles[i].password,
-                    pRI)) {
-                success = false;
-            }
-
-            if (!success) {
-                freeSetDataProfileData(num, dataProfiles, dataProfilePtrs, 4,
-                    &RIL_DataProfileInfo::apn, &RIL_DataProfileInfo::protocol,
-                    &RIL_DataProfileInfo::user, &RIL_DataProfileInfo::password);
-                return Void();
-            }
-
-            dataProfiles[i].profileId = (RIL_DataProfile) profiles[i].profileId;
-            dataProfiles[i].authType = (int) profiles[i].authType;
-            dataProfiles[i].type = (int) profiles[i].type;
-            dataProfiles[i].maxConnsTime = profiles[i].maxConnsTime;
-            dataProfiles[i].maxConns = profiles[i].maxConns;
-            dataProfiles[i].waitTime = profiles[i].waitTime;
-            dataProfiles[i].enabled = BOOL_TO_INT(profiles[i].enabled);
-        }
-
-        CALL_ONREQUEST(RIL_REQUEST_SET_DATA_PROFILE, dataProfilePtrs,
-                num * sizeof(RIL_DataProfileInfo *), pRI, mSlotId);
-
-        freeSetDataProfileData(num, dataProfiles, dataProfilePtrs, 4,
-                &RIL_DataProfileInfo::apn, &RIL_DataProfileInfo::protocol,
-                &RIL_DataProfileInfo::user, &RIL_DataProfileInfo::password);
-    } else {
-        RIL_DataProfileInfo_v15 *dataProfiles =
-            (RIL_DataProfileInfo_v15 *) calloc(num, sizeof(RIL_DataProfileInfo_v15));
-
-        if (dataProfiles == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-            return Void();
-        }
-
-        RIL_DataProfileInfo_v15 **dataProfilePtrs =
-            (RIL_DataProfileInfo_v15 **) calloc(num, sizeof(RIL_DataProfileInfo_v15 *));
-        if (dataProfilePtrs == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            free(dataProfiles);
-            sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-            return Void();
-        }
-
-        for (size_t i = 0; i < num; i++) {
-            dataProfilePtrs[i] = &dataProfiles[i];
-
-            success = copyHidlStringToRil(&dataProfiles[i].apn, profiles[i].apn, pRI);
-            if (success && !copyHidlStringToRil(&dataProfiles[i].protocol, profiles[i].protocol,
-                    pRI)) {
-                success = false;
-            }
-            if (success && !copyHidlStringToRil(&dataProfiles[i].roamingProtocol,
-                    profiles[i].roamingProtocol, pRI)) {
-                success = false;
-            }
-            if (success && !copyHidlStringToRil(&dataProfiles[i].user, profiles[i].user, pRI)) {
-                success = false;
-            }
-            if (success && !copyHidlStringToRil(&dataProfiles[i].password, profiles[i].password,
-                    pRI)) {
-                success = false;
-            }
-            if (success && !copyHidlStringToRil(&dataProfiles[i].mvnoMatchData,
-                    profiles[i].mvnoMatchData, pRI)) {
-                success = false;
-            }
-
-            if (success && !convertMvnoTypeToString(profiles[i].mvnoType,
-                    dataProfiles[i].mvnoType)) {
-                sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-                success = false;
-            }
-
-            if (!success) {
-                freeSetDataProfileData(num, dataProfiles, dataProfilePtrs, 6,
-                    &RIL_DataProfileInfo_v15::apn, &RIL_DataProfileInfo_v15::protocol,
-                    &RIL_DataProfileInfo_v15::roamingProtocol, &RIL_DataProfileInfo_v15::user,
-                    &RIL_DataProfileInfo_v15::password, &RIL_DataProfileInfo_v15::mvnoMatchData);
-                return Void();
-            }
-
-            dataProfiles[i].profileId = (RIL_DataProfile) profiles[i].profileId;
-            dataProfiles[i].authType = (int) profiles[i].authType;
-            dataProfiles[i].type = (int) profiles[i].type;
-            dataProfiles[i].maxConnsTime = profiles[i].maxConnsTime;
-            dataProfiles[i].maxConns = profiles[i].maxConns;
-            dataProfiles[i].waitTime = profiles[i].waitTime;
-            dataProfiles[i].enabled = BOOL_TO_INT(profiles[i].enabled);
-            dataProfiles[i].supportedTypesBitmask = profiles[i].supportedApnTypesBitmap;
-            dataProfiles[i].bearerBitmask = profiles[i].bearerBitmap;
-            dataProfiles[i].mtu = profiles[i].mtu;
-        }
-
-        CALL_ONREQUEST(RIL_REQUEST_SET_DATA_PROFILE, dataProfilePtrs,
-                num * sizeof(RIL_DataProfileInfo_v15 *), pRI, mSlotId);
-
-        freeSetDataProfileData(num, dataProfiles, dataProfilePtrs, 6,
-                &RIL_DataProfileInfo_v15::apn, &RIL_DataProfileInfo_v15::protocol,
-                &RIL_DataProfileInfo_v15::roamingProtocol, &RIL_DataProfileInfo_v15::user,
-                &RIL_DataProfileInfo_v15::password, &RIL_DataProfileInfo_v15::mvnoMatchData);
-    }
-
-    return Void();
-}
-
-Return<void> RadioImpl::requestShutdown(int32_t serial) {
-#if VDBG
-    RLOGD("requestShutdown: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_SHUTDOWN);
-    return Void();
-}
-
-Return<void> RadioImpl::getRadioCapability(int32_t serial) {
-#if VDBG
-    RLOGD("getRadioCapability: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_RADIO_CAPABILITY);
-    return Void();
-}
-
-Return<void> RadioImpl::setRadioCapability(int32_t serial, const RadioCapability& rc) {
-#if VDBG
-    RLOGD("setRadioCapability: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_SET_RADIO_CAPABILITY);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_RadioCapability rilRc = {};
-
-    // TODO : set rilRc.version using HIDL version ?
-    rilRc.session = rc.session;
-    rilRc.phase = (int) rc.phase;
-    rilRc.rat = (int) rc.raf;
-    rilRc.status = (int) rc.status;
-    strncpy(rilRc.logicalModemUuid, rc.logicalModemUuid.c_str(), MAX_UUID_LENGTH);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rilRc, sizeof(rilRc), pRI, mSlotId);
-
-    return Void();
-}
-
-Return<void> RadioImpl::startLceService(int32_t serial, int32_t reportInterval, bool pullMode) {
-#if VDBG
-    RLOGD("startLceService: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_START_LCE, 2, reportInterval,
-            BOOL_TO_INT(pullMode));
-    return Void();
-}
-
-Return<void> RadioImpl::stopLceService(int32_t serial) {
-#if VDBG
-    RLOGD("stopLceService: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_STOP_LCE);
-    return Void();
-}
-
-Return<void> RadioImpl::pullLceData(int32_t serial) {
-#if VDBG
-    RLOGD("pullLceData: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_PULL_LCEDATA);
-    return Void();
-}
-
-Return<void> RadioImpl::getModemActivityInfo(int32_t serial) {
-#if VDBG
-    RLOGD("getModemActivityInfo: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_ACTIVITY_INFO);
-    return Void();
-}
-
-Return<void> RadioImpl::setAllowedCarriers(int32_t serial, bool allAllowed,
-                                           const CarrierRestrictions& carriers) {
-#if VDBG
-    RLOGD("setAllowedCarriers: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-            RIL_REQUEST_SET_CARRIER_RESTRICTIONS);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_CarrierRestrictions cr = {};
-    RIL_Carrier *allowedCarriers = NULL;
-    RIL_Carrier *excludedCarriers = NULL;
-
-    cr.len_allowed_carriers = carriers.allowedCarriers.size();
-    allowedCarriers = (RIL_Carrier *)calloc(cr.len_allowed_carriers, sizeof(RIL_Carrier));
-    if (allowedCarriers == NULL) {
-        RLOGE("setAllowedCarriers: Memory allocation failed for request %s",
-                requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-        return Void();
-    }
-    cr.allowed_carriers = allowedCarriers;
-
-    cr.len_excluded_carriers = carriers.excludedCarriers.size();
-    excludedCarriers = (RIL_Carrier *)calloc(cr.len_excluded_carriers, sizeof(RIL_Carrier));
-    if (excludedCarriers == NULL) {
-        RLOGE("setAllowedCarriers: Memory allocation failed for request %s",
-                requestToString(pRI->pCI->requestNumber));
-        sendErrorResponse(pRI, RIL_E_NO_MEMORY);
-#ifdef MEMSET_FREED
-        memset(allowedCarriers, 0, cr.len_allowed_carriers * sizeof(RIL_Carrier));
-#endif
-        free(allowedCarriers);
-        return Void();
-    }
-    cr.excluded_carriers = excludedCarriers;
-
-    for (int i = 0; i < cr.len_allowed_carriers; i++) {
-        allowedCarriers[i].mcc = carriers.allowedCarriers[i].mcc.c_str();
-        allowedCarriers[i].mnc = carriers.allowedCarriers[i].mnc.c_str();
-        allowedCarriers[i].match_type = (RIL_CarrierMatchType) carriers.allowedCarriers[i].matchType;
-        allowedCarriers[i].match_data = carriers.allowedCarriers[i].matchData.c_str();
-    }
-
-    for (int i = 0; i < cr.len_excluded_carriers; i++) {
-        excludedCarriers[i].mcc = carriers.excludedCarriers[i].mcc.c_str();
-        excludedCarriers[i].mnc = carriers.excludedCarriers[i].mnc.c_str();
-        excludedCarriers[i].match_type =
-                (RIL_CarrierMatchType) carriers.excludedCarriers[i].matchType;
-        excludedCarriers[i].match_data = carriers.excludedCarriers[i].matchData.c_str();
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &cr, sizeof(RIL_CarrierRestrictions), pRI, mSlotId);
-
-#ifdef MEMSET_FREED
-    memset(allowedCarriers, 0, cr.len_allowed_carriers * sizeof(RIL_Carrier));
-    memset(excludedCarriers, 0, cr.len_excluded_carriers * sizeof(RIL_Carrier));
-#endif
-    free(allowedCarriers);
-    free(excludedCarriers);
-    return Void();
-}
-
-Return<void> RadioImpl::getAllowedCarriers(int32_t serial) {
-#if VDBG
-    RLOGD("getAllowedCarriers: serial %d", serial);
-#endif
-    dispatchVoid(serial, mSlotId, RIL_REQUEST_GET_CARRIER_RESTRICTIONS);
-    return Void();
-}
-
-Return<void> RadioImpl::sendDeviceState(int32_t serial, DeviceStateType deviceStateType,
-                                        bool state) {
-#if VDBG
-    RLOGD("sendDeviceState: serial %d", serial);
-#endif
-    if (s_vendorFunctions->version < 15) {
-        if (deviceStateType ==  DeviceStateType::LOW_DATA_EXPECTED) {
-            RLOGD("sendDeviceState: calling screen state %d", BOOL_TO_INT(!state));
-            dispatchInts(serial, mSlotId, RIL_REQUEST_SCREEN_STATE, 1, BOOL_TO_INT(!state));
-        } else {
-            RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-                    RIL_REQUEST_SEND_DEVICE_STATE);
-            sendErrorResponse(pRI, RIL_E_REQUEST_NOT_SUPPORTED);
-        }
-        return Void();
-    }
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SEND_DEVICE_STATE, 2, (int) deviceStateType,
-            BOOL_TO_INT(state));
-    return Void();
-}
-
-Return<void> RadioImpl::setIndicationFilter(int32_t serial, int32_t indicationFilter) {
-#if VDBG
-    RLOGD("setIndicationFilter: serial %d", serial);
-#endif
-    if (s_vendorFunctions->version < 15) {
-        RequestInfo *pRI = android::addRequestToList(serial, mSlotId,
-                RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER);
-        sendErrorResponse(pRI, RIL_E_REQUEST_NOT_SUPPORTED);
-        return Void();
-    }
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER, 1, indicationFilter);
-    return Void();
-}
-
-Return<void> RadioImpl::setSimCardPower(int32_t serial, bool powerUp) {
-#if VDBG
-    RLOGD("setSimCardPower: serial %d", serial);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_SIM_CARD_POWER, 1, BOOL_TO_INT(powerUp));
-    return Void();
-}
-
-Return<void> RadioImpl::setSimCardPower_1_1(int32_t serial, const V1_1::CardPowerState state) {
-#if VDBG
-    RLOGD("setSimCardPower_1_1: serial %d state %d", serial, state);
-#endif
-    dispatchInts(serial, mSlotId, RIL_REQUEST_SET_SIM_CARD_POWER, 1, state);
-    return Void();
-}
-
-Return<void> RadioImpl::setCarrierInfoForImsiEncryption(int32_t serial,
-        const V1_1::ImsiEncryptionInfo& data) {
-#if VDBG
-    RLOGD("setCarrierInfoForImsiEncryption: serial %d", serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(
-            serial, mSlotId, RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_CarrierInfoForImsiEncryption imsiEncryption = {};
-
-    if (!copyHidlStringToRil(&imsiEncryption.mnc, data.mnc, pRI)) {
-        return Void();
-    }
-    if (!copyHidlStringToRil(&imsiEncryption.mcc, data.mcc, pRI)) {
-        memsetAndFreeStrings(1, imsiEncryption.mnc);
-        return Void();
-    }
-    if (!copyHidlStringToRil(&imsiEncryption.keyIdentifier, data.keyIdentifier, pRI)) {
-        memsetAndFreeStrings(2, imsiEncryption.mnc, imsiEncryption.mcc);
-        return Void();
-    }
-    int32_t lSize = data.carrierKey.size();
-    imsiEncryption.carrierKey = new uint8_t[lSize];
-    memcpy(imsiEncryption.carrierKey, data.carrierKey.data(), lSize);
-    imsiEncryption.expirationTime = data.expirationTime;
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &imsiEncryption,
-            sizeof(RIL_CarrierInfoForImsiEncryption), pRI, mSlotId);
-    delete(imsiEncryption.carrierKey);
-    return Void();
-}
-
-Return<void> RadioImpl::startKeepalive(int32_t serial, const V1_1::KeepaliveRequest& keepalive) {
-#if VDBG
-    RLOGD("%s(): %d", __FUNCTION__, serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_START_KEEPALIVE);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    RIL_KeepaliveRequest kaReq = {};
-
-    kaReq.type = static_cast<RIL_KeepaliveType>(keepalive.type);
-    switch(kaReq.type) {
-        case NATT_IPV4:
-            if (keepalive.sourceAddress.size() != 4 ||
-                    keepalive.destinationAddress.size() != 4) {
-                RLOGE("Invalid address for keepalive!");
-                sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-                return Void();
-            }
-            break;
-        case NATT_IPV6:
-            if (keepalive.sourceAddress.size() != 16 ||
-                    keepalive.destinationAddress.size() != 16) {
-                RLOGE("Invalid address for keepalive!");
-                sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-                return Void();
-            }
-            break;
-        default:
-            RLOGE("Unknown packet keepalive type!");
-            sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
-            return Void();
-    }
-
-    ::memcpy(kaReq.sourceAddress, keepalive.sourceAddress.data(), keepalive.sourceAddress.size());
-    kaReq.sourcePort = keepalive.sourcePort;
-
-    ::memcpy(kaReq.destinationAddress,
-            keepalive.destinationAddress.data(), keepalive.destinationAddress.size());
-    kaReq.destinationPort = keepalive.destinationPort;
-
-    kaReq.maxKeepaliveIntervalMillis = keepalive.maxKeepaliveIntervalMillis;
-    kaReq.cid = keepalive.cid; // This is the context ID of the data call
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &kaReq, sizeof(RIL_KeepaliveRequest), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::stopKeepalive(int32_t serial, int32_t sessionHandle) {
-#if VDBG
-    RLOGD("%s(): %d", __FUNCTION__, serial);
-#endif
-    RequestInfo *pRI = android::addRequestToList(serial, mSlotId, RIL_REQUEST_STOP_KEEPALIVE);
-    if (pRI == NULL) {
-        return Void();
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &sessionHandle, sizeof(uint32_t), pRI, mSlotId);
-    return Void();
-}
-
-Return<void> RadioImpl::responseAcknowledgement() {
-    android::releaseWakeLock();
-    return Void();
-}
-
-Return<void> OemHookImpl::setResponseFunctions(
-        const ::android::sp<IOemHookResponse>& oemHookResponseParam,
-        const ::android::sp<IOemHookIndication>& oemHookIndicationParam) {
-#if VDBG
-    RLOGD("OemHookImpl::setResponseFunctions");
-#endif
-
-    pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(mSlotId);
-    int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
-    assert(ret == 0);
-
-    mOemHookResponse = oemHookResponseParam;
-    mOemHookIndication = oemHookIndicationParam;
-    mCounterOemHook[mSlotId]++;
-
-    ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
-    assert(ret == 0);
-
-    return Void();
-}
-
-Return<void> OemHookImpl::sendRequestRaw(int32_t serial, const hidl_vec<uint8_t>& data) {
-#if VDBG
-    RLOGD("OemHookImpl::sendRequestRaw: serial %d", serial);
-#endif
-    dispatchRaw(serial, mSlotId, RIL_REQUEST_OEM_HOOK_RAW, data);
-    return Void();
-}
-
-Return<void> OemHookImpl::sendRequestStrings(int32_t serial,
-        const hidl_vec<hidl_string>& data) {
-#if VDBG
-    RLOGD("OemHookImpl::sendRequestStrings: serial %d", serial);
-#endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_OEM_HOOK_STRINGS, data);
-    return Void();
-}
-
-/***************************************************************************************************
- * RESPONSE FUNCTIONS
- * Functions above are used for requests going from framework to vendor code. The ones below are
- * responses for those requests coming back from the vendor code.
- **************************************************************************************************/
-
-void radio::acknowledgeRequest(int slotId, int serial) {
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->acknowledgeRequest(serial);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("acknowledgeRequest: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-}
-
-void populateResponseInfo(RadioResponseInfo& responseInfo, int serial, int responseType,
-                         RIL_Errno e) {
-    responseInfo.serial = serial;
-    switch (responseType) {
-        case RESPONSE_SOLICITED:
-            responseInfo.type = RadioResponseType::SOLICITED;
-            break;
-        case RESPONSE_SOLICITED_ACK_EXP:
-            responseInfo.type = RadioResponseType::SOLICITED_ACK_EXP;
-            break;
-    }
-    responseInfo.error = (RadioError) e;
-}
-
-int responseIntOrEmpty(RadioResponseInfo& responseInfo, int serial, int responseType, RIL_Errno e,
-               void *response, size_t responseLen) {
-    populateResponseInfo(responseInfo, serial, responseType, e);
-    int ret = -1;
-
-    if (response == NULL && responseLen == 0) {
-        // Earlier RILs did not send a response for some cases although the interface
-        // expected an integer as response. Do not return error if response is empty. Instead
-        // Return -1 in those cases to maintain backward compatibility.
-    } else if (response == NULL || responseLen % sizeof(int) != 0) {
-        RLOGE("responseIntOrEmpty: Invalid response");
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-    } else {
-        int *p_int = (int *) response;
-        ret = p_int[0];
-    }
-    return ret;
-}
-
-int responseInt(RadioResponseInfo& responseInfo, int serial, int responseType, RIL_Errno e,
-               void *response, size_t responseLen) {
-    populateResponseInfo(responseInfo, serial, responseType, e);
-    int ret = -1;
-
-    if (response == NULL || responseLen % sizeof(int) != 0) {
-        RLOGE("responseInt: Invalid response");
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-    } else {
-        int *p_int = (int *) response;
-        ret = p_int[0];
-    }
-    return ret;
-}
-
-int radio::getIccCardStatusResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responseLen) {
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        CardStatus cardStatus = {};
-        RIL_CardStatus_v6 *p_cur = ((RIL_CardStatus_v6 *) response);
-        if (response == NULL || responseLen != sizeof(RIL_CardStatus_v6)
-                || p_cur->gsm_umts_subscription_app_index >= p_cur->num_applications
-                || p_cur->cdma_subscription_app_index >= p_cur->num_applications
-                || p_cur->ims_subscription_app_index >= p_cur->num_applications) {
-            RLOGE("getIccCardStatusResponse: Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            cardStatus.cardState = (CardState) p_cur->card_state;
-            cardStatus.universalPinState = (PinState) p_cur->universal_pin_state;
-            cardStatus.gsmUmtsSubscriptionAppIndex = p_cur->gsm_umts_subscription_app_index;
-            cardStatus.cdmaSubscriptionAppIndex = p_cur->cdma_subscription_app_index;
-            cardStatus.imsSubscriptionAppIndex = p_cur->ims_subscription_app_index;
-
-            RIL_AppStatus *rilAppStatus = p_cur->applications;
-            cardStatus.applications.resize(p_cur->num_applications);
-            AppStatus *appStatus = cardStatus.applications.data();
-#if VDBG
-            RLOGD("getIccCardStatusResponse: num_applications %d", p_cur->num_applications);
-#endif
-            for (int i = 0; i < p_cur->num_applications; i++) {
-                appStatus[i].appType = (AppType) rilAppStatus[i].app_type;
-                appStatus[i].appState = (AppState) rilAppStatus[i].app_state;
-                appStatus[i].persoSubstate = (PersoSubstate) rilAppStatus[i].perso_substate;
-                appStatus[i].aidPtr = convertCharPtrToHidlString(rilAppStatus[i].aid_ptr);
-                appStatus[i].appLabelPtr = convertCharPtrToHidlString(
-                        rilAppStatus[i].app_label_ptr);
-                appStatus[i].pin1Replaced = rilAppStatus[i].pin1_replaced;
-                appStatus[i].pin1 = (PinState) rilAppStatus[i].pin1;
-                appStatus[i].pin2 = (PinState) rilAppStatus[i].pin2;
-            }
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                getIccCardStatusResponse(responseInfo, cardStatus);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getIccCardStatusResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::supplyIccPinForAppResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("supplyIccPinForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                supplyIccPinForAppResponse(responseInfo, ret);
-        RLOGE("supplyIccPinForAppResponse: amit ret %d", ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("supplyIccPinForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::supplyIccPukForAppResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("supplyIccPukForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->supplyIccPukForAppResponse(
-                responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("supplyIccPukForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::supplyIccPin2ForAppResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("supplyIccPin2ForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                supplyIccPin2ForAppResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("supplyIccPin2ForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::supplyIccPuk2ForAppResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("supplyIccPuk2ForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                supplyIccPuk2ForAppResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("supplyIccPuk2ForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::changeIccPinForAppResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("changeIccPinForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                changeIccPinForAppResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("changeIccPinForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::changeIccPin2ForAppResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("changeIccPin2ForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                changeIccPin2ForAppResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("changeIccPin2ForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::supplyNetworkDepersonalizationResponse(int slotId,
-                                                 int responseType, int serial, RIL_Errno e,
-                                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("supplyNetworkDepersonalizationResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                supplyNetworkDepersonalizationResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("supplyNetworkDepersonalizationResponse: radioService[%d]->mRadioResponse == "
-                "NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCurrentCallsResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getCurrentCallsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        hidl_vec<Call> calls;
-        if ((response == NULL && responseLen != 0)
-                || (responseLen % sizeof(RIL_Call *)) != 0) {
-            RLOGE("getCurrentCallsResponse: Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int num = responseLen / sizeof(RIL_Call *);
-            calls.resize(num);
-
-            for (int i = 0 ; i < num ; i++) {
-                RIL_Call *p_cur = ((RIL_Call **) response)[i];
-                /* each call info */
-                calls[i].state = (CallState) p_cur->state;
-                calls[i].index = p_cur->index;
-                calls[i].toa = p_cur->toa;
-                calls[i].isMpty = p_cur->isMpty;
-                calls[i].isMT = p_cur->isMT;
-                calls[i].als = p_cur->als;
-                calls[i].isVoice = p_cur->isVoice;
-                calls[i].isVoicePrivacy = p_cur->isVoicePrivacy;
-                calls[i].number = convertCharPtrToHidlString(p_cur->number);
-                calls[i].numberPresentation = (CallPresentation) p_cur->numberPresentation;
-                calls[i].name = convertCharPtrToHidlString(p_cur->name);
-                calls[i].namePresentation = (CallPresentation) p_cur->namePresentation;
-                if (p_cur->uusInfo != NULL && p_cur->uusInfo->uusData != NULL) {
-                    RIL_UUS_Info *uusInfo = p_cur->uusInfo;
-                    calls[i].uusInfo.resize(1);
-                    calls[i].uusInfo[0].uusType = (UusType) uusInfo->uusType;
-                    calls[i].uusInfo[0].uusDcs = (UusDcs) uusInfo->uusDcs;
-                    // convert uusInfo->uusData to a null-terminated string
-                    char *nullTermStr = strndup(uusInfo->uusData, uusInfo->uusLength);
-                    calls[i].uusInfo[0].uusData = nullTermStr;
-                    free(nullTermStr);
-                }
-            }
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                getCurrentCallsResponse(responseInfo, calls);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCurrentCallsResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::dialResponse(int slotId,
-                       int responseType, int serial, RIL_Errno e, void *response,
-                       size_t responseLen) {
-#if VDBG
-    RLOGD("dialResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->dialResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("dialResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getIMSIForAppResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e, void *response,
-                                size_t responseLen) {
-#if VDBG
-    RLOGD("getIMSIForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getIMSIForAppResponse(
-                responseInfo, convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getIMSIForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::hangupConnectionResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("hangupConnectionResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->hangupConnectionResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("hangupConnectionResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::hangupWaitingOrBackgroundResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("hangupWaitingOrBackgroundResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus =
-                radioService[slotId]->mRadioResponse->hangupWaitingOrBackgroundResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("hangupWaitingOrBackgroundResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::hangupForegroundResumeBackgroundResponse(int slotId, int responseType, int serial,
-                                                    RIL_Errno e, void *response,
-                                                    size_t responseLen) {
-#if VDBG
-    RLOGD("hangupWaitingOrBackgroundResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus =
-                radioService[slotId]->mRadioResponse->hangupWaitingOrBackgroundResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("hangupWaitingOrBackgroundResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::switchWaitingOrHoldingAndActiveResponse(int slotId, int responseType, int serial,
-                                                   RIL_Errno e, void *response,
-                                                   size_t responseLen) {
-#if VDBG
-    RLOGD("switchWaitingOrHoldingAndActiveResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus =
-                radioService[slotId]->mRadioResponse->switchWaitingOrHoldingAndActiveResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("switchWaitingOrHoldingAndActiveResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::conferenceResponse(int slotId, int responseType,
-                             int serial, RIL_Errno e, void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("conferenceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->conferenceResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("conferenceResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::rejectCallResponse(int slotId, int responseType,
-                             int serial, RIL_Errno e, void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("rejectCallResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->rejectCallResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("rejectCallResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getLastCallFailCauseResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e, void *response,
-                                       size_t responseLen) {
-#if VDBG
-    RLOGD("getLastCallFailCauseResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        LastCallFailCauseInfo info = {};
-        info.vendorCause = hidl_string();
-        if (response == NULL) {
-            RLOGE("getCurrentCallsResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else if (responseLen == sizeof(RIL_LastCallFailCauseInfo))  {
-            RIL_LastCallFailCauseInfo *pFailCauseInfo = (RIL_LastCallFailCauseInfo *) response;
-            info.causeCode = (LastCallFailCause) pFailCauseInfo->cause_code;
-            info.vendorCause = convertCharPtrToHidlString(pFailCauseInfo->vendor_cause);
-        } else if (responseLen % sizeof(int) != 0) {
-            int *pInt = (int *) response;
-            info.causeCode = (LastCallFailCause) pInt[0];
-        } else {
-            RLOGE("getCurrentCallsResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getLastCallFailCauseResponse(
-                responseInfo, info);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getLastCallFailCauseResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getSignalStrengthResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getSignalStrengthResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        SignalStrength signalStrength = {};
-        if (response == NULL || (responseLen != sizeof(RIL_SignalStrength_v10)
-                && responseLen != sizeof(RIL_SignalStrength_v8))) {
-            RLOGE("getSignalStrengthResponse: Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            convertRilSignalStrengthToHal(response, responseLen, signalStrength);
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getSignalStrengthResponse(
-                responseInfo, signalStrength);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getSignalStrengthResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-RIL_CellInfoType getCellInfoTypeRadioTechnology(char *rat) {
-    if (rat == NULL) {
-        return RIL_CELL_INFO_TYPE_NONE;
-    }
-
-    int radioTech = atoi(rat);
-
-    switch(radioTech) {
-
-        case RADIO_TECH_GPRS:
-        case RADIO_TECH_EDGE:
-        case RADIO_TECH_GSM: {
-            return RIL_CELL_INFO_TYPE_GSM;
-        }
-
-        case RADIO_TECH_UMTS:
-        case RADIO_TECH_HSDPA:
-        case RADIO_TECH_HSUPA:
-        case RADIO_TECH_HSPA:
-        case RADIO_TECH_HSPAP: {
-            return RIL_CELL_INFO_TYPE_WCDMA;
-        }
-
-        case RADIO_TECH_IS95A:
-        case RADIO_TECH_IS95B:
-        case RADIO_TECH_1xRTT:
-        case RADIO_TECH_EVDO_0:
-        case RADIO_TECH_EVDO_A:
-        case RADIO_TECH_EVDO_B:
-        case RADIO_TECH_EHRPD: {
-            return RIL_CELL_INFO_TYPE_CDMA;
-        }
-
-        case RADIO_TECH_LTE:
-        case RADIO_TECH_LTE_CA: {
-            return RIL_CELL_INFO_TYPE_LTE;
-        }
-
-        case RADIO_TECH_TD_SCDMA: {
-            return RIL_CELL_INFO_TYPE_TD_SCDMA;
-        }
-
-        default: {
-            break;
-        }
-    }
-
-    return RIL_CELL_INFO_TYPE_NONE;
-
-}
-
-void fillCellIdentityResponse(CellIdentity &cellIdentity, RIL_CellIdentity_v16 &rilCellIdentity) {
-
-    cellIdentity.cellIdentityGsm.resize(0);
-    cellIdentity.cellIdentityWcdma.resize(0);
-    cellIdentity.cellIdentityCdma.resize(0);
-    cellIdentity.cellIdentityTdscdma.resize(0);
-    cellIdentity.cellIdentityLte.resize(0);
-    cellIdentity.cellInfoType = (CellInfoType)rilCellIdentity.cellInfoType;
-    switch(rilCellIdentity.cellInfoType) {
-
-        case RIL_CELL_INFO_TYPE_GSM: {
-            cellIdentity.cellIdentityGsm.resize(1);
-            cellIdentity.cellIdentityGsm[0].mcc =
-                    std::to_string(rilCellIdentity.cellIdentityGsm.mcc);
-            cellIdentity.cellIdentityGsm[0].mnc =
-                    std::to_string(rilCellIdentity.cellIdentityGsm.mnc);
-            cellIdentity.cellIdentityGsm[0].lac = rilCellIdentity.cellIdentityGsm.lac;
-            cellIdentity.cellIdentityGsm[0].cid = rilCellIdentity.cellIdentityGsm.cid;
-            cellIdentity.cellIdentityGsm[0].arfcn = rilCellIdentity.cellIdentityGsm.arfcn;
-            cellIdentity.cellIdentityGsm[0].bsic = rilCellIdentity.cellIdentityGsm.bsic;
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_WCDMA: {
-            cellIdentity.cellIdentityWcdma.resize(1);
-            cellIdentity.cellIdentityWcdma[0].mcc =
-                    std::to_string(rilCellIdentity.cellIdentityWcdma.mcc);
-            cellIdentity.cellIdentityWcdma[0].mnc =
-                    std::to_string(rilCellIdentity.cellIdentityWcdma.mnc);
-            cellIdentity.cellIdentityWcdma[0].lac = rilCellIdentity.cellIdentityWcdma.lac;
-            cellIdentity.cellIdentityWcdma[0].cid = rilCellIdentity.cellIdentityWcdma.cid;
-            cellIdentity.cellIdentityWcdma[0].psc = rilCellIdentity.cellIdentityWcdma.psc;
-            cellIdentity.cellIdentityWcdma[0].uarfcn = rilCellIdentity.cellIdentityWcdma.uarfcn;
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_CDMA: {
-            cellIdentity.cellIdentityCdma.resize(1);
-            cellIdentity.cellIdentityCdma[0].networkId = rilCellIdentity.cellIdentityCdma.networkId;
-            cellIdentity.cellIdentityCdma[0].systemId = rilCellIdentity.cellIdentityCdma.systemId;
-            cellIdentity.cellIdentityCdma[0].baseStationId =
-                    rilCellIdentity.cellIdentityCdma.basestationId;
-            cellIdentity.cellIdentityCdma[0].longitude = rilCellIdentity.cellIdentityCdma.longitude;
-            cellIdentity.cellIdentityCdma[0].latitude = rilCellIdentity.cellIdentityCdma.latitude;
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_LTE: {
-            cellIdentity.cellIdentityLte.resize(1);
-            cellIdentity.cellIdentityLte[0].mcc =
-                    std::to_string(rilCellIdentity.cellIdentityLte.mcc);
-            cellIdentity.cellIdentityLte[0].mnc =
-                    std::to_string(rilCellIdentity.cellIdentityLte.mnc);
-            cellIdentity.cellIdentityLte[0].ci = rilCellIdentity.cellIdentityLte.ci;
-            cellIdentity.cellIdentityLte[0].pci = rilCellIdentity.cellIdentityLte.pci;
-            cellIdentity.cellIdentityLte[0].tac = rilCellIdentity.cellIdentityLte.tac;
-            cellIdentity.cellIdentityLte[0].earfcn = rilCellIdentity.cellIdentityLte.earfcn;
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_TD_SCDMA: {
-            cellIdentity.cellIdentityTdscdma.resize(1);
-            cellIdentity.cellIdentityTdscdma[0].mcc =
-                    std::to_string(rilCellIdentity.cellIdentityTdscdma.mcc);
-            cellIdentity.cellIdentityTdscdma[0].mnc =
-                    std::to_string(rilCellIdentity.cellIdentityTdscdma.mnc);
-            cellIdentity.cellIdentityTdscdma[0].lac = rilCellIdentity.cellIdentityTdscdma.lac;
-            cellIdentity.cellIdentityTdscdma[0].cid = rilCellIdentity.cellIdentityTdscdma.cid;
-            cellIdentity.cellIdentityTdscdma[0].cpid = rilCellIdentity.cellIdentityTdscdma.cpid;
-            break;
-        }
-
-        default: {
-            break;
-        }
-    }
-}
-
-int convertResponseStringEntryToInt(char **response, int index, int numStrings) {
-    if ((response != NULL) &&  (numStrings > index) && (response[index] != NULL)) {
-        return atoi(response[index]);
-    }
-
-    return -1;
-}
-
-int convertResponseHexStringEntryToInt(char **response, int index, int numStrings) {
-    const int hexBase = 16;
-    if ((response != NULL) &&  (numStrings > index) && (response[index] != NULL)) {
-        return strtol(response[index], NULL, hexBase);
-    }
-
-    return -1;
-}
-
-/* Fill Cell Identity info from Voice Registration State Response.
- * This fucntion is applicable only for RIL Version < 15.
- * Response is a  "char **".
- * First and Second entries are in hex string format
- * and rest are integers represented in ascii format. */
-void fillCellIdentityFromVoiceRegStateResponseString(CellIdentity &cellIdentity,
-        int numStrings, char** response) {
-
-    RIL_CellIdentity_v16 rilCellIdentity;
-    memset(&rilCellIdentity, -1, sizeof(RIL_CellIdentity_v16));
-
-    rilCellIdentity.cellInfoType = getCellInfoTypeRadioTechnology(response[3]);
-    switch(rilCellIdentity.cellInfoType) {
-
-        case RIL_CELL_INFO_TYPE_GSM: {
-            /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityGsm.lac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityGsm.cid =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_WCDMA: {
-            /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityWcdma.lac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityWcdma.cid =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            rilCellIdentity.cellIdentityWcdma.psc =
-                    convertResponseStringEntryToInt(response, 14, numStrings);
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_TD_SCDMA:{
-            /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityTdscdma.lac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityTdscdma.cid =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_CDMA:{
-            rilCellIdentity.cellIdentityCdma.basestationId =
-                    convertResponseStringEntryToInt(response, 4, numStrings);
-            /* Order of Lat. and Long. swapped between RIL and HIDL interface versions. */
-            rilCellIdentity.cellIdentityCdma.latitude =
-                    convertResponseStringEntryToInt(response, 5, numStrings);
-            rilCellIdentity.cellIdentityCdma.longitude =
-                    convertResponseStringEntryToInt(response, 6, numStrings);
-            rilCellIdentity.cellIdentityCdma.systemId =
-                    convertResponseStringEntryToInt(response, 8, numStrings);
-            rilCellIdentity.cellIdentityCdma.networkId =
-                    convertResponseStringEntryToInt(response, 9, numStrings);
-            break;
-        }
-
-        case RIL_CELL_INFO_TYPE_LTE:{
-            /* valid TAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityLte.tac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityLte.ci =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            break;
-        }
-
-        default: {
-            break;
-        }
-    }
-
-    fillCellIdentityResponse(cellIdentity, rilCellIdentity);
-}
-
-/* Fill Cell Identity info from Data Registration State Response.
- * This fucntion is applicable only for RIL Version < 15.
- * Response is a  "char **".
- * First and Second entries are in hex string format
- * and rest are integers represented in ascii format. */
-void fillCellIdentityFromDataRegStateResponseString(CellIdentity &cellIdentity,
-        int numStrings, char** response) {
-
-    RIL_CellIdentity_v16 rilCellIdentity;
-    memset(&rilCellIdentity, -1, sizeof(RIL_CellIdentity_v16));
-
-    rilCellIdentity.cellInfoType = getCellInfoTypeRadioTechnology(response[3]);
-    switch(rilCellIdentity.cellInfoType) {
-        case RIL_CELL_INFO_TYPE_GSM: {
-            /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityGsm.lac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityGsm.cid =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            break;
-        }
-        case RIL_CELL_INFO_TYPE_WCDMA: {
-            /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityWcdma.lac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityWcdma.cid =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            break;
-        }
-        case RIL_CELL_INFO_TYPE_TD_SCDMA:{
-            /* valid LAC are hexstrings in the range 0x0000 - 0xffff */
-            rilCellIdentity.cellIdentityTdscdma.lac =
-                    convertResponseHexStringEntryToInt(response, 1, numStrings);
-
-            /* valid CID are hexstrings in the range 0x00000000 - 0xffffffff */
-            rilCellIdentity.cellIdentityTdscdma.cid =
-                    convertResponseHexStringEntryToInt(response, 2, numStrings);
-            break;
-        }
-        case RIL_CELL_INFO_TYPE_LTE: {
-            rilCellIdentity.cellIdentityLte.tac =
-                    convertResponseStringEntryToInt(response, 6, numStrings);
-            rilCellIdentity.cellIdentityLte.pci =
-                    convertResponseStringEntryToInt(response, 7, numStrings);
-            rilCellIdentity.cellIdentityLte.ci =
-                    convertResponseStringEntryToInt(response, 8, numStrings);
-            break;
-        }
-        default: {
-            break;
-        }
-    }
-
-    fillCellIdentityResponse(cellIdentity, rilCellIdentity);
-}
-
-int radio::getVoiceRegistrationStateResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getVoiceRegistrationStateResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        VoiceRegStateResult voiceRegResponse = {};
-        int numStrings = responseLen / sizeof(char *);
-        if (response == NULL) {
-               RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
-               if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else if (s_vendorFunctions->version <= 14) {
-            if (numStrings < 15) {
-                RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
-                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            } else {
-                char **resp = (char **) response;
-                voiceRegResponse.regState = (RegState) ATOI_NULL_HANDLED_DEF(resp[0], 4);
-                voiceRegResponse.rat = ATOI_NULL_HANDLED(resp[3]);
-                voiceRegResponse.cssSupported = ATOI_NULL_HANDLED_DEF(resp[7], 0);
-                voiceRegResponse.roamingIndicator = ATOI_NULL_HANDLED(resp[10]);
-                voiceRegResponse.systemIsInPrl = ATOI_NULL_HANDLED_DEF(resp[11], 0);
-                voiceRegResponse.defaultRoamingIndicator = ATOI_NULL_HANDLED_DEF(resp[12], 0);
-                voiceRegResponse.reasonForDenial = ATOI_NULL_HANDLED_DEF(resp[13], 0);
-                fillCellIdentityFromVoiceRegStateResponseString(voiceRegResponse.cellIdentity,
-                        15, resp);
-            }
-        } else {
-            RIL_VoiceRegistrationStateResponse *voiceRegState =
-                    (RIL_VoiceRegistrationStateResponse *)response;
-
-            if (responseLen != sizeof(RIL_VoiceRegistrationStateResponse)) {
-                RLOGE("getVoiceRegistrationStateResponse Invalid response: NULL");
-                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            } else {
-                voiceRegResponse.regState = (RegState) voiceRegState->regState;
-                voiceRegResponse.rat = voiceRegState->rat;;
-                voiceRegResponse.cssSupported = voiceRegState->cssSupported;
-                voiceRegResponse.roamingIndicator = voiceRegState->roamingIndicator;
-                voiceRegResponse.systemIsInPrl = voiceRegState->systemIsInPrl;
-                voiceRegResponse.defaultRoamingIndicator = voiceRegState->defaultRoamingIndicator;
-                voiceRegResponse.reasonForDenial = voiceRegState->reasonForDenial;
-                fillCellIdentityResponse(voiceRegResponse.cellIdentity,
-                        voiceRegState->cellIdentity);
-            }
-        }
-
-        Return<void> retStatus =
-                radioService[slotId]->mRadioResponse->getVoiceRegistrationStateResponse(
-                responseInfo, voiceRegResponse);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getVoiceRegistrationStateResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getDataRegistrationStateResponse(int slotId,
-                                           int responseType, int serial, RIL_Errno e,
-                                           void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getDataRegistrationStateResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        DataRegStateResult dataRegResponse = {};
-        if (response == NULL) {
-            RLOGE("getDataRegistrationStateResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else if (s_vendorFunctions->version <= 14) {
-            int numStrings = responseLen / sizeof(char *);
-            if (numStrings < 6) {
-                RLOGE("getDataRegistrationStateResponse Invalid response: NULL");
-                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            } else {
-                char **resp = (char **) response;
-                dataRegResponse.regState = (RegState) ATOI_NULL_HANDLED_DEF(resp[0], 4);
-                dataRegResponse.rat =  ATOI_NULL_HANDLED_DEF(resp[3], 0);
-                dataRegResponse.reasonDataDenied =  ATOI_NULL_HANDLED(resp[4]);
-                dataRegResponse.maxDataCalls =  ATOI_NULL_HANDLED_DEF(resp[5], 1);
-                fillCellIdentityFromDataRegStateResponseString(dataRegResponse.cellIdentity,
-                        numStrings < 11 ? 6 : 11, resp);
-            }
-        } else {
-            RIL_DataRegistrationStateResponse *dataRegState =
-                    (RIL_DataRegistrationStateResponse *)response;
-
-            if (responseLen != sizeof(RIL_DataRegistrationStateResponse)) {
-                RLOGE("getDataRegistrationStateResponse Invalid response: NULL");
-                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            } else {
-                dataRegResponse.regState = (RegState) dataRegState->regState;
-                dataRegResponse.rat = dataRegState->rat;;
-                dataRegResponse.reasonDataDenied = dataRegState->reasonDataDenied;
-                dataRegResponse.maxDataCalls = dataRegState->maxDataCalls;
-                fillCellIdentityResponse(dataRegResponse.cellIdentity, dataRegState->cellIdentity);
-            }
-        }
-
-        Return<void> retStatus =
-                radioService[slotId]->mRadioResponse->getDataRegistrationStateResponse(responseInfo,
-                dataRegResponse);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getDataRegistrationStateResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getOperatorResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responseLen) {
-#if VDBG
-    RLOGD("getOperatorResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_string longName;
-        hidl_string shortName;
-        hidl_string numeric;
-        int numStrings = responseLen / sizeof(char *);
-        if (response == NULL || numStrings < 3) {
-            RLOGE("getOperatorResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-
-        } else {
-            char **resp = (char **) response;
-            longName = convertCharPtrToHidlString(resp[0]);
-            shortName = convertCharPtrToHidlString(resp[1]);
-            numeric = convertCharPtrToHidlString(resp[2]);
-        }
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getOperatorResponse(
-                responseInfo, longName, shortName, numeric);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getOperatorResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setRadioPowerResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e, void *response,
-                                size_t responseLen) {
-    RLOGD("setRadioPowerResponse: serial %d", serial);
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->setRadioPowerResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setRadioPowerResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendDtmfResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e, void *response,
-                           size_t responseLen) {
-#if VDBG
-    RLOGD("sendDtmfResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->sendDtmfResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendDtmfResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-SendSmsResult makeSendSmsResult(RadioResponseInfo& responseInfo, int serial, int responseType,
-                                RIL_Errno e, void *response, size_t responseLen) {
-    populateResponseInfo(responseInfo, serial, responseType, e);
-    SendSmsResult result = {};
-
-    if (response != NULL && responseLen == sizeof(RIL_SMS_Response)) {
-        RIL_SMS_Response *resp = (RIL_SMS_Response *) response;
-        result.messageRef = resp->messageRef;
-        result.ackPDU = convertCharPtrToHidlString(resp->ackPDU);
-        result.errorCode = resp->errorCode;
-    } else if (response != NULL && responseLen == sizeof(RIL_SMS_Response_Ext)) {
-        RIL_SMS_Response *resp = &(((RIL_SMS_Response_Ext *) response)->response);
-        result.messageRef = resp->messageRef;
-        result.ackPDU = convertCharPtrToHidlString(resp->ackPDU);
-        result.errorCode = resp->errorCode;
-    } else {
-        RLOGE("Invalid response: NULL");
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        result.ackPDU = hidl_string();
-    }
-    return result;
-}
-
-int radio::sendSmsResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responseLen) {
-#if VDBG
-    RLOGD("sendSmsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        SendSmsResult result = makeSendSmsResult(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->sendSmsResponse(responseInfo,
-                result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendSmsResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendSMSExpectMoreResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responseLen) {
-#if VDBG
-    RLOGD("sendSMSExpectMoreResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        SendSmsResult result = makeSendSmsResult(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->sendSMSExpectMoreResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendSMSExpectMoreResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setupDataCallResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responseLen) {
-#if VDBG
-    RLOGD("setupDataCallResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        SetupDataCallResult result = {};
-
-        if (response == NULL || (responseLen % sizeof(RIL_Data_Call_Response_v11) != 0
-                && responseLen % sizeof(RIL_Data_Call_Response_v9) != 0
-                && responseLen % sizeof(RIL_Data_Call_Response_v6) != 0)) {
-            if (response != NULL) {
-                RLOGE("setupDataCallResponse: Invalid response");
-                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            }
-            result.status = DataCallFailCause::ERROR_UNSPECIFIED;
-            result.type = hidl_string();
-            result.ifname = hidl_string();
-            result.addresses = hidl_string();
-            result.dnses = hidl_string();
-            result.gateways = hidl_string();
-            result.pcscf = hidl_string();
-        } else if ((responseLen % sizeof(RIL_Data_Call_Response_v11)) == 0) {
-            convertRilDataCallToHal((RIL_Data_Call_Response_v11 *) response, result);
-        } else if ((responseLen % sizeof(RIL_Data_Call_Response_v9)) == 0) {
-            convertRilDataCallToHal((RIL_Data_Call_Response_v9 *) response, result);
-        } else if ((responseLen % sizeof(RIL_Data_Call_Response_v6)) == 0) {
-            convertRilDataCallToHal((RIL_Data_Call_Response_v6 *) response, result);
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->setupDataCallResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setupDataCallResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-IccIoResult responseIccIo(RadioResponseInfo& responseInfo, int serial, int responseType,
-                           RIL_Errno e, void *response, size_t responseLen) {
-    populateResponseInfo(responseInfo, serial, responseType, e);
-    IccIoResult result = {};
-
-    if (response == NULL || responseLen != sizeof(RIL_SIM_IO_Response)) {
-        RLOGE("Invalid response: NULL");
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        result.simResponse = hidl_string();
-    } else {
-        RIL_SIM_IO_Response *resp = (RIL_SIM_IO_Response *) response;
-        result.sw1 = resp->sw1;
-        result.sw2 = resp->sw2;
-        result.simResponse = convertCharPtrToHidlString(resp->simResponse);
-    }
-    return result;
-}
-
-int radio::iccIOForAppResponse(int slotId,
-                      int responseType, int serial, RIL_Errno e, void *response,
-                      size_t responseLen) {
-#if VDBG
-    RLOGD("iccIOForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        IccIoResult result = responseIccIo(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->iccIOForAppResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("iccIOForAppResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendUssdResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e, void *response,
-                           size_t responseLen) {
-#if VDBG
-    RLOGD("sendUssdResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->sendUssdResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendUssdResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::cancelPendingUssdResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responseLen) {
-#if VDBG
-    RLOGD("cancelPendingUssdResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->cancelPendingUssdResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cancelPendingUssdResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getClirResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responseLen) {
-#if VDBG
-    RLOGD("getClirResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        int n = -1, m = -1;
-        int numInts = responseLen / sizeof(int);
-        if (response == NULL || numInts < 2) {
-            RLOGE("getClirResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            n = pInt[0];
-            m = pInt[1];
-        }
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getClirResponse(responseInfo,
-                n, m);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getClirResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setClirResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responseLen) {
-#if VDBG
-    RLOGD("setClirResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->setClirResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setClirResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCallForwardStatusResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e,
-                                       void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getCallForwardStatusResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<CallForwardInfo> callForwardInfos;
-
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_CallForwardInfo *) != 0) {
-            RLOGE("getCallForwardStatusResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int num = responseLen / sizeof(RIL_CallForwardInfo *);
-            callForwardInfos.resize(num);
-            for (int i = 0 ; i < num; i++) {
-                RIL_CallForwardInfo *resp = ((RIL_CallForwardInfo **) response)[i];
-                callForwardInfos[i].status = (CallForwardInfoStatus) resp->status;
-                callForwardInfos[i].reason = resp->reason;
-                callForwardInfos[i].serviceClass = resp->serviceClass;
-                callForwardInfos[i].toa = resp->toa;
-                callForwardInfos[i].number = convertCharPtrToHidlString(resp->number);
-                callForwardInfos[i].timeSeconds = resp->timeSeconds;
-            }
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getCallForwardStatusResponse(
-                responseInfo, callForwardInfos);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCallForwardStatusResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCallForwardResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responseLen) {
-#if VDBG
-    RLOGD("setCallForwardResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->setCallForwardResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCallForwardResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCallWaitingResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responseLen) {
-#if VDBG
-    RLOGD("getCallWaitingResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        bool enable = false;
-        int serviceClass = -1;
-        int numInts = responseLen / sizeof(int);
-        if (response == NULL || numInts < 2) {
-            RLOGE("getCallWaitingResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            enable = pInt[0] == 1 ? true : false;
-            serviceClass = pInt[1];
-        }
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getCallWaitingResponse(
-                responseInfo, enable, serviceClass);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCallWaitingResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCallWaitingResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responseLen) {
-#if VDBG
-    RLOGD("setCallWaitingResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->setCallWaitingResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCallWaitingResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::acknowledgeLastIncomingGsmSmsResponse(int slotId,
-                                                int responseType, int serial, RIL_Errno e,
-                                                void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("acknowledgeLastIncomingGsmSmsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus =
-                radioService[slotId]->mRadioResponse->acknowledgeLastIncomingGsmSmsResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("acknowledgeLastIncomingGsmSmsResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::acceptCallResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e,
-                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("acceptCallResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->acceptCallResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("acceptCallResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::deactivateDataCallResponse(int slotId,
-                                                int responseType, int serial, RIL_Errno e,
-                                                void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("deactivateDataCallResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->deactivateDataCallResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("deactivateDataCallResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getFacilityLockForAppResponse(int slotId,
-                                        int responseType, int serial, RIL_Errno e,
-                                        void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getFacilityLockForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                getFacilityLockForAppResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getFacilityLockForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setFacilityLockForAppResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setFacilityLockForAppResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseIntOrEmpty(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setFacilityLockForAppResponse(responseInfo,
-                ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setFacilityLockForAppResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setBarringPasswordResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e,
-                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("acceptCallResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setBarringPasswordResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setBarringPasswordResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getNetworkSelectionModeResponse(int slotId,
-                                          int responseType, int serial, RIL_Errno e, void *response,
-                                          size_t responseLen) {
-#if VDBG
-    RLOGD("getNetworkSelectionModeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        bool manual = false;
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("getNetworkSelectionModeResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            manual = pInt[0] == 1 ? true : false;
-        }
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getNetworkSelectionModeResponse(
-                responseInfo,
-                manual);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getNetworkSelectionModeResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setNetworkSelectionModeAutomaticResponse(int slotId, int responseType, int serial,
-                                                    RIL_Errno e, void *response,
-                                                    size_t responseLen) {
-#if VDBG
-    RLOGD("setNetworkSelectionModeAutomaticResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setNetworkSelectionModeAutomaticResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setNetworkSelectionModeAutomaticResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setNetworkSelectionModeManualResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e,
-                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setNetworkSelectionModeManualResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setNetworkSelectionModeManualResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("acceptCallResponse: radioService[%d]->setNetworkSelectionModeManualResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int convertOperatorStatusToInt(const char *str) {
-    if (strncmp("unknown", str, 9) == 0) {
-        return (int) OperatorStatus::UNKNOWN;
-    } else if (strncmp("available", str, 9) == 0) {
-        return (int) OperatorStatus::AVAILABLE;
-    } else if (strncmp("current", str, 9) == 0) {
-        return (int) OperatorStatus::CURRENT;
-    } else if (strncmp("forbidden", str, 9) == 0) {
-        return (int) OperatorStatus::FORBIDDEN;
-    } else {
-        return -1;
-    }
-}
-
-int radio::getAvailableNetworksResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responseLen) {
-#if VDBG
-    RLOGD("getAvailableNetworksResponse: serial %d", serial);
-#endif
-    int qanRespStrings = property_get_int32("ro.ril.telephony.qan_resp_strings", 4);
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<OperatorInfo> networks;
-        if ((response == NULL && responseLen != 0)
-                || responseLen % (qanRespStrings * sizeof(char *)) != 0) {
-            RLOGE("getAvailableNetworksResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            char **resp = (char **) response;
-            int numStrings = responseLen / sizeof(char *);
-            networks.resize(numStrings/qanRespStrings);
-            for (int i = 0, j = 0; i < numStrings; i = i + qanRespStrings, j++) {
-                networks[j].alphaLong = convertCharPtrToHidlString(resp[i]);
-                networks[j].alphaShort = convertCharPtrToHidlString(resp[i + 1]);
-                networks[j].operatorNumeric = convertCharPtrToHidlString(resp[i + 2]);
-                int status = convertOperatorStatusToInt(resp[i + 3]);
-                if (status == -1) {
-                    if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-                } else {
-                    networks[j].status = (OperatorStatus) status;
-                }
-            }
-        }
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getAvailableNetworksResponse(responseInfo,
-                networks);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getAvailableNetworksResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::startDtmfResponse(int slotId,
-                            int responseType, int serial, RIL_Errno e,
-                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("startDtmfResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->startDtmfResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("startDtmfResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stopDtmfResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e,
-                           void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("stopDtmfResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->stopDtmfResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stopDtmfResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getBasebandVersionResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getBasebandVersionResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getBasebandVersionResponse(responseInfo,
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getBasebandVersionResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::separateConnectionResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("separateConnectionResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->separateConnectionResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("separateConnectionResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setMuteResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setMuteResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setMuteResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setMuteResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getMuteResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responseLen) {
-#if VDBG
-    RLOGD("getMuteResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        bool enable = false;
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("getMuteResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            enable = pInt[0] == 1 ? true : false;
-        }
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getMuteResponse(responseInfo,
-                enable);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getMuteResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getClipResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getClipResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getClipResponse(responseInfo,
-                (ClipStatus) ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getClipResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getDataCallListResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getDataCallListResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        hidl_vec<SetupDataCallResult> ret;
-        if ((response == NULL && responseLen != 0)
-                || (responseLen % sizeof(RIL_Data_Call_Response_v11) != 0
-                && responseLen % sizeof(RIL_Data_Call_Response_v9) != 0
-                && responseLen % sizeof(RIL_Data_Call_Response_v6) != 0)) {
-            RLOGE("getDataCallListResponse: invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            convertRilDataCallListToHal(response, responseLen, ret);
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getDataCallListResponse(
-                responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getDataCallListResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setSuppServiceNotificationsResponse(int slotId,
-                                              int responseType, int serial, RIL_Errno e,
-                                              void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setSuppServiceNotificationsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setSuppServiceNotificationsResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setSuppServiceNotificationsResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::deleteSmsOnSimResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("deleteSmsOnSimResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->deleteSmsOnSimResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("deleteSmsOnSimResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setBandModeResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setBandModeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setBandModeResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setBandModeResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::writeSmsToSimResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e,
-                                void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("writeSmsToSimResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->writeSmsToSimResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("writeSmsToSimResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getAvailableBandModesResponse(int slotId,
-                                        int responseType, int serial, RIL_Errno e, void *response,
-                                        size_t responseLen) {
-#if VDBG
-    RLOGD("getAvailableBandModesResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<RadioBandMode> modes;
-        if ((response == NULL && responseLen != 0)|| responseLen % sizeof(int) != 0) {
-            RLOGE("getAvailableBandModesResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            int numInts = responseLen / sizeof(int);
-            modes.resize(numInts);
-            for (int i = 0; i < numInts; i++) {
-                modes[i] = (RadioBandMode) pInt[i];
-            }
-        }
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getAvailableBandModesResponse(responseInfo,
-                modes);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getAvailableBandModesResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendEnvelopeResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("sendEnvelopeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendEnvelopeResponse(responseInfo,
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendEnvelopeResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendTerminalResponseToSimResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("sendTerminalResponseToSimResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendTerminalResponseToSimResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendTerminalResponseToSimResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::handleStkCallSetupRequestFromSimResponse(int slotId,
-                                                   int responseType, int serial,
-                                                   RIL_Errno e, void *response,
-                                                   size_t responseLen) {
-#if VDBG
-    RLOGD("handleStkCallSetupRequestFromSimResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->handleStkCallSetupRequestFromSimResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("handleStkCallSetupRequestFromSimResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::explicitCallTransferResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e,
-                                       void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("explicitCallTransferResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->explicitCallTransferResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("explicitCallTransferResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setPreferredNetworkTypeResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setPreferredNetworkTypeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setPreferredNetworkTypeResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setPreferredNetworkTypeResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-
-int radio::getPreferredNetworkTypeResponse(int slotId,
-                                          int responseType, int serial, RIL_Errno e,
-                                          void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getPreferredNetworkTypeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getPreferredNetworkTypeResponse(
-                responseInfo, (PreferredNetworkType) ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getPreferredNetworkTypeResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getNeighboringCidsResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getNeighboringCidsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<NeighboringCell> cells;
-
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_NeighboringCell *) != 0) {
-            RLOGE("getNeighboringCidsResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int num = responseLen / sizeof(RIL_NeighboringCell *);
-            cells.resize(num);
-            for (int i = 0 ; i < num; i++) {
-                RIL_NeighboringCell *resp = ((RIL_NeighboringCell **) response)[i];
-                cells[i].cid = convertCharPtrToHidlString(resp->cid);
-                cells[i].rssi = resp->rssi;
-            }
-        }
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getNeighboringCidsResponse(responseInfo,
-                cells);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getNeighboringCidsResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setLocationUpdatesResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setLocationUpdatesResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setLocationUpdatesResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setLocationUpdatesResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCdmaSubscriptionSourceResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setCdmaSubscriptionSourceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setCdmaSubscriptionSourceResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCdmaSubscriptionSourceResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCdmaRoamingPreferenceResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setCdmaRoamingPreferenceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setCdmaRoamingPreferenceResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCdmaRoamingPreferenceResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCdmaRoamingPreferenceResponse(int slotId,
-                                           int responseType, int serial, RIL_Errno e,
-                                           void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getCdmaRoamingPreferenceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getCdmaRoamingPreferenceResponse(
-                responseInfo, (CdmaRoamingType) ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCdmaRoamingPreferenceResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setTTYModeResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e,
-                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setTTYModeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setTTYModeResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setTTYModeResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getTTYModeResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e,
-                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getTTYModeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getTTYModeResponse(responseInfo,
-                (TtyMode) ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getTTYModeResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setPreferredVoicePrivacyResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setPreferredVoicePrivacyResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setPreferredVoicePrivacyResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setPreferredVoicePrivacyResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getPreferredVoicePrivacyResponse(int slotId,
-                                           int responseType, int serial, RIL_Errno e,
-                                           void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getPreferredVoicePrivacyResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        bool enable = false;
-        int numInts = responseLen / sizeof(int);
-        if (response == NULL || numInts < 1) {
-            RLOGE("getPreferredVoicePrivacyResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            enable = pInt[0] == 1 ? true : false;
-        }
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getPreferredVoicePrivacyResponse(
-                responseInfo, enable);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getPreferredVoicePrivacyResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendCDMAFeatureCodeResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("sendCDMAFeatureCodeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendCDMAFeatureCodeResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendCDMAFeatureCodeResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendBurstDtmfResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("sendBurstDtmfResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendBurstDtmfResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendBurstDtmfResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendCdmaSmsResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responseLen) {
-#if VDBG
-    RLOGD("sendCdmaSmsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        SendSmsResult result = makeSendSmsResult(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendCdmaSmsResponse(responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendCdmaSmsResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::acknowledgeLastIncomingCdmaSmsResponse(int slotId,
-                                                 int responseType, int serial, RIL_Errno e,
-                                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("acknowledgeLastIncomingCdmaSmsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->acknowledgeLastIncomingCdmaSmsResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("acknowledgeLastIncomingCdmaSmsResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getGsmBroadcastConfigResponse(int slotId,
-                                        int responseType, int serial, RIL_Errno e,
-                                        void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getGsmBroadcastConfigResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<GsmBroadcastSmsConfigInfo> configs;
-
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_GSM_BroadcastSmsConfigInfo *) != 0) {
-            RLOGE("getGsmBroadcastConfigResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int num = responseLen / sizeof(RIL_GSM_BroadcastSmsConfigInfo *);
-            configs.resize(num);
-            for (int i = 0 ; i < num; i++) {
-                RIL_GSM_BroadcastSmsConfigInfo *resp =
-                        ((RIL_GSM_BroadcastSmsConfigInfo **) response)[i];
-                configs[i].fromServiceId = resp->fromServiceId;
-                configs[i].toServiceId = resp->toServiceId;
-                configs[i].fromCodeScheme = resp->fromCodeScheme;
-                configs[i].toCodeScheme = resp->toCodeScheme;
-                configs[i].selected = resp->selected == 1 ? true : false;
-            }
-        }
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getGsmBroadcastConfigResponse(responseInfo,
-                configs);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getGsmBroadcastConfigResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setGsmBroadcastConfigResponse(int slotId,
-                                        int responseType, int serial, RIL_Errno e,
-                                        void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setGsmBroadcastConfigResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setGsmBroadcastConfigResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setGsmBroadcastConfigResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setGsmBroadcastActivationResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setGsmBroadcastActivationResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setGsmBroadcastActivationResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setGsmBroadcastActivationResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCdmaBroadcastConfigResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e,
-                                         void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getCdmaBroadcastConfigResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<CdmaBroadcastSmsConfigInfo> configs;
-
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_CDMA_BroadcastSmsConfigInfo *) != 0) {
-            RLOGE("getCdmaBroadcastConfigResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int num = responseLen / sizeof(RIL_CDMA_BroadcastSmsConfigInfo *);
-            configs.resize(num);
-            for (int i = 0 ; i < num; i++) {
-                RIL_CDMA_BroadcastSmsConfigInfo *resp =
-                        ((RIL_CDMA_BroadcastSmsConfigInfo **) response)[i];
-                configs[i].serviceCategory = resp->service_category;
-                configs[i].language = resp->language;
-                configs[i].selected = resp->selected == 1 ? true : false;
-            }
-        }
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getCdmaBroadcastConfigResponse(responseInfo,
-                configs);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCdmaBroadcastConfigResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCdmaBroadcastConfigResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e,
-                                         void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setCdmaBroadcastConfigResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setCdmaBroadcastConfigResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCdmaBroadcastConfigResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCdmaBroadcastActivationResponse(int slotId,
-                                             int responseType, int serial, RIL_Errno e,
-                                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setCdmaBroadcastActivationResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setCdmaBroadcastActivationResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCdmaBroadcastActivationResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCDMASubscriptionResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e, void *response,
-                                      size_t responseLen) {
-#if VDBG
-    RLOGD("getCDMASubscriptionResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        int numStrings = responseLen / sizeof(char *);
-        hidl_string emptyString;
-        if (response == NULL || numStrings < 5) {
-            RLOGE("getOperatorResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            Return<void> retStatus
-                    = radioService[slotId]->mRadioResponse->getCDMASubscriptionResponse(
-                    responseInfo, emptyString, emptyString, emptyString, emptyString, emptyString);
-            radioService[slotId]->checkReturnStatus(retStatus);
-        } else {
-            char **resp = (char **) response;
-            Return<void> retStatus
-                    = radioService[slotId]->mRadioResponse->getCDMASubscriptionResponse(
-                    responseInfo,
-                    convertCharPtrToHidlString(resp[0]),
-                    convertCharPtrToHidlString(resp[1]),
-                    convertCharPtrToHidlString(resp[2]),
-                    convertCharPtrToHidlString(resp[3]),
-                    convertCharPtrToHidlString(resp[4]));
-            radioService[slotId]->checkReturnStatus(retStatus);
-        }
-    } else {
-        RLOGE("getCDMASubscriptionResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::writeSmsToRuimResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("writeSmsToRuimResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->writeSmsToRuimResponse(responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("writeSmsToRuimResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::deleteSmsOnRuimResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("deleteSmsOnRuimResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->deleteSmsOnRuimResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("deleteSmsOnRuimResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getDeviceIdentityResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responseLen) {
-#if VDBG
-    RLOGD("getDeviceIdentityResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        int numStrings = responseLen / sizeof(char *);
-        hidl_string emptyString;
-        if (response == NULL || numStrings < 4) {
-            RLOGE("getDeviceIdentityResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            Return<void> retStatus
-                    = radioService[slotId]->mRadioResponse->getDeviceIdentityResponse(responseInfo,
-                    emptyString, emptyString, emptyString, emptyString);
-            radioService[slotId]->checkReturnStatus(retStatus);
-        } else {
-            char **resp = (char **) response;
-            Return<void> retStatus
-                    = radioService[slotId]->mRadioResponse->getDeviceIdentityResponse(responseInfo,
-                    convertCharPtrToHidlString(resp[0]),
-                    convertCharPtrToHidlString(resp[1]),
-                    convertCharPtrToHidlString(resp[2]),
-                    convertCharPtrToHidlString(resp[3]));
-            radioService[slotId]->checkReturnStatus(retStatus);
-        }
-    } else {
-        RLOGE("getDeviceIdentityResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::exitEmergencyCallbackModeResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("exitEmergencyCallbackModeResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->exitEmergencyCallbackModeResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("exitEmergencyCallbackModeResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getSmscAddressResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getSmscAddressResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getSmscAddressResponse(responseInfo,
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getSmscAddressResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setSmscAddressResponse(int slotId,
-                                             int responseType, int serial, RIL_Errno e,
-                                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setSmscAddressResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setSmscAddressResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setSmscAddressResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::reportSmsMemoryStatusResponse(int slotId,
-                                        int responseType, int serial, RIL_Errno e,
-                                        void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("reportSmsMemoryStatusResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->reportSmsMemoryStatusResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("reportSmsMemoryStatusResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::reportStkServiceIsRunningResponse(int slotId,
-                                             int responseType, int serial, RIL_Errno e,
-                                             void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("reportStkServiceIsRunningResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->
-                reportStkServiceIsRunningResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("reportStkServiceIsRunningResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCdmaSubscriptionSourceResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getCdmaSubscriptionSourceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getCdmaSubscriptionSourceResponse(
-                responseInfo, (CdmaSubscriptionSource) ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCdmaSubscriptionSourceResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::requestIsimAuthenticationResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("requestIsimAuthenticationResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->requestIsimAuthenticationResponse(
-                responseInfo,
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("requestIsimAuthenticationResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::acknowledgeIncomingGsmSmsWithPduResponse(int slotId,
-                                                   int responseType,
-                                                   int serial, RIL_Errno e, void *response,
-                                                   size_t responseLen) {
-#if VDBG
-    RLOGD("acknowledgeIncomingGsmSmsWithPduResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->acknowledgeIncomingGsmSmsWithPduResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("acknowledgeIncomingGsmSmsWithPduResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendEnvelopeWithStatusResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e, void *response,
-                                         size_t responseLen) {
-#if VDBG
-    RLOGD("sendEnvelopeWithStatusResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        IccIoResult result = responseIccIo(responseInfo, serial, responseType, e,
-                response, responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendEnvelopeWithStatusResponse(responseInfo,
-                result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendEnvelopeWithStatusResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getVoiceRadioTechnologyResponse(int slotId,
-                                          int responseType, int serial, RIL_Errno e,
-                                          void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getVoiceRadioTechnologyResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getVoiceRadioTechnologyResponse(
-                responseInfo, (RadioTechnology) ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getVoiceRadioTechnologyResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getCellInfoListResponse(int slotId,
-                                   int responseType,
-                                   int serial, RIL_Errno e, void *response,
-                                   size_t responseLen) {
-#if VDBG
-    RLOGD("getCellInfoListResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        hidl_vec<CellInfo> ret;
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_CellInfo_v12) != 0) {
-            RLOGE("getCellInfoListResponse: Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            convertRilCellInfoListToHal(response, responseLen, ret);
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getCellInfoListResponse(
-                responseInfo, ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getCellInfoListResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCellInfoListRateResponse(int slotId,
-                                       int responseType,
-                                       int serial, RIL_Errno e, void *response,
-                                       size_t responseLen) {
-#if VDBG
-    RLOGD("setCellInfoListRateResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setCellInfoListRateResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCellInfoListRateResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setInitialAttachApnResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e,
-                                       void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setInitialAttachApnResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setInitialAttachApnResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setInitialAttachApnResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getImsRegistrationStateResponse(int slotId,
-                                           int responseType, int serial, RIL_Errno e,
-                                           void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getImsRegistrationStateResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        bool isRegistered = false;
-        int ratFamily = 0;
-        int numInts = responseLen / sizeof(int);
-        if (response == NULL || numInts < 2) {
-            RLOGE("getImsRegistrationStateResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            int *pInt = (int *) response;
-            isRegistered = pInt[0] == 1 ? true : false;
-            ratFamily = pInt[1];
-        }
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getImsRegistrationStateResponse(
-                responseInfo, isRegistered, (RadioTechnologyFamily) ratFamily);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getImsRegistrationStateResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendImsSmsResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responseLen) {
-#if VDBG
-    RLOGD("sendImsSmsResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        SendSmsResult result = makeSendSmsResult(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendImsSmsResponse(responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendSmsResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::iccTransmitApduBasicChannelResponse(int slotId,
-                                               int responseType, int serial, RIL_Errno e,
-                                               void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("iccTransmitApduBasicChannelResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        IccIoResult result = responseIccIo(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->iccTransmitApduBasicChannelResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("iccTransmitApduBasicChannelResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::iccOpenLogicalChannelResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e, void *response,
-                                         size_t responseLen) {
-#if VDBG
-    RLOGD("iccOpenLogicalChannelResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        int channelId = -1;
-        hidl_vec<int8_t> selectResponse;
-        int numInts = responseLen / sizeof(int);
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("iccOpenLogicalChannelResponse Invalid response: NULL");
-            if (response != NULL) {
-                if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-            }
-        } else {
-            int *pInt = (int *) response;
-            channelId = pInt[0];
-            selectResponse.resize(numInts - 1);
-            for (int i = 1; i < numInts; i++) {
-                selectResponse[i - 1] = (int8_t) pInt[i];
-            }
-        }
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->iccOpenLogicalChannelResponse(responseInfo,
-                channelId, selectResponse);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("iccOpenLogicalChannelResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::iccCloseLogicalChannelResponse(int slotId,
-                                          int responseType, int serial, RIL_Errno e,
-                                          void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("iccCloseLogicalChannelResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->iccCloseLogicalChannelResponse(
-                responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("iccCloseLogicalChannelResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::iccTransmitApduLogicalChannelResponse(int slotId,
-                                                 int responseType, int serial, RIL_Errno e,
-                                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("iccTransmitApduLogicalChannelResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        IccIoResult result = responseIccIo(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->iccTransmitApduLogicalChannelResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("iccTransmitApduLogicalChannelResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::nvReadItemResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("nvReadItemResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->nvReadItemResponse(
-                responseInfo,
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("nvReadItemResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::nvWriteItemResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("nvWriteItemResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->nvWriteItemResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("nvWriteItemResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::nvWriteCdmaPrlResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("nvWriteCdmaPrlResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->nvWriteCdmaPrlResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("nvWriteCdmaPrlResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::nvResetConfigResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("nvResetConfigResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->nvResetConfigResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("nvResetConfigResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setUiccSubscriptionResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e,
-                                       void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setUiccSubscriptionResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setUiccSubscriptionResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setUiccSubscriptionResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setDataAllowedResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setDataAllowedResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setDataAllowedResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setDataAllowedResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getHardwareConfigResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getHardwareConfigResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        hidl_vec<HardwareConfig> result;
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_HardwareConfig) != 0) {
-            RLOGE("hardwareConfigChangedInd: invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            convertRilHardwareConfigListToHal(response, responseLen, result);
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getHardwareConfigResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getHardwareConfigResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::requestIccSimAuthenticationResponse(int slotId,
-                                               int responseType, int serial, RIL_Errno e,
-                                               void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("requestIccSimAuthenticationResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        IccIoResult result = responseIccIo(responseInfo, serial, responseType, e, response,
-                responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->requestIccSimAuthenticationResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("requestIccSimAuthenticationResponse: radioService[%d]->mRadioResponse "
-                "== NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setDataProfileResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setDataProfileResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setDataProfileResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setDataProfileResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::requestShutdownResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("requestShutdownResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->requestShutdownResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("requestShutdownResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-void responseRadioCapability(RadioResponseInfo& responseInfo, int serial,
-        int responseType, RIL_Errno e, void *response, size_t responseLen, RadioCapability& rc) {
-    populateResponseInfo(responseInfo, serial, responseType, e);
-
-    if (response == NULL || responseLen != sizeof(RIL_RadioCapability)) {
-        RLOGE("responseRadioCapability: Invalid response");
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        rc.logicalModemUuid = hidl_string();
-    } else {
-        convertRilRadioCapabilityToHal(response, responseLen, rc);
-    }
-}
-
-int radio::getRadioCapabilityResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getRadioCapabilityResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        RadioCapability result = {};
-        responseRadioCapability(responseInfo, serial, responseType, e, response, responseLen,
-                result);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->getRadioCapabilityResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getRadioCapabilityResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setRadioCapabilityResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e,
-                                     void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setRadioCapabilityResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        RadioCapability result = {};
-        responseRadioCapability(responseInfo, serial, responseType, e, response, responseLen,
-                result);
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->setRadioCapabilityResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setRadioCapabilityResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-LceStatusInfo responseLceStatusInfo(RadioResponseInfo& responseInfo, int serial, int responseType,
-                                    RIL_Errno e, void *response, size_t responseLen) {
-    populateResponseInfo(responseInfo, serial, responseType, e);
-    LceStatusInfo result = {};
-
-    if (response == NULL || responseLen != sizeof(RIL_LceStatusInfo)) {
-        RLOGE("Invalid response: NULL");
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-    } else {
-        RIL_LceStatusInfo *resp = (RIL_LceStatusInfo *) response;
-        result.lceStatus = (LceStatus) resp->lce_status;
-        result.actualIntervalMs = (uint8_t) resp->actual_interval_ms;
-    }
-    return result;
-}
-
-int radio::startLceServiceResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("startLceServiceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        LceStatusInfo result = responseLceStatusInfo(responseInfo, serial, responseType, e,
-                response, responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->startLceServiceResponse(responseInfo,
-                result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("startLceServiceResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stopLceServiceResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("stopLceServiceResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        LceStatusInfo result = responseLceStatusInfo(responseInfo, serial, responseType, e,
-                response, responseLen);
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->stopLceServiceResponse(responseInfo,
-                result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stopLceServiceResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::pullLceDataResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("pullLceDataResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-
-        LceDataInfo result = {};
-        if (response == NULL || responseLen != sizeof(RIL_LceDataInfo)) {
-            RLOGE("pullLceDataResponse: Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            convertRilLceDataInfoToHal(response, responseLen, result);
-        }
-
-        Return<void> retStatus = radioService[slotId]->mRadioResponse->pullLceDataResponse(
-                responseInfo, result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("pullLceDataResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::getModemActivityInfoResponse(int slotId,
-                                        int responseType, int serial, RIL_Errno e,
-                                        void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getModemActivityInfoResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        ActivityStatsInfo info;
-        if (response == NULL || responseLen != sizeof(RIL_ActivityStatsInfo)) {
-            RLOGE("getModemActivityInfoResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            RIL_ActivityStatsInfo *resp = (RIL_ActivityStatsInfo *)response;
-            info.sleepModeTimeMs = resp->sleep_mode_time_ms;
-            info.idleModeTimeMs = resp->idle_mode_time_ms;
-            for(int i = 0; i < RIL_NUM_TX_POWER_LEVELS; i++) {
-                info.txmModetimeMs[i] = resp->tx_mode_time_ms[i];
-            }
-            info.rxModeTimeMs = resp->rx_mode_time_ms;
-        }
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getModemActivityInfoResponse(responseInfo,
-                info);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getModemActivityInfoResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setAllowedCarriersResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setAllowedCarriersResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        int ret = responseInt(responseInfo, serial, responseType, e, response, responseLen);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setAllowedCarriersResponse(responseInfo,
-                ret);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setAllowedCarriersResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::getAllowedCarriersResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("getAllowedCarriersResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        CarrierRestrictions carrierInfo = {};
-        bool allAllowed = true;
-        if (response == NULL) {
-#if VDBG
-            RLOGD("getAllowedCarriersResponse response is NULL: all allowed");
-#endif
-            carrierInfo.allowedCarriers.resize(0);
-            carrierInfo.excludedCarriers.resize(0);
-        } else if (responseLen != sizeof(RIL_CarrierRestrictions)) {
-            RLOGE("getAllowedCarriersResponse Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            RIL_CarrierRestrictions *pCr = (RIL_CarrierRestrictions *)response;
-            if (pCr->len_allowed_carriers > 0 || pCr->len_excluded_carriers > 0) {
-                allAllowed = false;
-            }
-
-            carrierInfo.allowedCarriers.resize(pCr->len_allowed_carriers);
-            for(int i = 0; i < pCr->len_allowed_carriers; i++) {
-                RIL_Carrier *carrier = pCr->allowed_carriers + i;
-                carrierInfo.allowedCarriers[i].mcc = convertCharPtrToHidlString(carrier->mcc);
-                carrierInfo.allowedCarriers[i].mnc = convertCharPtrToHidlString(carrier->mnc);
-                carrierInfo.allowedCarriers[i].matchType = (CarrierMatchType) carrier->match_type;
-                carrierInfo.allowedCarriers[i].matchData =
-                        convertCharPtrToHidlString(carrier->match_data);
-            }
-
-            carrierInfo.excludedCarriers.resize(pCr->len_excluded_carriers);
-            for(int i = 0; i < pCr->len_excluded_carriers; i++) {
-                RIL_Carrier *carrier = pCr->excluded_carriers + i;
-                carrierInfo.excludedCarriers[i].mcc = convertCharPtrToHidlString(carrier->mcc);
-                carrierInfo.excludedCarriers[i].mnc = convertCharPtrToHidlString(carrier->mnc);
-                carrierInfo.excludedCarriers[i].matchType = (CarrierMatchType) carrier->match_type;
-                carrierInfo.excludedCarriers[i].matchData =
-                        convertCharPtrToHidlString(carrier->match_data);
-            }
-        }
-
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->getAllowedCarriersResponse(responseInfo,
-                allAllowed, carrierInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("getAllowedCarriersResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendDeviceStateResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen) {
-#if VDBG
-    RLOGD("sendDeviceStateResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->sendDeviceStateResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("sendDeviceStateResponse: radioService[%d]->mRadioResponse == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::setCarrierInfoForImsiEncryptionResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen) {
-    RLOGD("setCarrierInfoForImsiEncryptionResponse: serial %d", serial);
-    if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus = radioService[slotId]->mRadioResponseV1_1->
-                setCarrierInfoForImsiEncryptionResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setCarrierInfoForImsiEncryptionResponse: radioService[%d]->mRadioResponseV1_1 == "
-                "NULL", slotId);
-    }
-    return 0;
-}
-
-int radio::setIndicationFilterResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen) {
-#if VDBG
-    RLOGD("setIndicationFilterResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponse->setIndicationFilterResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("setIndicationFilterResponse: radioService[%d]->mRadioResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::setSimCardPowerResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("setSimCardPowerResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponse != NULL
-            || radioService[slotId]->mRadioResponseV1_1 != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
-            Return<void> retStatus = radioService[slotId]->mRadioResponseV1_1->
-                    setSimCardPowerResponse_1_1(responseInfo);
-            radioService[slotId]->checkReturnStatus(retStatus);
-        } else {
-            RLOGD("setSimCardPowerResponse: radioService[%d]->mRadioResponseV1_1 == NULL",
-                    slotId);
-            Return<void> retStatus
-                    = radioService[slotId]->mRadioResponse->setSimCardPowerResponse(responseInfo);
-            radioService[slotId]->checkReturnStatus(retStatus);
-        }
-    } else {
-        RLOGE("setSimCardPowerResponse: radioService[%d]->mRadioResponse == NULL && "
-                "radioService[%d]->mRadioResponseV1_1 == NULL", slotId, slotId);
-    }
-    return 0;
-}
-
-int radio::startNetworkScanResponse(int slotId, int responseType, int serial, RIL_Errno e,
-                                    void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("startNetworkScanResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponseV1_1->startNetworkScanResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("startNetworkScanResponse: radioService[%d]->mRadioResponseV1_1 == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stopNetworkScanResponse(int slotId, int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("stopNetworkScanResponse: serial %d", serial);
-#endif
-
-    if (radioService[slotId]->mRadioResponseV1_1 != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        Return<void> retStatus
-                = radioService[slotId]->mRadioResponseV1_1->stopNetworkScanResponse(responseInfo);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stopNetworkScanResponse: radioService[%d]->mRadioResponseV1_1 == NULL", slotId);
-    }
-
-    return 0;
-}
-
-void convertRilKeepaliveStatusToHal(const RIL_KeepaliveStatus *rilStatus,
-        V1_1::KeepaliveStatus& halStatus) {
-    halStatus.sessionHandle = rilStatus->sessionHandle;
-    halStatus.code = static_cast<V1_1::KeepaliveStatusCode>(rilStatus->code);
-}
-
-int radio::startKeepaliveResponse(int slotId, int responseType, int serial, RIL_Errno e,
-                                    void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("%s(): %d", __FUNCTION__, serial);
-#endif
-    RadioResponseInfo responseInfo = {};
-    populateResponseInfo(responseInfo, serial, responseType, e);
-
-    // If we don't have a radio service, there's nothing we can do
-    if (radioService[slotId]->mRadioResponseV1_1 == NULL) {
-        RLOGE("%s: radioService[%d]->mRadioResponseV1_1 == NULL", __FUNCTION__, slotId);
-        return 0;
-    }
-
-    V1_1::KeepaliveStatus ks = {};
-    if (response == NULL || responseLen != sizeof(V1_1::KeepaliveStatus)) {
-        RLOGE("%s: invalid response - %d", __FUNCTION__, static_cast<int>(e));
-        if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-    } else {
-        convertRilKeepaliveStatusToHal(static_cast<RIL_KeepaliveStatus*>(response), ks);
-    }
-
-    Return<void> retStatus =
-            radioService[slotId]->mRadioResponseV1_1->startKeepaliveResponse(responseInfo, ks);
-    radioService[slotId]->checkReturnStatus(retStatus);
-    return 0;
-}
-
-int radio::stopKeepaliveResponse(int slotId, int responseType, int serial, RIL_Errno e,
-                                    void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("%s(): %d", __FUNCTION__, serial);
-#endif
-    RadioResponseInfo responseInfo = {};
-    populateResponseInfo(responseInfo, serial, responseType, e);
-
-    // If we don't have a radio service, there's nothing we can do
-    if (radioService[slotId]->mRadioResponseV1_1 == NULL) {
-        RLOGE("%s: radioService[%d]->mRadioResponseV1_1 == NULL", __FUNCTION__, slotId);
-        return 0;
-    }
-
-    Return<void> retStatus =
-            radioService[slotId]->mRadioResponseV1_1->stopKeepaliveResponse(responseInfo);
-    radioService[slotId]->checkReturnStatus(retStatus);
-    return 0;
-}
-
-int radio::sendRequestRawResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responseLen) {
-#if VDBG
-   RLOGD("sendRequestRawResponse: serial %d", serial);
-#endif
-
-    if (oemHookService[slotId]->mOemHookResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<uint8_t> data;
-
-        if (response == NULL) {
-            RLOGE("sendRequestRawResponse: Invalid response");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            data.setToExternal((uint8_t *) response, responseLen);
-        }
-        Return<void> retStatus = oemHookService[slotId]->mOemHookResponse->
-                sendRequestRawResponse(responseInfo, data);
-        checkReturnStatus(slotId, retStatus, false);
-    } else {
-        RLOGE("sendRequestRawResponse: oemHookService[%d]->mOemHookResponse == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::sendRequestStringsResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen) {
-#if VDBG
-    RLOGD("sendRequestStringsResponse: serial %d", serial);
-#endif
-
-    if (oemHookService[slotId]->mOemHookResponse != NULL) {
-        RadioResponseInfo responseInfo = {};
-        populateResponseInfo(responseInfo, serial, responseType, e);
-        hidl_vec<hidl_string> data;
-
-        if ((response == NULL && responseLen != 0) || responseLen % sizeof(char *) != 0) {
-            RLOGE("sendRequestStringsResponse Invalid response: NULL");
-            if (e == RIL_E_SUCCESS) responseInfo.error = RadioError::INVALID_RESPONSE;
-        } else {
-            char **resp = (char **) response;
-            int numStrings = responseLen / sizeof(char *);
-            data.resize(numStrings);
-            for (int i = 0; i < numStrings; i++) {
-                data[i] = convertCharPtrToHidlString(resp[i]);
-            }
-        }
-        Return<void> retStatus
-                = oemHookService[slotId]->mOemHookResponse->sendRequestStringsResponse(
-                responseInfo, data);
-        checkReturnStatus(slotId, retStatus, false);
-    } else {
-        RLOGE("sendRequestStringsResponse: oemHookService[%d]->mOemHookResponse == "
-                "NULL", slotId);
-    }
-
-    return 0;
-}
-
-/***************************************************************************************************
- * INDICATION FUNCTIONS
- * The below function handle unsolicited messages coming from the Radio
- * (messages for which there is no pending request)
- **************************************************************************************************/
-
-RadioIndicationType convertIntToRadioIndicationType(int indicationType) {
-    return indicationType == RESPONSE_UNSOLICITED ? (RadioIndicationType::UNSOLICITED) :
-            (RadioIndicationType::UNSOLICITED_ACK_EXP);
-}
-
-int radio::radioStateChangedInd(int slotId,
-                                 int indicationType, int token, RIL_Errno e, void *response,
-                                 size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        RadioState radioState =
-                (RadioState) CALL_ONSTATEREQUEST(slotId);
-        RLOGD("radioStateChangedInd: radioState %d", radioState);
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->radioStateChanged(
-                convertIntToRadioIndicationType(indicationType), radioState);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("radioStateChangedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::callStateChangedInd(int slotId,
-                               int indicationType, int token, RIL_Errno e, void *response,
-                               size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("callStateChangedInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->callStateChanged(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("callStateChangedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::networkStateChangedInd(int slotId,
-                                  int indicationType, int token, RIL_Errno e, void *response,
-                                  size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("networkStateChangedInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->networkStateChanged(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("networkStateChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-uint8_t hexCharToInt(uint8_t c) {
-    if (c >= '0' && c <= '9') return (c - '0');
-    if (c >= 'A' && c <= 'F') return (c - 'A' + 10);
-    if (c >= 'a' && c <= 'f') return (c - 'a' + 10);
-
-    return INVALID_HEX_CHAR;
-}
-
-uint8_t * convertHexStringToBytes(void *response, size_t responseLen) {
-    if (responseLen % 2 != 0) {
-        return NULL;
-    }
-
-    uint8_t *bytes = (uint8_t *)calloc(responseLen/2, sizeof(uint8_t));
-    if (bytes == NULL) {
-        RLOGE("convertHexStringToBytes: cannot allocate memory for bytes string");
-        return NULL;
-    }
-    uint8_t *hexString = (uint8_t *)response;
-
-    for (size_t i = 0; i < responseLen; i += 2) {
-        uint8_t hexChar1 = hexCharToInt(hexString[i]);
-        uint8_t hexChar2 = hexCharToInt(hexString[i + 1]);
-
-        if (hexChar1 == INVALID_HEX_CHAR || hexChar2 == INVALID_HEX_CHAR) {
-            RLOGE("convertHexStringToBytes: invalid hex char %d %d",
-                    hexString[i], hexString[i + 1]);
-            free(bytes);
-            return NULL;
-        }
-        bytes[i/2] = ((hexChar1 << 4) | hexChar2);
-    }
-
-    return bytes;
-}
-
-int radio::newSmsInd(int slotId, int indicationType,
-                     int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("newSmsInd: invalid response");
-            return 0;
-        }
-
-        uint8_t *bytes = convertHexStringToBytes(response, responseLen);
-        if (bytes == NULL) {
-            RLOGE("newSmsInd: convertHexStringToBytes failed");
-            return 0;
-        }
-
-        hidl_vec<uint8_t> pdu;
-        pdu.setToExternal(bytes, responseLen/2);
-#if VDBG
-        RLOGD("newSmsInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->newSms(
-                convertIntToRadioIndicationType(indicationType), pdu);
-        radioService[slotId]->checkReturnStatus(retStatus);
-        free(bytes);
-    } else {
-        RLOGE("newSmsInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::newSmsStatusReportInd(int slotId,
-                                 int indicationType, int token, RIL_Errno e, void *response,
-                                 size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("newSmsStatusReportInd: invalid response");
-            return 0;
-        }
-
-        uint8_t *bytes = convertHexStringToBytes(response, responseLen);
-        if (bytes == NULL) {
-            RLOGE("newSmsStatusReportInd: convertHexStringToBytes failed");
-            return 0;
-        }
-
-        hidl_vec<uint8_t> pdu;
-        pdu.setToExternal(bytes, responseLen/2);
-#if VDBG
-        RLOGD("newSmsStatusReportInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->newSmsStatusReport(
-                convertIntToRadioIndicationType(indicationType), pdu);
-        radioService[slotId]->checkReturnStatus(retStatus);
-        free(bytes);
-    } else {
-        RLOGE("newSmsStatusReportInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::newSmsOnSimInd(int slotId, int indicationType,
-                          int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("newSmsOnSimInd: invalid response");
-            return 0;
-        }
-        int32_t recordNumber = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("newSmsOnSimInd: slotIndex %d", recordNumber);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->newSmsOnSim(
-                convertIntToRadioIndicationType(indicationType), recordNumber);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("newSmsOnSimInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::onUssdInd(int slotId, int indicationType,
-                     int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen < 2 * sizeof(char *)) {
-            RLOGE("onUssdInd: invalid response");
-            return 0;
-        }
-        char **strings = (char **) response;
-        char *mode = strings[0];
-        hidl_string msg = convertCharPtrToHidlString(strings[1]);
-        UssdModeType modeType = (UssdModeType) atoi(mode);
-#if VDBG
-        RLOGD("onUssdInd: mode %s", mode);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->onUssd(
-                convertIntToRadioIndicationType(indicationType), modeType, msg);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("onUssdInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::nitzTimeReceivedInd(int slotId,
-                               int indicationType, int token, RIL_Errno e, void *response,
-                               size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("nitzTimeReceivedInd: invalid response");
-            return 0;
-        }
-        hidl_string nitzTime;
-        int64_t timeReceived = android::elapsedRealtime();
-        char *resp = strndup((char *) response, responseLen);
-        char *tmp = resp;
-
-        /* Find the 3rd comma */
-        for (int i = 0; i < 3; i++) {
-            if (tmp != NULL) {
-                tmp = strchr(tmp + 1, ',');
-            }
-        }
-
-        /* Make the 3rd comma the end of the string */
-        if (tmp != NULL) {
-            *tmp = '\0';
-        }
-
-        nitzTime = convertCharPtrToHidlString(resp);
-        free(resp);
-#if VDBG
-        RLOGD("nitzTimeReceivedInd: nitzTime %s receivedTime %" PRId64, nitzTime.c_str(),
-                timeReceived);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->nitzTimeReceived(
-                convertIntToRadioIndicationType(indicationType), nitzTime, timeReceived);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("nitzTimeReceivedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-        return -1;
-    }
-
-    return 0;
-}
-
-void convertRilSignalStrengthToHalV8(void *response, size_t responseLen,
-        SignalStrength& signalStrength) {
-    RIL_SignalStrength_v8 *rilSignalStrength = (RIL_SignalStrength_v8 *) response;
-
-    // Fixup LTE for backwards compatibility
-    // signalStrength: -1 -> 99
-    if (rilSignalStrength->LTE_SignalStrength.signalStrength == -1) {
-        rilSignalStrength->LTE_SignalStrength.signalStrength = 99;
-    }
-    // rsrp: -1 -> INT_MAX all other negative value to positive.
-    // So remap here
-    if (rilSignalStrength->LTE_SignalStrength.rsrp == -1) {
-        rilSignalStrength->LTE_SignalStrength.rsrp = INT_MAX;
-    } else if (rilSignalStrength->LTE_SignalStrength.rsrp < -1) {
-        rilSignalStrength->LTE_SignalStrength.rsrp = -rilSignalStrength->LTE_SignalStrength.rsrp;
-    }
-    // rsrq: -1 -> INT_MAX
-    if (rilSignalStrength->LTE_SignalStrength.rsrq == -1) {
-        rilSignalStrength->LTE_SignalStrength.rsrq = INT_MAX;
-    }
-    // Not remapping rssnr is already using INT_MAX
-    // cqi: -1 -> INT_MAX
-    if (rilSignalStrength->LTE_SignalStrength.cqi == -1) {
-        rilSignalStrength->LTE_SignalStrength.cqi = INT_MAX;
-    }
-
-    signalStrength.gw.signalStrength = rilSignalStrength->GW_SignalStrength.signalStrength;
-    signalStrength.gw.bitErrorRate = rilSignalStrength->GW_SignalStrength.bitErrorRate;
-    signalStrength.cdma.dbm = rilSignalStrength->CDMA_SignalStrength.dbm;
-    signalStrength.cdma.ecio = rilSignalStrength->CDMA_SignalStrength.ecio;
-    signalStrength.evdo.dbm = rilSignalStrength->EVDO_SignalStrength.dbm;
-    signalStrength.evdo.ecio = rilSignalStrength->EVDO_SignalStrength.ecio;
-    signalStrength.evdo.signalNoiseRatio =
-            rilSignalStrength->EVDO_SignalStrength.signalNoiseRatio;
-    signalStrength.lte.signalStrength = rilSignalStrength->LTE_SignalStrength.signalStrength;
-    signalStrength.lte.rsrp = rilSignalStrength->LTE_SignalStrength.rsrp;
-    signalStrength.lte.rsrq = rilSignalStrength->LTE_SignalStrength.rsrq;
-    signalStrength.lte.rssnr = rilSignalStrength->LTE_SignalStrength.rssnr;
-    signalStrength.lte.cqi = rilSignalStrength->LTE_SignalStrength.cqi;
-    signalStrength.lte.timingAdvance = rilSignalStrength->LTE_SignalStrength.timingAdvance;
-    signalStrength.tdScdma.rscp = INT_MAX;
-}
-
-void convertRilSignalStrengthToHalV10(void *response, size_t responseLen,
-        SignalStrength& signalStrength) {
-    RIL_SignalStrength_v10 *rilSignalStrength = (RIL_SignalStrength_v10 *) response;
-
-    // Fixup LTE for backwards compatibility
-    // signalStrength: -1 -> 99
-    if (rilSignalStrength->LTE_SignalStrength.signalStrength == -1) {
-        rilSignalStrength->LTE_SignalStrength.signalStrength = 99;
-    }
-    // rsrp: -1 -> INT_MAX all other negative value to positive.
-    // So remap here
-    if (rilSignalStrength->LTE_SignalStrength.rsrp == -1) {
-        rilSignalStrength->LTE_SignalStrength.rsrp = INT_MAX;
-    } else if (rilSignalStrength->LTE_SignalStrength.rsrp < -1) {
-        rilSignalStrength->LTE_SignalStrength.rsrp = -rilSignalStrength->LTE_SignalStrength.rsrp;
-    }
-    // rsrq: -1 -> INT_MAX
-    if (rilSignalStrength->LTE_SignalStrength.rsrq == -1) {
-        rilSignalStrength->LTE_SignalStrength.rsrq = INT_MAX;
-    }
-    // Not remapping rssnr is already using INT_MAX
-    // cqi: -1 -> INT_MAX
-    if (rilSignalStrength->LTE_SignalStrength.cqi == -1) {
-        rilSignalStrength->LTE_SignalStrength.cqi = INT_MAX;
-    }
-
-    signalStrength.gw.signalStrength = rilSignalStrength->GW_SignalStrength.signalStrength;
-    signalStrength.gw.bitErrorRate = rilSignalStrength->GW_SignalStrength.bitErrorRate;
-    signalStrength.cdma.dbm = rilSignalStrength->CDMA_SignalStrength.dbm;
-    signalStrength.cdma.ecio = rilSignalStrength->CDMA_SignalStrength.ecio;
-    signalStrength.evdo.dbm = rilSignalStrength->EVDO_SignalStrength.dbm;
-    signalStrength.evdo.ecio = rilSignalStrength->EVDO_SignalStrength.ecio;
-    signalStrength.evdo.signalNoiseRatio =
-            rilSignalStrength->EVDO_SignalStrength.signalNoiseRatio;
-    signalStrength.lte.signalStrength = rilSignalStrength->LTE_SignalStrength.signalStrength;
-    signalStrength.lte.rsrp = rilSignalStrength->LTE_SignalStrength.rsrp;
-    signalStrength.lte.rsrq = rilSignalStrength->LTE_SignalStrength.rsrq;
-    signalStrength.lte.rssnr = rilSignalStrength->LTE_SignalStrength.rssnr;
-    signalStrength.lte.cqi = rilSignalStrength->LTE_SignalStrength.cqi;
-    signalStrength.lte.timingAdvance = rilSignalStrength->LTE_SignalStrength.timingAdvance;
-    signalStrength.tdScdma.rscp = rilSignalStrength->TD_SCDMA_SignalStrength.rscp;
-}
-
-void convertRilSignalStrengthToHal(void *response, size_t responseLen,
-        SignalStrength& signalStrength) {
-    if (responseLen == sizeof(RIL_SignalStrength_v8)) {
-        convertRilSignalStrengthToHalV8(response, responseLen, signalStrength);
-    } else {
-        convertRilSignalStrengthToHalV10(response, responseLen, signalStrength);
-    }
-}
-
-int radio::currentSignalStrengthInd(int slotId,
-                                    int indicationType, int token, RIL_Errno e,
-                                    void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || (responseLen != sizeof(RIL_SignalStrength_v10)
-                && responseLen != sizeof(RIL_SignalStrength_v8))) {
-            RLOGE("currentSignalStrengthInd: invalid response");
-            return 0;
-        }
-
-        SignalStrength signalStrength = {};
-        convertRilSignalStrengthToHal(response, responseLen, signalStrength);
-
-#if VDBG
-        RLOGD("currentSignalStrengthInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->currentSignalStrength(
-                convertIntToRadioIndicationType(indicationType), signalStrength);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("currentSignalStrengthInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-void convertRilDataCallToHal(RIL_Data_Call_Response_v6 *dcResponse,
-        SetupDataCallResult& dcResult) {
-    dcResult.status = (DataCallFailCause) dcResponse->status;
-    dcResult.suggestedRetryTime = dcResponse->suggestedRetryTime;
-    dcResult.cid = dcResponse->cid;
-    dcResult.active = dcResponse->active;
-    dcResult.type = convertCharPtrToHidlString(dcResponse->type);
-    dcResult.ifname = convertCharPtrToHidlString(dcResponse->ifname);
-    dcResult.addresses = convertCharPtrToHidlString(dcResponse->addresses);
-    dcResult.dnses = convertCharPtrToHidlString(dcResponse->dnses);
-    dcResult.gateways = convertCharPtrToHidlString(dcResponse->gateways);
-    dcResult.pcscf = hidl_string();
-    dcResult.mtu = 0;
-}
-
-void convertRilDataCallToHal(RIL_Data_Call_Response_v9 *dcResponse,
-        SetupDataCallResult& dcResult) {
-    dcResult.status = (DataCallFailCause) dcResponse->status;
-    dcResult.suggestedRetryTime = dcResponse->suggestedRetryTime;
-    dcResult.cid = dcResponse->cid;
-    dcResult.active = dcResponse->active;
-    dcResult.type = convertCharPtrToHidlString(dcResponse->type);
-    dcResult.ifname = convertCharPtrToHidlString(dcResponse->ifname);
-    dcResult.addresses = convertCharPtrToHidlString(dcResponse->addresses);
-    dcResult.dnses = convertCharPtrToHidlString(dcResponse->dnses);
-    dcResult.gateways = convertCharPtrToHidlString(dcResponse->gateways);
-    dcResult.pcscf = convertCharPtrToHidlString(dcResponse->pcscf);
-    dcResult.mtu = 0;
-}
-
-void convertRilDataCallToHal(RIL_Data_Call_Response_v11 *dcResponse,
-        SetupDataCallResult& dcResult) {
-    dcResult.status = (DataCallFailCause) dcResponse->status;
-    dcResult.suggestedRetryTime = dcResponse->suggestedRetryTime;
-    dcResult.cid = dcResponse->cid;
-    dcResult.active = dcResponse->active;
-    dcResult.type = convertCharPtrToHidlString(dcResponse->type);
-    dcResult.ifname = convertCharPtrToHidlString(dcResponse->ifname);
-    dcResult.addresses = convertCharPtrToHidlString(dcResponse->addresses);
-    dcResult.dnses = convertCharPtrToHidlString(dcResponse->dnses);
-    dcResult.gateways = convertCharPtrToHidlString(dcResponse->gateways);
-    dcResult.pcscf = convertCharPtrToHidlString(dcResponse->pcscf);
-    dcResult.mtu = dcResponse->mtu;
-}
-
-void convertRilDataCallListToHal(void *response, size_t responseLen,
-        hidl_vec<SetupDataCallResult>& dcResultList) {
-    int num;
-
-    if ((responseLen % sizeof(RIL_Data_Call_Response_v11)) == 0) {
-        num = responseLen / sizeof(RIL_Data_Call_Response_v11);
-        RIL_Data_Call_Response_v11 *dcResponse = (RIL_Data_Call_Response_v11 *) response;
-        dcResultList.resize(num);
-        for (int i = 0; i < num; i++) {
-            convertRilDataCallToHal(&dcResponse[i], dcResultList[i]);
-        }
-    } else if ((responseLen % sizeof(RIL_Data_Call_Response_v9)) == 0) {
-        num = responseLen / sizeof(RIL_Data_Call_Response_v9);
-        RIL_Data_Call_Response_v9 *dcResponse = (RIL_Data_Call_Response_v9 *) response;
-        dcResultList.resize(num);
-        for (int i = 0; i < num; i++) {
-            convertRilDataCallToHal(&dcResponse[i], dcResultList[i]);
-        }
-    } else if ((responseLen % sizeof(RIL_Data_Call_Response_v6)) == 0) {
-        num = responseLen / sizeof(RIL_Data_Call_Response_v6);
-        RIL_Data_Call_Response_v6 *dcResponse = (RIL_Data_Call_Response_v6 *) response;
-        dcResultList.resize(num);
-        for (int i = 0; i < num; i++) {
-            convertRilDataCallToHal(&dcResponse[i], dcResultList[i]);
-        }
-    }
-}
-
-int radio::dataCallListChangedInd(int slotId,
-                                  int indicationType, int token, RIL_Errno e, void *response,
-                                  size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if ((response == NULL && responseLen != 0)
-                || (responseLen % sizeof(RIL_Data_Call_Response_v11) != 0
-                && responseLen % sizeof(RIL_Data_Call_Response_v9) != 0
-                && responseLen % sizeof(RIL_Data_Call_Response_v6) != 0)) {
-            RLOGE("dataCallListChangedInd: invalid response");
-            return 0;
-        }
-        hidl_vec<SetupDataCallResult> dcList;
-        convertRilDataCallListToHal(response, responseLen, dcList);
-#if VDBG
-        RLOGD("dataCallListChangedInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->dataCallListChanged(
-                convertIntToRadioIndicationType(indicationType), dcList);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("dataCallListChangedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::suppSvcNotifyInd(int slotId, int indicationType,
-                            int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_SuppSvcNotification)) {
-            RLOGE("suppSvcNotifyInd: invalid response");
-            return 0;
-        }
-
-        SuppSvcNotification suppSvc = {};
-        RIL_SuppSvcNotification *ssn = (RIL_SuppSvcNotification *) response;
-        suppSvc.isMT = ssn->notificationType;
-        suppSvc.code = ssn->code;
-        suppSvc.index = ssn->index;
-        suppSvc.type = ssn->type;
-        suppSvc.number = convertCharPtrToHidlString(ssn->number);
-
-#if VDBG
-        RLOGD("suppSvcNotifyInd: isMT %d code %d index %d type %d",
-                suppSvc.isMT, suppSvc.code, suppSvc.index, suppSvc.type);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->suppSvcNotify(
-                convertIntToRadioIndicationType(indicationType), suppSvc);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("suppSvcNotifyInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stkSessionEndInd(int slotId, int indicationType,
-                            int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("stkSessionEndInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->stkSessionEnd(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stkSessionEndInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stkProactiveCommandInd(int slotId,
-                                  int indicationType, int token, RIL_Errno e, void *response,
-                                  size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("stkProactiveCommandInd: invalid response");
-            return 0;
-        }
-#if VDBG
-        RLOGD("stkProactiveCommandInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->stkProactiveCommand(
-                convertIntToRadioIndicationType(indicationType),
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stkProactiveCommandInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stkEventNotifyInd(int slotId, int indicationType,
-                             int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("stkEventNotifyInd: invalid response");
-            return 0;
-        }
-#if VDBG
-        RLOGD("stkEventNotifyInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->stkEventNotify(
-                convertIntToRadioIndicationType(indicationType),
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stkEventNotifyInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stkCallSetupInd(int slotId, int indicationType,
-                           int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("stkCallSetupInd: invalid response");
-            return 0;
-        }
-        int32_t timeout = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("stkCallSetupInd: timeout %d", timeout);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->stkCallSetup(
-                convertIntToRadioIndicationType(indicationType), timeout);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stkCallSetupInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::simSmsStorageFullInd(int slotId,
-                                int indicationType, int token, RIL_Errno e, void *response,
-                                size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("simSmsStorageFullInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->simSmsStorageFull(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("simSmsStorageFullInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::simRefreshInd(int slotId, int indicationType,
-                         int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_SimRefreshResponse_v7)) {
-            RLOGE("simRefreshInd: invalid response");
-            return 0;
-        }
-
-        SimRefreshResult refreshResult = {};
-        RIL_SimRefreshResponse_v7 *simRefreshResponse = ((RIL_SimRefreshResponse_v7 *) response);
-        refreshResult.type =
-                (V1_0::SimRefreshType) simRefreshResponse->result;
-        refreshResult.efId = simRefreshResponse->ef_id;
-        refreshResult.aid = convertCharPtrToHidlString(simRefreshResponse->aid);
-
-#if VDBG
-        RLOGD("simRefreshInd: type %d efId %d", refreshResult.type, refreshResult.efId);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->simRefresh(
-                convertIntToRadioIndicationType(indicationType), refreshResult);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("simRefreshInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-void convertRilCdmaSignalInfoRecordToHal(RIL_CDMA_SignalInfoRecord *signalInfoRecord,
-        CdmaSignalInfoRecord& record) {
-    record.isPresent = signalInfoRecord->isPresent;
-    record.signalType = signalInfoRecord->signalType;
-    record.alertPitch = signalInfoRecord->alertPitch;
-    record.signal = signalInfoRecord->signal;
-}
-
-int radio::callRingInd(int slotId, int indicationType,
-                       int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        bool isGsm;
-        CdmaSignalInfoRecord record = {};
-        if (response == NULL || responseLen == 0) {
-            isGsm = true;
-        } else {
-            isGsm = false;
-            if (responseLen != sizeof (RIL_CDMA_SignalInfoRecord)) {
-                RLOGE("callRingInd: invalid response");
-                return 0;
-            }
-            convertRilCdmaSignalInfoRecordToHal((RIL_CDMA_SignalInfoRecord *) response, record);
-        }
-
-#if VDBG
-        RLOGD("callRingInd: isGsm %d", isGsm);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->callRing(
-                convertIntToRadioIndicationType(indicationType), isGsm, record);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("callRingInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::simStatusChangedInd(int slotId,
-                               int indicationType, int token, RIL_Errno e, void *response,
-                               size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("simStatusChangedInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->simStatusChanged(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("simStatusChangedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaNewSmsInd(int slotId, int indicationType,
-                         int token, RIL_Errno e, void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_CDMA_SMS_Message)) {
-            RLOGE("cdmaNewSmsInd: invalid response");
-            return 0;
-        }
-
-        CdmaSmsMessage msg = {};
-        RIL_CDMA_SMS_Message *rilMsg = (RIL_CDMA_SMS_Message *) response;
-        msg.teleserviceId = rilMsg->uTeleserviceID;
-        msg.isServicePresent = rilMsg->bIsServicePresent;
-        msg.serviceCategory = rilMsg->uServicecategory;
-        msg.address.digitMode =
-                (V1_0::CdmaSmsDigitMode) rilMsg->sAddress.digit_mode;
-        msg.address.numberMode =
-                (V1_0::CdmaSmsNumberMode) rilMsg->sAddress.number_mode;
-        msg.address.numberType =
-                (V1_0::CdmaSmsNumberType) rilMsg->sAddress.number_type;
-        msg.address.numberPlan =
-                (V1_0::CdmaSmsNumberPlan) rilMsg->sAddress.number_plan;
-
-        int digitLimit = MIN((rilMsg->sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
-        msg.address.digits.setToExternal(rilMsg->sAddress.digits, digitLimit);
-
-        msg.subAddress.subaddressType = (V1_0::CdmaSmsSubaddressType)
-                rilMsg->sSubAddress.subaddressType;
-        msg.subAddress.odd = rilMsg->sSubAddress.odd;
-
-        digitLimit= MIN((rilMsg->sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
-        msg.subAddress.digits.setToExternal(rilMsg->sSubAddress.digits, digitLimit);
-
-        digitLimit = MIN((rilMsg->uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
-        msg.bearerData.setToExternal(rilMsg->aBearerData, digitLimit);
-
-#if VDBG
-        RLOGD("cdmaNewSmsInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cdmaNewSms(
-                convertIntToRadioIndicationType(indicationType), msg);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaNewSmsInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::newBroadcastSmsInd(int slotId,
-                              int indicationType, int token, RIL_Errno e, void *response,
-                              size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("newBroadcastSmsInd: invalid response");
-            return 0;
-        }
-
-        hidl_vec<uint8_t> data;
-        data.setToExternal((uint8_t *) response, responseLen);
-#if VDBG
-        RLOGD("newBroadcastSmsInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->newBroadcastSms(
-                convertIntToRadioIndicationType(indicationType), data);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("newBroadcastSmsInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaRuimSmsStorageFullInd(int slotId,
-                                     int indicationType, int token, RIL_Errno e, void *response,
-                                     size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("cdmaRuimSmsStorageFullInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cdmaRuimSmsStorageFull(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaRuimSmsStorageFullInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::restrictedStateChangedInd(int slotId,
-                                     int indicationType, int token, RIL_Errno e, void *response,
-                                     size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("restrictedStateChangedInd: invalid response");
-            return 0;
-        }
-        int32_t state = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("restrictedStateChangedInd: state %d", state);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->restrictedStateChanged(
-                convertIntToRadioIndicationType(indicationType), (PhoneRestrictedState) state);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("restrictedStateChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::enterEmergencyCallbackModeInd(int slotId,
-                                         int indicationType, int token, RIL_Errno e, void *response,
-                                         size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("enterEmergencyCallbackModeInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->enterEmergencyCallbackMode(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("enterEmergencyCallbackModeInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaCallWaitingInd(int slotId,
-                              int indicationType, int token, RIL_Errno e, void *response,
-                              size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_CDMA_CallWaiting_v6)) {
-            RLOGE("cdmaCallWaitingInd: invalid response");
-            return 0;
-        }
-
-        CdmaCallWaiting callWaitingRecord = {};
-        RIL_CDMA_CallWaiting_v6 *callWaitingRil = ((RIL_CDMA_CallWaiting_v6 *) response);
-        callWaitingRecord.number = convertCharPtrToHidlString(callWaitingRil->number);
-        callWaitingRecord.numberPresentation =
-                (CdmaCallWaitingNumberPresentation) callWaitingRil->numberPresentation;
-        callWaitingRecord.name = convertCharPtrToHidlString(callWaitingRil->name);
-        convertRilCdmaSignalInfoRecordToHal(&callWaitingRil->signalInfoRecord,
-                callWaitingRecord.signalInfoRecord);
-        callWaitingRecord.numberType = (CdmaCallWaitingNumberType) callWaitingRil->number_type;
-        callWaitingRecord.numberPlan = (CdmaCallWaitingNumberPlan) callWaitingRil->number_plan;
-
-#if VDBG
-        RLOGD("cdmaCallWaitingInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cdmaCallWaiting(
-                convertIntToRadioIndicationType(indicationType), callWaitingRecord);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaCallWaitingInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaOtaProvisionStatusInd(int slotId,
-                                     int indicationType, int token, RIL_Errno e, void *response,
-                                     size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("cdmaOtaProvisionStatusInd: invalid response");
-            return 0;
-        }
-        int32_t status = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("cdmaOtaProvisionStatusInd: status %d", status);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cdmaOtaProvisionStatus(
-                convertIntToRadioIndicationType(indicationType), (CdmaOtaProvisionStatus) status);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaOtaProvisionStatusInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaInfoRecInd(int slotId,
-                          int indicationType, int token, RIL_Errno e, void *response,
-                          size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_CDMA_InformationRecords)) {
-            RLOGE("cdmaInfoRecInd: invalid response");
-            return 0;
-        }
-
-        CdmaInformationRecords records = {};
-        RIL_CDMA_InformationRecords *recordsRil = (RIL_CDMA_InformationRecords *) response;
-
-        char* string8 = NULL;
-        int num = MIN(recordsRil->numberOfInfoRecs, RIL_CDMA_MAX_NUMBER_OF_INFO_RECS);
-        if (recordsRil->numberOfInfoRecs > RIL_CDMA_MAX_NUMBER_OF_INFO_RECS) {
-            RLOGE("cdmaInfoRecInd: received %d recs which is more than %d, dropping "
-                    "additional ones", recordsRil->numberOfInfoRecs,
-                    RIL_CDMA_MAX_NUMBER_OF_INFO_RECS);
-        }
-        records.infoRec.resize(num);
-        for (int i = 0 ; i < num ; i++) {
-            CdmaInformationRecord *record = &records.infoRec[i];
-            RIL_CDMA_InformationRecord *infoRec = &recordsRil->infoRec[i];
-            record->name = (CdmaInfoRecName) infoRec->name;
-            // All vectors should be size 0 except one which will be size 1. Set everything to
-            // size 0 initially.
-            record->display.resize(0);
-            record->number.resize(0);
-            record->signal.resize(0);
-            record->redir.resize(0);
-            record->lineCtrl.resize(0);
-            record->clir.resize(0);
-            record->audioCtrl.resize(0);
-            switch (infoRec->name) {
-                case RIL_CDMA_DISPLAY_INFO_REC:
-                case RIL_CDMA_EXTENDED_DISPLAY_INFO_REC: {
-                    if (infoRec->rec.display.alpha_len > CDMA_ALPHA_INFO_BUFFER_LENGTH) {
-                        RLOGE("cdmaInfoRecInd: invalid display info response length %d "
-                                "expected not more than %d", (int) infoRec->rec.display.alpha_len,
-                                CDMA_ALPHA_INFO_BUFFER_LENGTH);
-                        return 0;
-                    }
-                    string8 = (char*) malloc((infoRec->rec.display.alpha_len + 1) * sizeof(char));
-                    if (string8 == NULL) {
-                        RLOGE("cdmaInfoRecInd: Memory allocation failed for "
-                                "responseCdmaInformationRecords");
-                        return 0;
-                    }
-                    memcpy(string8, infoRec->rec.display.alpha_buf, infoRec->rec.display.alpha_len);
-                    string8[(int)infoRec->rec.display.alpha_len] = '\0';
-
-                    record->display.resize(1);
-                    record->display[0].alphaBuf = string8;
-                    free(string8);
-                    string8 = NULL;
-                    break;
-                }
-
-                case RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC:
-                case RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC:
-                case RIL_CDMA_CONNECTED_NUMBER_INFO_REC: {
-                    if (infoRec->rec.number.len > CDMA_NUMBER_INFO_BUFFER_LENGTH) {
-                        RLOGE("cdmaInfoRecInd: invalid display info response length %d "
-                                "expected not more than %d", (int) infoRec->rec.number.len,
-                                CDMA_NUMBER_INFO_BUFFER_LENGTH);
-                        return 0;
-                    }
-                    string8 = (char*) malloc((infoRec->rec.number.len + 1) * sizeof(char));
-                    if (string8 == NULL) {
-                        RLOGE("cdmaInfoRecInd: Memory allocation failed for "
-                                "responseCdmaInformationRecords");
-                        return 0;
-                    }
-                    memcpy(string8, infoRec->rec.number.buf, infoRec->rec.number.len);
-                    string8[(int)infoRec->rec.number.len] = '\0';
-
-                    record->number.resize(1);
-                    record->number[0].number = string8;
-                    free(string8);
-                    string8 = NULL;
-                    record->number[0].numberType = infoRec->rec.number.number_type;
-                    record->number[0].numberPlan = infoRec->rec.number.number_plan;
-                    record->number[0].pi = infoRec->rec.number.pi;
-                    record->number[0].si = infoRec->rec.number.si;
-                    break;
-                }
-
-                case RIL_CDMA_SIGNAL_INFO_REC: {
-                    record->signal.resize(1);
-                    record->signal[0].isPresent = infoRec->rec.signal.isPresent;
-                    record->signal[0].signalType = infoRec->rec.signal.signalType;
-                    record->signal[0].alertPitch = infoRec->rec.signal.alertPitch;
-                    record->signal[0].signal = infoRec->rec.signal.signal;
-
-                    /* Drop the response to workaround the "ring of death" bug */
-                    if (infoRec->rec.signal.isPresent
-                            /* IS95_CONST_IR_SIGNAL_IS54B */
-                            && infoRec->rec.signal.signalType == 2
-                            /* IS95_CONST_IR_ALERT_MED */
-                            && infoRec->rec.signal.alertPitch == 0
-                            /* IS95_CONST_IR_SIG_IS54B_L */
-                            && infoRec->rec.signal.signal == 1) {
-                        return 0;
-                    }
-
-                    break;
-                }
-
-                case RIL_CDMA_REDIRECTING_NUMBER_INFO_REC: {
-                    if (infoRec->rec.redir.redirectingNumber.len >
-                                                  CDMA_NUMBER_INFO_BUFFER_LENGTH) {
-                        RLOGE("cdmaInfoRecInd: invalid display info response length %d "
-                                "expected not more than %d\n",
-                                (int)infoRec->rec.redir.redirectingNumber.len,
-                                CDMA_NUMBER_INFO_BUFFER_LENGTH);
-                        return 0;
-                    }
-                    string8 = (char*) malloc((infoRec->rec.redir.redirectingNumber.len + 1) *
-                            sizeof(char));
-                    if (string8 == NULL) {
-                        RLOGE("cdmaInfoRecInd: Memory allocation failed for "
-                                "responseCdmaInformationRecords");
-                        return 0;
-                    }
-                    memcpy(string8, infoRec->rec.redir.redirectingNumber.buf,
-                            infoRec->rec.redir.redirectingNumber.len);
-                    string8[(int)infoRec->rec.redir.redirectingNumber.len] = '\0';
-
-                    record->redir.resize(1);
-                    record->redir[0].redirectingNumber.number = string8;
-                    free(string8);
-                    string8 = NULL;
-                    record->redir[0].redirectingNumber.numberType =
-                            infoRec->rec.redir.redirectingNumber.number_type;
-                    record->redir[0].redirectingNumber.numberPlan =
-                            infoRec->rec.redir.redirectingNumber.number_plan;
-                    record->redir[0].redirectingNumber.pi = infoRec->rec.redir.redirectingNumber.pi;
-                    record->redir[0].redirectingNumber.si = infoRec->rec.redir.redirectingNumber.si;
-                    record->redir[0].redirectingReason =
-                            (CdmaRedirectingReason) infoRec->rec.redir.redirectingReason;
-                    break;
-                }
-
-                case RIL_CDMA_LINE_CONTROL_INFO_REC: {
-                    record->lineCtrl.resize(1);
-                    record->lineCtrl[0].lineCtrlPolarityIncluded =
-                            infoRec->rec.lineCtrl.lineCtrlPolarityIncluded;
-                    record->lineCtrl[0].lineCtrlToggle = infoRec->rec.lineCtrl.lineCtrlToggle;
-                    record->lineCtrl[0].lineCtrlReverse = infoRec->rec.lineCtrl.lineCtrlReverse;
-                    record->lineCtrl[0].lineCtrlPowerDenial =
-                            infoRec->rec.lineCtrl.lineCtrlPowerDenial;
-                    break;
-                }
-
-                case RIL_CDMA_T53_CLIR_INFO_REC: {
-                    record->clir.resize(1);
-                    record->clir[0].cause = infoRec->rec.clir.cause;
-                    break;
-                }
-
-                case RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC: {
-                    record->audioCtrl.resize(1);
-                    record->audioCtrl[0].upLink = infoRec->rec.audioCtrl.upLink;
-                    record->audioCtrl[0].downLink = infoRec->rec.audioCtrl.downLink;
-                    break;
-                }
-
-                case RIL_CDMA_T53_RELEASE_INFO_REC:
-                    RLOGE("cdmaInfoRecInd: RIL_CDMA_T53_RELEASE_INFO_REC: INVALID");
-                    return 0;
-
-                default:
-                    RLOGE("cdmaInfoRecInd: Incorrect name value");
-                    return 0;
-            }
-        }
-
-#if VDBG
-        RLOGD("cdmaInfoRecInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cdmaInfoRec(
-                convertIntToRadioIndicationType(indicationType), records);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaInfoRecInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::indicateRingbackToneInd(int slotId,
-                                   int indicationType, int token, RIL_Errno e, void *response,
-                                   size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("indicateRingbackToneInd: invalid response");
-            return 0;
-        }
-        bool start = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("indicateRingbackToneInd: start %d", start);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->indicateRingbackTone(
-                convertIntToRadioIndicationType(indicationType), start);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("indicateRingbackToneInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::resendIncallMuteInd(int slotId,
-                               int indicationType, int token, RIL_Errno e, void *response,
-                               size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("resendIncallMuteInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->resendIncallMute(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("resendIncallMuteInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaSubscriptionSourceChangedInd(int slotId,
-                                            int indicationType, int token, RIL_Errno e,
-                                            void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("cdmaSubscriptionSourceChangedInd: invalid response");
-            return 0;
-        }
-        int32_t cdmaSource = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("cdmaSubscriptionSourceChangedInd: cdmaSource %d", cdmaSource);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->
-                cdmaSubscriptionSourceChanged(convertIntToRadioIndicationType(indicationType),
-                (CdmaSubscriptionSource) cdmaSource);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaSubscriptionSourceChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::cdmaPrlChangedInd(int slotId,
-                             int indicationType, int token, RIL_Errno e, void *response,
-                             size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("cdmaPrlChangedInd: invalid response");
-            return 0;
-        }
-        int32_t version = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("cdmaPrlChangedInd: version %d", version);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cdmaPrlChanged(
-                convertIntToRadioIndicationType(indicationType), version);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cdmaPrlChangedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::exitEmergencyCallbackModeInd(int slotId,
-                                        int indicationType, int token, RIL_Errno e, void *response,
-                                        size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("exitEmergencyCallbackModeInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->exitEmergencyCallbackMode(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("exitEmergencyCallbackModeInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::rilConnectedInd(int slotId,
-                           int indicationType, int token, RIL_Errno e, void *response,
-                           size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        RLOGD("rilConnectedInd");
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->rilConnected(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("rilConnectedInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::voiceRadioTechChangedInd(int slotId,
-                                    int indicationType, int token, RIL_Errno e, void *response,
-                                    size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("voiceRadioTechChangedInd: invalid response");
-            return 0;
-        }
-        int32_t rat = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("voiceRadioTechChangedInd: rat %d", rat);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->voiceRadioTechChanged(
-                convertIntToRadioIndicationType(indicationType), (RadioTechnology) rat);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("voiceRadioTechChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-void convertRilCellInfoListToHal(void *response, size_t responseLen, hidl_vec<CellInfo>& records) {
-    int num = responseLen / sizeof(RIL_CellInfo_v12);
-    records.resize(num);
-
-    RIL_CellInfo_v12 *rillCellInfo = (RIL_CellInfo_v12 *) response;
-    for (int i = 0; i < num; i++) {
-        records[i].cellInfoType = (CellInfoType) rillCellInfo->cellInfoType;
-        records[i].registered = rillCellInfo->registered;
-        records[i].timeStampType = (TimeStampType) rillCellInfo->timeStampType;
-        records[i].timeStamp = rillCellInfo->timeStamp;
-        // All vectors should be size 0 except one which will be size 1. Set everything to
-        // size 0 initially.
-        records[i].gsm.resize(0);
-        records[i].wcdma.resize(0);
-        records[i].cdma.resize(0);
-        records[i].lte.resize(0);
-        records[i].tdscdma.resize(0);
-        switch(rillCellInfo->cellInfoType) {
-            case RIL_CELL_INFO_TYPE_GSM: {
-                records[i].gsm.resize(1);
-                CellInfoGsm *cellInfoGsm = &records[i].gsm[0];
-                cellInfoGsm->cellIdentityGsm.mcc =
-                        std::to_string(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mcc);
-                cellInfoGsm->cellIdentityGsm.mnc =
-                        std::to_string(rillCellInfo->CellInfo.gsm.cellIdentityGsm.mnc);
-                cellInfoGsm->cellIdentityGsm.lac =
-                        rillCellInfo->CellInfo.gsm.cellIdentityGsm.lac;
-                cellInfoGsm->cellIdentityGsm.cid =
-                        rillCellInfo->CellInfo.gsm.cellIdentityGsm.cid;
-                cellInfoGsm->cellIdentityGsm.arfcn =
-                        rillCellInfo->CellInfo.gsm.cellIdentityGsm.arfcn;
-                cellInfoGsm->cellIdentityGsm.bsic =
-                        rillCellInfo->CellInfo.gsm.cellIdentityGsm.bsic;
-                cellInfoGsm->signalStrengthGsm.signalStrength =
-                        rillCellInfo->CellInfo.gsm.signalStrengthGsm.signalStrength;
-                cellInfoGsm->signalStrengthGsm.bitErrorRate =
-                        rillCellInfo->CellInfo.gsm.signalStrengthGsm.bitErrorRate;
-                cellInfoGsm->signalStrengthGsm.timingAdvance =
-                        rillCellInfo->CellInfo.gsm.signalStrengthGsm.timingAdvance;
-                break;
-            }
-
-            case RIL_CELL_INFO_TYPE_WCDMA: {
-                records[i].wcdma.resize(1);
-                CellInfoWcdma *cellInfoWcdma = &records[i].wcdma[0];
-                cellInfoWcdma->cellIdentityWcdma.mcc =
-                        std::to_string(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mcc);
-                cellInfoWcdma->cellIdentityWcdma.mnc =
-                        std::to_string(rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.mnc);
-                cellInfoWcdma->cellIdentityWcdma.lac =
-                        rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.lac;
-                cellInfoWcdma->cellIdentityWcdma.cid =
-                        rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.cid;
-                cellInfoWcdma->cellIdentityWcdma.psc =
-                        rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.psc;
-                cellInfoWcdma->cellIdentityWcdma.uarfcn =
-                        rillCellInfo->CellInfo.wcdma.cellIdentityWcdma.uarfcn;
-                cellInfoWcdma->signalStrengthWcdma.signalStrength =
-                        rillCellInfo->CellInfo.wcdma.signalStrengthWcdma.signalStrength;
-                cellInfoWcdma->signalStrengthWcdma.bitErrorRate =
-                        rillCellInfo->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate;
-                break;
-            }
-
-            case RIL_CELL_INFO_TYPE_CDMA: {
-                records[i].cdma.resize(1);
-                CellInfoCdma *cellInfoCdma = &records[i].cdma[0];
-                cellInfoCdma->cellIdentityCdma.networkId =
-                        rillCellInfo->CellInfo.cdma.cellIdentityCdma.networkId;
-                cellInfoCdma->cellIdentityCdma.systemId =
-                        rillCellInfo->CellInfo.cdma.cellIdentityCdma.systemId;
-                cellInfoCdma->cellIdentityCdma.baseStationId =
-                        rillCellInfo->CellInfo.cdma.cellIdentityCdma.basestationId;
-                cellInfoCdma->cellIdentityCdma.longitude =
-                        rillCellInfo->CellInfo.cdma.cellIdentityCdma.longitude;
-                cellInfoCdma->cellIdentityCdma.latitude =
-                        rillCellInfo->CellInfo.cdma.cellIdentityCdma.latitude;
-                cellInfoCdma->signalStrengthCdma.dbm =
-                        rillCellInfo->CellInfo.cdma.signalStrengthCdma.dbm;
-                cellInfoCdma->signalStrengthCdma.ecio =
-                        rillCellInfo->CellInfo.cdma.signalStrengthCdma.ecio;
-                cellInfoCdma->signalStrengthEvdo.dbm =
-                        rillCellInfo->CellInfo.cdma.signalStrengthEvdo.dbm;
-                cellInfoCdma->signalStrengthEvdo.ecio =
-                        rillCellInfo->CellInfo.cdma.signalStrengthEvdo.ecio;
-                cellInfoCdma->signalStrengthEvdo.signalNoiseRatio =
-                        rillCellInfo->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio;
-                break;
-            }
-
-            case RIL_CELL_INFO_TYPE_LTE: {
-                records[i].lte.resize(1);
-                CellInfoLte *cellInfoLte = &records[i].lte[0];
-                cellInfoLte->cellIdentityLte.mcc =
-                        std::to_string(rillCellInfo->CellInfo.lte.cellIdentityLte.mcc);
-                cellInfoLte->cellIdentityLte.mnc =
-                        std::to_string(rillCellInfo->CellInfo.lte.cellIdentityLte.mnc);
-                cellInfoLte->cellIdentityLte.ci =
-                        rillCellInfo->CellInfo.lte.cellIdentityLte.ci;
-                cellInfoLte->cellIdentityLte.pci =
-                        rillCellInfo->CellInfo.lte.cellIdentityLte.pci;
-                cellInfoLte->cellIdentityLte.tac =
-                        rillCellInfo->CellInfo.lte.cellIdentityLte.tac;
-                cellInfoLte->cellIdentityLte.earfcn =
-                        rillCellInfo->CellInfo.lte.cellIdentityLte.earfcn;
-                cellInfoLte->signalStrengthLte.signalStrength =
-                        rillCellInfo->CellInfo.lte.signalStrengthLte.signalStrength;
-                cellInfoLte->signalStrengthLte.rsrp =
-                        rillCellInfo->CellInfo.lte.signalStrengthLte.rsrp;
-                cellInfoLte->signalStrengthLte.rsrq =
-                        rillCellInfo->CellInfo.lte.signalStrengthLte.rsrq;
-                cellInfoLte->signalStrengthLte.rssnr =
-                        rillCellInfo->CellInfo.lte.signalStrengthLte.rssnr;
-                cellInfoLte->signalStrengthLte.cqi =
-                        rillCellInfo->CellInfo.lte.signalStrengthLte.cqi;
-                cellInfoLte->signalStrengthLte.timingAdvance =
-                        rillCellInfo->CellInfo.lte.signalStrengthLte.timingAdvance;
-                break;
-            }
-
-            case RIL_CELL_INFO_TYPE_TD_SCDMA: {
-                records[i].tdscdma.resize(1);
-                CellInfoTdscdma *cellInfoTdscdma = &records[i].tdscdma[0];
-                cellInfoTdscdma->cellIdentityTdscdma.mcc =
-                        std::to_string(rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
-                cellInfoTdscdma->cellIdentityTdscdma.mnc =
-                        std::to_string(rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
-                cellInfoTdscdma->cellIdentityTdscdma.lac =
-                        rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.lac;
-                cellInfoTdscdma->cellIdentityTdscdma.cid =
-                        rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.cid;
-                cellInfoTdscdma->cellIdentityTdscdma.cpid =
-                        rillCellInfo->CellInfo.tdscdma.cellIdentityTdscdma.cpid;
-                cellInfoTdscdma->signalStrengthTdscdma.rscp =
-                        rillCellInfo->CellInfo.tdscdma.signalStrengthTdscdma.rscp;
-                break;
-            }
-            default: {
-                break;
-            }
-        }
-        rillCellInfo += 1;
-    }
-}
-
-int radio::cellInfoListInd(int slotId,
-                           int indicationType, int token, RIL_Errno e, void *response,
-                           size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if ((response == NULL && responseLen != 0) || responseLen % sizeof(RIL_CellInfo_v12) != 0) {
-            RLOGE("cellInfoListInd: invalid response");
-            return 0;
-        }
-
-        hidl_vec<CellInfo> records;
-        convertRilCellInfoListToHal(response, responseLen, records);
-
-#if VDBG
-        RLOGD("cellInfoListInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->cellInfoList(
-                convertIntToRadioIndicationType(indicationType), records);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("cellInfoListInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::imsNetworkStateChangedInd(int slotId,
-                                     int indicationType, int token, RIL_Errno e, void *response,
-                                     size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-#if VDBG
-        RLOGD("imsNetworkStateChangedInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->imsNetworkStateChanged(
-                convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("imsNetworkStateChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::subscriptionStatusChangedInd(int slotId,
-                                        int indicationType, int token, RIL_Errno e, void *response,
-                                        size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("subscriptionStatusChangedInd: invalid response");
-            return 0;
-        }
-        bool activate = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("subscriptionStatusChangedInd: activate %d", activate);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->subscriptionStatusChanged(
-                convertIntToRadioIndicationType(indicationType), activate);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("subscriptionStatusChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::srvccStateNotifyInd(int slotId,
-                               int indicationType, int token, RIL_Errno e, void *response,
-                               size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen % sizeof(int) != 0) {
-            RLOGE("srvccStateNotifyInd: invalid response");
-            return 0;
-        }
-        int32_t state = ((int32_t *) response)[0];
-#if VDBG
-        RLOGD("srvccStateNotifyInd: rat %d", state);
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->srvccStateNotify(
-                convertIntToRadioIndicationType(indicationType), (SrvccState) state);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("srvccStateNotifyInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-void convertRilHardwareConfigListToHal(void *response, size_t responseLen,
-        hidl_vec<HardwareConfig>& records) {
-    int num = responseLen / sizeof(RIL_HardwareConfig);
-    records.resize(num);
-
-    RIL_HardwareConfig *rilHardwareConfig = (RIL_HardwareConfig *) response;
-    for (int i = 0; i < num; i++) {
-        records[i].type = (HardwareConfigType) rilHardwareConfig[i].type;
-        records[i].uuid = convertCharPtrToHidlString(rilHardwareConfig[i].uuid);
-        records[i].state = (HardwareConfigState) rilHardwareConfig[i].state;
-        switch (rilHardwareConfig[i].type) {
-            case RIL_HARDWARE_CONFIG_MODEM: {
-                records[i].modem.resize(1);
-                records[i].sim.resize(0);
-                HardwareConfigModem *hwConfigModem = &records[i].modem[0];
-                hwConfigModem->rat = rilHardwareConfig[i].cfg.modem.rat;
-                hwConfigModem->maxVoice = rilHardwareConfig[i].cfg.modem.maxVoice;
-                hwConfigModem->maxData = rilHardwareConfig[i].cfg.modem.maxData;
-                hwConfigModem->maxStandby = rilHardwareConfig[i].cfg.modem.maxStandby;
-                break;
-            }
-
-            case RIL_HARDWARE_CONFIG_SIM: {
-                records[i].sim.resize(1);
-                records[i].modem.resize(0);
-                records[i].sim[0].modemUuid =
-                        convertCharPtrToHidlString(rilHardwareConfig[i].cfg.sim.modemUuid);
-                break;
-            }
-        }
-    }
-}
-
-int radio::hardwareConfigChangedInd(int slotId,
-                                    int indicationType, int token, RIL_Errno e, void *response,
-                                    size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if ((response == NULL && responseLen != 0)
-                || responseLen % sizeof(RIL_HardwareConfig) != 0) {
-            RLOGE("hardwareConfigChangedInd: invalid response");
-            return 0;
-        }
-
-        hidl_vec<HardwareConfig> configs;
-        convertRilHardwareConfigListToHal(response, responseLen, configs);
-
-#if VDBG
-        RLOGD("hardwareConfigChangedInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->hardwareConfigChanged(
-                convertIntToRadioIndicationType(indicationType), configs);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("hardwareConfigChangedInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-void convertRilRadioCapabilityToHal(void *response, size_t responseLen, RadioCapability& rc) {
-    RIL_RadioCapability *rilRadioCapability = (RIL_RadioCapability *) response;
-    rc.session = rilRadioCapability->session;
-    rc.phase = (V1_0::RadioCapabilityPhase) rilRadioCapability->phase;
-    rc.raf = rilRadioCapability->rat;
-    rc.logicalModemUuid = convertCharPtrToHidlString(rilRadioCapability->logicalModemUuid);
-    rc.status = (V1_0::RadioCapabilityStatus) rilRadioCapability->status;
-}
-
-int radio::radioCapabilityIndicationInd(int slotId,
-                                        int indicationType, int token, RIL_Errno e, void *response,
-                                        size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_RadioCapability)) {
-            RLOGE("radioCapabilityIndicationInd: invalid response");
-            return 0;
-        }
-
-        RadioCapability rc = {};
-        convertRilRadioCapabilityToHal(response, responseLen, rc);
-
-#if VDBG
-        RLOGD("radioCapabilityIndicationInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->radioCapabilityIndication(
-                convertIntToRadioIndicationType(indicationType), rc);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("radioCapabilityIndicationInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType) {
-    if ((reqType == SS_INTERROGATION) &&
-        (serType == SS_CFU ||
-         serType == SS_CF_BUSY ||
-         serType == SS_CF_NO_REPLY ||
-         serType == SS_CF_NOT_REACHABLE ||
-         serType == SS_CF_ALL ||
-         serType == SS_CF_ALL_CONDITIONAL)) {
-        return true;
-    }
-    return false;
-}
-
-int radio::onSupplementaryServiceIndicationInd(int slotId,
-                                               int indicationType, int token, RIL_Errno e,
-                                               void *response, size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_StkCcUnsolSsResponse)) {
-            RLOGE("onSupplementaryServiceIndicationInd: invalid response");
-            return 0;
-        }
-
-        RIL_StkCcUnsolSsResponse *rilSsResponse = (RIL_StkCcUnsolSsResponse *) response;
-        StkCcUnsolSsResult ss = {};
-        ss.serviceType = (SsServiceType) rilSsResponse->serviceType;
-        ss.requestType = (SsRequestType) rilSsResponse->requestType;
-        ss.teleserviceType = (SsTeleserviceType) rilSsResponse->teleserviceType;
-        ss.serviceClass = rilSsResponse->serviceClass;
-        ss.result = (RadioError) rilSsResponse->result;
-
-        if (isServiceTypeCfQuery(rilSsResponse->serviceType, rilSsResponse->requestType)) {
-#if VDBG
-            RLOGD("onSupplementaryServiceIndicationInd CF type, num of Cf elements %d",
-                    rilSsResponse->cfData.numValidIndexes);
-#endif
-            if (rilSsResponse->cfData.numValidIndexes > NUM_SERVICE_CLASSES) {
-                RLOGE("onSupplementaryServiceIndicationInd numValidIndexes is greater than "
-                        "max value %d, truncating it to max value", NUM_SERVICE_CLASSES);
-                rilSsResponse->cfData.numValidIndexes = NUM_SERVICE_CLASSES;
-            }
-
-            ss.cfData.resize(1);
-            ss.ssInfo.resize(0);
-
-            /* number of call info's */
-            ss.cfData[0].cfInfo.resize(rilSsResponse->cfData.numValidIndexes);
-
-            for (int i = 0; i < rilSsResponse->cfData.numValidIndexes; i++) {
-                 RIL_CallForwardInfo cf = rilSsResponse->cfData.cfInfo[i];
-                 CallForwardInfo *cfInfo = &ss.cfData[0].cfInfo[i];
-
-                 cfInfo->status = (CallForwardInfoStatus) cf.status;
-                 cfInfo->reason = cf.reason;
-                 cfInfo->serviceClass = cf.serviceClass;
-                 cfInfo->toa = cf.toa;
-                 cfInfo->number = convertCharPtrToHidlString(cf.number);
-                 cfInfo->timeSeconds = cf.timeSeconds;
-#if VDBG
-                 RLOGD("onSupplementaryServiceIndicationInd: "
-                        "Data: %d,reason=%d,cls=%d,toa=%d,num=%s,tout=%d],", cf.status,
-                        cf.reason, cf.serviceClass, cf.toa, (char*)cf.number, cf.timeSeconds);
-#endif
-            }
-        } else {
-            ss.ssInfo.resize(1);
-            ss.cfData.resize(0);
-
-            /* each int */
-            ss.ssInfo[0].ssInfo.resize(SS_INFO_MAX);
-            for (int i = 0; i < SS_INFO_MAX; i++) {
-#if VDBG
-                 RLOGD("onSupplementaryServiceIndicationInd: Data: %d",
-                        rilSsResponse->ssInfo[i]);
-#endif
-                 ss.ssInfo[0].ssInfo[i] = rilSsResponse->ssInfo[i];
-            }
-        }
-
-#if VDBG
-        RLOGD("onSupplementaryServiceIndicationInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->
-                onSupplementaryServiceIndication(convertIntToRadioIndicationType(indicationType),
-                ss);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("onSupplementaryServiceIndicationInd: "
-                "radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::stkCallControlAlphaNotifyInd(int slotId,
-                                        int indicationType, int token, RIL_Errno e, void *response,
-                                        size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("stkCallControlAlphaNotifyInd: invalid response");
-            return 0;
-        }
-#if VDBG
-        RLOGD("stkCallControlAlphaNotifyInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->stkCallControlAlphaNotify(
-                convertIntToRadioIndicationType(indicationType),
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("stkCallControlAlphaNotifyInd: radioService[%d]->mRadioIndication == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-void convertRilLceDataInfoToHal(void *response, size_t responseLen, LceDataInfo& lce) {
-    RIL_LceDataInfo *rilLceDataInfo = (RIL_LceDataInfo *)response;
-    lce.lastHopCapacityKbps = rilLceDataInfo->last_hop_capacity_kbps;
-    lce.confidenceLevel = rilLceDataInfo->confidence_level;
-    lce.lceSuspended = rilLceDataInfo->lce_suspended;
-}
-
-int radio::lceDataInd(int slotId,
-                      int indicationType, int token, RIL_Errno e, void *response,
-                      size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_LceDataInfo)) {
-            RLOGE("lceDataInd: invalid response");
-            return 0;
-        }
-
-        LceDataInfo lce = {};
-        convertRilLceDataInfoToHal(response, responseLen, lce);
-#if VDBG
-        RLOGD("lceDataInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->lceData(
-                convertIntToRadioIndicationType(indicationType), lce);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("lceDataInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::pcoDataInd(int slotId,
-                      int indicationType, int token, RIL_Errno e, void *response,
-                      size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen != sizeof(RIL_PCO_Data)) {
-            RLOGE("pcoDataInd: invalid response");
-            return 0;
-        }
-
-        PcoDataInfo pco = {};
-        RIL_PCO_Data *rilPcoData = (RIL_PCO_Data *)response;
-        pco.cid = rilPcoData->cid;
-        pco.bearerProto = convertCharPtrToHidlString(rilPcoData->bearer_proto);
-        pco.pcoId = rilPcoData->pco_id;
-        pco.contents.setToExternal((uint8_t *) rilPcoData->contents, rilPcoData->contents_length);
-
-#if VDBG
-        RLOGD("pcoDataInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->pcoData(
-                convertIntToRadioIndicationType(indicationType), pco);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("pcoDataInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::modemResetInd(int slotId,
-                         int indicationType, int token, RIL_Errno e, void *response,
-                         size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("modemResetInd: invalid response");
-            return 0;
-        }
-#if VDBG
-        RLOGD("modemResetInd");
-#endif
-        Return<void> retStatus = radioService[slotId]->mRadioIndication->modemReset(
-                convertIntToRadioIndicationType(indicationType),
-                convertCharPtrToHidlString((char *) response));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("modemResetInd: radioService[%d]->mRadioIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-int radio::networkScanResultInd(int slotId,
-                                int indicationType, int token, RIL_Errno e, void *response,
-                                size_t responseLen) {
-#if VDBG
-    RLOGD("networkScanResultInd");
-#endif
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndicationV1_1 != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("networkScanResultInd: invalid response");
-            return 0;
-        }
-        RLOGD("networkScanResultInd");
-
-#if VDBG
-        RLOGD("networkScanResultInd");
-#endif
-
-        RIL_NetworkScanResult *networkScanResult = (RIL_NetworkScanResult *) response;
-
-        V1_1::NetworkScanResult result;
-        result.status = (V1_1::ScanStatus) networkScanResult->status;
-        result.error = (RadioError) e;
-        convertRilCellInfoListToHal(
-                networkScanResult->network_infos,
-                networkScanResult->network_infos_length * sizeof(RIL_CellInfo_v12),
-                result.networkInfos);
-
-        Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_1->networkScanResult(
-                convertIntToRadioIndicationType(indicationType), result);
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("networkScanResultInd: radioService[%d]->mRadioIndicationV1_1 == NULL", slotId);
-    }
-    return 0;
-}
-
-int radio::carrierInfoForImsiEncryption(int slotId,
-                                  int indicationType, int token, RIL_Errno e, void *response,
-                                  size_t responseLen) {
-    if (radioService[slotId] != NULL && radioService[slotId]->mRadioIndicationV1_1 != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("carrierInfoForImsiEncryption: invalid response");
-            return 0;
-        }
-        RLOGD("carrierInfoForImsiEncryption");
-        Return<void> retStatus = radioService[slotId]->mRadioIndicationV1_1->
-                carrierInfoForImsiEncryption(convertIntToRadioIndicationType(indicationType));
-        radioService[slotId]->checkReturnStatus(retStatus);
-    } else {
-        RLOGE("carrierInfoForImsiEncryption: radioService[%d]->mRadioIndicationV1_1 == NULL",
-                slotId);
-    }
-
-    return 0;
-}
-
-int radio::keepaliveStatusInd(int slotId,
-                         int indicationType, int token, RIL_Errno e, void *response,
-                         size_t responseLen) {
-#if VDBG
-    RLOGD("%s(): token=%d", __FUNCTION__, token);
-#endif
-    if (radioService[slotId] == NULL || radioService[slotId]->mRadioIndication == NULL) {
-        RLOGE("%s: radioService[%d]->mRadioIndication == NULL", __FUNCTION__, slotId);
-        return 0;
-    }
-
-    auto ret = V1_1::IRadioIndication::castFrom(
-        radioService[slotId]->mRadioIndication);
-    if (!ret.isOk()) {
-        RLOGE("%s: ret.isOk() == false for radioService[%d]", __FUNCTION__, slotId);
-        return 0;
-    }
-    sp<V1_1::IRadioIndication> radioIndicationV1_1 = ret;
-
-    if (response == NULL || responseLen != sizeof(V1_1::KeepaliveStatus)) {
-        RLOGE("%s: invalid response", __FUNCTION__);
-        return 0;
-    }
-
-    V1_1::KeepaliveStatus ks;
-    convertRilKeepaliveStatusToHal(static_cast<RIL_KeepaliveStatus*>(response), ks);
-
-    Return<void> retStatus = radioIndicationV1_1->keepaliveStatus(
-            convertIntToRadioIndicationType(indicationType), ks);
-    radioService[slotId]->checkReturnStatus(retStatus);
-    return 0;
-}
-
-int radio::oemHookRawInd(int slotId,
-                         int indicationType, int token, RIL_Errno e, void *response,
-                         size_t responseLen) {
-    if (oemHookService[slotId] != NULL && oemHookService[slotId]->mOemHookIndication != NULL) {
-        if (response == NULL || responseLen == 0) {
-            RLOGE("oemHookRawInd: invalid response");
-            return 0;
-        }
-
-        hidl_vec<uint8_t> data;
-        data.setToExternal((uint8_t *) response, responseLen);
-#if VDBG
-        RLOGD("oemHookRawInd");
-#endif
-        Return<void> retStatus = oemHookService[slotId]->mOemHookIndication->oemHookRaw(
-                convertIntToRadioIndicationType(indicationType), data);
-        checkReturnStatus(slotId, retStatus, false);
-    } else {
-        RLOGE("oemHookRawInd: oemHookService[%d]->mOemHookIndication == NULL", slotId);
-    }
-
-    return 0;
-}
-
-void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands) {
-    using namespace android::hardware;
-    int simCount = 1;
-    const char *serviceNames[] = {
-            android::RIL_getServiceName()
-            #if (SIM_COUNT >= 2)
-            , RIL2_SERVICE_NAME
-            #if (SIM_COUNT >= 3)
-            , RIL3_SERVICE_NAME
-            #if (SIM_COUNT >= 4)
-            , RIL4_SERVICE_NAME
-            #endif
-            #endif
-            #endif
-            };
-
-    #if (SIM_COUNT >= 2)
-    simCount = SIM_COUNT;
-    #endif
-
-    configureRpcThreadpool(1, true /* callerWillJoin */);
-    for (int i = 0; i < simCount; i++) {
-        pthread_rwlock_t *radioServiceRwlockPtr = getRadioServiceRwlock(i);
-        int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
-        assert(ret == 0);
-
-        radioService[i] = new RadioImpl;
-        radioService[i]->mSlotId = i;
-        oemHookService[i] = new OemHookImpl;
-        oemHookService[i]->mSlotId = i;
-        RLOGD("registerService: starting android::hardware::radio::V1_1::IRadio %s",
-                serviceNames[i]);
-        android::status_t status = radioService[i]->registerAsService(serviceNames[i]);
-        status = oemHookService[i]->registerAsService(serviceNames[i]);
-
-        ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
-        assert(ret == 0);
-    }
-
-    s_vendorFunctions = callbacks;
-    s_commands = commands;
-}
-
-void rilc_thread_pool() {
-    joinRpcThreadpool();
-}
-
-pthread_rwlock_t * radio::getRadioServiceRwlock(int slotId) {
-    pthread_rwlock_t *radioServiceRwlockPtr = &radioServiceRwlock;
-
-    #if (SIM_COUNT >= 2)
-    if (slotId == 2) radioServiceRwlockPtr = &radioServiceRwlock2;
-    #if (SIM_COUNT >= 3)
-    if (slotId == 3) radioServiceRwlockPtr = &radioServiceRwlock3;
-    #if (SIM_COUNT >= 4)
-    if (slotId == 4) radioServiceRwlockPtr = &radioServiceRwlock4;
-    #endif
-    #endif
-    #endif
-
-    return radioServiceRwlockPtr;
-}
diff --git a/libril/ril_service.h b/libril/ril_service.h
deleted file mode 100644
index 2240e2a..0000000
--- a/libril/ril_service.h
+++ /dev/null
@@ -1,748 +0,0 @@
-/*
- * Copyright (c) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef RIL_SERVICE_H
-#define RIL_SERVICE_H
-
-#include <telephony/ril.h>
-#include <ril_internal.h>
-
-namespace radio {
-void registerService(RIL_RadioFunctions *callbacks, android::CommandInfo *commands);
-
-int getIccCardStatusResponse(int slotId, int responseType,
-                            int token, RIL_Errno e, void *response, size_t responselen);
-
-int supplyIccPinForAppResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int supplyIccPukForAppResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int supplyIccPin2ForAppResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e, void *response,
-                               size_t responselen);
-
-int supplyIccPuk2ForAppResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e, void *response,
-                               size_t responselen);
-
-int changeIccPinForAppResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int changeIccPin2ForAppResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e, void *response,
-                               size_t responselen);
-
-int supplyNetworkDepersonalizationResponse(int slotId,
-                                          int responseType, int serial, RIL_Errno e,
-                                          void *response, size_t responselen);
-
-int getCurrentCallsResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e, void *response,
-                           size_t responselen);
-
-int dialResponse(int slotId,
-                int responseType, int serial, RIL_Errno e, void *response, size_t responselen);
-
-int getIMSIForAppResponse(int slotId, int responseType,
-                         int serial, RIL_Errno e, void *response, size_t responselen);
-
-int hangupConnectionResponse(int slotId, int responseType,
-                            int serial, RIL_Errno e, void *response, size_t responselen);
-
-int hangupWaitingOrBackgroundResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int hangupForegroundResumeBackgroundResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responselen);
-
-int switchWaitingOrHoldingAndActiveResponse(int slotId,
-                                           int responseType, int serial, RIL_Errno e,
-                                           void *response, size_t responselen);
-
-int conferenceResponse(int slotId, int responseType,
-                      int serial, RIL_Errno e, void *response, size_t responselen);
-
-int rejectCallResponse(int slotId, int responseType,
-                      int serial, RIL_Errno e, void *response, size_t responselen);
-
-int getLastCallFailCauseResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e, void *response,
-                                size_t responselen);
-
-int getSignalStrengthResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responseLen);
-
-int getVoiceRegistrationStateResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int getDataRegistrationStateResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responselen);
-
-int getOperatorResponse(int slotId,
-                       int responseType, int serial, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int setRadioPowerResponse(int slotId,
-                         int responseType, int serial, RIL_Errno e, void *response,
-                         size_t responselen);
-
-int sendDtmfResponse(int slotId,
-                    int responseType, int serial, RIL_Errno e, void *response,
-                    size_t responselen);
-
-int sendSmsResponse(int slotId,
-                   int responseType, int serial, RIL_Errno e, void *response,
-                   size_t responselen);
-
-int sendSMSExpectMoreResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e, void *response,
-                             size_t responselen);
-
-int setupDataCallResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responseLen);
-
-int iccIOForAppResponse(int slotId,
-                       int responseType, int serial, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int sendUssdResponse(int slotId,
-                    int responseType, int serial, RIL_Errno e, void *response,
-                    size_t responselen);
-
-int cancelPendingUssdResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e, void *response,
-                             size_t responselen);
-
-int getClirResponse(int slotId,
-                   int responseType, int serial, RIL_Errno e, void *response, size_t responselen);
-
-int setClirResponse(int slotId,
-                   int responseType, int serial, RIL_Errno e, void *response, size_t responselen);
-
-int getCallForwardStatusResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e, void *response,
-                                size_t responselen);
-
-int setCallForwardResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responselen);
-
-int getCallWaitingResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responselen);
-
-int setCallWaitingResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responselen);
-
-int acknowledgeLastIncomingGsmSmsResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e, void *response,
-                                         size_t responselen);
-
-int acceptCallResponse(int slotId,
-                      int responseType, int serial, RIL_Errno e, void *response,
-                      size_t responselen);
-
-int deactivateDataCallResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int getFacilityLockForAppResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int setFacilityLockForAppResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int setBarringPasswordResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int getNetworkSelectionModeResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e, void *response,
-                                   size_t responselen);
-
-int setNetworkSelectionModeAutomaticResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responselen);
-
-int setNetworkSelectionModeManualResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e, void *response,
-                                         size_t responselen);
-
-int getAvailableNetworksResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e, void *response,
-                                size_t responselen);
-
-int startNetworkScanResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e, void *response,
-                             size_t responselen);
-
-int stopNetworkScanResponse(int slotId,
-                            int responseType, int serial, RIL_Errno e, void *response,
-                            size_t responselen);
-
-int startDtmfResponse(int slotId,
-                     int responseType, int serial, RIL_Errno e, void *response,
-                     size_t responselen);
-
-int stopDtmfResponse(int slotId,
-                    int responseType, int serial, RIL_Errno e, void *response,
-                    size_t responselen);
-
-int getBasebandVersionResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int separateConnectionResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int setMuteResponse(int slotId,
-                   int responseType, int serial, RIL_Errno e, void *response,
-                   size_t responselen);
-
-int getMuteResponse(int slotId,
-                   int responseType, int serial, RIL_Errno e, void *response,
-                   size_t responselen);
-
-int getClipResponse(int slotId,
-                   int responseType, int serial, RIL_Errno e, void *response,
-                   size_t responselen);
-
-int getDataCallListResponse(int slotId,
-                            int responseType, int serial, RIL_Errno e,
-                            void *response, size_t responseLen);
-
-int setSuppServiceNotificationsResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e, void *response,
-                                       size_t responselen);
-
-int writeSmsToSimResponse(int slotId,
-                         int responseType, int serial, RIL_Errno e, void *response,
-                         size_t responselen);
-
-int deleteSmsOnSimResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responselen);
-
-int setBandModeResponse(int slotId,
-                       int responseType, int serial, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int getAvailableBandModesResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int sendEnvelopeResponse(int slotId,
-                        int responseType, int serial, RIL_Errno e, void *response,
-                        size_t responselen);
-
-int sendTerminalResponseToSimResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int handleStkCallSetupRequestFromSimResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responselen);
-
-int explicitCallTransferResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e, void *response,
-                                size_t responselen);
-
-int setPreferredNetworkTypeResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e, void *response,
-                                   size_t responselen);
-
-int getPreferredNetworkTypeResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e, void *response,
-                                   size_t responselen);
-
-int getNeighboringCidsResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int setLocationUpdatesResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int setCdmaSubscriptionSourceResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int setCdmaRoamingPreferenceResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responselen);
-
-int getCdmaRoamingPreferenceResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responselen);
-
-int setTTYModeResponse(int slotId,
-                      int responseType, int serial, RIL_Errno e, void *response,
-                      size_t responselen);
-
-int getTTYModeResponse(int slotId,
-                      int responseType, int serial, RIL_Errno e, void *response,
-                      size_t responselen);
-
-int setPreferredVoicePrivacyResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responselen);
-
-int getPreferredVoicePrivacyResponse(int slotId,
-                                    int responseType, int serial, RIL_Errno e, void *response,
-                                    size_t responselen);
-
-int sendCDMAFeatureCodeResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responselen);
-
-int sendBurstDtmfResponse(int slotId,
-                         int responseType, int serial, RIL_Errno e, void *response,
-                         size_t responselen);
-
-int sendCdmaSmsResponse(int slotId,
-                       int responseType, int serial, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int acknowledgeLastIncomingCdmaSmsResponse(int slotId,
-                                          int responseType, int serial, RIL_Errno e, void *response,
-                                          size_t responselen);
-
-int getGsmBroadcastConfigResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int setGsmBroadcastConfigResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int setGsmBroadcastActivationResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int getCdmaBroadcastConfigResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e, void *response,
-                                  size_t responselen);
-
-int setCdmaBroadcastConfigResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e, void *response,
-                                  size_t responselen);
-
-int setCdmaBroadcastActivationResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responselen);
-
-int getCDMASubscriptionResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e, void *response,
-                               size_t responselen);
-
-int writeSmsToRuimResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responselen);
-
-int deleteSmsOnRuimResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e, void *response,
-                           size_t responselen);
-
-int getDeviceIdentityResponse(int slotId,
-                             int responseType, int serial, RIL_Errno e, void *response,
-                             size_t responselen);
-
-int exitEmergencyCallbackModeResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int getSmscAddressResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e, void *response,
-                          size_t responselen);
-
-int setCdmaBroadcastActivationResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responselen);
-
-int setSmscAddressResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responselen);
-
-int reportSmsMemoryStatusResponse(int slotId,
-                                 int responseType, int serial, RIL_Errno e,
-                                 void *response, size_t responselen);
-
-int reportStkServiceIsRunningResponse(int slotId,
-                                      int responseType, int serial, RIL_Errno e,
-                                      void *response, size_t responseLen);
-
-int getCdmaSubscriptionSourceResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int requestIsimAuthenticationResponse(int slotId,
-                                     int responseType, int serial, RIL_Errno e, void *response,
-                                     size_t responselen);
-
-int acknowledgeIncomingGsmSmsWithPduResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responselen);
-
-int sendEnvelopeWithStatusResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e, void *response,
-                                  size_t responselen);
-
-int getVoiceRadioTechnologyResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responselen);
-
-int getCellInfoListResponse(int slotId,
-                            int responseType,
-                            int serial, RIL_Errno e, void *response,
-                            size_t responseLen);
-
-int setCellInfoListRateResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responselen);
-
-int setInitialAttachApnResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responselen);
-
-int getImsRegistrationStateResponse(int slotId,
-                                   int responseType, int serial, RIL_Errno e,
-                                   void *response, size_t responselen);
-
-int sendImsSmsResponse(int slotId, int responseType,
-                      int serial, RIL_Errno e, void *response, size_t responselen);
-
-int iccTransmitApduBasicChannelResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e,
-                                       void *response, size_t responselen);
-
-int iccOpenLogicalChannelResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e, void *response,
-                                  size_t responselen);
-
-
-int iccCloseLogicalChannelResponse(int slotId,
-                                  int responseType, int serial, RIL_Errno e,
-                                  void *response, size_t responselen);
-
-int iccTransmitApduLogicalChannelResponse(int slotId,
-                                         int responseType, int serial, RIL_Errno e,
-                                         void *response, size_t responselen);
-
-int nvReadItemResponse(int slotId,
-                      int responseType, int serial, RIL_Errno e,
-                      void *response, size_t responselen);
-
-
-int nvWriteItemResponse(int slotId,
-                       int responseType, int serial, RIL_Errno e,
-                       void *response, size_t responselen);
-
-int nvWriteCdmaPrlResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responselen);
-
-int nvResetConfigResponse(int slotId,
-                         int responseType, int serial, RIL_Errno e,
-                         void *response, size_t responselen);
-
-int setUiccSubscriptionResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responselen);
-
-int setDataAllowedResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responselen);
-
-int getHardwareConfigResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responseLen);
-
-int requestIccSimAuthenticationResponse(int slotId,
-                                       int responseType, int serial, RIL_Errno e,
-                                       void *response, size_t responselen);
-
-int setDataProfileResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responselen);
-
-int requestShutdownResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e,
-                           void *response, size_t responselen);
-
-int getRadioCapabilityResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen);
-
-int setRadioCapabilityResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen);
-
-int startLceServiceResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e,
-                           void *response, size_t responselen);
-
-int stopLceServiceResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responselen);
-
-int pullLceDataResponse(int slotId,
-                        int responseType, int serial, RIL_Errno e,
-                        void *response, size_t responseLen);
-
-int getModemActivityInfoResponse(int slotId,
-                                int responseType, int serial, RIL_Errno e,
-                                void *response, size_t responselen);
-
-int setAllowedCarriersResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen);
-
-int getAllowedCarriersResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen);
-
-int sendDeviceStateResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen);
-
-int setIndicationFilterResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen);
-
-int setSimCardPowerResponse(int slotId,
-                              int responseType, int serial, RIL_Errno e,
-                              void *response, size_t responselen);
-
-int startKeepaliveResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e,
-                           void *response, size_t responselen);
-
-int stopKeepaliveResponse(int slotId,
-                          int responseType, int serial, RIL_Errno e,
-                          void *response, size_t responselen);
-
-void acknowledgeRequest(int slotId, int serial);
-
-int radioStateChangedInd(int slotId,
-                          int indicationType, int token, RIL_Errno e, void *response,
-                          size_t responseLen);
-
-int callStateChangedInd(int slotId, int indType, int token,
-                        RIL_Errno e, void *response, size_t responselen);
-
-int networkStateChangedInd(int slotId, int indType,
-                                int token, RIL_Errno e, void *response, size_t responselen);
-
-int newSmsInd(int slotId, int indicationType,
-              int token, RIL_Errno e, void *response, size_t responselen);
-
-int newSmsStatusReportInd(int slotId, int indicationType,
-                          int token, RIL_Errno e, void *response, size_t responselen);
-
-int newSmsOnSimInd(int slotId, int indicationType,
-                   int token, RIL_Errno e, void *response, size_t responselen);
-
-int onUssdInd(int slotId, int indicationType,
-              int token, RIL_Errno e, void *response, size_t responselen);
-
-int nitzTimeReceivedInd(int slotId, int indicationType,
-                        int token, RIL_Errno e, void *response, size_t responselen);
-
-int currentSignalStrengthInd(int slotId,
-                             int indicationType, int token, RIL_Errno e,
-                             void *response, size_t responselen);
-
-int dataCallListChangedInd(int slotId, int indicationType,
-                           int token, RIL_Errno e, void *response, size_t responselen);
-
-int suppSvcNotifyInd(int slotId, int indicationType,
-                     int token, RIL_Errno e, void *response, size_t responselen);
-
-int stkSessionEndInd(int slotId, int indicationType,
-                     int token, RIL_Errno e, void *response, size_t responselen);
-
-int stkProactiveCommandInd(int slotId, int indicationType,
-                           int token, RIL_Errno e, void *response, size_t responselen);
-
-int stkEventNotifyInd(int slotId, int indicationType,
-                      int token, RIL_Errno e, void *response, size_t responselen);
-
-int stkCallSetupInd(int slotId, int indicationType,
-                    int token, RIL_Errno e, void *response, size_t responselen);
-
-int simSmsStorageFullInd(int slotId, int indicationType,
-                         int token, RIL_Errno e, void *response, size_t responselen);
-
-int simRefreshInd(int slotId, int indicationType,
-                  int token, RIL_Errno e, void *response, size_t responselen);
-
-int callRingInd(int slotId, int indicationType,
-                int token, RIL_Errno e, void *response, size_t responselen);
-
-int simStatusChangedInd(int slotId, int indicationType,
-                        int token, RIL_Errno e, void *response, size_t responselen);
-
-int cdmaNewSmsInd(int slotId, int indicationType,
-                  int token, RIL_Errno e, void *response, size_t responselen);
-
-int newBroadcastSmsInd(int slotId,
-                       int indicationType, int token, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int cdmaRuimSmsStorageFullInd(int slotId,
-                              int indicationType, int token, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int restrictedStateChangedInd(int slotId,
-                              int indicationType, int token, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int enterEmergencyCallbackModeInd(int slotId,
-                                  int indicationType, int token, RIL_Errno e, void *response,
-                                  size_t responselen);
-
-int cdmaCallWaitingInd(int slotId,
-                       int indicationType, int token, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int cdmaOtaProvisionStatusInd(int slotId,
-                              int indicationType, int token, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int cdmaInfoRecInd(int slotId,
-                   int indicationType, int token, RIL_Errno e, void *response,
-                   size_t responselen);
-
-int oemHookRawInd(int slotId,
-                  int indicationType, int token, RIL_Errno e, void *response,
-                  size_t responselen);
-
-int indicateRingbackToneInd(int slotId,
-                            int indicationType, int token, RIL_Errno e, void *response,
-                            size_t responselen);
-
-int resendIncallMuteInd(int slotId,
-                        int indicationType, int token, RIL_Errno e, void *response,
-                        size_t responselen);
-
-int cdmaSubscriptionSourceChangedInd(int slotId,
-                                     int indicationType, int token, RIL_Errno e,
-                                     void *response, size_t responselen);
-
-int cdmaPrlChangedInd(int slotId,
-                      int indicationType, int token, RIL_Errno e, void *response,
-                      size_t responselen);
-
-int exitEmergencyCallbackModeInd(int slotId,
-                                 int indicationType, int token, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int rilConnectedInd(int slotId,
-                    int indicationType, int token, RIL_Errno e, void *response,
-                    size_t responselen);
-
-int voiceRadioTechChangedInd(int slotId,
-                             int indicationType, int token, RIL_Errno e, void *response,
-                             size_t responselen);
-
-int cellInfoListInd(int slotId,
-                    int indicationType, int token, RIL_Errno e, void *response,
-                    size_t responselen);
-
-int imsNetworkStateChangedInd(int slotId,
-                              int indicationType, int token, RIL_Errno e, void *response,
-                              size_t responselen);
-
-int subscriptionStatusChangedInd(int slotId,
-                                 int indicationType, int token, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int srvccStateNotifyInd(int slotId,
-                        int indicationType, int token, RIL_Errno e, void *response,
-                        size_t responselen);
-
-int hardwareConfigChangedInd(int slotId,
-                             int indicationType, int token, RIL_Errno e, void *response,
-                             size_t responselen);
-
-int radioCapabilityIndicationInd(int slotId,
-                                 int indicationType, int token, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int onSupplementaryServiceIndicationInd(int slotId,
-                                        int indicationType, int token, RIL_Errno e,
-                                        void *response, size_t responselen);
-
-int stkCallControlAlphaNotifyInd(int slotId,
-                                 int indicationType, int token, RIL_Errno e, void *response,
-                                 size_t responselen);
-
-int lceDataInd(int slotId,
-               int indicationType, int token, RIL_Errno e, void *response,
-               size_t responselen);
-
-int pcoDataInd(int slotId,
-               int indicationType, int token, RIL_Errno e, void *response,
-               size_t responselen);
-
-int modemResetInd(int slotId,
-                  int indicationType, int token, RIL_Errno e, void *response,
-                  size_t responselen);
-
-int networkScanResultInd(int slotId,
-                         int indicationType, int token, RIL_Errno e, void *response,
-                         size_t responselen);
-
-int keepaliveStatusInd(int slotId,
-                       int indicationType, int token, RIL_Errno e, void *response,
-                       size_t responselen);
-
-int sendRequestRawResponse(int slotId,
-                           int responseType, int serial, RIL_Errno e,
-                           void *response, size_t responseLen);
-
-int sendRequestStringsResponse(int slotId,
-                               int responseType, int serial, RIL_Errno e,
-                               void *response, size_t responseLen);
-
-int setCarrierInfoForImsiEncryptionResponse(int slotId,
-                                            int responseType, int serial, RIL_Errno e,
-                                            void *response, size_t responseLen);
-
-int carrierInfoForImsiEncryption(int slotId,
-                        int responseType, int serial, RIL_Errno e,
-                        void *response, size_t responseLen);
-
-pthread_rwlock_t * getRadioServiceRwlock(int slotId);
-
-}   // namespace radio
-
-#endif  // RIL_SERVICE_H
diff --git a/libril/ril_unsol_commands.h b/libril/ril_unsol_commands.h
deleted file mode 100644
index bd2cf70..0000000
--- a/libril/ril_unsol_commands.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* //device/libs/telephony/ril_unsol_commands.h
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-    {RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED, radio::radioStateChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, radio::callStateChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, radio::networkStateChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_SMS, radio::newSmsInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT, radio::newSmsStatusReportInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM, radio::newSmsOnSimInd, WAKE_PARTIAL},
-    {RIL_UNSOL_ON_USSD, radio::onUssdInd, WAKE_PARTIAL},
-    {RIL_UNSOL_ON_USSD_REQUEST, radio::onUssdInd, DONT_WAKE},
-    {RIL_UNSOL_NITZ_TIME_RECEIVED, radio::nitzTimeReceivedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_SIGNAL_STRENGTH, radio::currentSignalStrengthInd, DONT_WAKE},
-    {RIL_UNSOL_DATA_CALL_LIST_CHANGED, radio::dataCallListChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_SUPP_SVC_NOTIFICATION, radio::suppSvcNotifyInd, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_SESSION_END, radio::stkSessionEndInd, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_PROACTIVE_COMMAND, radio::stkProactiveCommandInd, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_EVENT_NOTIFY, radio::stkEventNotifyInd, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_CALL_SETUP, radio::stkCallSetupInd, WAKE_PARTIAL},
-    {RIL_UNSOL_SIM_SMS_STORAGE_FULL, radio::simSmsStorageFullInd, WAKE_PARTIAL},
-    {RIL_UNSOL_SIM_REFRESH, radio::simRefreshInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CALL_RING, radio::callRingInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, radio::simStatusChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_CDMA_NEW_SMS, radio::cdmaNewSmsInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS, radio::newBroadcastSmsInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL, radio::cdmaRuimSmsStorageFullInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESTRICTED_STATE_CHANGED, radio::restrictedStateChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE, radio::enterEmergencyCallbackModeInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_CALL_WAITING, radio::cdmaCallWaitingInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, radio::cdmaOtaProvisionStatusInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_INFO_REC, radio::cdmaInfoRecInd, WAKE_PARTIAL},
-    {RIL_UNSOL_OEM_HOOK_RAW, radio::oemHookRawInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RINGBACK_TONE, radio::indicateRingbackToneInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESEND_INCALL_MUTE, radio::resendIncallMuteInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, radio::cdmaSubscriptionSourceChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_PRL_CHANGED, radio::cdmaPrlChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, radio::exitEmergencyCallbackModeInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RIL_CONNECTED, radio::rilConnectedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, radio::voiceRadioTechChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CELL_INFO_LIST, radio::cellInfoListInd, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, radio::imsNetworkStateChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, radio::subscriptionStatusChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_SRVCC_STATE_NOTIFY, radio::srvccStateNotifyInd, WAKE_PARTIAL},
-    {RIL_UNSOL_HARDWARE_CONFIG_CHANGED, radio::hardwareConfigChangedInd, WAKE_PARTIAL},
-    {RIL_UNSOL_DC_RT_INFO_CHANGED, NULL, WAKE_PARTIAL},
-    {RIL_UNSOL_RADIO_CAPABILITY, radio::radioCapabilityIndicationInd, WAKE_PARTIAL},
-    {RIL_UNSOL_ON_SS, radio::onSupplementaryServiceIndicationInd, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, radio::stkCallControlAlphaNotifyInd, WAKE_PARTIAL},
-    {RIL_UNSOL_LCEDATA_RECV, radio::lceDataInd, WAKE_PARTIAL},
-    {RIL_UNSOL_PCO_DATA, radio::pcoDataInd, WAKE_PARTIAL},
-    {RIL_UNSOL_MODEM_RESTART, radio::modemResetInd, WAKE_PARTIAL},
-    {RIL_UNSOL_CARRIER_INFO_IMSI_ENCRYPTION, radio::carrierInfoForImsiEncryption, WAKE_PARTIAL},
-    {RIL_UNSOL_NETWORK_SCAN_RESULT, radio::networkScanResultInd, WAKE_PARTIAL},
diff --git a/libril/sap_service.cpp b/libril/sap_service.cpp
deleted file mode 100644
index 52ebd6c..0000000
--- a/libril/sap_service.cpp
+++ /dev/null
@@ -1,965 +0,0 @@
-/*
- * Copyright (c) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "RIL_SAP"
-
-#include <android/hardware/radio/1.1/ISap.h>
-
-#include <hwbinder/IPCThreadState.h>
-#include <hwbinder/ProcessState.h>
-#include <sap_service.h>
-#include "pb_decode.h"
-#include "pb_encode.h"
-
-using namespace android::hardware::radio::V1_0;
-using ::android::hardware::Return;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::hidl_array;
-using ::android::hardware::Void;
-using android::CommandInfo;
-using android::RequestInfo;
-using android::requestToString;
-using android::sp;
-
-struct SapImpl;
-
-#if (SIM_COUNT >= 2)
-sp<SapImpl> sapService[SIM_COUNT];
-#else
-sp<SapImpl> sapService[1];
-#endif
-
-struct SapImpl : public android::hardware::radio::V1_1::ISap {
-    int32_t slotId;
-    sp<ISapCallback> sapCallback;
-    RIL_SOCKET_ID rilSocketId;
-
-    Return<void> setCallback(const ::android::sp<ISapCallback>& sapCallbackParam);
-
-    Return<void> connectReq(int32_t token, int32_t maxMsgSize);
-
-    Return<void> disconnectReq(int32_t token);
-
-    Return<void> apduReq(int32_t token, SapApduType type, const hidl_vec<uint8_t>& command);
-
-    Return<void> transferAtrReq(int32_t token);
-
-    Return<void> powerReq(int32_t token, bool state);
-
-    Return<void> resetSimReq(int32_t token);
-
-    Return<void> transferCardReaderStatusReq(int32_t token);
-
-    Return<void> setTransferProtocolReq(int32_t token, SapTransferProtocol transferProtocol);
-
-    MsgHeader* createMsgHeader(MsgId msgId, int32_t token);
-
-    Return<void> addPayloadAndDispatchRequest(MsgHeader *msg, uint16_t reqLen, uint8_t *reqPtr);
-
-    void sendFailedResponse(MsgId msgId, int32_t token, int numPointers, ...);
-
-    void checkReturnStatus(Return<void>& ret);
-};
-
-void SapImpl::checkReturnStatus(Return<void>& ret) {
-    if (ret.isOk() == false) {
-        RLOGE("checkReturnStatus: unable to call response/indication callback: %s",
-                ret.description().c_str());
-        // Remote process (SapRilReceiver.java) hosting the callback must be dead. Reset the
-        // callback object; there's no other recovery to be done here. When the client process is
-        // back up, it will call setCallback()
-        sapCallback = NULL;
-    }
-}
-
-Return<void> SapImpl::setCallback(const ::android::sp<ISapCallback>& sapCallbackParam) {
-    RLOGD("SapImpl::setCallback for slotId %d", slotId);
-    sapCallback = sapCallbackParam;
-    return Void();
-}
-
-MsgHeader* SapImpl::createMsgHeader(MsgId msgId, int32_t token) {
-    // Memory for msg will be freed by RilSapSocket::onRequestComplete()
-    MsgHeader *msg = (MsgHeader *)calloc(1, sizeof(MsgHeader));
-    if (msg == NULL) {
-        return NULL;
-    }
-    msg->token = token;
-    msg->type = MsgType_REQUEST;
-    msg->id = msgId;
-    msg->error = Error_RIL_E_SUCCESS;
-    return msg;
-}
-
-Return<void> SapImpl::addPayloadAndDispatchRequest(MsgHeader *msg, uint16_t reqLen,
-        uint8_t *reqPtr) {
-    pb_bytes_array_t *payload = (pb_bytes_array_t *) malloc(sizeof(pb_bytes_array_t) - 1 + reqLen);
-    msg->payload = payload;
-    if (msg->payload == NULL) {
-        sendFailedResponse(msg->id, msg->token, 2, reqPtr, msg);
-        return Void();
-    }
-    msg->payload->size = reqLen;
-    memcpy(msg->payload->bytes, reqPtr, reqLen);
-
-    RilSapSocket *sapSocket = RilSapSocket::getSocketById(rilSocketId);
-    if (sapSocket) {
-        RLOGD("SapImpl::addPayloadAndDispatchRequest: calling dispatchRequest");
-        sapSocket->dispatchRequest(msg);
-    } else {
-        RLOGE("SapImpl::addPayloadAndDispatchRequest: sapSocket is null");
-        sendFailedResponse(msg->id, msg->token, 3, msg->payload, reqPtr, msg);
-        return Void();
-    }
-    free(payload);
-    free(reqPtr);
-    return Void();
-}
-
-void SapImpl::sendFailedResponse(MsgId msgId, int32_t token, int numPointers, ...) {
-    va_list ap;
-    va_start(ap, numPointers);
-    for (int i = 0; i < numPointers; i++) {
-        void *ptr = va_arg(ap, void *);
-        if (ptr) free(ptr);
-    }
-    va_end(ap);
-    Return<void> retStatus;
-    switch(msgId) {
-        case MsgId_RIL_SIM_SAP_CONNECT:
-            retStatus = sapCallback->connectResponse(token, SapConnectRsp::CONNECT_FAILURE, 0);
-            break;
-
-        case MsgId_RIL_SIM_SAP_DISCONNECT:
-            retStatus = sapCallback->disconnectResponse(token);
-            break;
-
-        case MsgId_RIL_SIM_SAP_APDU: {
-            hidl_vec<uint8_t> apduRsp;
-            retStatus = sapCallback->apduResponse(token, SapResultCode::GENERIC_FAILURE, apduRsp);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_TRANSFER_ATR: {
-            hidl_vec<uint8_t> atr;
-            retStatus = sapCallback->transferAtrResponse(token, SapResultCode::GENERIC_FAILURE,
-                    atr);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_POWER:
-            retStatus = sapCallback->powerResponse(token, SapResultCode::GENERIC_FAILURE);
-            break;
-
-        case MsgId_RIL_SIM_SAP_RESET_SIM:
-            retStatus = sapCallback->resetSimResponse(token, SapResultCode::GENERIC_FAILURE);
-            break;
-
-        case MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS:
-            retStatus = sapCallback->transferCardReaderStatusResponse(token,
-                    SapResultCode::GENERIC_FAILURE, 0);
-            break;
-
-        case MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL:
-            retStatus = sapCallback->transferProtocolResponse(token, SapResultCode::NOT_SUPPORTED);
-            break;
-
-        default:
-            return;
-    }
-    sapService[slotId]->checkReturnStatus(retStatus);
-}
-
-Return<void> SapImpl::connectReq(int32_t token, int32_t maxMsgSize) {
-    RLOGD("SapImpl::connectReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_CONNECT, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::connectReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_CONNECT, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_CONNECT_REQ *****/
-    RIL_SIM_SAP_CONNECT_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_CONNECT_REQ));
-    req.max_message_size = maxMsgSize;
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_CONNECT_REQ_fields, &req)) {
-        RLOGE("SapImpl::connectReq: Error getting encoded size for RIL_SIM_SAP_CONNECT_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_CONNECT, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::connectReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_CONNECT, token, 1, msg);
-        return Void();
-    }
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::connectReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_CONNECT_REQ_fields, &req)) {
-        RLOGE("SapImpl::connectReq: Error encoding RIL_SIM_SAP_CONNECT_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_CONNECT, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_CONNECT_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::disconnectReq(int32_t token) {
-    RLOGD("SapImpl::disconnectReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_DISCONNECT, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::disconnectReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_DISCONNECT, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_DISCONNECT_REQ *****/
-    RIL_SIM_SAP_DISCONNECT_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_DISCONNECT_REQ));
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_DISCONNECT_REQ_fields, &req)) {
-        RLOGE("SapImpl::disconnectReq: Error getting encoded size for RIL_SIM_SAP_DISCONNECT_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_DISCONNECT, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::disconnectReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_DISCONNECT, token, 1, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::disconnectReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_DISCONNECT_REQ_fields, &req)) {
-        RLOGE("SapImpl::disconnectReq: Error encoding RIL_SIM_SAP_DISCONNECT_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_DISCONNECT, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_DISCONNECT_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::apduReq(int32_t token, SapApduType type, const hidl_vec<uint8_t>& command) {
-    RLOGD("SapImpl::apduReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_APDU, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::apduReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_APDU, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_APDU_REQ *****/
-    RIL_SIM_SAP_APDU_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_APDU_REQ));
-    req.type = (RIL_SIM_SAP_APDU_REQ_Type)type;
-
-    if (command.size() > 0) {
-        req.command = (pb_bytes_array_t *)malloc(sizeof(pb_bytes_array_t) - 1 + command.size());
-        if (req.command == NULL) {
-            RLOGE("SapImpl::apduReq: Error allocating memory for req.command");
-            sendFailedResponse(MsgId_RIL_SIM_SAP_APDU, token, 1, msg);
-            return Void();
-        }
-        req.command->size = command.size();
-        memcpy(req.command->bytes, command.data(), command.size());
-    }
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_APDU_REQ_fields, &req)) {
-        RLOGE("SapImpl::apduReq: Error getting encoded size for RIL_SIM_SAP_APDU_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_APDU, token, 2, req.command, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::apduReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_APDU, token, 2, req.command, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::apduReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_APDU_REQ_fields, &req)) {
-        RLOGE("SapImpl::apduReq: Error encoding RIL_SIM_SAP_APDU_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_APDU, token, 3, req.command, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_APDU_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::transferAtrReq(int32_t token) {
-    RLOGD("SapImpl::transferAtrReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_TRANSFER_ATR, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::transferAtrReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_ATR, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_TRANSFER_ATR_REQ *****/
-    RIL_SIM_SAP_TRANSFER_ATR_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_TRANSFER_ATR_REQ));
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_TRANSFER_ATR_REQ_fields, &req)) {
-        RLOGE("SapImpl::transferAtrReq: Error getting encoded size for "
-                "RIL_SIM_SAP_TRANSFER_ATR_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_ATR, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::transferAtrReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_ATR, token, 1, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::transferAtrReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_TRANSFER_ATR_REQ_fields, &req)) {
-        RLOGE("SapImpl::transferAtrReq: Error encoding RIL_SIM_SAP_TRANSFER_ATR_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_ATR, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_TRANSFER_ATR_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::powerReq(int32_t token, bool state) {
-    RLOGD("SapImpl::powerReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_POWER, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::powerReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_POWER, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_POWER_REQ *****/
-    RIL_SIM_SAP_POWER_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_POWER_REQ));
-    req.state = state;
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_POWER_REQ_fields, &req)) {
-        RLOGE("SapImpl::powerReq: Error getting encoded size for RIL_SIM_SAP_POWER_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_POWER, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::powerReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_POWER, token, 1, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::powerReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_POWER_REQ_fields, &req)) {
-        RLOGE("SapImpl::powerReq: Error encoding RIL_SIM_SAP_POWER_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_POWER, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_POWER_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::resetSimReq(int32_t token) {
-    RLOGD("SapImpl::resetSimReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_RESET_SIM, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::resetSimReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_RESET_SIM, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_RESET_SIM_REQ *****/
-    RIL_SIM_SAP_RESET_SIM_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_RESET_SIM_REQ));
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_RESET_SIM_REQ_fields, &req)) {
-        RLOGE("SapImpl::resetSimReq: Error getting encoded size for RIL_SIM_SAP_RESET_SIM_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_RESET_SIM, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::resetSimReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_RESET_SIM, token, 1, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::resetSimReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_RESET_SIM_REQ_fields, &req)) {
-        RLOGE("SapImpl::resetSimReq: Error encoding RIL_SIM_SAP_RESET_SIM_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_RESET_SIM, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_RESET_SIM_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::transferCardReaderStatusReq(int32_t token) {
-    RLOGD("SapImpl::transferCardReaderStatusReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::transferCardReaderStatusReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ *****/
-    RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ));
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ_fields,
-            &req)) {
-        RLOGE("SapImpl::transferCardReaderStatusReq: Error getting encoded size for "
-                "RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::transferCardReaderStatusReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS, token, 1, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::transferCardReaderStatusReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ_fields, &req)) {
-        RLOGE("SapImpl::transferCardReaderStatusReq: Error encoding "
-                "RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-Return<void> SapImpl::setTransferProtocolReq(int32_t token, SapTransferProtocol transferProtocol) {
-    RLOGD("SapImpl::setTransferProtocolReq");
-    MsgHeader *msg = createMsgHeader(MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL, token);
-    if (msg == NULL) {
-        RLOGE("SapImpl::setTransferProtocolReq: Error allocating memory for msg");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL, token, 0);
-        return Void();
-    }
-
-    /***** Encode RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ *****/
-    RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ req;
-    memset(&req, 0, sizeof(RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ));
-    req.protocol = (RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ_Protocol)transferProtocol;
-
-    size_t encodedSize = 0;
-    if (!pb_get_encoded_size(&encodedSize, RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ_fields, &req)) {
-        RLOGE("SapImpl::setTransferProtocolReq: Error getting encoded size for "
-                "RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL, token, 1, msg);
-        return Void();
-    }
-
-    uint8_t *buffer = (uint8_t *)calloc(1, encodedSize);
-    if (buffer == NULL) {
-        RLOGE("SapImpl::setTransferProtocolReq: Error allocating memory for buffer");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL, token, 1, msg);
-        return Void();
-    }
-
-    pb_ostream_t stream = pb_ostream_from_buffer(buffer, encodedSize);
-
-    RLOGD("SapImpl::setTransferProtocolReq calling pb_encode");
-    if (!pb_encode(&stream, RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ_fields, &req)) {
-        RLOGE("SapImpl::setTransferProtocolReq: Error encoding "
-                "RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ");
-        sendFailedResponse(MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL, token, 2, buffer, msg);
-        return Void();
-    }
-    /***** Encode RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_REQ done *****/
-
-    /* encoded req is payload */
-    return addPayloadAndDispatchRequest(msg, stream.bytes_written, buffer);
-}
-
-void *sapDecodeMessage(MsgId msgId, MsgType msgType, uint8_t *payloadPtr, size_t payloadLen) {
-    void *responsePtr = NULL;
-    pb_istream_t stream;
-
-    /* Create the stream */
-    stream = pb_istream_from_buffer((uint8_t *)payloadPtr, payloadLen);
-
-    /* Decode based on the message id */
-    switch (msgId)
-    {
-        case MsgId_RIL_SIM_SAP_CONNECT:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_CONNECT_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_CONNECT_RSP_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_CONNECT_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_DISCONNECT:
-            if (msgType == MsgType_RESPONSE) {
-                responsePtr = malloc(sizeof(RIL_SIM_SAP_DISCONNECT_RSP));
-                if (responsePtr) {
-                    if (!pb_decode(&stream, RIL_SIM_SAP_DISCONNECT_RSP_fields, responsePtr)) {
-                        RLOGE("Error decoding RIL_SIM_SAP_DISCONNECT_RSP");
-                        return NULL;
-                    }
-                }
-            } else {
-                responsePtr = malloc(sizeof(RIL_SIM_SAP_DISCONNECT_IND));
-                if (responsePtr) {
-                    if (!pb_decode(&stream, RIL_SIM_SAP_DISCONNECT_IND_fields, responsePtr)) {
-                        RLOGE("Error decoding RIL_SIM_SAP_DISCONNECT_IND");
-                        return NULL;
-                    }
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_APDU:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_APDU_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_APDU_RSP_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_APDU_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_TRANSFER_ATR:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_TRANSFER_ATR_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_TRANSFER_ATR_RSP_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_TRANSFER_ATR_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_POWER:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_POWER_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_POWER_RSP_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_POWER_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_RESET_SIM:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_RESET_SIM_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_RESET_SIM_RSP_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_RESET_SIM_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_STATUS:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_STATUS_IND));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_STATUS_IND_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_STATUS_IND");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP_fields,
-                        responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_ERROR_RESP:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_ERROR_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_ERROR_RSP_fields, responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_ERROR_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL:
-            responsePtr = malloc(sizeof(RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_RSP));
-            if (responsePtr) {
-                if (!pb_decode(&stream, RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_RSP_fields,
-                        responsePtr)) {
-                    RLOGE("Error decoding RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_RSP");
-                    return NULL;
-                }
-            }
-            break;
-
-        default:
-            break;
-    }
-    return responsePtr;
-} /* sapDecodeMessage */
-
-sp<SapImpl> getSapImpl(RilSapSocket *sapSocket) {
-    switch (sapSocket->getSocketId()) {
-        case RIL_SOCKET_1:
-            RLOGD("getSapImpl: returning sapService[0]");
-            return sapService[0];
-        #if (SIM_COUNT >= 2)
-        case RIL_SOCKET_2:
-            return sapService[1];
-        #if (SIM_COUNT >= 3)
-        case RIL_SOCKET_3:
-            return sapService[2];
-        #if (SIM_COUNT >= 4)
-        case RIL_SOCKET_4:
-            return sapService[3];
-        #endif
-        #endif
-        #endif
-        default:
-            return NULL;
-    }
-}
-
-SapResultCode convertApduResponseProtoToHal(RIL_SIM_SAP_APDU_RSP_Response responseProto) {
-    switch(responseProto) {
-        case RIL_SIM_SAP_APDU_RSP_Response_RIL_E_SUCCESS:
-            return SapResultCode::SUCCESS;
-        case RIL_SIM_SAP_APDU_RSP_Response_RIL_E_GENERIC_FAILURE:
-            return SapResultCode::GENERIC_FAILURE;
-        case RIL_SIM_SAP_APDU_RSP_Response_RIL_E_SIM_NOT_READY:
-            return SapResultCode::CARD_NOT_ACCESSSIBLE;
-        case RIL_SIM_SAP_APDU_RSP_Response_RIL_E_SIM_ALREADY_POWERED_OFF:
-            return SapResultCode::CARD_ALREADY_POWERED_OFF;
-        case RIL_SIM_SAP_APDU_RSP_Response_RIL_E_SIM_ABSENT:
-            return SapResultCode::CARD_REMOVED;
-        default:
-            return SapResultCode::GENERIC_FAILURE;
-    }
-}
-
-SapResultCode convertTransferAtrResponseProtoToHal(
-        RIL_SIM_SAP_TRANSFER_ATR_RSP_Response responseProto) {
-    switch(responseProto) {
-        case RIL_SIM_SAP_TRANSFER_ATR_RSP_Response_RIL_E_SUCCESS:
-            return SapResultCode::SUCCESS;
-        case RIL_SIM_SAP_TRANSFER_ATR_RSP_Response_RIL_E_GENERIC_FAILURE:
-            return SapResultCode::GENERIC_FAILURE;
-        case RIL_SIM_SAP_TRANSFER_ATR_RSP_Response_RIL_E_SIM_ALREADY_POWERED_OFF:
-            return SapResultCode::CARD_ALREADY_POWERED_OFF;
-        case RIL_SIM_SAP_TRANSFER_ATR_RSP_Response_RIL_E_SIM_ABSENT:
-            return SapResultCode::CARD_REMOVED;
-        case RIL_SIM_SAP_TRANSFER_ATR_RSP_Response_RIL_E_SIM_DATA_NOT_AVAILABLE:
-            return SapResultCode::DATA_NOT_AVAILABLE;
-        default:
-            return SapResultCode::GENERIC_FAILURE;
-    }
-}
-
-SapResultCode convertPowerResponseProtoToHal(RIL_SIM_SAP_POWER_RSP_Response responseProto) {
-    switch(responseProto) {
-        case RIL_SIM_SAP_POWER_RSP_Response_RIL_E_SUCCESS:
-            return SapResultCode::SUCCESS;
-        case RIL_SIM_SAP_POWER_RSP_Response_RIL_E_GENERIC_FAILURE:
-            return SapResultCode::GENERIC_FAILURE;
-        case RIL_SIM_SAP_POWER_RSP_Response_RIL_E_SIM_ABSENT:
-            return SapResultCode::CARD_REMOVED;
-        case RIL_SIM_SAP_POWER_RSP_Response_RIL_E_SIM_ALREADY_POWERED_OFF:
-            return SapResultCode::CARD_ALREADY_POWERED_OFF;
-        case RIL_SIM_SAP_POWER_RSP_Response_RIL_E_SIM_ALREADY_POWERED_ON:
-            return SapResultCode::CARD_ALREADY_POWERED_ON;
-        default:
-            return SapResultCode::GENERIC_FAILURE;
-    }
-}
-
-SapResultCode convertResetSimResponseProtoToHal(RIL_SIM_SAP_RESET_SIM_RSP_Response responseProto) {
-    switch(responseProto) {
-        case RIL_SIM_SAP_RESET_SIM_RSP_Response_RIL_E_SUCCESS:
-            return SapResultCode::SUCCESS;
-        case RIL_SIM_SAP_RESET_SIM_RSP_Response_RIL_E_GENERIC_FAILURE:
-            return SapResultCode::GENERIC_FAILURE;
-        case RIL_SIM_SAP_RESET_SIM_RSP_Response_RIL_E_SIM_ABSENT:
-            return SapResultCode::CARD_REMOVED;
-        case RIL_SIM_SAP_RESET_SIM_RSP_Response_RIL_E_SIM_NOT_READY:
-            return SapResultCode::CARD_NOT_ACCESSSIBLE;
-        case RIL_SIM_SAP_RESET_SIM_RSP_Response_RIL_E_SIM_ALREADY_POWERED_OFF:
-            return SapResultCode::CARD_ALREADY_POWERED_OFF;
-    }
-    return SapResultCode::GENERIC_FAILURE;
-}
-
-SapResultCode convertTransferCardReaderStatusResponseProtoToHal(
-        RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP_Response responseProto) {
-    switch(responseProto) {
-        case RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP_Response_RIL_E_SUCCESS:
-            return SapResultCode::SUCCESS;
-        case RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP_Response_RIL_E_GENERIC_FAILURE:
-            return SapResultCode::GENERIC_FAILURE;
-        case RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP_Response_RIL_E_SIM_DATA_NOT_AVAILABLE:
-            return SapResultCode::DATA_NOT_AVAILABLE;
-    }
-    return SapResultCode::GENERIC_FAILURE;
-}
-
-void processResponse(MsgHeader *rsp, RilSapSocket *sapSocket, MsgType msgType) {
-    MsgId msgId = rsp->id;
-    uint8_t *data = rsp->payload->bytes;
-    size_t dataLen = rsp->payload->size;
-
-    void *messagePtr = sapDecodeMessage(msgId, msgType, data, dataLen);
-
-    sp<SapImpl> sapImpl = getSapImpl(sapSocket);
-    if (sapImpl->sapCallback == NULL) {
-        RLOGE("processResponse: sapCallback == NULL; msgId = %d; msgType = %d",
-                msgId, msgType);
-        return;
-    }
-
-    if (messagePtr == NULL) {
-        RLOGE("processResponse: *messagePtr == NULL; msgId = %d; msgType = %d",
-                msgId, msgType);
-        sapImpl->sendFailedResponse(msgId, rsp->token, 0);
-        return;
-    }
-
-    RLOGD("processResponse: sapCallback != NULL; msgId = %d; msgType = %d",
-            msgId, msgType);
-
-    Return<void> retStatus;
-    switch (msgId) {
-        case MsgId_RIL_SIM_SAP_CONNECT: {
-            RIL_SIM_SAP_CONNECT_RSP *connectRsp = (RIL_SIM_SAP_CONNECT_RSP *)messagePtr;
-            RLOGD("processResponse: calling sapCallback->connectResponse %d %d %d",
-                    rsp->token,
-                    connectRsp->response,
-                    connectRsp->max_message_size);
-            retStatus = sapImpl->sapCallback->connectResponse(rsp->token,
-                    (SapConnectRsp)connectRsp->response,
-                    connectRsp->max_message_size);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_DISCONNECT:
-            if (msgType == MsgType_RESPONSE) {
-                RLOGD("processResponse: calling sapCallback->disconnectResponse %d", rsp->token);
-                retStatus = sapImpl->sapCallback->disconnectResponse(rsp->token);
-            } else {
-                RIL_SIM_SAP_DISCONNECT_IND *disconnectInd =
-                        (RIL_SIM_SAP_DISCONNECT_IND *)messagePtr;
-                RLOGD("processResponse: calling sapCallback->disconnectIndication %d %d",
-                        rsp->token, disconnectInd->disconnectType);
-                retStatus = sapImpl->sapCallback->disconnectIndication(rsp->token,
-                        (SapDisconnectType)disconnectInd->disconnectType);
-            }
-            break;
-
-        case MsgId_RIL_SIM_SAP_APDU: {
-            RIL_SIM_SAP_APDU_RSP *apduRsp = (RIL_SIM_SAP_APDU_RSP *)messagePtr;
-            SapResultCode apduResponse = convertApduResponseProtoToHal(apduRsp->response);
-            RLOGD("processResponse: calling sapCallback->apduResponse %d %d",
-                    rsp->token, apduResponse);
-            hidl_vec<uint8_t> apduRspVec;
-            if (apduRsp->apduResponse != NULL && apduRsp->apduResponse->size > 0) {
-                apduRspVec.setToExternal(apduRsp->apduResponse->bytes, apduRsp->apduResponse->size);
-            }
-            retStatus = sapImpl->sapCallback->apduResponse(rsp->token, apduResponse, apduRspVec);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_TRANSFER_ATR: {
-            RIL_SIM_SAP_TRANSFER_ATR_RSP *transferAtrRsp =
-                (RIL_SIM_SAP_TRANSFER_ATR_RSP *)messagePtr;
-            SapResultCode transferAtrResponse =
-                convertTransferAtrResponseProtoToHal(transferAtrRsp->response);
-            RLOGD("processResponse: calling sapCallback->transferAtrResponse %d %d",
-                    rsp->token, transferAtrResponse);
-            hidl_vec<uint8_t> transferAtrRspVec;
-            if (transferAtrRsp->atr != NULL && transferAtrRsp->atr->size > 0) {
-                transferAtrRspVec.setToExternal(transferAtrRsp->atr->bytes,
-                        transferAtrRsp->atr->size);
-            }
-            retStatus = sapImpl->sapCallback->transferAtrResponse(rsp->token, transferAtrResponse,
-                    transferAtrRspVec);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_POWER: {
-            SapResultCode powerResponse = convertPowerResponseProtoToHal(
-                    ((RIL_SIM_SAP_POWER_RSP *)messagePtr)->response);
-            RLOGD("processResponse: calling sapCallback->powerResponse %d %d",
-                    rsp->token, powerResponse);
-            retStatus = sapImpl->sapCallback->powerResponse(rsp->token, powerResponse);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_RESET_SIM: {
-            SapResultCode resetSimResponse = convertResetSimResponseProtoToHal(
-                    ((RIL_SIM_SAP_RESET_SIM_RSP *)messagePtr)->response);
-            RLOGD("processResponse: calling sapCallback->resetSimResponse %d %d",
-                    rsp->token, resetSimResponse);
-            retStatus = sapImpl->sapCallback->resetSimResponse(rsp->token, resetSimResponse);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_STATUS: {
-            RIL_SIM_SAP_STATUS_IND *statusInd = (RIL_SIM_SAP_STATUS_IND *)messagePtr;
-            RLOGD("processResponse: calling sapCallback->statusIndication %d %d",
-                    rsp->token, statusInd->statusChange);
-            retStatus = sapImpl->sapCallback->statusIndication(rsp->token,
-                    (SapStatus)statusInd->statusChange);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS: {
-            RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP *transferStatusRsp =
-                    (RIL_SIM_SAP_TRANSFER_CARD_READER_STATUS_RSP *)messagePtr;
-            SapResultCode transferCardReaderStatusResponse =
-                    convertTransferCardReaderStatusResponseProtoToHal(
-                    transferStatusRsp->response);
-            RLOGD("processResponse: calling sapCallback->transferCardReaderStatusResponse %d %d %d",
-                    rsp->token,
-                    transferCardReaderStatusResponse,
-                    transferStatusRsp->CardReaderStatus);
-            retStatus = sapImpl->sapCallback->transferCardReaderStatusResponse(rsp->token,
-                    transferCardReaderStatusResponse,
-                    transferStatusRsp->CardReaderStatus);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_ERROR_RESP: {
-            RLOGD("processResponse: calling sapCallback->errorResponse %d", rsp->token);
-            retStatus = sapImpl->sapCallback->errorResponse(rsp->token);
-            break;
-        }
-
-        case MsgId_RIL_SIM_SAP_SET_TRANSFER_PROTOCOL: {
-            SapResultCode setTransferProtocolResponse;
-            if (((RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_RSP *)messagePtr)->response ==
-                    RIL_SIM_SAP_SET_TRANSFER_PROTOCOL_RSP_Response_RIL_E_SUCCESS) {
-                setTransferProtocolResponse = SapResultCode::SUCCESS;
-            } else {
-                setTransferProtocolResponse = SapResultCode::NOT_SUPPORTED;
-            }
-            RLOGD("processResponse: calling sapCallback->transferProtocolResponse %d %d",
-                    rsp->token, setTransferProtocolResponse);
-            retStatus = sapImpl->sapCallback->transferProtocolResponse(rsp->token,
-                    setTransferProtocolResponse);
-            break;
-        }
-
-        default:
-            return;
-    }
-    sapImpl->checkReturnStatus(retStatus);
-}
-
-void sap::processResponse(MsgHeader *rsp, RilSapSocket *sapSocket) {
-    processResponse(rsp, sapSocket, MsgType_RESPONSE);
-}
-
-void sap::processUnsolResponse(MsgHeader *rsp, RilSapSocket *sapSocket) {
-    processResponse(rsp, sapSocket, MsgType_UNSOL_RESPONSE);
-}
-
-void sap::registerService(RIL_RadioFunctions *callbacks) {
-    using namespace android::hardware;
-    int simCount = 1;
-    const char *serviceNames[] = {
-        android::RIL_getServiceName()
-        #if (SIM_COUNT >= 2)
-        , RIL2_SERVICE_NAME
-        #if (SIM_COUNT >= 3)
-        , RIL3_SERVICE_NAME
-        #if (SIM_COUNT >= 4)
-        , RIL4_SERVICE_NAME
-        #endif
-        #endif
-        #endif
-    };
-
-    RIL_SOCKET_ID socketIds[] = {
-        RIL_SOCKET_1
-        #if (SIM_COUNT >= 2)
-        , RIL_SOCKET_2
-        #if (SIM_COUNT >= 3)
-        , RIL_SOCKET_3
-        #if (SIM_COUNT >= 4)
-        , RIL_SOCKET_4
-        #endif
-        #endif
-        #endif
-    };
-    #if (SIM_COUNT >= 2)
-    simCount = SIM_COUNT;
-    #endif
-
-    for (int i = 0; i < simCount; i++) {
-        sapService[i] = new SapImpl;
-        sapService[i]->slotId = i;
-        sapService[i]->rilSocketId = socketIds[i];
-        RLOGD("registerService: starting ISap %s for slotId %d", serviceNames[i], i);
-        android::status_t status = sapService[i]->registerAsService(serviceNames[i]);
-        RLOGD("registerService: started ISap %s status %d", serviceNames[i], status);
-    }
-}
diff --git a/libril/sap_service.h b/libril/sap_service.h
deleted file mode 100644
index afed612..0000000
--- a/libril/sap_service.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef SAP_SERVICE_H
-#define SAP_SERVICE_H
-
-#include <telephony/ril.h>
-#include <ril_internal.h>
-#include <RilSapSocket.h>
-#include <hardware/ril/librilutils/proto/sap-api.pb.h>
-
-namespace sap {
-
-void registerService(RIL_RadioFunctions *callbacks);
-void processResponse(MsgHeader *rsp, RilSapSocket *sapSocket);
-void processUnsolResponse(MsgHeader *rsp, RilSapSocket *sapSocket);
-
-}   // namespace android
-
-#endif  // RIL_SERVICE_H
\ No newline at end of file
-- 
2.7.4

