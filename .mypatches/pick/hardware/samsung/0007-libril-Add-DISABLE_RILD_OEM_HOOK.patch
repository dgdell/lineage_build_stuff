From 34b3f644dd59b14f9e3da4b0c890ba11742cb090 Mon Sep 17 00:00:00 2001
From: Steven Moreland <smoreland@google.com>
Date: Tue, 20 Mar 2018 11:20:05 -0700
Subject: [PATCH 07/14] libril: Add DISABLE_RILD_OEM_HOOK.

OEM hook is deprecated, so adding a way to disable it to
this radio implementation.

Bug: 75322118
Test: boot device w/ DISABLE_RILD_OEM_HOOK works, lshal
Change-Id: Ie7ade48476d2c330df608e9cc8dab805f84dd81d
---
 ril/libril/Android.mk      |  4 ++++
 ril/libril/ril_service.cpp | 21 ++++++++++++++++++---
 2 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/ril/libril/Android.mk b/ril/libril/Android.mk
index ed57b2e..6479eee 100644
--- a/ril/libril/Android.mk
+++ b/ril/libril/Android.mk
@@ -58,6 +58,10 @@ ifeq ($(BOARD_NEEDS_IMS_TYPE_FIELD), true)
 LOCAL_CFLAGS += -DNEEDS_IMS_TYPE_FIELD
 endif
 
+ifneq ($(DISABLE_RILD_OEM_HOOK),)
+    LOCAL_CFLAGS += -DOEM_HOOK_DISABLED
+endif
+
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
 LOCAL_C_INCLUDES += external/nanopb-c
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
diff --git a/ril/libril/ril_service.cpp b/ril/libril/ril_service.cpp
index bdd91bc..b5f8530 100644
--- a/ril/libril/ril_service.cpp
+++ b/ril/libril/ril_service.cpp
@@ -59,6 +59,12 @@ using android::sp;
 #define CALL_ONSTATEREQUEST(a) s_vendorFunctions->onStateRequest()
 #endif
 
+#ifdef OEM_HOOK_DISABLED
+constexpr bool kOemHookEnabled = false;
+#else
+constexpr bool kOemHookEnabled = true;
+#endif
+
 RIL_RadioFunctions *s_vendorFunctions = NULL;
 static CommandInfo *s_commands;
 
@@ -6417,6 +6423,8 @@ int radio::sendRequestRawResponse(int slotId,
    RLOGD("sendRequestRawResponse: serial %d", serial);
 #endif
 
+    if (!kOemHookEnabled) return 0;
+
     if (oemHookService[slotId]->mOemHookResponse != NULL) {
         RadioResponseInfo responseInfo = {};
         populateResponseInfo(responseInfo, serial, responseType, e);
@@ -6446,6 +6454,8 @@ int radio::sendRequestStringsResponse(int slotId,
     RLOGD("sendRequestStringsResponse: serial %d", serial);
 #endif
 
+    if (!kOemHookEnabled) return 0;
+
     if (oemHookService[slotId]->mOemHookResponse != NULL) {
         RadioResponseInfo responseInfo = {};
         populateResponseInfo(responseInfo, serial, responseType, e);
@@ -8426,6 +8436,8 @@ int radio::modemResetInd(int slotId,
 int radio::oemHookRawInd(int slotId,
                          int indicationType, int token, RIL_Errno e, void *response,
                          size_t responseLen) {
+    if (!kOemHookEnabled) return 0;
+
     if (oemHookService[slotId] != NULL && oemHookService[slotId]->mOemHookIndication != NULL) {
         if (response == NULL || responseLen == 0) {
             RLOGE("oemHookRawInd: invalid response");
@@ -8475,11 +8487,14 @@ void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands
 
         radioService[i] = new RadioImpl;
         radioService[i]->mSlotId = i;
-        oemHookService[i] = new OemHookImpl;
-        oemHookService[i]->mSlotId = i;
         RLOGD("registerService: starting IRadio %s", serviceNames[i]);
         android::status_t status = radioService[i]->registerAsService(serviceNames[i]);
-        status = oemHookService[i]->registerAsService(serviceNames[i]);
+
+        if (kOemHookEnabled) {
+            oemHookService[i] = new OemHookImpl;
+            oemHookService[i]->mSlotId = i;
+            status = oemHookService[i]->registerAsService(serviceNames[i]);
+        }
 
         ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
         assert(ret == 0);
-- 
2.17.1

