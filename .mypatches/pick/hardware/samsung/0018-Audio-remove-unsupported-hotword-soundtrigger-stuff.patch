From 44335364f633fda7447b4fff9a2106bf1abcdc09 Mon Sep 17 00:00:00 2001
From: stenkinevgeniy <stenkinevgeniy@gmail.com>
Date: Mon, 7 May 2018 18:00:13 +0000
Subject: [PATCH 18/35] Audio: remove unsupported hotword/soundtrigger stuff.

Change-Id: Ie21f94e80a18f5a5805a3ee00e12e83fa2fc3f1a
(cherry picked from commit 35dbc1e39fa7d355edbebe0071145aac45cc1075)
---
 audio/audio_hw.c | 143 +++++++----------------------------------------
 audio/audio_hw.h |  15 +----
 2 files changed, 20 insertions(+), 138 deletions(-)

diff --git a/audio/audio_hw.c b/audio/audio_hw.c
index 9aa5989..c76bac4 100644
--- a/audio/audio_hw.c
+++ b/audio/audio_hw.c
@@ -2,6 +2,7 @@
  * Copyright (C) 2013 The Android Open Source Project
  * Copyright (C) 2017 Christopher N. Hesse <raymanfx@gmail.com>
  * Copyright (C) 2017 Andreas Schneider <asn@cryptomilk.org>
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -186,26 +187,6 @@ static struct pcm_device_profile pcm_device_capture_sco = {
     .devices = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET,
 };
 
-#ifdef SOUND_CAPTURE_HOTWORD_DEVICE
-static struct pcm_device_profile pcm_device_hotword_streaming = {
-    .config = {
-        .channels = 1,
-        .rate = 16000,
-        .period_size = CAPTURE_PERIOD_SIZE,
-        .period_count = CAPTURE_PERIOD_COUNT,
-        .format = PCM_FORMAT_S16_LE,
-        .start_threshold = CAPTURE_START_THRESHOLD,
-        .stop_threshold = 0,
-        .silence_threshold = 0,
-        .avail_min = 0,
-    },
-    .card = SOUND_CARD,
-    .id = SOUND_CAPTURE_HOTWORD_DEVICE,
-    .type = PCM_HOTWORD_STREAMING,
-    .devices = AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_WIRED_HEADSET|AUDIO_DEVICE_IN_BACK_MIC
-};
-#endif
-
 static struct pcm_device_profile * const pcm_devices[] = {
     &pcm_device_playback,
     &pcm_device_capture,
@@ -214,9 +195,6 @@ static struct pcm_device_profile * const pcm_devices[] = {
     &pcm_device_capture_sco,
 #ifdef SOUND_CAPTURE_LOOPBACK_AEC_DEVICE
     &pcm_device_capture_loopback_aec,
-#endif
-#ifdef SOUND_CAPTURE_HOTWORD_DEVICE
-    &pcm_device_hotword_streaming,
 #endif
     NULL,
 };
@@ -227,7 +205,6 @@ static const char * const use_case_table[AUDIO_USECASE_MAX] = {
     [USECASE_AUDIO_PLAYBACK_OFFLOAD] = "compress-offload-playback",
     [USECASE_AUDIO_PLAYBACK_DEEP_BUFFER] = "playback deep-buffer",
     [USECASE_AUDIO_CAPTURE] = "capture",
-    [USECASE_AUDIO_CAPTURE_HOTWORD] = "capture-hotword",
     [USECASE_VOICE_CALL] = "voice-call",
 };
 
@@ -1040,9 +1017,6 @@ static int select_devices(struct audio_device *adev,
 
     ALOGV("%s: usecase(%d)", __func__, uc_id);
 
-    if (uc_id == USECASE_AUDIO_CAPTURE_HOTWORD)
-        return 0;
-
     usecase = get_usecase_from_type(adev, PCM_CAPTURE|VOICE_CALL);
     if (usecase != NULL) {
         active_input = (struct stream_in *)usecase->stream;
@@ -2297,32 +2271,15 @@ static int start_input_stream(struct stream_in *in)
           pcm_device->pcm_profile->config.channels,pcm_device->pcm_profile->config.rate,
           pcm_device->pcm_profile->config.format, pcm_device->pcm_profile->config.period_size);
 
-    if (pcm_profile->type == PCM_HOTWORD_STREAMING) {
-        if (!adev->sound_trigger_open_for_streaming) {
-            ALOGE("%s: No handle to sound trigger HAL", __func__);
-            ret = -EIO;
-            goto error_open;
-        }
-        pcm_device->pcm = NULL;
-        pcm_device->sound_trigger_handle = adev->sound_trigger_open_for_streaming();
-        if (pcm_device->sound_trigger_handle <= 0) {
-            ALOGE("%s: Failed to open DSP for streaming", __func__);
-            ret = -EIO;
-            goto error_open;
-        }
-        ALOGV("Opened DSP successfully");
-    } else {
-        pcm_device->sound_trigger_handle = 0;
-        pcm_device->pcm = pcm_open(pcm_device->pcm_profile->card, pcm_device->pcm_profile->id,
+    pcm_device->pcm = pcm_open(pcm_device->pcm_profile->card, pcm_device->pcm_profile->id,
                                    PCM_IN | PCM_MONOTONIC, &pcm_device->pcm_profile->config);
 
-        if (pcm_device->pcm && !pcm_is_ready(pcm_device->pcm)) {
-            ALOGE("%s: %s", __func__, pcm_get_error(pcm_device->pcm));
-            pcm_close(pcm_device->pcm);
-            pcm_device->pcm = NULL;
-            ret = -EIO;
-            goto error_open;
-        }
+    if (pcm_device->pcm && !pcm_is_ready(pcm_device->pcm)) {
+        ALOGE("%s: %s", __func__, pcm_get_error(pcm_device->pcm));
+        pcm_close(pcm_device->pcm);
+        pcm_device->pcm = NULL;
+        ret = -EIO;
+        goto error_open;
     }
 
 skip_pcm_handling:
@@ -2419,14 +2376,9 @@ static int out_close_pcm_devices(struct stream_out *out)
 {
     struct pcm_device *pcm_device;
     struct listnode *node;
-    struct audio_device *adev = out->dev;
 
     list_for_each(node, &out->pcm_dev_list) {
         pcm_device = node_to_item(node, struct pcm_device, stream_list_node);
-        if (pcm_device->sound_trigger_handle > 0) {
-            adev->sound_trigger_close_for_streaming(pcm_device->sound_trigger_handle);
-            pcm_device->sound_trigger_handle = 0;
-        }
         if (pcm_device->pcm) {
             pcm_close(pcm_device->pcm);
             pcm_device->pcm = NULL;
@@ -3458,7 +3410,6 @@ static int in_close_pcm_devices(struct stream_in *in)
 {
     struct pcm_device *pcm_device;
     struct listnode *node;
-    struct audio_device *adev = in->dev;
 
     list_for_each(node, &in->pcm_dev_list) {
         pcm_device = node_to_item(node, struct pcm_device, stream_list_node);
@@ -3466,9 +3417,6 @@ static int in_close_pcm_devices(struct stream_in *in)
             if (pcm_device->pcm)
                 pcm_close(pcm_device->pcm);
             pcm_device->pcm = NULL;
-            if (pcm_device->sound_trigger_handle > 0)
-                adev->sound_trigger_close_for_streaming(pcm_device->sound_trigger_handle);
-            pcm_device->sound_trigger_handle = 0;
         }
     }
     return 0;
@@ -3642,21 +3590,6 @@ static int in_set_gain(struct audio_stream_in *stream, float gain)
     return 0;
 }
 
-static ssize_t read_bytes_from_dsp(struct stream_in *in, void* buffer,
-                                   size_t bytes)
-{
-    struct pcm_device *pcm_device;
-    struct audio_device *adev = in->dev;
-
-    pcm_device = node_to_item(list_head(&in->pcm_dev_list),
-                              struct pcm_device, stream_list_node);
-
-    if (pcm_device->sound_trigger_handle > 0)
-        return adev->sound_trigger_read_samples(pcm_device->sound_trigger_handle, buffer, bytes);
-    else
-        return 0;
-}
-
 static ssize_t in_read(struct audio_stream_in *stream, void *buffer,
                        size_t bytes)
 {
@@ -3708,21 +3641,15 @@ static ssize_t in_read(struct audio_stream_in *stream, void *buffer,
 false_alarm:
 
     if (!list_empty(&in->pcm_dev_list)) {
-        if (in->usecase == USECASE_AUDIO_CAPTURE_HOTWORD) {
-            bytes = read_bytes_from_dsp(in, buffer, bytes);
-            if (bytes > 0)
-                read_and_process_successful = true;
-        } else {
-            /*
-             * Read PCM and:
-             * - resample if needed
-             * - process if pre-processors are attached
-             * - discard unwanted channels
-             */
-            frames = read_and_process_frames(in, buffer, frames_rq);
-            if (frames >= 0)
-                read_and_process_successful = true;
-        }
+       /*
+        * Read PCM and:
+        * - resample if needed
+        * - process if pre-processors are attached
+        * - discard unwanted channels
+        */
+        frames = read_and_process_frames(in, buffer, frames_rq);
+        if (frames >= 0)
+            read_and_process_successful = true;
     }
 
     /*
@@ -4341,8 +4268,7 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
                                audio_channel_count_from_in_mask(config->channel_mask)) != 0)
         return -EINVAL;
 
-    usecase_type_t usecase_type = source == AUDIO_SOURCE_HOTWORD ?
-                PCM_HOTWORD_STREAMING : flags & AUDIO_INPUT_FLAG_FAST ?
+    usecase_type_t usecase_type = flags & AUDIO_INPUT_FLAG_FAST ?
                         PCM_CAPTURE_LOW_LATENCY : PCM_CAPTURE;
     pcm_profile = get_pcm_device(usecase_type, devices);
     if (pcm_profile == NULL && usecase_type == PCM_CAPTURE_LOW_LATENCY) {
@@ -4393,11 +4319,7 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
     in->config = pcm_profile->config;
 
     /* Update config params with the requested sample rate and channels */
-    if (source == AUDIO_SOURCE_HOTWORD) {
-        in->usecase = USECASE_AUDIO_CAPTURE_HOTWORD;
-    } else {
-        in->usecase = USECASE_AUDIO_CAPTURE;
-    }
+    in->usecase = USECASE_AUDIO_CAPTURE;
     in->usecase_type = usecase_type;
 
     pthread_mutex_init(&in->lock, (const pthread_mutexattr_t *) NULL);
@@ -4587,33 +4509,6 @@ static int adev_open(const hw_module_t *module, const char *name,
         }
     }
 
-    if (access(SOUND_TRIGGER_HAL_LIBRARY_PATH, R_OK) == 0) {
-        adev->sound_trigger_lib = dlopen(SOUND_TRIGGER_HAL_LIBRARY_PATH, RTLD_NOW);
-        if (adev->sound_trigger_lib == NULL) {
-            ALOGE("%s: DLOPEN failed for %s", __func__, SOUND_TRIGGER_HAL_LIBRARY_PATH);
-        } else {
-            ALOGV("%s: DLOPEN successful for %s", __func__, SOUND_TRIGGER_HAL_LIBRARY_PATH);
-            adev->sound_trigger_open_for_streaming =
-                        (int (*)(void))dlsym(adev->sound_trigger_lib,
-                                                        "sound_trigger_open_for_streaming");
-            adev->sound_trigger_read_samples =
-                        (size_t (*)(int, void *, size_t))dlsym(adev->sound_trigger_lib,
-                                                        "sound_trigger_read_samples");
-            adev->sound_trigger_close_for_streaming =
-                        (int (*)(int))dlsym(adev->sound_trigger_lib,
-                                                        "sound_trigger_close_for_streaming");
-            if (!adev->sound_trigger_open_for_streaming ||
-                !adev->sound_trigger_read_samples ||
-                !adev->sound_trigger_close_for_streaming) {
-
-                ALOGE("%s: Error grabbing functions in %s", __func__, SOUND_TRIGGER_HAL_LIBRARY_PATH);
-                adev->sound_trigger_open_for_streaming = 0;
-                adev->sound_trigger_read_samples = 0;
-                adev->sound_trigger_close_for_streaming = 0;
-            }
-        }
-    }
-
     adev->voice.session = voice_session_init(adev);
     if (adev->voice.session == NULL) {
         ALOGE("%s: Failed to initialize voice session data", __func__);
diff --git a/audio/audio_hw.h b/audio/audio_hw.h
index f1de6e8..0be4149 100644
--- a/audio/audio_hw.h
+++ b/audio/audio_hw.h
@@ -1,6 +1,7 @@
 /*
  * Copyright (C) 2013 The Android Open Source Project
  * Copyright (C) 2017 Christopher N. Hesse <raymanfx@gmail.com>
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -48,12 +49,6 @@ struct effect_info_s {
 };
 #endif
 
-#ifdef __LP64__
-#define SOUND_TRIGGER_HAL_LIBRARY_PATH "/system/lib64/hw/sound_trigger.primary.flounder.so"
-#else
-#define SOUND_TRIGGER_HAL_LIBRARY_PATH "/system/lib/hw/sound_trigger.primary.flounder.so"
-#endif
-
 /* Sound devices specific to the platform
  * The DEVICE_OUT_* and DEVICE_IN_* should be mapped to these sound
  * devices to enable corresponding mixer paths
@@ -190,7 +185,6 @@ typedef enum {
 
     /* Capture usecases */
     USECASE_AUDIO_CAPTURE,
-    USECASE_AUDIO_CAPTURE_HOTWORD,
 
     USECASE_VOICE_CALL,
     AUDIO_USECASE_MAX
@@ -225,7 +219,6 @@ typedef enum {
     PCM_PLAYBACK = 0x1,
     PCM_CAPTURE = 0x2,
     VOICE_CALL = 0x4,
-    PCM_HOTWORD_STREAMING = 0x8,
     PCM_CAPTURE_LOW_LATENCY = 0x10,
 } usecase_type_t;
 
@@ -252,7 +245,6 @@ struct pcm_device {
     struct resampler_itfe*     resampler;
     int16_t*                   res_buffer;
     size_t                     res_byte_count;
-    int                        sound_trigger_handle;
 };
 
 struct stream_out {
@@ -423,11 +415,6 @@ struct audio_device {
     volatile int32_t        echo_reference_generation;
 #endif
 
-    void*                   sound_trigger_lib;
-    int                     (*sound_trigger_open_for_streaming)();
-    size_t                  (*sound_trigger_read_samples)(int, void*, size_t);
-    int                     (*sound_trigger_close_for_streaming)(int);
-
     pthread_mutex_t         lock_inputs; /* see note below on mutex acquisition order */
     amplifier_device_t      *amp;
 };
-- 
2.17.1

