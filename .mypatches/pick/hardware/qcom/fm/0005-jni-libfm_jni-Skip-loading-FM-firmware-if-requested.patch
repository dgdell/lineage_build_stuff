From 3a0257d34ec04ea8ff3fc491314273b09f850b35 Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <ricardo@cyngn.com>
Date: Tue, 4 Nov 2014 15:14:08 +0000
Subject: [PATCH 05/51] jni/libfm_jni: Skip loading FM firmware if requested

Not all boards require a firmware download for FM. Set
TARGET_QCOM_NO_FM_FIRMWARE if the device doesn't require
a fw image to run FM

Change-Id: If18650af934f840a54f53fa9474a3341df0e3e68

jni: Confine the firmware-load skipping to the actual loading

Change If18650af934f840a54f53fa9474a3341df0e3e68 removed the
property-setting steps from the initialization routine. Bring it
back, as we may want to use those properties to trigger module
state changes from init. The recommended flow for devices with
the latest IRIS driver is the following:

on property:vendor.hw.fm.init=0
    write /sys/module/radio_iris_transport/parameters/fmsmd_set 0

on property:vendor.hw.fm.init=1
    write /sys/module/radio_iris_transport/parameters/fmsmd_set 1

Change-Id: Ifddf678398fec2e4bfa9688c044da7d75898e056
---
 jni/Android.mk                  |  4 ++++
 jni/android_hardware_fm.cpp     | 14 +++++++++++++-
 libfm_jni/Android.mk            |  4 ++++
 libfm_jni/FmIoctlsInterface.cpp | 20 +++++++++++++++++++-
 4 files changed, 40 insertions(+), 2 deletions(-)

diff --git a/jni/Android.mk b/jni/Android.mk
index b536356d..1a029caf 100644
--- a/jni/Android.mk
+++ b/jni/Android.mk
@@ -28,6 +28,10 @@ ifeq ($(TARGET_FM_LEGACY_PATCHLOADER),true)
     LOCAL_CFLAGS += -DFM_LEGACY_PATCHLOADER
 endif
 
+ifeq ($(TARGET_QCOM_NO_FM_FIRMWARE),true)
+    LOCAL_CFLAGS += -DQCOM_NO_FM_FIRMWARE
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 
diff --git a/jni/android_hardware_fm.cpp b/jni/android_hardware_fm.cpp
index 0dca4fa6..182f9eca 100644
--- a/jni/android_hardware_fm.cpp
+++ b/jni/android_hardware_fm.cpp
@@ -653,7 +653,7 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
         (JNIEnv* env, jobject thiz, jstring path)
 {
     int fd;
-    int i, retval=0, err;
+    int i = 0, retval=0, err;
     char value[PROPERTY_VALUE_MAX] = {'\0'};
     char versionStr[40] = {'\0'};
     int init_success = 0;
@@ -695,6 +695,7 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
        property_set("vendor.hw.fm.mode", "normal");
        /* Need to clear the hw.fm.init firstly */
        property_set("vendor.hw.fm.init", "0");
+#ifndef QCOM_NO_FM_FIRMWARE
        property_set("ctl.start", "fm_dl");
        sched_yield();
        for(i=0; i<45; i++) {
@@ -706,6 +707,11 @@ static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
             usleep(WAIT_TIMEOUT);
          }
        }
+#else
+       property_set("vendor.hw.fm.init", "1");
+       usleep(WAIT_TIMEOUT);
+       init_success = 1;
+#endif
        ALOGE("init_success:%d after %f seconds \n", init_success, 0.2*i);
        if(!init_success) {
          property_set("ctl.stop", "fm_dl");
@@ -1199,7 +1205,9 @@ static jint android_hardware_fmradio_FmReceiverJNI_getRawRdsNative
 static jint android_hardware_fmradio_FmReceiverJNI_setNotchFilterNative(JNIEnv * env, jobject thiz,jint fd, jint id, jboolean aValue)
 {
     char value[PROPERTY_VALUE_MAX] = {'\0'};
+#ifndef QCOM_NO_FM_FIRMWARE
     int init_success = 0,i;
+#endif
     char notch[PROPERTY_VALUE_MAX] = {0x00};
     int band;
     int err = 0;
@@ -1217,6 +1225,7 @@ static jint android_hardware_fmradio_FmReceiverJNI_setNotchFilterNative(JNIEnv *
        else
           property_set("vendor.hw.fm.mode", "wa_disable");
 
+#ifndef QCOM_NO_FM_FIRMWARE
        property_set("ctl.start", "fm_dl");
        sched_yield();
        for(i=0; i<10; i++) {
@@ -1229,6 +1238,9 @@ static jint android_hardware_fmradio_FmReceiverJNI_setNotchFilterNative(JNIEnv *
           }
        }
        ALOGE("init_success:%d after %f seconds \n", init_success, 0.2*i);
+#else
+       usleep(WAIT_TIMEOUT);
+#endif
 
        property_get("vendor.notch.value", notch, NULL);
        ALOGE("Notch = %s",notch);
diff --git a/libfm_jni/Android.mk b/libfm_jni/Android.mk
index c221e71d..70959330 100644
--- a/libfm_jni/Android.mk
+++ b/libfm_jni/Android.mk
@@ -28,6 +28,10 @@ ifeq ($(TARGET_FM_LEGACY_PATCHLOADER),true)
     LOCAL_CFLAGS += -DFM_LEGACY_PATCHLOADER
 endif
 
+ifeq ($(TARGET_QCOM_NO_FM_FIRMWARE),true)
+    LOCAL_CFLAGS += -DQCOM_NO_FM_FIRMWARE
+endif
+
 LOCAL_MODULE := libfmjni
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/libfm_jni/FmIoctlsInterface.cpp b/libfm_jni/FmIoctlsInterface.cpp
index fbe035c5..7c40886f 100644
--- a/libfm_jni/FmIoctlsInterface.cpp
+++ b/libfm_jni/FmIoctlsInterface.cpp
@@ -46,7 +46,9 @@ int FmIoctlsInterface :: start_fm_patch_dl
     int ret;
     int init_success = 0;
     char versionStr[MAX_VER_STR_LEN] = {'\0'};
+#ifndef QCOM_NO_FM_FIRMWARE
     char prop_value[PROPERTY_VALUE_MAX] = {'\0'};
+#endif
     struct v4l2_capability cap;
 
     ALOGE("start_fm_patch_dl = %d\n",fd);
@@ -69,6 +71,7 @@ int FmIoctlsInterface :: start_fm_patch_dl
             ALOGE("set FM_INIT_PROP done");
             if(ret != PROP_SET_SUCC)
                return FM_FAILURE;
+#ifndef QCOM_NO_FM_FIRMWARE
             ret = property_set(SCRIPT_START_PROP, SOC_PATCH_DL_SCRPT);
             if(ret != PROP_SET_SUCC)
                return FM_FAILURE;
@@ -81,6 +84,13 @@ int FmIoctlsInterface :: start_fm_patch_dl
                     usleep(INIT_WAIT_TIMEOUT);
                 }
             }
+#else
+            ret = property_set(FM_INIT_PROP, "1");
+            usleep(INIT_WAIT_TIMEOUT);
+            if(ret != PROP_SET_SUCC)
+               return FM_FAILURE;
+            init_success = 1;
+#endif
             if(!init_success) {
                 property_set(SCRIPT_STOP_PROP, SOC_PATCH_DL_SCRPT);
                 return FM_FAILURE;
@@ -98,6 +108,7 @@ int  FmIoctlsInterface :: close_fm_patch_dl
     void
 )
 {
+#ifndef QCOM_NO_FM_FIRMWARE
     int ret;
 
     ret = property_set(SCRIPT_STOP_PROP, SOC_PATCH_DL_SCRPT);
@@ -106,6 +117,9 @@ int  FmIoctlsInterface :: close_fm_patch_dl
     }else {
         return FM_SUCCESS;
     }
+#else
+    return FM_SUCCESS;
+#endif
 }
 
 int  FmIoctlsInterface :: get_cur_freq
@@ -167,9 +181,10 @@ int  FmIoctlsInterface :: set_control
 
 int  FmIoctlsInterface :: set_calibration
 (
-    UINT fd
+    UINT fd __unused
 )
 {
+#ifndef QCOM_NO_FM_FIRMWARE
     int ret;
     FILE *cal_fp;
     struct v4l2_ext_control ext_ctl;
@@ -198,6 +213,9 @@ int  FmIoctlsInterface :: set_calibration
     }else {
         return FM_FAILURE;
     }
+#else
+    return FM_SUCCESS;
+#endif
 }
 
 int  FmIoctlsInterface :: get_control
-- 
2.17.1

