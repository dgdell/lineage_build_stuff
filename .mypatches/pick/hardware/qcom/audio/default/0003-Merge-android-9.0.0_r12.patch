From 359685525eb5a64afa51e59af4e00ed88cc2a972 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Fri, 19 Oct 2018 12:03:54 +0200
Subject: [PATCH 3/3] Merge android-9.0.0_r12

commit d589c0daf1a914556d4b6fb22247a4f89f68b6d6
Merge: f720fceb7 fb636b875
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Tue Aug 7 01:22:58 2018 +0000

    Merge cherrypicks of [4703954, 4703955, 4703956, 4703974, 4702197, 4701815, 4701816, 4703428, 4703957, 4703429, 4701817, 4701818, 4701819, 4701820, 4701821, 4701822, 4701823, 4703431, 4703432, 4704034, 4704035, 4701660] into pi-dr1-release

    Change-Id: Ibebe67f8bb12ada6f5292584651bc76f4a1f91a3

commit fb636b875f2d0a10496a4473da0258e4356b5e78
Author: juyuchen <juyuchen@google.com>
Date:   Mon Aug 6 15:39:34 2018 +0800

    audio: fix static noise on speaker path when enable incall-music

    Bug: 111107345
    Test: manual audio test

    Change-Id: I8da727326b0d5dd1d89623dae55e33f2b39830df
    Signed-off-by: juyuchen <juyuchen@google.com>
    Signed-off-by: David Lin <dtwlin@google.com>
    (cherry picked from commit 66c4ecfa84116e12c5cb3b430208365cdfb0b2c9)

commit f720fceb7464100ebe5a36ff7b12eb78cdcbdeb5
Merge: b7c7e6cfe 7964549ea
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Thu Jul 19 03:10:46 2018 +0000

    Snap for 4900918 from 7964549ea0dd5a0115d0e6562c7daa167986457c to pi-dr1-release

    Change-Id: I802391a0592ce9231a89bbc7c827f66c1a510fbd

commit 7964549ea0dd5a0115d0e6562c7daa167986457c
Merge: 5790f3eb0 72a3ceab0
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Wed Jul 18 20:55:43 2018 +0000

    Merge "visualizer: Pass sound card and capture device from audio HAL" into pi-dev

commit 5790f3eb018b092a0fcb3ef9e55d5d3b04373a70
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Wed Jun 20 14:41:26 2018 -0700

    hal: Configure frame size of AAC encoded output

    BT sink devices have a limitation on the packet sizes
    they can receive and handle from BT sources. AAC encoder
    can produce output frames which can vary in size based on
    content being encoded. If frame size exceeds MTU size of
    BT sink device, it will lead to incorrect decoding of
    frames in BT sink.
    Solve this problem by sending a frame configuration parameter
    (MTU/Peak bitrate) while starting A2DP playback on AAC.
    Parameter is passed by bthost_ipc to audio HAL which passes
    it to DSP during AAC encoder configuration.

    Bug: 78907438
    Test: Manual testing with AAC headset
    Change-Id: I58e30e7e0a486065a95bc7d7463c45e1c5c3e6eb

commit 72a3ceab00258fef500f0b6f3c41870c806cefdf
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Fri Apr 6 13:56:37 2018 -0700

    visualizer: Pass sound card and capture device from audio HAL

    Sound card number and capture device id were hardcoded in
    visualizer. Fix this by passing card number and capture
    device id while starting visualizer output from audio HAL.

    Bug: 65263761
    Change-Id: Icc5c33e35d836f524918900b3bfdf2a587465505
    (cherry picked from commit 90c3646a8b97158c2c3f33677815909219cc8f03)

commit b7c7e6cfea591b51c41f1bcce6308db15354e3ac
Merge: 3d658970b 702c15751
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Sun Jul 15 03:01:30 2018 +0000

    Snap for 4894342 from 702c15751ca43c51781ed31491741c56c6122be3 to pi-dr1-release

    Change-Id: I4767110ed398a74d001a213736960fbee85ce289

commit 702c15751ca43c51781ed31491741c56c6122be3
Author: Kevin Rocard <krocard@google.com>
Date:   Wed Jul 11 20:52:03 2018 -0700

    A2DP set_parameter: return correct status value

    The A2DP offload set_parameter code was returning the value
    of a temporary variable use to parse the value pairs
    instead of the status of the operation.

    This mean that an error was wrongly returned when
    setting the value of any key that was not
    AUDIO_PARAMETER_RECONFIG_A2DP (the last one parsed).

    Test: vts-tradefed run commandAndExit vts -m VtsHalAudioV4_0Target
    Bug: 111113768
    Change-Id: Ic32bdaafb8d048322d1c560f4f4c3deefeba63df
    Signed-off-by: Kevin Rocard <krocard@google.com>

commit 3d658970bb607a47d7ff037959d82c0da623ec4d
Merge: 8556c8403 41b4fe4c5
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Thu Jul 12 03:03:52 2018 +0000

    Snap for 4887958 from 41b4fe4c5750792a2c7afbc479bd742034f9a4df to pi-dr1-release

    Change-Id: If9c8f2990974f6b16c95283a1dcafd7485db3d63

commit 41b4fe4c5750792a2c7afbc479bd742034f9a4df
Author: David Lin <dtwlin@google.com>
Date:   Sun Jul 8 16:14:24 2018 -0700

    hal: speaker protect: Add deinit function to clean up

    This patch adds a deinit function for speaker protection module to
    perform any clean ups needed. This as well implements the deinit for
    Cirrus Logic speaker protection module to wait for the threads to
    finish.

    Bug: 111113768
    Test: VtsHalAudioV4_0Target
    Change-Id: I3c89f173d726e265ce64ea4a7e43b49210f8721c
    Signed-off-by: David Lin <dtwlin@google.com>

commit 4d2221b1b98e4e57bcafb8875456ed5e6a0aa810
Author: juyuchen <juyuchen@google.com>
Date:   Fri Jul 6 14:26:22 2018 +0800

    audio: Add a build flag to enable cirrus speaker calibration.

    Enable cirrus's speaker calibration function when define the build CIRRUS_FACTORY_CALIBRATION flag.

    Bug: 111113768
    Bug: 111239347
    Test: manual audio test

    Change-Id: Ie59dd2ffb5ab6d54e29ac10131fffc90193152df
    Signed-off-by: juyuchen <juyuchen@google.com>

commit 8556c8403bf8cfaa5fa27ee88f96f94588607334
Merge: 609dad19f bfb120400
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Jun 27 21:45:06 2018 +0000

    Merge "Snap for 4866033 from eedbcac379a26bd7cce9225df33ba6c73ccd34b9 to pi-dr1-release" into pi-dr1-release

commit bfb120400a175064d65506a197b4f9aaea11db8c
Merge: a853b4b3f eedbcac37
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Jun 27 21:32:36 2018 +0000

    Snap for 4866033 from eedbcac379a26bd7cce9225df33ba6c73ccd34b9 to pi-dr1-release

    Change-Id: I9e1e4694b05b42c81418d56168e2d70131174953

commit 609dad19f497e4e831fa625e9771dfa39cd44620
Merge: a853b4b3f eedbcac37
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Jun 27 21:31:00 2018 +0000

    Snap for 4866033 from eedbcac379a26bd7cce9225df33ba6c73ccd34b9 to pi-dr1-release

    Change-Id: I5b9555e09dc5198a109ababa8da6be78d60d5161

commit eedbcac379a26bd7cce9225df33ba6c73ccd34b9
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Thu Jun 21 16:46:50 2018 -0700

    hal: Reset A2DP backend before SCO is started

    SCO and A2DP share the same Slimbus backend.
    During A2DP to SCO transition, A2DP sound device in
    audio HAL if disabled after SCO audio route is enabled
    overwrites SCO backend config with A2DP reset config.
    Reset A2DP config with A2DP suspension rather than
    wait for it to be handled from stop playback.
    Don't reset backend if stop playback is called
    while A2DP is suspended.
    Also, set/reset slimbus TX config only when usecase is
    LDAC ABR.

    Bug: 80647629
    Test: Manual
    Change-Id: Idc80617aabb6d94d325dc7cad75099272a4582e5

commit a853b4b3f6447c20320d9ccbcf4e8ee65dccbe65
Merge: a9ddcff8f 6d945d284
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Sun Jun 24 03:07:32 2018 +0000

    Snap for 4859140 from 6d945d2847901bcff560dcd3108cfac0cca5f43d to pi-dr1-release

    Change-Id: I6a7ad22b18e29ecffd534e504b656dc93abd875c

commit 6d945d2847901bcff560dcd3108cfac0cca5f43d
Author: Jasmine Cha <chajasmine@google.com>
Date:   Tue Jun 19 09:49:04 2018 -0700

    audio: Load maxx_conf.ini by snd factor

    bug: 110378172
    Test: media playback test

    Change-Id: If3fa6a671eb48b84e17e7dcb287dd9f704a772ce
    Signed-off-by: Jasmine Cha <chajasmine@google.com>

commit a9ddcff8f568f0a5cd809fa44ae8cf570c90447d
Merge: 85649542c c1b760853
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Sun Jun 17 03:05:03 2018 +0000

    Snap for 4845430 from c1b7608539dbe41d75c19a6e242cbcbb906c705a to pi-dr1-release

    Change-Id: I82695b0dd191566cadd7dddb2f31df9057b699d6

commit c1b7608539dbe41d75c19a6e242cbcbb906c705a
Merge: 50fcc10af f76dae505
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Sat Jun 16 03:11:13 2018 +0000

    Merge "audio: Notify sthal of pending record as part of device enable" into pi-dev

commit 50fcc10afc171b179151538572c0994b13a7b780
Merge: 3f81b3b12 220b32e5e
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jun 15 03:10:19 2018 +0000

    Merge "audio: fix app type's acdb transfer to kernel driver" into pi-dev

commit f76dae505a2b39b49ccefb58839c393584a3760d
Author: Haynes Mathew George <hgeorge@codeaurora.org>
Date:   Wed Jun 13 16:06:19 2018 -0700

    audio: Notify sthal of pending record as part of device enable

    sthal by default disables soundtrigger
    sessions when an audio record session is
    started. The record hint is processed
    in the sthal as part of enabling the record
    audio route. This is insufficient as controls
    enabled as part of audio record device enable
    may be reset when the soundtrigger session
    is reset in sthal. Provide hint to sthal
    before enabling the record device to fix this.

    Bug: 109700532
    Change-Id: Idec8563e55107828ac48a1fb7cdde3b45ef0c07a

commit 3f81b3b12dbbdef65cc9a9b7efe8184c859f61de
Merge: 84757f372 88512e973
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jun 15 00:07:08 2018 +0000

    Merge "audio: hal: check routing after stop_output_stream" into pi-dev

commit 84757f37228aea0b0a1582910c0bb276c768c230
Author: Bhalchandra Gajare <gajare@codeaurora.org>
Date:   Mon Jun 11 18:18:30 2018 -0700

    hal: poll for SLPI subsystem status

    Add support to poll for SLPI(Sensor Low Power Island) subsystem
    offline and online status events and pass to sound trigger hal.

    Bug: 109833647
    Test: stream audio, restart SLPI, audio continues to stream
    Change-Id: I667a050aca7d8547e4f42776fae5185b2861a77f

commit 88512e9730f2db1820ce8c38a7cd1d14e9859fe6
Author: HW Lee <hwlee@google.com>
Date:   Tue Jun 12 15:26:09 2018 +0800

    audio: hal: check routing after stop_output_stream

    In case of voip playback during the music playback through speaker, the
    music will be switched to handset because it is the primary output of
    the voip. Once the voip playback has finished, the music playback should
    be switched back to speaker if the music is still being played.

    Bug: 80404632
    Test: manual audio test
    Change-Id: I91916c0913da5137d04433d4d69506bda030affa

commit 220b32e5ef138054e60c29273d1d93c305f80b71
Author: juyuchen <juyuchen@google.com>
Date:   Thu May 31 16:14:26 2018 +0800

    audio: fix app type's acdb transfer to kernel driver

    Bug: 80403838
    Test: manual audio test

    Change-Id: I7da41f866651026c3153cde5b9f93b5969227adc
    Signed-off-by: juyuchen <juyuchen@google.com>

commit 85649542cf5c03ef6afe2daf7dc725b1f9daf60d
Merge: 5d0261eae 9baad3909
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Thu Jun 7 03:03:46 2018 +0000

    Snap for 4826407 from 9baad39099c53d433332f80b75f53da19d4c1fb4 to pi-dr1-release

    Change-Id: I7dfbc5ba650d3e484c59855cb5cbfd17d9649efe

Change-Id: Icb61fc584cf17b42d64402b9a2f195e0736bc84c
---
 hal/audio_extn/a2dp.c            | 135 ++++++++++++++++++++-----------
 hal/audio_extn/audio_extn.h      |   3 +
 hal/audio_extn/cirrus_playback.c | 108 ++++++++++++++++++++++++-
 hal/audio_extn/maxxaudio.c       |  24 ++++--
 hal/audio_extn/sndmonitor.c      |  44 +++++++++-
 hal/audio_extn/soundtrigger.c    |  20 ++++-
 hal/audio_extn/spkr_protection.c |   5 ++
 hal/audio_extn/utils.c           |  37 ++++++---
 hal/audio_hw.c                   |  43 +++++++---
 hal/audio_hw.h                   |   2 +-
 hal/msm8916/platform.c           |   4 +
 hal/msm8916/platform.h           |   1 +
 hal/msm8974/platform.c           |   5 ++
 hal/msm8974/platform.h           |   1 +
 visualizer/Android.mk            |   8 --
 visualizer/offload_visualizer.c  |  25 ++++--
 16 files changed, 364 insertions(+), 101 deletions(-)

diff --git a/hal/audio_extn/a2dp.c b/hal/audio_extn/a2dp.c
index d1671a8d1..797daeeed 100644
--- a/hal/audio_extn/a2dp.c
+++ b/hal/audio_extn/a2dp.c
@@ -159,6 +159,11 @@ typedef enum {
     IMC_ENABLE,
 } imc_status_t;
 
+typedef enum {
+    MTU_SIZE,
+    PEAK_BIT_RATE,
+} frame_control_type_t;
+
 /* PCM config for ABR Feedback hostless front end */
 static struct pcm_config pcm_config_abr = {
     .channels = 1,
@@ -288,6 +293,17 @@ struct imc_dec_enc_info {
     uint32_t comm_instance;
 };
 
+/* Structure to control frame size of AAC encoded frames. */
+struct aac_frame_size_control_t {
+    /* Type of frame size control: MTU_SIZE / PEAK_BIT_RATE*/
+    uint32_t ctl_type;
+    /* Control value
+     * MTU_SIZE: MTU size in bytes
+     * PEAK_BIT_RATE: Peak bitrate in bits per second.
+     */
+    uint32_t ctl_value;
+};
+
 /* Structure used for ABR config of AFE encoder and decoder. */
 struct abr_enc_cfg_t {
     /* Link quality level to bitrate mapping info sent to DSP. */
@@ -310,10 +326,7 @@ struct abr_dec_cfg_t {
  * These values should match with DSP interface defintion
  */
 
-/* AAC encoder configuration structure. */
-typedef struct aac_enc_cfg_t aac_enc_cfg_t;
-
-struct aac_enc_cfg_t {
+struct aac_cfg_blk_t {
     /* Encoder media format for AAC */
     uint32_t      enc_format;
 
@@ -333,6 +346,14 @@ struct aac_enc_cfg_t {
     uint32_t      sample_rate;
 } __attribute__ ((packed));
 
+/* AAC encoder configuration structure. */
+typedef struct aac_enc_cfg_t aac_enc_cfg_t;
+
+struct aac_enc_cfg_t {
+    struct aac_cfg_blk_t aac_cfg;
+    struct aac_frame_size_control_t frame_ctl;
+} __attribute__ ((packed));
+
 /* SBC encoder configuration structure. */
 typedef struct sbc_enc_cfg_t sbc_enc_cfg_t;
 
@@ -493,6 +514,7 @@ typedef struct {
     uint32_t sampling_rate;
     uint32_t bitrate;
     uint32_t bits_per_sample;
+    struct aac_frame_size_control_t frame_ctl;
 } audio_aac_encoder_config;
 
 /* Information about Bluetooth LDAC encoder configuration
@@ -807,20 +829,21 @@ static int a2dp_set_backend_cfg()
     }
 
     // Set Tx backend sample rate
-    if (a2dp.abr_config.is_abr_enabled)
+    if (a2dp.abr_config.is_abr_enabled) {
         rate_str = ABR_TX_SAMPLE_RATE;
 
-    ALOGV("%s: set backend tx sample rate = %s", __func__, rate_str);
-    ctl_sample_rate = mixer_get_ctl_by_name(a2dp.adev->mixer,
-                                        MIXER_SAMPLE_RATE_TX);
-    if (!ctl_sample_rate) {
-        ALOGE("%s: ERROR backend sample rate mixer control not identifed", __func__);
-        return -ENOSYS;
-    }
-    if (mixer_ctl_set_enum_by_string(ctl_sample_rate, rate_str) != 0) {
-        ALOGE("%s: Failed to set backend sample rate = %s",
-                                    __func__, rate_str);
-        return -ENOSYS;
+        ALOGV("%s: set backend tx sample rate = %s", __func__, rate_str);
+        ctl_sample_rate = mixer_get_ctl_by_name(a2dp.adev->mixer,
+                                            MIXER_SAMPLE_RATE_TX);
+        if (!ctl_sample_rate) {
+            ALOGE("%s: ERROR backend sample rate mixer control not identifed", __func__);
+            return -ENOSYS;
+        }
+        if (mixer_ctl_set_enum_by_string(ctl_sample_rate, rate_str) != 0) {
+            ALOGE("%s: Failed to set backend sample rate = %s",
+                                        __func__, rate_str);
+            return -ENOSYS;
+        }
     }
 
     // Configure AFE input channels
@@ -901,15 +924,17 @@ static int a2dp_reset_backend_cfg()
         return -ENOSYS;
     }
 
-    ctl_sample_rate_tx = mixer_get_ctl_by_name(a2dp.adev->mixer,
-                                        MIXER_SAMPLE_RATE_TX);
-    if (!ctl_sample_rate_tx) {
-        ALOGE("%s: ERROR Tx backend sample rate mixer control not identifed", __func__);
-        return -ENOSYS;
-    }
-    if (mixer_ctl_set_enum_by_string(ctl_sample_rate_tx, rate_str) != 0) {
-        ALOGE("%s: Failed to reset Tx backend sample rate = %s", __func__, rate_str);
-        return -ENOSYS;
+    if (a2dp.abr_config.is_abr_enabled) {
+        ctl_sample_rate_tx = mixer_get_ctl_by_name(a2dp.adev->mixer,
+                                            MIXER_SAMPLE_RATE_TX);
+        if (!ctl_sample_rate_tx) {
+            ALOGE("%s: ERROR Tx backend sample rate mixer control not identifed", __func__);
+            return -ENOSYS;
+        }
+        if (mixer_ctl_set_enum_by_string(ctl_sample_rate_tx, rate_str) != 0) {
+            ALOGE("%s: Failed to reset Tx backend sample rate = %s", __func__, rate_str);
+            return -ENOSYS;
+        }
     }
 
     // Reset AFE input channels
@@ -1184,23 +1209,25 @@ static bool configure_aac_enc_format(audio_aac_encoder_config *aac_bt_cfg)
         goto exit;
     }
     memset(&aac_dsp_cfg, 0x0, sizeof(aac_dsp_cfg));
-    aac_dsp_cfg.enc_format = ENC_MEDIA_FMT_AAC;
-    aac_dsp_cfg.bit_rate = aac_bt_cfg->bitrate;
-    aac_dsp_cfg.sample_rate = aac_bt_cfg->sampling_rate;
+    aac_dsp_cfg.aac_cfg.enc_format = ENC_MEDIA_FMT_AAC;
+    aac_dsp_cfg.aac_cfg.bit_rate = aac_bt_cfg->bitrate;
+    aac_dsp_cfg.aac_cfg.sample_rate = aac_bt_cfg->sampling_rate;
     switch (aac_bt_cfg->enc_mode) {
         case 0:
-            aac_dsp_cfg.enc_mode = MEDIA_FMT_AAC_AOT_LC;
+            aac_dsp_cfg.aac_cfg.enc_mode = MEDIA_FMT_AAC_AOT_LC;
             break;
         case 2:
-            aac_dsp_cfg.enc_mode = MEDIA_FMT_AAC_AOT_PS;
+            aac_dsp_cfg.aac_cfg.enc_mode = MEDIA_FMT_AAC_AOT_PS;
             break;
         case 1:
         default:
-            aac_dsp_cfg.enc_mode = MEDIA_FMT_AAC_AOT_SBR;
+            aac_dsp_cfg.aac_cfg.enc_mode = MEDIA_FMT_AAC_AOT_SBR;
             break;
     }
-    aac_dsp_cfg.aac_fmt_flag = aac_bt_cfg->format_flag;
-    aac_dsp_cfg.channel_cfg = aac_bt_cfg->channels;
+    aac_dsp_cfg.aac_cfg.aac_fmt_flag = aac_bt_cfg->format_flag;
+    aac_dsp_cfg.aac_cfg.channel_cfg = aac_bt_cfg->channels;
+    aac_dsp_cfg.frame_ctl.ctl_type = aac_bt_cfg->frame_ctl.ctl_type;
+    aac_dsp_cfg.frame_ctl.ctl_value = aac_bt_cfg->frame_ctl.ctl_value;
     ret = mixer_ctl_set_array(ctl_enc_data, (void *)&aac_dsp_cfg,
                               sizeof(aac_dsp_cfg));
     if (ret != 0) {
@@ -1218,7 +1245,7 @@ static bool configure_aac_enc_format(audio_aac_encoder_config *aac_bt_cfg)
     a2dp.enc_sampling_rate = aac_bt_cfg->sampling_rate;
     a2dp.enc_channels = aac_bt_cfg->channels;
     ALOGV("%s: Successfully updated AAC enc format with sampling rate: %d channels:%d",
-           __func__, aac_dsp_cfg.sample_rate, aac_dsp_cfg.channel_cfg);
+           __func__, aac_dsp_cfg.aac_cfg.sample_rate, aac_dsp_cfg.aac_cfg.channel_cfg);
 exit:
     return is_configured;
 }
@@ -1457,6 +1484,15 @@ static int reset_a2dp_dec_config_params()
     return ret;
 }
 
+static void reset_a2dp_config() {
+    reset_a2dp_enc_config_params();
+    reset_a2dp_dec_config_params();
+    a2dp_reset_backend_cfg();
+    if (a2dp.abr_config.is_abr_enabled && a2dp.abr_config.abr_started)
+        stop_abr();
+    a2dp.abr_config.is_abr_enabled = false;
+}
+
 int audio_extn_a2dp_stop_playback()
 {
     int ret = 0;
@@ -1479,12 +1515,8 @@ int audio_extn_a2dp_stop_playback()
             ALOGE("%s: stop stream to Bluetooth IPC lib failed", __func__);
         else
             ALOGV("%s: stop steam to Bluetooth IPC lib successful", __func__);
-        reset_a2dp_enc_config_params();
-        reset_a2dp_dec_config_params();
-        a2dp_reset_backend_cfg();
-        if (a2dp.abr_config.is_abr_enabled && a2dp.abr_config.abr_started)
-            stop_abr();
-        a2dp.abr_config.is_abr_enabled = false;
+        if (!a2dp.a2dp_suspended)
+            reset_a2dp_config();
         a2dp.a2dp_started = false;
     }
     ALOGD("%s: Stop A2DP playback total active sessions :%d", __func__,
@@ -1495,13 +1527,14 @@ int audio_extn_a2dp_stop_playback()
 int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
 {
      int ret = 0, val;
+     int status = 0;
      char value[32] = {0};
      struct audio_usecase *uc_info;
      struct listnode *node;
 
      if (a2dp.is_a2dp_offload_enabled == false) {
         ALOGV("%s: No supported encoders identified,ignoring A2DP setparam", __func__);
-        ret = -EINVAL;
+        status = -EINVAL;
         goto param_handled;
      }
 
@@ -1549,8 +1582,7 @@ int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
                         pthread_mutex_lock(&a2dp.adev->lock);
                     }
                 }
-                reset_a2dp_enc_config_params();
-                reset_a2dp_dec_config_params();
+                reset_a2dp_config();
                 if (a2dp.audio_stream_suspend) {
                    a2dp.audio_stream_suspend();
                 }
@@ -1580,12 +1612,23 @@ int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
                 if (a2dp.a2dp_total_active_session_request > 0) {
                     ALOGD("%s: Calling Bluetooth IPC lib start post suspend state", __func__);
                     if (a2dp.audio_stream_start) {
-                        ret =  a2dp.audio_stream_start();
-                        if (ret != 0) {
+                        status =  a2dp.audio_stream_start();
+                        if (status != 0) {
                             ALOGE("%s: Bluetooth controller start failed", __func__);
                             a2dp.a2dp_started = false;
+                        } else {
+                            if (!configure_a2dp_encoder_format()) {
+                                ALOGE("%s: Encoder params configuration failed post suspend", __func__);
+                                a2dp.a2dp_started = false;
+                                status = -ETIMEDOUT;
+                            }
                         }
                     }
+                    if (a2dp.a2dp_started) {
+                        a2dp_set_backend_cfg();
+                        if (a2dp.abr_config.is_abr_enabled)
+                            start_abr();
+                    }
                 }
                 list_for_each(node, &a2dp.adev->usecase_list) {
                     uc_info = node_to_item(node, struct audio_usecase, list);
@@ -1613,7 +1656,7 @@ int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
 
 param_handled:
      ALOGV("%s: end of A2DP setparam", __func__);
-     return ret;
+     return status;
 }
 
 void audio_extn_a2dp_set_handoff_mode(bool is_on)
diff --git a/hal/audio_extn/audio_extn.h b/hal/audio_extn/audio_extn.h
index b1c701d7d..1c28b6b65 100644
--- a/hal/audio_extn/audio_extn.h
+++ b/hal/audio_extn/audio_extn.h
@@ -42,6 +42,7 @@ void audio_extn_set_snd_card_split(const char* in_snd_card_name);
 #define audio_extn_spkr_prot_stop_processing(snd_device)     (0)
 #define audio_extn_spkr_prot_is_enabled() (false)
 #define audio_extn_get_spkr_prot_snd_device(snd_device) (snd_device)
+#define audio_extn_spkr_prot_deinit(adev)       (0)
 #else
 void audio_extn_spkr_prot_init(void *adev);
 int audio_extn_spkr_prot_start_processing(snd_device_t snd_device);
@@ -49,6 +50,8 @@ void audio_extn_spkr_prot_stop_processing(snd_device_t snd_device);
 bool audio_extn_spkr_prot_is_enabled();
 int audio_extn_get_spkr_prot_snd_device(snd_device_t snd_device);
 void audio_extn_spkr_prot_calib_cancel(void *adev);
+void audio_extn_spkr_prot_deinit(void *adev);
+
 #endif
 
 #ifndef HFP_ENABLED
diff --git a/hal/audio_extn/cirrus_playback.c b/hal/audio_extn/cirrus_playback.c
index 21dbc10ed..25fe258d7 100644
--- a/hal/audio_extn/cirrus_playback.c
+++ b/hal/audio_extn/cirrus_playback.c
@@ -155,7 +155,11 @@ static struct pcm_config pcm_config_cirrus_rx = {
 
 static struct cirrus_playback_session handle;
 
+#ifdef CIRRUS_FACTORY_CALIBRATION
 static void *audio_extn_cirrus_calibration_thread();
+#else
+static void *audio_extn_cirrus_config_thread();
+#endif
 
 #ifdef ENABLE_CIRRUS_DETECTION
 static void *audio_extn_cirrus_failure_detect_thread();
@@ -175,11 +179,30 @@ void audio_extn_spkr_prot_init(void *adev) {
 
     pthread_mutex_init(&handle.fb_prot_mutex, NULL);
 
+#ifdef CIRRUS_FACTORY_CALIBRATION
     (void)pthread_create(&handle.calibration_thread,
                 (const pthread_attr_t *) NULL,
                 audio_extn_cirrus_calibration_thread, &handle);
+#else
+    (void)pthread_create(&handle.calibration_thread,
+                (const pthread_attr_t *) NULL,
+                audio_extn_cirrus_config_thread, &handle);
+#endif
+}
+
+void audio_extn_spkr_prot_deinit(void *adev __unused) {
+    ALOGV("%s: Entry", __func__);
+
+#ifdef ENABLE_CIRRUS_DETECTION
+    pthread_join(handle.failure_detect_thread, NULL);
+#endif
+    pthread_join(handle.calibration_thread, NULL);
+    pthread_mutex_destroy(&handle.fb_prot_mutex);
+
+    ALOGV("%s: Exit", __func__);
 }
 
+#ifdef CIRRUS_FACTORY_CALIBRATION
 static int audio_extn_cirrus_run_calibration() {
     struct audio_device *adev = handle.adev_handle;
     struct crus_sp_ioctl_header header;
@@ -282,7 +305,6 @@ static int audio_extn_cirrus_run_calibration() {
         if (ret < 0)
             goto exit;
 
-#ifdef ENABLED_CIRRUS_WRITE_CAL_FILE
         cal_file = fopen(CRUS_CAL_FILE, "wb");
         if (cal_file == NULL) {
             ALOGE("%s: Cannot create Cirrus SP calibration file (%s)",
@@ -305,7 +327,6 @@ static int audio_extn_cirrus_run_calibration() {
 
         ALOGI("%s: Cirrus calibration file successfully written",
               __func__);
-#endif
     }
 
     header.size = sizeof(header);
@@ -531,6 +552,89 @@ exit:
     return NULL;
 }
 
+#else
+static void *audio_extn_cirrus_config_thread(void) {
+    struct audio_device *adev = handle.adev_handle;
+    struct crus_sp_ioctl_header header;
+    struct cirrus_cal_result_t result;
+    struct mixer_ctl *ctl_config = NULL;
+    FILE *cal_file = NULL;
+    int ret = 0, dev_file = -1;
+
+    ALOGI("%s: ++", __func__);
+
+    memset(&result, 0, sizeof(result));
+
+    dev_file = open(CRUS_SP_FILE, O_RDWR | O_NONBLOCK);
+    if (dev_file < 0) {
+        ALOGE("%s: Failed to open Cirrus Playback IOCTL (%d)",
+              __func__, dev_file);
+        ret = -EINVAL;
+        goto exit;
+    }
+
+    cal_file = fopen(CRUS_CAL_FILE, "r");
+    if (cal_file) {
+        ret = fread(&result, sizeof(result), 1, cal_file);
+
+        if (ret != 1) {
+            ALOGE("%s: Cirrus SP calibration file cannot be read , read size: %lu file error: %d",
+                 __func__, (unsigned long)ret * sizeof(result), ferror(cal_file));
+            ret = -EINVAL;
+            goto exit;
+        }
+    }
+
+    header.size = sizeof(header);
+    header.module_id = CRUS_MODULE_ID_TX;
+    header.param_id = 0;
+    header.data_length = sizeof(result);
+    header.data = &result;
+
+    ret = ioctl(dev_file, CRUS_SP_IOCTL_SET_CALIB, &header);
+
+    if (ret < 0) {
+        ALOGE("%s: Cirrus SP calibration IOCTL failure", __func__);
+        goto exit;
+    }
+
+    ctl_config = mixer_get_ctl_by_name(adev->mixer,
+                       CRUS_SP_LOAD_CONF_MIXER);
+    if (!ctl_config) {
+        ALOGE("%s: Could not get ctl for mixer commands", __func__);
+        ret = -EINVAL;
+        goto exit;
+    }
+
+    ret = mixer_ctl_set_value(ctl_config, 0, 2);
+    if (ret < 0) {
+        ALOGE("%s load tx config failed", __func__);
+        goto exit;
+    }
+
+    ret = mixer_ctl_set_value(ctl_config, 0, 1);
+    if (ret < 0) {
+        ALOGE("%s load rx config failed", __func__);
+        goto exit;
+    }
+
+    ret = mixer_ctl_set_value(ctl_config, 0, 0);
+    if (ret < 0) {
+        ALOGE("%s set idle state failed", __func__);
+        goto exit;
+    }
+
+exit:
+    if (dev_file >= 0)
+        close(dev_file);
+    if (cal_file)
+        fclose(cal_file);
+
+    ALOGI("%s: ret: %d --", __func__, ret);
+    return NULL;
+}
+#endif
+
 #ifdef ENABLE_CIRRUS_DETECTION
 void *audio_extn_cirrus_failure_detect_thread() {
     struct audio_device *adev = handle.adev_handle;
diff --git a/hal/audio_extn/maxxaudio.c b/hal/audio_extn/maxxaudio.c
index 9007da7c7..fc6533230 100644
--- a/hal/audio_extn/maxxaudio.c
+++ b/hal/audio_extn/maxxaudio.c
@@ -37,7 +37,7 @@
 #define PRESET_PATH "/vendor/etc"
 #define MPS_BASE_STRING "default"
 #define USER_PRESET_PATH ""
-#define CONFIG_PATH "/vendor/etc/maxx_conf.ini"
+#define CONFIG_BASE_STRING "maxx_conf"
 #define CAL_PRESIST_STR "cal_persist"
 #define CAL_SAMPLERATE_STR "cal_samplerate"
 
@@ -344,6 +344,7 @@ void audio_extn_ma_init(void *platform)
     int ret = 0;
     char lib_path[128] = {0};
     char mps_path[128] = {0};
+    char cnf_path[128] = {0};
     struct snd_card_split *snd_split_handle = NULL;
     snd_split_handle = audio_extn_get_snd_card_split();
 
@@ -427,8 +428,17 @@ void audio_extn_ma_init(void *platform)
                  PRESET_PATH, MPS_BASE_STRING, snd_split_handle->form_factor);
     }
 
+    /* get config files */
+    if (snd_split_handle == NULL) {
+        snprintf(cnf_path, sizeof(cnf_path), "%s/%s.ini",
+                 PRESET_PATH, CONFIG_BASE_STRING);
+    } else {
+        snprintf(cnf_path, sizeof(cnf_path), "%s/%s_%s.ini",
+                 PRESET_PATH, CONFIG_BASE_STRING, snd_split_handle->form_factor);
+    }
+
     /* check file */
-    if (access(mps_path, F_OK) < 0) {
+    if (access(mps_path, R_OK) < 0) {
         ALOGW("%s: file %s isn't existed.", __func__, mps_path);
         goto error;
     } else
@@ -440,16 +450,18 @@ void audio_extn_ma_init(void *platform)
         goto error;
     }
     */
-    if (access(CONFIG_PATH, F_OK) < 0) {
-        ALOGW("%s: file %s isn't existed.", __func__, CONFIG_PATH);
+
+    if (access(cnf_path, R_OK) < 0) {
+        ALOGW("%s: file %s isn't existed.", __func__, cnf_path);
         goto error;
-    }
+    } else
+        ALOGD("%s: Loading ini file: %s", __func__, cnf_path);
 
     /* init ma parameter */
     if (my_data->ma_param_init(&g_ma_audio_cal_handle,
                                mps_path,
                                USER_PRESET_PATH, /* unused */
-                               CONFIG_PATH,
+                               cnf_path,
                                &set_audio_cal)) {
         if (!g_ma_audio_cal_handle) {
             ALOGE("%s: ma parameters initialize failed", __func__);
diff --git a/hal/audio_extn/sndmonitor.c b/hal/audio_extn/sndmonitor.c
index 6e06d0363..2e8fd43fb 100644
--- a/hal/audio_extn/sndmonitor.c
+++ b/hal/audio_extn/sndmonitor.c
@@ -51,6 +51,11 @@
 #define MAX_CPE_SLEEP_RETRY 2
 #define CPE_SLEEP_WAIT 100
 
+#define SPLI_STATE_PATH "/proc/wcd-spi-ac/svc-state"
+#define SLPI_MAGIC_NUM 0x3000
+#define MAX_SLPI_SLEEP_RETRY 2
+#define SLPI_SLEEP_WAIT_MS 100
+
 #define MAX_SLEEP_RETRY 100
 #define AUDIO_INIT_SLEEP_WAIT 100 /* 100 ms */
 
@@ -245,6 +250,31 @@ static int enum_sndcards()
     if (line)
         free(line);
     fclose(fp);
+
+    /* Add fd to query for SLPI status */
+    if (access(SPLI_STATE_PATH, R_OK) < 0) {
+        ALOGV("access to %s failed: %s", SPLI_STATE_PATH, strerror(errno));
+    } else {
+        tries = MAX_SLPI_SLEEP_RETRY;
+        ALOGV("Open %s", SPLI_STATE_PATH);
+        while (tries--) {
+            if ((fd = open(SPLI_STATE_PATH, O_RDONLY)) < 0) {
+                ALOGW("Open %s failed %s, retry", SPLI_STATE_PATH,
+                      strerror(errno));
+                usleep(SLPI_SLEEP_WAIT_MS * 1000);
+                continue;
+            }
+            break;
+        }
+        if (fd >= 0) {
+            ret = add_new_sndcard(SLPI_MAGIC_NUM, fd);
+            if (ret != 0)
+                close(fd);
+            else
+                num_cards++;
+        }
+    }
+
     ALOGV("sndmonitor registerer num_cards %d", num_cards);
     sndmonitor.num_cards = num_cards;
     return num_cards ? 0 : -1;
@@ -383,7 +413,6 @@ bool on_sndcard_state_update(sndcard_t * s)
 
     ALOGV("card num %d, new state %s", s->card, rd_buf);
 
-    bool is_cpe = (s->card >= CPE_MAGIC_NUM);
     if (strstr(rd_buf, "OFFLINE"))
         status = CARD_STATUS_OFFLINE;
     else if (strstr(rd_buf, "ONLINE"))
@@ -404,11 +433,18 @@ bool on_sndcard_state_update(sndcard_t * s)
         return -1;
 
     char val[32] = {0};
-    // cpe actual card num is (card - MAGIC_NUM). so subtract accordingly
-    snprintf(val, sizeof(val), "%d,%s", s->card - (is_cpe ? CPE_MAGIC_NUM : 0),
+    bool is_cpe = ((s->card >= CPE_MAGIC_NUM) && (s->card < SLPI_MAGIC_NUM));
+    bool is_slpi = (s->card == SLPI_MAGIC_NUM);
+    /*
+     * cpe actual card num is (card - CPE_MAGIC_NUM), so subtract accordingly.
+     * SLPI actual fd num is (card - SLPI_MAGIC_NUM), so subtract accordingly.
+     */
+    snprintf(val, sizeof(val), "%d,%s",
+        s->card - (is_cpe ? CPE_MAGIC_NUM : (is_slpi ? SLPI_MAGIC_NUM : 0)),
                  status == CARD_STATUS_ONLINE ? "ONLINE" : "OFFLINE");
 
-    if (str_parms_add_str(params, is_cpe ? "CPE_STATUS" : "SND_CARD_STATUS",
+    if (str_parms_add_str(params,
+            is_cpe ? "CPE_STATUS" : (is_slpi ? "SLPI_STATUS" : "SND_CARD_STATUS"),
                           val) < 0)
         return -1;
 
diff --git a/hal/audio_extn/soundtrigger.c b/hal/audio_extn/soundtrigger.c
index c11e74721..063a7babe 100644
--- a/hal/audio_extn/soundtrigger.c
+++ b/hal/audio_extn/soundtrigger.c
@@ -78,7 +78,9 @@ typedef enum {
     SND_CARD_STATUS_OFFLINE,
     SND_CARD_STATUS_ONLINE,
     CPE_STATUS_OFFLINE,
-    CPE_STATUS_ONLINE
+    CPE_STATUS_ONLINE,
+    SLPI_STATUS_OFFLINE,
+    SLPI_STATUS_ONLINE,
 } ssr_event_status_t;
 
 struct sound_trigger_session_info {
@@ -362,9 +364,6 @@ void audio_extn_sound_trigger_update_device_status(snd_device_t snd_device,
     if (!st_dev)
        return;
 
-    if (st_dev->sthal_prop_api_version >= STHAL_PROP_API_VERSION_1_0)
-        return;
-
     if (snd_device >= SND_DEVICE_OUT_BEGIN &&
         snd_device < SND_DEVICE_OUT_END) {
         device_type = PCM_PLAYBACK;
@@ -484,6 +483,19 @@ void audio_extn_sound_trigger_set_parameters(struct audio_device *adev __unused,
         event.u.value = val;
         st_dev->st_callback(AUDIO_EVENT_NUM_ST_SESSIONS, &event);
     }
+
+    ret = str_parms_get_str(params, "SLPI_STATUS", value, sizeof(value));
+    if (ret > 0) {
+        if (strstr(value, "OFFLINE")) {
+            event.u.status = SLPI_STATUS_OFFLINE;
+            st_dev->st_callback(AUDIO_EVENT_SSR, &event);
+        } else if (strstr(value, "ONLINE")) {
+            event.u.status = SLPI_STATUS_ONLINE;
+            st_dev->st_callback(AUDIO_EVENT_SSR, &event);
+        } else {
+            ALOGE("%s: unknown SLPI status", __func__);
+        }
+    }
 }
 
 int audio_extn_sound_trigger_init(struct audio_device *adev)
diff --git a/hal/audio_extn/spkr_protection.c b/hal/audio_extn/spkr_protection.c
index 8c09a295f..dba69a076 100644
--- a/hal/audio_extn/spkr_protection.c
+++ b/hal/audio_extn/spkr_protection.c
@@ -780,6 +780,11 @@ void audio_extn_spkr_prot_init(void *adev)
     }
 }
 
+void audio_extn_spkr_prot_deinit(void *adev __unused)
+{
+    ALOGV("%s: Entry", __func__);
+}
+
 int audio_extn_get_spkr_prot_snd_device(snd_device_t snd_device)
 {
     if (!handle.spkr_prot_enable)
diff --git a/hal/audio_extn/utils.c b/hal/audio_extn/utils.c
index 1751a30e1..73de0abaa 100644
--- a/hal/audio_extn/utils.c
+++ b/hal/audio_extn/utils.c
@@ -345,6 +345,8 @@ int audio_extn_utils_send_app_type_cfg(struct audio_device *adev,
     int sample_rate;
     int app_type;
     int acdb_dev_id;
+    int new_snd_device[2] = {0};
+    int i = 0, num_devices = 1;
     size_t app_type_cfg[MAX_LENGTH_MIXER_CONTROL_IN_INT] = {0};
     char mixer_ctl_name[MAX_LENGTH_MIXER_CONTROL_IN_INT] = {0};
     int pcm_device_id;
@@ -379,18 +381,33 @@ int audio_extn_utils_send_app_type_cfg(struct audio_device *adev,
         return -1;
     }
 
-    acdb_dev_id = derive_acdb_dev_id(adev, usecase);
-    if (acdb_dev_id <= 0) {
-        ALOGE("%s: Couldn't get the acdb dev id", __func__);
-        return -1;
-    }
+    if (usecase->type == PCM_PLAYBACK) {
+        if (platform_can_split_snd_device(usecase->out_snd_device,
+                                          &num_devices, new_snd_device) < 0)
+            new_snd_device[0] = usecase->out_snd_device;
+
+    } else if (usecase->type == PCM_CAPTURE)
+        new_snd_device[0] = usecase->in_snd_device;
 
     pcm_device_id = platform_get_pcm_device_id(usecase->id, usecase->type);
-    set_stream_app_type_mixer_ctrl(adev, pcm_device_id, app_type, acdb_dev_id,
-                                   sample_rate,
-                                   usecase->type,
-                                   usecase->type == PCM_PLAYBACK ? usecase->out_snd_device :
-                                                                   usecase->in_snd_device);
+
+    for (i = 0; i < num_devices; i++) {
+        acdb_dev_id = platform_get_snd_device_acdb_id(new_snd_device[i]);
+
+        if (acdb_dev_id < 0) {
+            ALOGE("%s: Could not find acdb id for device(%d)",
+                  __func__, new_snd_device[i]);
+            return -EINVAL;
+        }
+        ALOGV("%s: sending app type for snd_device(%d) acdb_id(%d) i %d",
+              __func__, new_snd_device[i], acdb_dev_id, i);
+
+        set_stream_app_type_mixer_ctrl(adev, pcm_device_id, app_type, acdb_dev_id,
+                                       sample_rate,
+                                       usecase->type,
+                                       new_snd_device[i]);
+    }
+
     return 0;
 }
 
diff --git a/hal/audio_hw.c b/hal/audio_hw.c
index 0a12cff5c..955957317 100644
--- a/hal/audio_hw.c
+++ b/hal/audio_hw.c
@@ -1373,6 +1373,10 @@ int select_devices(struct audio_device *adev,
             out_snd_device = SND_DEVICE_OUT_SPEAKER;
     }
 
+    if (usecase->id == USECASE_INCALL_MUSIC_UPLINK) {
+        out_snd_device = SND_DEVICE_OUT_VOICE_MUSIC_TX;
+    }
+
     if (out_snd_device != SND_DEVICE_NONE &&
             out_snd_device != adev->last_logged_snd_device[uc_id][0]) {
         ALOGD("%s: changing use case %s output device from(%d: %s, acdb %d) to (%d: %s, acdb %d)",
@@ -1954,6 +1958,8 @@ static int stop_output_stream(struct stream_out *out)
     int i, ret = 0;
     struct audio_usecase *uc_info;
     struct audio_device *adev = out->dev;
+    bool has_voip_usecase =
+        get_usecase_from_list(adev, USECASE_AUDIO_PLAYBACK_VOIP) != NULL;
 
     ALOGV("%s: enter: usecase(%d: %s)", __func__,
           out->usecase, use_case_table[out->usecase]);
@@ -1987,15 +1993,7 @@ static int stop_output_stream(struct stream_out *out)
     /* Must be called after removing the usecase from list */
     if (out->devices & AUDIO_DEVICE_OUT_AUX_DIGITAL)
         check_and_set_hdmi_channels(adev, DEFAULT_HDMI_OUT_CHANNELS);
-    else if (out->devices & AUDIO_DEVICE_OUT_SPEAKER_SAFE) {
-        struct listnode *node;
-        struct audio_usecase *usecase;
-        list_for_each(node, &adev->usecase_list) {
-            usecase = node_to_item(node, struct audio_usecase, list);
-            if (usecase->devices & AUDIO_DEVICE_OUT_SPEAKER)
-                select_devices(adev, usecase->id);
-        }
-    } else if (audio_is_usb_out_device(out->devices & AUDIO_DEVICE_OUT_ALL_USB)) {
+    else if (audio_is_usb_out_device(out->devices & AUDIO_DEVICE_OUT_ALL_USB)) {
         ret = check_and_set_usb_service_interval(adev, uc_info, false /*min*/);
         if (ret == 0) {
             /* default service interval was successfully updated,
@@ -2005,6 +2003,22 @@ static int stop_output_stream(struct stream_out *out)
         ret = 0;
     }
 
+    if (has_voip_usecase ||
+            out->devices & AUDIO_DEVICE_OUT_SPEAKER_SAFE) {
+        struct listnode *node;
+        struct audio_usecase *usecase;
+        list_for_each(node, &adev->usecase_list) {
+            usecase = node_to_item(node, struct audio_usecase, list);
+            if (usecase->type == PCM_CAPTURE || usecase == uc_info)
+                continue;
+
+            ALOGD("%s: select_devices at usecase(%d: %s) after removing the usecase(%d: %s)",
+                __func__, usecase->id, use_case_table[usecase->id],
+                out->usecase, use_case_table[out->usecase]);
+            select_devices(adev, usecase->id);
+        }
+    }
+
     free(uc_info);
     ALOGV("%s: exit: status(%d)", __func__, ret);
     return ret;
@@ -2105,8 +2119,13 @@ int start_output_stream(struct stream_out *out)
         if (out->offload_callback)
             compress_nonblock(out->compr, out->non_blocking);
 
-        if (adev->visualizer_start_output != NULL)
-            adev->visualizer_start_output(out->handle, out->pcm_device_id);
+        if (adev->visualizer_start_output != NULL) {
+            int capture_device_id =
+                platform_get_pcm_device_id(USECASE_AUDIO_RECORD_AFE_PROXY,
+                                           PCM_CAPTURE);
+            adev->visualizer_start_output(out->handle, out->pcm_device_id,
+                                          adev->snd_card, capture_device_id);
+        }
         if (adev->offload_effects_start_output != NULL)
             adev->offload_effects_start_output(out->handle, out->pcm_device_id);
     } else if (out->usecase == USECASE_AUDIO_PLAYBACK_MMAP) {
@@ -5608,7 +5627,7 @@ static int adev_open(const hw_module_t *module, const char *name,
     } else {
         ALOGV("%s: DLOPEN successful for %s", __func__, VISUALIZER_LIBRARY_PATH);
         adev->visualizer_start_output =
-                    (int (*)(audio_io_handle_t, int))dlsym(adev->visualizer_lib,
+                    (int (*)(audio_io_handle_t, int, int, int))dlsym(adev->visualizer_lib,
                                                     "visualizer_hal_start_output");
         adev->visualizer_stop_output =
                     (int (*)(audio_io_handle_t, int))dlsym(adev->visualizer_lib,
diff --git a/hal/audio_hw.h b/hal/audio_hw.h
index 921c249c9..637984409 100644
--- a/hal/audio_hw.h
+++ b/hal/audio_hw.h
@@ -337,7 +337,7 @@ struct audio_device {
     card_status_t card_status;
 
     void *visualizer_lib;
-    int (*visualizer_start_output)(audio_io_handle_t, int);
+    int (*visualizer_start_output)(audio_io_handle_t, int, int, int);
     int (*visualizer_stop_output)(audio_io_handle_t, int);
 
     /* The pcm_params use_case_table is loaded by adev_verify_devices() upon
diff --git a/hal/msm8916/platform.c b/hal/msm8916/platform.c
index d92243e90..f6508c31a 100644
--- a/hal/msm8916/platform.c
+++ b/hal/msm8916/platform.c
@@ -232,6 +232,7 @@ static const char * const device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_VCO_HEADPHONES] = "voice-tty-vco-headphones",
     [SND_DEVICE_OUT_VOICE_TTY_HCO_HANDSET] = "voice-tty-hco-handset",
     [SND_DEVICE_OUT_VOICE_TX] = "voice-tx",
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = "voice-music-tx",
     [SND_DEVICE_OUT_AFE_PROXY] = "afe-proxy",
     [SND_DEVICE_OUT_USB_HEADSET] = "usb-headphones",
     [SND_DEVICE_OUT_USB_HEADPHONES] = "usb-headphones",
@@ -326,6 +327,7 @@ static int acdb_device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_VCO_HEADPHONES] = 17,
     [SND_DEVICE_OUT_VOICE_TTY_HCO_HANDSET] = 37,
     [SND_DEVICE_OUT_VOICE_TX] = 45,
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = 3,
     [SND_DEVICE_OUT_AFE_PROXY] = 0,
     [SND_DEVICE_OUT_USB_HEADSET] = 45,
     [SND_DEVICE_OUT_VOICE_USB_HEADSET] = 45,
@@ -1205,6 +1207,8 @@ void platform_deinit(void *platform)
     struct operator_specific_device *device_item;
     struct listnode *node;
 
+    audio_extn_spkr_prot_deinit(my_data->adev);
+
     hw_info_deinit(my_data->hw_info);
 
     for (dev = 0; dev < SND_DEVICE_MAX; dev++) {
diff --git a/hal/msm8916/platform.h b/hal/msm8916/platform.h
index b69b6c9f7..5b4004f7e 100644
--- a/hal/msm8916/platform.h
+++ b/hal/msm8916/platform.h
@@ -78,6 +78,7 @@ enum {
     SND_DEVICE_OUT_VOICE_TTY_VCO_HEADPHONES,
     SND_DEVICE_OUT_VOICE_TTY_HCO_HANDSET,
     SND_DEVICE_OUT_VOICE_TX,
+    SND_DEVICE_OUT_VOICE_MUSIC_TX,
     SND_DEVICE_OUT_AFE_PROXY,
     SND_DEVICE_OUT_USB_HEADSET,
     SND_DEVICE_OUT_USB_HEADPHONES,
diff --git a/hal/msm8974/platform.c b/hal/msm8974/platform.c
index 429291cfb..0750e7521 100644
--- a/hal/msm8974/platform.c
+++ b/hal/msm8974/platform.c
@@ -271,6 +271,7 @@ static const char * const device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_FULL_USB] = "voice-tty-full-usb",
     [SND_DEVICE_OUT_VOICE_TTY_VCO_USB] = "voice-tty-vco-usb",
     [SND_DEVICE_OUT_VOICE_TX] = "voice-tx",
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = "voice-music-tx",
     [SND_DEVICE_OUT_USB_HEADSET] = "usb-headset",
     [SND_DEVICE_OUT_VOICE_USB_HEADSET] = "usb-headset",
     [SND_DEVICE_OUT_USB_HEADPHONES] = "usb-headphones",
@@ -393,6 +394,7 @@ static int acdb_device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_FULL_USB] = 17,
     [SND_DEVICE_OUT_VOICE_TTY_VCO_USB] = 17,
     [SND_DEVICE_OUT_VOICE_TX] = 45,
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = 3,
     [SND_DEVICE_OUT_USB_HEADSET] = 45,
     [SND_DEVICE_OUT_VOICE_USB_HEADSET] = 45,
     [SND_DEVICE_OUT_USB_HEADPHONES] = 45,
@@ -1240,6 +1242,7 @@ static void set_platform_defaults(struct platform_data * my_data)
     hw_interface_table[SND_DEVICE_OUT_VOICE_HAC_HANDSET] = strdup("SLIMBUS_0_RX");
     hw_interface_table[SND_DEVICE_OUT_VOICE_SPEAKER] = strdup("SLIMBUS_0_RX");
     hw_interface_table[SND_DEVICE_OUT_VOICE_HEADPHONES] = strdup("SLIMBUS_0_RX");
+    hw_interface_table[SND_DEVICE_OUT_VOICE_MUSIC_TX] = strdup("VOICE_PLAYBACK_TX");
     hw_interface_table[SND_DEVICE_OUT_VOICE_LINE] = strdup("SLIMBUS_0_RX");
     hw_interface_table[SND_DEVICE_OUT_HDMI] = strdup("HDMI_RX");
     hw_interface_table[SND_DEVICE_OUT_SPEAKER_AND_HDMI] = strdup("SLIMBUS_0_RX-and-HDMI_RX");
@@ -1834,6 +1837,8 @@ void platform_deinit(void *platform)
     struct platform_data *my_data = (struct platform_data *)platform;
     close_csd_client(my_data->csd);
 
+    audio_extn_spkr_prot_deinit(my_data->adev);
+
     hw_info_deinit(my_data->hw_info);
 
     for (dev = 0; dev < SND_DEVICE_MAX; dev++) {
diff --git a/hal/msm8974/platform.h b/hal/msm8974/platform.h
index 2c7eebf2d..8661fad74 100644
--- a/hal/msm8974/platform.h
+++ b/hal/msm8974/platform.h
@@ -89,6 +89,7 @@ enum {
     SND_DEVICE_OUT_VOICE_TTY_VCO_USB,
     SND_DEVICE_OUT_VOICE_HAC_HANDSET,
     SND_DEVICE_OUT_VOICE_TX,
+    SND_DEVICE_OUT_VOICE_MUSIC_TX,
     SND_DEVICE_OUT_SPEAKER_PROTECTED,
     SND_DEVICE_OUT_VOICE_SPEAKER_PROTECTED,
     SND_DEVICE_OUT_VOICE_SPEAKER_HFP,
diff --git a/visualizer/Android.mk b/visualizer/Android.mk
index 7d7cfe982..13a45c734 100644
--- a/visualizer/Android.mk
+++ b/visualizer/Android.mk
@@ -27,14 +27,6 @@ LOCAL_SHARED_LIBRARIES := \
 	libdl \
 	libtinyalsa
 
-# HACK to set the right record proxy effect card number.
-# It should be retrieved from the primary hal USECASE_AUDIO_RECORD_AFE_PROXY.
-ifneq ($(filter msm8998,$(TARGET_BOARD_PLATFORM)),)
-  LOCAL_CFLAGS := -DCAPTURE_DEVICE=7
-else
-  LOCAL_CFLAGS := -DCAPTURE_DEVICE=8
-endif
-
 LOCAL_CFLAGS += \
     -Wall \
     -Werror \
diff --git a/visualizer/offload_visualizer.c b/visualizer/offload_visualizer.c
index 860dfce83..74beac733 100644
--- a/visualizer/offload_visualizer.c
+++ b/visualizer/offload_visualizer.c
@@ -145,6 +145,12 @@ const effect_descriptor_t *descriptors[] = {
         NULL,
 };
 
+struct pcm_capture_config {
+    int snd_card_num;
+    int capture_device_id;
+};
+
+struct pcm_capture_config capture_config;
 
 pthread_once_t once = PTHREAD_ONCE_INIT;
 int init_status;
@@ -172,16 +178,12 @@ bool exit_thread;
 /* 0 if the capture thread was created successfully */
 int thread_status;
 
-
 #define DSP_OUTPUT_LATENCY_MS 0 /* Fudge factor for latency after capture point in audio DSP */
 
 /* Retry for delay for mixer open */
 #define RETRY_NUMBER 10
 #define RETRY_US 500000
 
-#define MIXER_CARD 0
-#define SOUND_CARD 0
-
 /* Proxy port supports only MMAP read and those fixed parameters*/
 #define AUDIO_CAPTURE_CHANNEL_COUNT 2
 #define AUDIO_CAPTURE_SMP_RATE 48000
@@ -338,10 +340,10 @@ void *capture_thread_loop(void *arg __unused)
 
     pthread_mutex_lock(&lock);
 
-    mixer = mixer_open(MIXER_CARD);
+    mixer = mixer_open(capture_config.snd_card_num);
     while (mixer == NULL && retry_num < RETRY_NUMBER) {
         usleep(RETRY_US);
-        mixer = mixer_open(MIXER_CARD);
+        mixer = mixer_open(capture_config.snd_card_num);
         retry_num++;
     }
     if (mixer == NULL) {
@@ -357,7 +359,8 @@ void *capture_thread_loop(void *arg __unused)
             if (!capture_enabled) {
                 ret = configure_proxy_capture(mixer, 1);
                 if (ret == 0) {
-                    pcm = pcm_open(SOUND_CARD, CAPTURE_DEVICE,
+                    pcm = pcm_open(capture_config.snd_card_num,
+                                   capture_config.capture_device_id,
                                    PCM_IN|PCM_MMAP|PCM_NOIRQ, &pcm_config_capture);
                     if (pcm && !pcm_is_ready(pcm)) {
                         ALOGW("%s: %s", __func__, pcm_get_error(pcm));
@@ -427,7 +430,8 @@ void *capture_thread_loop(void *arg __unused)
  */
 
 __attribute__ ((visibility ("default")))
-int visualizer_hal_start_output(audio_io_handle_t output, int pcm_id) {
+int visualizer_hal_start_output(audio_io_handle_t output, int pcm_id,
+                                int card_number, int pcm_capture_id) {
     int ret = 0;
     struct listnode *node;
 
@@ -444,6 +448,11 @@ int visualizer_hal_start_output(audio_io_handle_t output, int pcm_id) {
         goto exit;
     }
 
+    ALOGV("%s card number %d pcm_capture_id %d",
+          __func__, card_number, pcm_capture_id);
+    capture_config.snd_card_num = card_number;
+    capture_config.capture_device_id = pcm_capture_id;
+
     output_context_t *out_ctxt = (output_context_t *)malloc(sizeof(output_context_t));
     out_ctxt->handle = output;
     list_init(&out_ctxt->effects_list);
-- 
2.17.1

