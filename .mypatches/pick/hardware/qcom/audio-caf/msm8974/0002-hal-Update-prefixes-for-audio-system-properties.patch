From 97ba1042357707325b4bcecc1a9636bf35b3d6ab Mon Sep 17 00:00:00 2001
From: Aniket Kumar Lata <alata@codeaurora.org>
Date: Tue, 2 May 2017 12:33:46 -0700
Subject: [PATCH 2/2] hal: Update prefixes for audio system properties

Vendor created android system properties are required to have
vendor/qti prefix. Update vendor specific audio system
properties used in HAL.

CRs-Fixed: 2034869
Change-Id: Ibdb1d12fedee1ce12073e8b90fdec814318f3acf
---
 hal/audio_extn/audio_extn.c       |  4 ++--
 hal/audio_extn/compress_capture.c |  2 +-
 hal/audio_extn/dolby.c            |  2 +-
 hal/audio_extn/spkr_protection.c  |  2 +-
 hal/audio_extn/ssr.c              |  4 ++--
 hal/audio_hw.c                    |  8 ++++----
 hal/msm8960/platform.c            |  8 ++++----
 hal/msm8974/platform.c            | 12 ++++++------
 hal/voice_extn/compress_voip.c    |  4 ++--
 9 files changed, 23 insertions(+), 23 deletions(-)

diff --git a/hal/audio_extn/audio_extn.c b/hal/audio_extn/audio_extn.c
index 9eeb5e3f7..790527b68 100644
--- a/hal/audio_extn/audio_extn.c
+++ b/hal/audio_extn/audio_extn.c
@@ -82,7 +82,7 @@ bool audio_extn_should_use_handset_anc(int in_channels)
 {
     char prop_aanc[PROPERTY_VALUE_MAX] = "false";
 
-    property_get("persist.aanc.enable", prop_aanc, "0");
+    property_get("persist.vendor.audio.aanc.enable", prop_aanc, "0");
     if (!strncmp("true", prop_aanc, 4)) {
         ALOGD("%s: AANC enabled in the property", __func__);
         aextnmod.aanc_enabled = 1;
@@ -96,7 +96,7 @@ bool audio_extn_should_use_fb_anc(void)
 {
   char prop_anc[PROPERTY_VALUE_MAX] = "feedforward";
 
-  property_get("persist.headset.anc.type", prop_anc, "0");
+  property_get("persist.vendor.audio.headset.anc.type", prop_anc, "0");
   if (!strncmp("feedback", prop_anc, sizeof("feedback"))) {
     ALOGD("%s: FB ANC headset type enabled\n", __func__);
     return true;
diff --git a/hal/audio_extn/compress_capture.c b/hal/audio_extn/compress_capture.c
index b8722a3c9..b5069d5e6 100644
--- a/hal/audio_extn/compress_capture.c
+++ b/hal/audio_extn/compress_capture.c
@@ -74,7 +74,7 @@ bool audio_extn_compr_cap_enabled()
     char prop_value[PROPERTY_VALUE_MAX] = {0};
     bool tunnel_encode = false;
 
-    property_get("tunnel.audio.encode",prop_value,"0");
+    property_get("vendor.audio.tunnel.encode",prop_value,"0");
     if (!strncmp("true", prop_value, sizeof("true")))
         return true;
     else
diff --git a/hal/audio_extn/dolby.c b/hal/audio_extn/dolby.c
index 0b26a7fcf..587f2a4b4 100644
--- a/hal/audio_extn/dolby.c
+++ b/hal/audio_extn/dolby.c
@@ -448,7 +448,7 @@ void audio_extn_dolby_set_dmid(struct audio_device *adev)
     if (!send)
         return;
 
-    property_get("dmid",c_dmid,"0");
+    property_get("vendor.audio.dmid",c_dmid,"0");
     i_dmid = atoll(c_dmid);
 
     ctl = mixer_get_ctl_by_name(adev->mixer, mixer_ctl_name);
diff --git a/hal/audio_extn/spkr_protection.c b/hal/audio_extn/spkr_protection.c
index c5a9a0517..0605cf036 100644
--- a/hal/audio_extn/spkr_protection.c
+++ b/hal/audio_extn/spkr_protection.c
@@ -520,7 +520,7 @@ void audio_extn_spkr_prot_init(void *adev)
         ALOGE("%s: Invalid params", __func__);
         return;
     }
-    property_get("persist.speaker.prot.enable", value, "");
+    property_get("persist.vendor.audio.speaker.prot.enable", value, "");
     handle.spkr_prot_enable = false;
     if (!strncmp("true", value, 4))
        handle.spkr_prot_enable = true;
diff --git a/hal/audio_extn/ssr.c b/hal/audio_extn/ssr.c
index 5be8f06d5..78307dd24 100644
--- a/hal/audio_extn/ssr.c
+++ b/hal/audio_extn/ssr.c
@@ -362,7 +362,7 @@ void audio_extn_ssr_update_enabled()
 {
     char ssr_enabled[PROPERTY_VALUE_MAX] = "false";
 
-    property_get("ro.qc.sdk.audio.ssr",ssr_enabled,"0");
+    property_get("ro.vendor.audio.sdk.ssr",ssr_enabled,"0");
     if (!strncmp("true", ssr_enabled, 4)) {
         ALOGD("%s: surround sound recording is supported", __func__);
         ssrmod.is_ssr_enabled = true;
@@ -399,7 +399,7 @@ int32_t audio_extn_ssr_init(struct stream_in *in)
         return ret;
     }
 
-    property_get("ssr.pcmdump",c_multi_ch_dump,"0");
+    property_get("vendor.audio.ssr.pcmdump",c_multi_ch_dump,"0");
     if (0 == strncmp("true", c_multi_ch_dump, sizeof("ssr.dump-pcm"))) {
         /* Remember to change file system permission of data(e.g. chmod 777 data/),
           otherwise, fopen may fail */
diff --git a/hal/audio_hw.c b/hal/audio_hw.c
index 0d1306d3b..0d6406350 100644
--- a/hal/audio_hw.c
+++ b/hal/audio_hw.c
@@ -366,7 +366,7 @@ static int check_and_set_gapless_mode(struct audio_device *adev, bool enable_gap
     struct mixer_ctl *ctl;
 
     ALOGV("%s:", __func__);
-    gapless_enabled = property_get_bool("audio.offload.gapless.enabled", false);
+    gapless_enabled = property_get_bool("vendor.audio.offload.gapless.enabled", false);
 
     /*Disable gapless if its AV playback*/
     gapless_enabled = gapless_enabled && enable_gapless;
@@ -1231,7 +1231,7 @@ static audio_usecase_t get_offload_usecase(struct audio_device *adev)
     unsigned int i, num_usecase = sizeof(offload_usecases)/sizeof(offload_usecases[0]);
     char value[PROPERTY_VALUE_MAX] = {0};
 
-    property_get("audio.offload.multiple.enabled", value, NULL);
+    property_get("vendor.audio.offload.multiple.enabled", value, NULL);
     if (!(atoi(value) || !strncmp("true", value, 4)))
         num_usecase = 1; /* If prop is not set, limit the num of offload usecases to 1 */
 
@@ -3891,7 +3891,7 @@ static int adev_open(const hw_module_t *module, const char *name,
 
     char value[PROPERTY_VALUE_MAX];
     int trial;
-    if (property_get("audio_hal.period_size", value, NULL) > 0) {
+    if (property_get("vendor.audio_hal.period_size", value, NULL) > 0) {
         trial = atoi(value);
         if (period_size_is_plausible_for_low_latency(trial)) {
             pcm_config_low_latency.period_size = trial;
@@ -3900,7 +3900,7 @@ static int adev_open(const hw_module_t *module, const char *name,
             configured_low_latency_capture_period_size = trial;
         }
     }
-    if (property_get("audio_hal.in_period_size", value, NULL) > 0) {
+    if (property_get("vendor.audio_hal.in_period_size", value, NULL) > 0) {
         trial = atoi(value);
         if (period_size_is_plausible_for_low_latency(trial)) {
             configured_low_latency_capture_period_size = trial;
diff --git a/hal/msm8960/platform.c b/hal/msm8960/platform.c
index 4a65f4d73..ea0ec9a6e 100644
--- a/hal/msm8960/platform.c
+++ b/hal/msm8960/platform.c
@@ -238,7 +238,7 @@ void *platform_init(struct audio_device *adev)
     my_data->fluence_in_voice_rec = false;
     my_data->fluence_type = FLUENCE_NONE;
 
-    property_get("ro.qc.sdk.audio.fluencetype", value, "");
+    property_get("ro.vendor.audio.sdk.fluencetype", value, "");
     if (!strncmp("fluencepro", value, sizeof("fluencepro"))) {
         my_data->fluence_type = FLUENCE_QUAD_MIC;
     } else if (!strncmp("fluence", value, sizeof("fluence"))) {
@@ -248,17 +248,17 @@ void *platform_init(struct audio_device *adev)
     }
 
     if (my_data->fluence_type != FLUENCE_NONE) {
-        property_get("persist.audio.fluence.voicecall",value,"");
+        property_get("persist.vendor.audio.fluence.voicecall",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_voice_call = true;
         }
 
-        property_get("persist.audio.fluence.voicerec",value,"");
+        property_get("persist.vendor.audio.fluence.voicerec",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_voice_rec = true;
         }
 
-        property_get("persist.audio.fluence.speaker",value,"");
+        property_get("persist.vendor.audio.fluence.speaker",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_spkr_mode = true;
         }
diff --git a/hal/msm8974/platform.c b/hal/msm8974/platform.c
index ca96c6999..f56e02b5f 100644
--- a/hal/msm8974/platform.c
+++ b/hal/msm8974/platform.c
@@ -974,7 +974,7 @@ void *platform_init(struct audio_device *adev)
     my_data->fluence_in_audio_rec = false;
     my_data->fluence_type = FLUENCE_NONE;
 
-    property_get("ro.qc.sdk.audio.fluencetype", my_data->fluence_cap, "");
+    property_get("ro.vendor.audio.sdk.fluencetype", my_data->fluence_cap, "");
     if (!strncmp("fluencepro", my_data->fluence_cap, sizeof("fluencepro"))) {
         my_data->fluence_type = FLUENCE_QUAD_MIC | FLUENCE_DUAL_MIC;
     } else if (!strncmp("fluence", my_data->fluence_cap, sizeof("fluence"))) {
@@ -984,22 +984,22 @@ void *platform_init(struct audio_device *adev)
     }
 
     if (my_data->fluence_type != FLUENCE_NONE) {
-        property_get("persist.audio.fluence.voicecall",value,"");
+        property_get("persist.vendor.audio.fluence.voicecall",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_voice_call = true;
         }
 
-        property_get("persist.audio.fluence.voicerec",value,"");
+        property_get("persist.vendor.audio.fluence.voicerec",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_voice_rec = true;
         }
 
-        property_get("persist.audio.fluence.audiorec",value,"");
+        property_get("persist.vendor.audio.fluence.audiorec",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_audio_rec = true;
         }
 
-        property_get("persist.audio.fluence.speaker",value,"");
+        property_get("persist.vendor.audio.fluence.speaker",value,"");
         if (!strncmp("true", value, sizeof("true"))) {
             my_data->fluence_in_spkr_mode = true;
         }
@@ -2306,7 +2306,7 @@ uint32_t platform_get_compress_offload_buffer_size(audio_offload_info_t* info)
 {
     char value[PROPERTY_VALUE_MAX] = {0};
     uint32_t fragment_size = COMPRESS_OFFLOAD_FRAGMENT_SIZE;
-    if((property_get("audio.offload.buffer.size.kb", value, "")) &&
+    if((property_get("vendor.audio.offload.buffer.size.kb", value, "")) &&
             atoi(value)) {
         fragment_size =  atoi(value) * 1024;
     }
diff --git a/hal/voice_extn/compress_voip.c b/hal/voice_extn/compress_voip.c
index fa1ad3c44..cc92a6e04 100644
--- a/hal/voice_extn/compress_voip.c
+++ b/hal/voice_extn/compress_voip.c
@@ -758,7 +758,7 @@ bool voice_extn_compress_voip_pcm_prop_check()
 {
     char prop_value[PROPERTY_VALUE_MAX] = {0};
 
-    property_get("use.voice.path.for.pcm.voip", prop_value, "0");
+    property_get("vendor.voice.path.for.pcm.voip", prop_value, "0");
     if (!strncmp("true", prop_value, sizeof("true")))
     {
         ALOGD("%s: VoIP PCM property is enabled", __func__);
@@ -772,7 +772,7 @@ bool voice_extn_dedicated_voip_device_prop_check()
 {
     char prop_value[PROPERTY_VALUE_MAX] = {0};
 
-    property_get("use.dedicated.device.for.voip", prop_value, "0");
+    property_get("vendor.dedicated.device.for.voip", prop_value, "0");
     if (!strncmp("true", prop_value, sizeof("true")))
     {
         ALOGD("%s: Using dedicated path for VoIP", __func__);
-- 
2.17.1

