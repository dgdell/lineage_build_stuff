From 5ca92ac5b0c3cde164ba8857fcc1209942061305 Mon Sep 17 00:00:00 2001
From: John Muir <muirj@google.com>
Date: Wed, 10 May 2017 13:56:06 -0700
Subject: [PATCH 08/13] Apply the Cherokee's mechanism of stopping hci_filter
 to ROME

This change is for devices based on msm8998 hardware only. This
only impacts standalone VR devices based o that are using oc-dev:
this commit is already merged in master.

Original author: Luke Zhang <lukez@codeaurora.org>

Previously for ROME SOC, we killed the wcnss_filter directly during
BT_off, which may cause the wcnss_filter not to release wake_lock
before exit. Changed it by applying the Cherokee's mechanism to wait
for wcnss_filter to exit.

CRs-fixed: 2004084
Change-Id: Ifee851fd9c9995bfd95e3649aa0fe623905d6686
Bug: 38055350
Test: BT functions.
---
 libbt-vendor/src/bt_vendor_qcom.c | 72 +++++++++++++------------------
 1 file changed, 29 insertions(+), 43 deletions(-)

diff --git a/libbt-vendor/src/bt_vendor_qcom.c b/libbt-vendor/src/bt_vendor_qcom.c
index 74487b3..a8a1866 100644
--- a/libbt-vendor/src/bt_vendor_qcom.c
+++ b/libbt-vendor/src/bt_vendor_qcom.c
@@ -284,55 +284,41 @@ void stop_hci_filter() {
 
        ALOGV("%s: Entry ", __func__);
 
-       if ((soc_type = get_bt_soc_type()) == BT_SOC_CHEROKEE) {
-           property_get("vendor.wc_transport.hci_filter_status", value, "0");
-           if (strcmp(value, "0") == 0) {
-               ALOGI("%s: hci_filter has been stopped already", __func__);
+       property_get("vendor.wc_transport.hci_filter_status", value, "0");
+       if (strcmp(value, "0") == 0) {
+           ALOGI("%s: hci_filter has been stopped already", __func__);
+       }
+       else {
+           filter_ctrl = connect_to_local_socket("wcnssfilter_ctrl");
+           if (filter_ctrl < 0) {
+               ALOGI("%s: Error while connecting to CTRL_SOCK, filter should stopped: %d",
+                     __func__, filter_ctrl);
            }
            else {
-               filter_ctrl = connect_to_local_socket("wcnssfilter_ctrl");
-               if (filter_ctrl < 0) {
-                   ALOGI("%s: Error while connecting to CTRL_SOCK, filter should stopped: %d",
-                          __func__, filter_ctrl);
-               }
-               else {
-                   retval = write(filter_ctrl, &stop_val, 1);
-                   if (retval != 1) {
-                       ALOGI("%s: problem writing to CTRL_SOCK, ignore: %d", __func__, retval);
-                       //Ignore and fallback
-                   }
-
-                   close(filter_ctrl);
+               retval = write(filter_ctrl, &stop_val, 1);
+               if (retval != 1) {
+                   ALOGI("%s: problem writing to CTRL_SOCK, ignore: %d", __func__, retval);
+                   //Ignore and fallback
                }
-           }
 
-           /* Ensure Filter is closed by checking the status before
-              RFKILL 0 operation. this should ideally comeout very
-              quick */
-           for(i=0; i<500; i++) {
-               property_get(BT_VND_FILTER_START, value, "false");
-               if (strcmp(value, "false") == 0) {
-                   ALOGI("%s: WCNSS_FILTER stopped", __func__);
-                   usleep(STOP_WAIT_TIMEOUT * 10);
-                   break;
-               } else {
-                   /*sleep of 1ms, This should give enough time for FILTER to
-                   exit with all necessary cleanup*/
-                   usleep(STOP_WAIT_TIMEOUT);
-               }
+               close(filter_ctrl);
            }
+       }
 
-           /*Never use SIGKILL to stop the filter*/
-           /* Filter will be stopped by below two conditions
-            - by Itself, When it realizes there are no CONNECTED clients
-            - Or through STOP_WCNSS_FILTER byte on Control socket
-            both of these ensure clean shutdown of chip
-           */
-           //property_set(BT_VND_FILTER_START, "false");
-       } else if (soc_type == BT_SOC_ROME) {
-           property_set(BT_VND_FILTER_START, "false");
-       } else {
-           ALOGI("%s: Unknown soc type %d, Unexpected!", __func__, soc_type);
+       /* Ensure Filter is closed by checking the status before
+          RFKILL 0 operation. this should ideally comeout very
+          quick */
+       for(i=0; i<500; i++) {
+           property_get(BT_VND_FILTER_START, value, "false");
+           if (strcmp(value, "false") == 0) {
+               ALOGI("%s: WCNSS_FILTER stopped", __func__);
+               usleep(STOP_WAIT_TIMEOUT * 10);
+               break;
+           } else {
+               /*sleep of 1ms, This should give enough time for FILTER to
+               exit with all necessary cleanup*/
+               usleep(STOP_WAIT_TIMEOUT);
+           }
        }
 
        ALOGV("%s: Exit ", __func__);
-- 
2.17.1

