From 7f5445e3df6fb7dcd8178f49ecf6422140c3d0af Mon Sep 17 00:00:00 2001
From: dianlujitao <dianlujitao@lineageos.org>
Date: Thu, 18 Jan 2018 23:34:38 +0800
Subject: [PATCH 3/4] power: msm8996: Add support for power profile and cpu
 boost

 * Based on Zhao Wei Liew's implementation from the legacy HAL.
 * We no longer handle POWER_HINT_INTERACTION and POWER_HINT_LAUNCH,
   they're now supported directly by Qualcomm mp-ctl.

Change-Id: I03a5229fc8b97e8fb593ba831625c001e926e1d6
---
 power-8996.c | 99 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 99 insertions(+)

diff --git a/power-8996.c b/power-8996.c
index c0ad481..88cca53 100644
--- a/power-8996.c
+++ b/power-8996.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -50,6 +51,75 @@
 static int display_hint_sent;
 static int camera_hint_ref_count;
 
+static int current_power_profile = PROFILE_BALANCED;
+
+static int profile_high_performance[] = {
+    SCHED_BOOST_ON_V3, 0x1,
+    ALL_CPUS_PWR_CLPS_DIS_V3, 0x1,
+    CPUS_ONLINE_MIN_BIG, 0x2,
+    CPUS_ONLINE_MIN_LITTLE, 0x2,
+    MIN_FREQ_BIG_CORE_0, 0xFFF,
+    MIN_FREQ_LITTLE_CORE_0, 0xFFF,
+};
+
+static int profile_power_save[] = {
+    CPUS_ONLINE_MAX_LIMIT_BIG, 0x1,
+    MAX_FREQ_BIG_CORE_0, 0x3E8,
+    MAX_FREQ_LITTLE_CORE_0, 0x3E8,
+};
+
+static int profile_bias_power[] = {
+    MAX_FREQ_BIG_CORE_0, 0x514,
+    MAX_FREQ_LITTLE_CORE_0, 0x3E8,
+};
+
+static int profile_bias_performance[] = {
+    CPUS_ONLINE_MAX_LIMIT_BIG, 0x2,
+    CPUS_ONLINE_MAX_LIMIT_LITTLE, 0x2,
+    MIN_FREQ_BIG_CORE_0, 0x578,
+};
+
+int get_number_of_profiles() {
+    return 5;
+}
+
+static void set_power_profile(int profile) {
+
+    if (profile == current_power_profile)
+        return;
+
+    ALOGV("%s: Profile=%d", __func__, profile);
+
+    if (current_power_profile != PROFILE_BALANCED) {
+        undo_hint_action(DEFAULT_PROFILE_HINT_ID);
+        ALOGV("%s: Hint undone", __func__);
+    }
+
+    if (profile == PROFILE_POWER_SAVE) {
+        perform_hint_action(DEFAULT_PROFILE_HINT_ID, profile_power_save,
+                ARRAY_SIZE(profile_power_save));
+        ALOGD("%s: Set powersave mode", __func__);
+
+    } else if (profile == PROFILE_HIGH_PERFORMANCE) {
+        perform_hint_action(DEFAULT_PROFILE_HINT_ID, profile_high_performance,
+                ARRAY_SIZE(profile_high_performance));
+        ALOGD("%s: Set performance mode", __func__);
+
+    } else if (profile == PROFILE_BIAS_POWER) {
+        perform_hint_action(DEFAULT_PROFILE_HINT_ID, profile_bias_power,
+                ARRAY_SIZE(profile_bias_power));
+        ALOGD("%s: Set bias power mode", __func__);
+
+    } else if (profile == PROFILE_BIAS_PERFORMANCE) {
+        perform_hint_action(DEFAULT_PROFILE_HINT_ID, profile_bias_performance,
+                ARRAY_SIZE(profile_bias_performance));
+        ALOGD("%s: Set bias perf mode", __func__);
+
+    }
+
+    current_power_profile = profile;
+}
+
 static int process_video_encode_hint(void *metadata)
 {
     char governor[80];
@@ -123,13 +193,42 @@ static int process_video_encode_hint(void *metadata)
     return HINT_NONE;
 }
 
+static int resources_cpu_boost[] = {
+    SCHED_BOOST_ON_V3, 0x1,
+    MIN_FREQ_BIG_CORE_0, 0x3E8,
+};
+
+/* Declare function before use */
+void interaction(int duration, int num_args, int opt_list[]);
+
 int power_hint_override(power_hint_t hint, void *data)
 {
     int ret_val = HINT_NONE;
+    int duration;
+
+    if (hint == POWER_HINT_SET_PROFILE) {
+        set_power_profile(*(int32_t *)data);
+        return HINT_HANDLED;
+    }
+
+    /* Skip other hints in power save mode */
+    if (current_power_profile == PROFILE_POWER_SAVE)
+        return HINT_HANDLED;
+
     switch(hint) {
         case POWER_HINT_VIDEO_ENCODE:
             ret_val = process_video_encode_hint(data);
             break;
+        case POWER_HINT_CPU_BOOST:
+        {
+            duration = *(int32_t *)data / 1000;
+            if (duration > 0) {
+                interaction(duration, ARRAY_SIZE(resources_cpu_boost),
+                        resources_cpu_boost);
+                ret_val = HINT_HANDLED;
+            }
+            break;
+        }
         default:
             break;
     }
-- 
2.7.4

