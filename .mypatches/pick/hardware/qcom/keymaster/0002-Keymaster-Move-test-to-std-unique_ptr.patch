From a42e6b57634343ee88deb60498addb7fc14da907 Mon Sep 17 00:00:00 2001
From: Andreas Gampe <agampe@google.com>
Date: Mon, 2 Oct 2017 12:05:47 -0700
Subject: [PATCH 2/2] Keymaster: Move test to std::unique_ptr

In preparation for UniquePtr removal.

Test: none
Change-Id: I54c0be6ee938252fc0492ae745aa45e41631d342
---
 keymaster_qcom.cpp | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/keymaster_qcom.cpp b/keymaster_qcom.cpp
index a390f37..09d3ad7 100644
--- a/keymaster_qcom.cpp
+++ b/keymaster_qcom.cpp
@@ -38,11 +38,12 @@
 #include <dirent.h>
 #include <fcntl.h>
 
+#include <memory>
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <dlfcn.h>
 
-#include <nativehelper/UniquePtr.h>
 #include <cutils/properties.h>
 
 #include "QSEEComAPI.h"
@@ -86,16 +87,16 @@ struct EVP_PKEY_Delete {
         EVP_PKEY_free(p);
     }
 };
-typedef UniquePtr<EVP_PKEY, EVP_PKEY_Delete> Unique_EVP_PKEY;
+typedef std::unique_ptr<EVP_PKEY, EVP_PKEY_Delete> Unique_EVP_PKEY;
 
 struct RSA_Delete {
     void operator()(RSA* p) const {
         RSA_free(p);
     }
 };
-typedef UniquePtr<RSA, RSA_Delete> Unique_RSA;
+typedef std::unique_ptr<RSA, RSA_Delete> Unique_RSA;
 
-typedef UniquePtr<keymaster0_device_t> Unique_keymaster_device_t;
+typedef std::unique_ptr<keymaster0_device_t> Unique_keymaster_device_t;
 
 /**
  * Many OpenSSL APIs take ownership of an argument on success but don't free the argument
@@ -179,7 +180,7 @@ static int qcom_km_get_keypair_public(const keymaster0_device_t* dev,
         return -1;
     }
 
-    UniquePtr<uint8_t> key(static_cast<uint8_t*>(malloc(len)));
+    std::unique_ptr<uint8_t> key(static_cast<uint8_t*>(malloc(len)));
     if (key.get() == NULL) {
         ALOGE("Could not allocate memory for public key data");
         return -1;
@@ -374,7 +375,7 @@ static int qcom_km_generate_keypair(const keymaster0_device_t* dev,
         ALOGE("Generate key command failed resp->status = %d ret =%d", resp->status, ret);
         return -1;
     } else {
-        UniquePtr<unsigned char[]> keydata(new unsigned char[resp->key_blob_len]);
+        std::unique_ptr<unsigned char[]> keydata(new unsigned char[resp->key_blob_len]);
         if (keydata.get() == NULL) {
             ALOGE("could not allocate memory for key blob");
             return -1;
@@ -457,7 +458,7 @@ static int qcom_km_import_keypair(const keymaster0_device_t* dev,
         qcom_km_ion_dealloc(&ihandle);
         return -1;
     } else {
-        UniquePtr<unsigned char[]> keydata(new unsigned char[resp->key_blob_len]);
+        std::unique_ptr<unsigned char[]> keydata(new unsigned char[resp->key_blob_len]);
         if (keydata.get() == NULL) {
             ALOGE("could not allocate memory for key blob");
             return -1;
@@ -557,7 +558,7 @@ static int qcom_km_sign_data(const keymaster0_device_t* dev,
         qcom_km_ion_dealloc(&ihandle);
         return -1;
     } else {
-        UniquePtr<uint8_t> signedDataPtr(reinterpret_cast<uint8_t*>(malloc(resp->sig_len)));
+        std::unique_ptr<uint8_t> signedDataPtr(reinterpret_cast<uint8_t*>(malloc(resp->sig_len)));
         if (signedDataPtr.get() == NULL) {
             ALOGE("Sign data memory allocation failed");
             qcom_km_ion_dealloc(&ihandle);
-- 
2.17.0

