From 6a2de9298d017f4cdaf3ec6391b7521597ee0443 Mon Sep 17 00:00:00 2001
From: dianlujitao <dianlujitao@lineageos.org>
Date: Thu, 22 Feb 2018 16:39:45 +0800
Subject: [PATCH] lineagehw: Use HIDL for livedisplay vendor impl

Change-Id: Ibafa2eda5c8ea4a48e401f87b73b1c065e4f9521
---
 Android.mk                                         |   7 +-
 src/org/lineageos/hardware/AdaptiveBacklight.java  |  12 +-
 src/org/lineageos/hardware/ColorBalance.java       |  13 +-
 src/org/lineageos/hardware/DisplayModeControl.java |  12 +-
 .../lineageos/hardware/LiveDisplayVendorImpl.java  | 386 ++++++++++++++++++---
 src/org/lineageos/hardware/PictureAdjustment.java  |  20 +-
 .../lineageos/hardware/SunlightEnhancement.java    |  12 +-
 src/org/lineageos/hardware/Utils.java              |  68 ++++
 8 files changed, 458 insertions(+), 72 deletions(-)
 create mode 100644 src/org/lineageos/hardware/Utils.java

diff --git a/Android.mk b/Android.mk
index 251737a..71cf0d0 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
 # Copyright (C) 2013 The CyanogenMod Project
-# Copyright (C) 2017 The LineageOS Project
+# Copyright (C) 2017-2018 The LineageOS Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -44,7 +44,10 @@ LOCAL_SRC_FILES += $(default_classes) $(unique_specific_classes)
 
 LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE := org.lineageos.hardware
-LOCAL_JAVA_LIBRARIES := org.lineageos.platform.internal services
+LOCAL_JAVA_LIBRARIES := \
+    org.lineageos.platform.internal \
+    services \
+    vendor.lineage.livedisplay-V1.0-java
 
 include $(BUILD_JAVA_LIBRARY)
 
diff --git a/src/org/lineageos/hardware/AdaptiveBacklight.java b/src/org/lineageos/hardware/AdaptiveBacklight.java
index 95809cf..f9cc2bd 100644
--- a/src/org/lineageos/hardware/AdaptiveBacklight.java
+++ b/src/org/lineageos/hardware/AdaptiveBacklight.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 The CyanogenMod Project
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +17,11 @@
 
 package org.lineageos.hardware;
 
-import org.lineageos.internal.util.FileUtils;
-
 import android.util.Log;
 
+import org.lineageos.internal.util.FileUtils;
+import vendor.lineage.livedisplay.V1_0.Feature;
+
 /**
  * Adaptive backlight support (this refers to technologies like NVIDIA SmartDimmer,
  * QCOM CABL or Samsung CABC).
@@ -31,7 +33,7 @@ public class AdaptiveBacklight {
     private static final String FILE_CABC = "/sys/class/graphics/fb0/cabc";
 
     private static final boolean sHasNativeSupport =
-            LiveDisplayVendorImpl.hasNativeFeature(LiveDisplayVendorImpl.ADAPTIVE_BACKLIGHT);
+            LiveDisplayVendorImpl.getInstance().hasNativeFeature(Feature.ADAPTIVE_BACKLIGHT);
 
     /**
      * Whether device supports an adaptive backlight technology.
@@ -55,7 +57,7 @@ public class AdaptiveBacklight {
     public static boolean isEnabled() {
         try {
             if (sHasNativeSupport) {
-                return LiveDisplayVendorImpl.native_isAdaptiveBacklightEnabled();
+                return LiveDisplayVendorImpl.getInstance().isAdaptiveBacklightEnabled();
             }
             return Integer.parseInt(FileUtils.readOneLine(FILE_CABC)) > 0;
         } catch (Exception e) {
@@ -73,7 +75,7 @@ public class AdaptiveBacklight {
      */
     public static boolean setEnabled(boolean status) {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_setAdaptiveBacklightEnabled(status);
+            return LiveDisplayVendorImpl.getInstance().setAdaptiveBacklightEnabled(status);
         }
         return FileUtils.writeLine(FILE_CABC, status ? "1" : "0");
     }
diff --git a/src/org/lineageos/hardware/ColorBalance.java b/src/org/lineageos/hardware/ColorBalance.java
index b5df0f3..3260bfa 100644
--- a/src/org/lineageos/hardware/ColorBalance.java
+++ b/src/org/lineageos/hardware/ColorBalance.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +17,8 @@
 
 package org.lineageos.hardware;
 
+import vendor.lineage.livedisplay.V1_0.Feature;
+
 /**
  * Color balance support
  *
@@ -27,7 +30,7 @@ package org.lineageos.hardware;
 public class ColorBalance {
 
     private static final boolean sHasNativeSupport =
-            LiveDisplayVendorImpl.hasNativeFeature(LiveDisplayVendorImpl.COLOR_BALANCE);
+            LiveDisplayVendorImpl.getInstance().hasNativeFeature(Feature.COLOR_BALANCE);
 
     /**
      * Whether device supports color balance control
@@ -46,7 +49,7 @@ public class ColorBalance {
      */
     public static int getValue() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getColorBalance();
+            return LiveDisplayVendorImpl.getInstance().getColorBalance();
         }
         return 0;
     }
@@ -60,7 +63,7 @@ public class ColorBalance {
      */
     public static boolean setValue(int value) {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_setColorBalance(value);
+            return LiveDisplayVendorImpl.getInstance().setColorBalance(value);
         }
         return false;
     }
@@ -71,7 +74,7 @@ public class ColorBalance {
      */
     public static int getMinValue() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getColorBalanceRange().getLower();
+            return LiveDisplayVendorImpl.getInstance().getColorBalanceRange().getLower();
         }
         return 0;
     }
@@ -82,7 +85,7 @@ public class ColorBalance {
      */
     public static int getMaxValue() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getColorBalanceRange().getUpper();
+            return LiveDisplayVendorImpl.getInstance().getColorBalanceRange().getUpper();
         }
         return 0;
     }
diff --git a/src/org/lineageos/hardware/DisplayModeControl.java b/src/org/lineageos/hardware/DisplayModeControl.java
index bbc1a96..ecb271a 100644
--- a/src/org/lineageos/hardware/DisplayModeControl.java
+++ b/src/org/lineageos/hardware/DisplayModeControl.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2015 The CyanogenMod Project
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +20,7 @@ package org.lineageos.hardware;
 import android.util.Log;
 
 import lineageos.hardware.DisplayMode;
+import vendor.lineage.livedisplay.V1_0.Feature;
 
 /*
  * Display Modes API
@@ -35,7 +37,7 @@ import lineageos.hardware.DisplayMode;
 public class DisplayModeControl {
 
     private static final boolean sHasNativeSupport =
-            LiveDisplayVendorImpl.hasNativeFeature(LiveDisplayVendorImpl.DISPLAY_MODES);
+            LiveDisplayVendorImpl.getInstance().hasNativeFeature(Feature.DISPLAY_MODES);
 
     /*
      * All HAF classes should export this boolean.
@@ -56,7 +58,7 @@ public class DisplayModeControl {
         if (!sHasNativeSupport) {
             return new DisplayMode[0];
         }
-        return LiveDisplayVendorImpl.native_getDisplayModes();
+        return LiveDisplayVendorImpl.getInstance().getDisplayModes();
     }
 
     /*
@@ -67,7 +69,7 @@ public class DisplayModeControl {
         if (!sHasNativeSupport) {
             return null;
         }
-        return LiveDisplayVendorImpl.native_getCurrentDisplayMode();
+        return LiveDisplayVendorImpl.getInstance().getCurrentDisplayMode();
     }
 
     /*
@@ -80,7 +82,7 @@ public class DisplayModeControl {
         if (!sHasNativeSupport) {
             return false;
         }
-        return LiveDisplayVendorImpl.native_setDisplayMode(mode, makeDefault);
+        return LiveDisplayVendorImpl.getInstance().setDisplayMode(mode, makeDefault);
     }
 
     /*
@@ -91,6 +93,6 @@ public class DisplayModeControl {
         if (!sHasNativeSupport) {
             return null;
         }
-        return LiveDisplayVendorImpl.native_getDefaultDisplayMode();
+        return LiveDisplayVendorImpl.getInstance().getDefaultDisplayMode();
     }
 }
diff --git a/src/org/lineageos/hardware/LiveDisplayVendorImpl.java b/src/org/lineageos/hardware/LiveDisplayVendorImpl.java
index c3efd4c..680d1c0 100644
--- a/src/org/lineageos/hardware/LiveDisplayVendorImpl.java
+++ b/src/org/lineageos/hardware/LiveDisplayVendorImpl.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2015 The CyanogenMod Project
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,73 +17,376 @@
 
 package org.lineageos.hardware;
 
+import android.os.IHwBinder.DeathRecipient;
+import android.os.RemoteException;
 import android.util.Log;
 import android.util.Range;
+import com.android.internal.annotations.GuardedBy;
 
 import lineageos.hardware.DisplayMode;
 import lineageos.hardware.HSIC;
+import vendor.lineage.livedisplay.V1_0.IColor;
 
 /**
  * This class loads an implementation of the LiveDisplay native interface.
  */
 public class LiveDisplayVendorImpl {
 
-    public static final String TAG = "LiveDisplayVendorImpl";
+    private static final String TAG = "LiveDisplayVendorImpl";
 
-    public static final int DISPLAY_MODES = 0x1;
-    public static final int COLOR_BALANCE = 0x2;
-    public static final int OUTDOOR_MODE = 0x4;
-    public static final int ADAPTIVE_BACKLIGHT = 0x8;
-    public static final int PICTURE_ADJUSTMENT = 0x10;
+    @GuardedBy("this")
+    private IColor mDaemon;
+    private int mFeatures;
 
-    private static boolean sNativeLibraryLoaded;
-    private static int     sFeatures;
+    private LiveDisplayVendorImpl() {}
 
-    static {
-        try {
-            System.loadLibrary("jni_livedisplay");
+    private static class LiveDisplayVendorImplHolder {
+        private static final LiveDisplayVendorImpl instance = new LiveDisplayVendorImpl();
+    }
+
+    public static LiveDisplayVendorImpl getInstance() {
+        return LiveDisplayVendorImplHolder.instance;
+    }
 
-            final int features = native_getSupportedFeatures();
-            if (features > 0) {
-                Log.i(TAG, "Using native LiveDisplay backend (features: " + features + ")");
+    private synchronized IColor getColorService() {
+        if (mDaemon == null) {
+            Log.v(TAG, "mDaemon was null, reconnect to LiveDisplay IColor");
+            try {
+                mDaemon = IColor.getService();
+            } catch (java.util.NoSuchElementException e) {
+                // Service doesn't exist or cannot be opened. Logged below.
+            } catch (RemoteException e) {
+                Log.e(TAG, "Failed to get LiveDisplay IColor interface", e);
+            }
+            if (mDaemon == null) {
+                Log.w(TAG, "LiveDisplay IColor HIDL not available");
+                return null;
             }
 
-            sNativeLibraryLoaded = features > 0;
-            sFeatures = features;
-        } catch (Throwable t) {
-            sNativeLibraryLoaded = false;
-            sFeatures = 0;
+            mDaemon.asBinder().linkToDeath(new DeathRecipient() {
+                @Override
+                public void serviceDied(long cookie) {
+                    Log.e(TAG, "LiveDisplay IColor HAL died");
+                    reset();
+                }
+            }, 0);
+        }
+        return mDaemon;
+    }
+
+    private void reset() {
+        mFeatures = 0;
+        synchronized (this) {
+            mDaemon = null;
+        }
+    }
+
+    public boolean hasNativeFeature(int feature) {
+        if (mFeatures == 0) {
+            IColor daemon = getColorService();
+            if (daemon == null) {
+                Log.e(TAG, "hasNativeFeature: no LiveDisplay IColor HAL!");
+                return false;
+            }
+            try {
+                mFeatures = daemon.getSupportedFeatures();
+                Log.i(TAG, "Using LiveDisplay IColor backend (features: " + mFeatures + ")");
+            } catch (RemoteException e) {
+                Log.e(TAG, "hasNativeFeature failed", e);
+                reset();
+                return false;
+            }
         }
+        Log.d(TAG, "hasNativeFeature: mFeatures=" + Integer.toString(mFeatures));
+        return (mFeatures & feature) != 0;
     }
 
-    public static boolean hasNativeFeature(int feature) {
-        return sNativeLibraryLoaded && ((sFeatures & feature) != 0);
+    public DisplayMode[] getDisplayModes() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getDisplayModes: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.HIDLModeListToArray(daemon.getDisplayModes());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getDisplayModes failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public DisplayMode getCurrentDisplayMode() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getCurrentDisplayMode: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            DisplayMode mode = Utils.fromHIDLMode(daemon.getCurrentDisplayMode());
+            // mode.id is -1 means it's invalid.
+            return mode.id == -1 ? null : mode;
+        } catch (RemoteException e) {
+            Log.e(TAG, "getDisplayModes failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public DisplayMode getDefaultDisplayMode() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getDefaultDisplayMode: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            DisplayMode mode = Utils.fromHIDLMode(daemon.getDefaultDisplayMode());
+            // mode.id is -1 means it's invalid.
+            return mode.id == -1 ? null : mode;
+        } catch (RemoteException e) {
+            Log.e(TAG, "getDefaultDisplayMode failed", e);
+            reset();
+        }
+        return null;
     }
 
-    private static native int native_getSupportedFeatures();
+    public boolean setDisplayMode(DisplayMode mode, boolean makeDefault) {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "setDisplayMode: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.setDisplayMode(mode.id, makeDefault);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setDisplayMode failed", e);
+            reset();
+        }
+        return false;
+    }
 
-    public static native DisplayMode[] native_getDisplayModes();
-    public static native DisplayMode native_getCurrentDisplayMode();
-    public static native DisplayMode native_getDefaultDisplayMode();
-    public static native boolean native_setDisplayMode(DisplayMode mode, boolean makeDefault);
+    public boolean setAdaptiveBacklightEnabled(boolean enabled) {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "setAdaptiveBacklightEnabled: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.setAdaptiveBacklightEnabled(enabled);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setAdaptiveBacklightEnabled failed", e);
+            reset();
+        }
+        return false;
+    }
 
-    public static native boolean native_setAdaptiveBacklightEnabled(boolean enabled);
-    public static native boolean native_isAdaptiveBacklightEnabled();
+    public boolean isAdaptiveBacklightEnabled() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "isAdaptiveBacklightEnabled: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.isAdaptiveBacklightEnabled();
+        } catch (RemoteException e) {
+            Log.e(TAG, "isAdaptiveBacklightEnabled failed", e);
+            reset();
+        }
+        return false;
+    }
 
-    public static native boolean native_setOutdoorModeEnabled(boolean enabled);
-    public static native boolean native_isOutdoorModeEnabled();
+    public boolean setOutdoorModeEnabled(boolean enabled) {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "setOutdoorModeEnabled: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.setOutdoorModeEnabled(enabled);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setOutdoorModeEnabled failed", e);
+            reset();
+        }
+        return false;
+    }
 
-    public static native Range<Integer> native_getColorBalanceRange();
-    public static native int native_getColorBalance();
-    public static native boolean native_setColorBalance(int value);
+    public boolean isOutdoorModeEnabled() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "isOutdoorModeEnabled: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.isOutdoorModeEnabled();
+        } catch (RemoteException e) {
+            Log.e(TAG, "isOutdoorModeEnabled failed", e);
+            reset();
+        }
+        return false;
+    }
 
-    public static native boolean native_setPictureAdjustment(final HSIC hsic);
-    public static native HSIC native_getPictureAdjustment();
-    public static native HSIC native_getDefaultPictureAdjustment();
+    public Range<Integer> getColorBalanceRange() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getColorBalanceRange: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLRange(daemon.getColorBalanceRange());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getColorBalanceRange failed", e);
+            reset();
+        }
+        return null;
+    }
 
-    public static native Range<Float> native_getHueRange();
-    public static native Range<Float> native_getSaturationRange();
-    public static native Range<Float> native_getIntensityRange();
-    public static native Range<Float> native_getContrastRange();
-    public static native Range<Float> native_getSaturationThresholdRange();
+    public int getColorBalance() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getColorBalance: no LiveDisplay IColor HAL!");
+            return 0;
+        }
+        try {
+            return daemon.getColorBalance();
+        } catch (RemoteException e) {
+            Log.e(TAG, "getColorBalance failed", e);
+            reset();
+        }
+        return 0;
+    }
+
+    public boolean setColorBalance(int value) {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "setColorBalance: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.setColorBalance(value);
+        } catch (RemoteException e) {
+            Log.e(TAG, "setColorBalance failed", e);
+            reset();
+        }
+        return false;
+    }
+
+    public boolean setPictureAdjustment(final HSIC hsic) {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "setPictureAdjustment: no LiveDisplay IColor HAL!");
+            return false;
+        }
+        try {
+            return daemon.setPictureAdjustment(Utils.toHIDLHSIC(hsic));
+        } catch (RemoteException e) {
+            Log.e(TAG, "setPictureAdjustment failed", e);
+            reset();
+        }
+        return false;
+    }
+
+    public HSIC getPictureAdjustment() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getPictureAdjustment: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLHSIC(daemon.getPictureAdjustment());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getPictureAdjustment failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public HSIC getDefaultPictureAdjustment() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getDefaultPictureAdjustment: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLHSIC(daemon.getDefaultPictureAdjustment());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getDefaultPictureAdjustment failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public Range<Float> getHueRange() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getHueRange: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLIntRange(daemon.getHueRange());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getHueRange failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public Range<Float> getSaturationRange() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getSaturationRange: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLRange(daemon.getSaturationRange());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getSaturationRange failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public Range<Float> getIntensityRange() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getIntensityRange: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLRange(daemon.getIntensityRange());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getIntensityRange failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public Range<Float> getContrastRange() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getContrastRange: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLRange(daemon.getContrastRange());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getContrastRange failed", e);
+            reset();
+        }
+        return null;
+    }
+
+    public Range<Float> getSaturationThresholdRange() {
+        IColor daemon = getColorService();
+        if (daemon == null) {
+            Log.e(TAG, "getSaturationThresholdRange: no LiveDisplay IColor HAL!");
+            return null;
+        }
+        try {
+            return Utils.fromHIDLRange(daemon.getSaturationThresholdRange());
+        } catch (RemoteException e) {
+            Log.e(TAG, "getSaturationThresholdRange failed", e);
+            reset();
+        }
+        return null;
+    }
 }
diff --git a/src/org/lineageos/hardware/PictureAdjustment.java b/src/org/lineageos/hardware/PictureAdjustment.java
index a31efc9..da2b68e 100644
--- a/src/org/lineageos/hardware/PictureAdjustment.java
+++ b/src/org/lineageos/hardware/PictureAdjustment.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 The CyanogenMod Project
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +20,7 @@ package org.lineageos.hardware;
 import android.util.Range;
 
 import lineageos.hardware.HSIC;
+import vendor.lineage.livedisplay.V1_0.Feature;
 
 /**
  * Picture adjustment support
@@ -29,7 +31,7 @@ import lineageos.hardware.HSIC;
 public class PictureAdjustment {
 
     private static final boolean sHasNativeSupport =
-            LiveDisplayVendorImpl.hasNativeFeature(LiveDisplayVendorImpl.PICTURE_ADJUSTMENT);
+            LiveDisplayVendorImpl.getInstance().hasNativeFeature(Feature.PICTURE_ADJUSTMENT);
 
     /**
      * Whether device supports picture adjustment
@@ -48,7 +50,7 @@ public class PictureAdjustment {
      */
     public static HSIC getHSIC() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getPictureAdjustment();
+            return LiveDisplayVendorImpl.getInstance().getPictureAdjustment();
         }
         return null;
     }
@@ -63,7 +65,7 @@ public class PictureAdjustment {
      */
     public static HSIC getDefaultHSIC() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getDefaultPictureAdjustment();
+            return LiveDisplayVendorImpl.getInstance().getDefaultPictureAdjustment();
         }
         return null;
     }
@@ -77,7 +79,7 @@ public class PictureAdjustment {
      */
     public static boolean setHSIC(final HSIC hsic) {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_setPictureAdjustment(hsic);
+            return LiveDisplayVendorImpl.getInstance().setPictureAdjustment(hsic);
         }
         return false;
     }
@@ -88,7 +90,7 @@ public class PictureAdjustment {
      */
     public static Range<Float> getHueRange() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getHueRange();
+            return LiveDisplayVendorImpl.getInstance().getHueRange();
         }
         return new Range(0.0f, 0.0f);
     }
@@ -99,7 +101,7 @@ public class PictureAdjustment {
      */
     public static Range<Float> getSaturationRange() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getSaturationRange();
+            return LiveDisplayVendorImpl.getInstance().getSaturationRange();
         }
         return new Range(0.0f, 0.0f);
     }
@@ -110,7 +112,7 @@ public class PictureAdjustment {
      */
     public static Range<Float> getIntensityRange() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getIntensityRange();
+            return LiveDisplayVendorImpl.getInstance().getIntensityRange();
         }
         return new Range(0.0f, 0.0f);
     }
@@ -121,7 +123,7 @@ public class PictureAdjustment {
      */
     public static Range<Float> getContrastRange() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getContrastRange();
+            return LiveDisplayVendorImpl.getInstance().getContrastRange();
         }
         return new Range(0.0f, 0.0f);
     }
@@ -135,7 +137,7 @@ public class PictureAdjustment {
      */
     public static Range<Float> getSaturationThresholdRange() {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_getSaturationThresholdRange();
+            return LiveDisplayVendorImpl.getInstance().getSaturationThresholdRange();
         }
         return new Range(0.0f, 0.0f);
     }
diff --git a/src/org/lineageos/hardware/SunlightEnhancement.java b/src/org/lineageos/hardware/SunlightEnhancement.java
index cde2aa1..4410f57 100644
--- a/src/org/lineageos/hardware/SunlightEnhancement.java
+++ b/src/org/lineageos/hardware/SunlightEnhancement.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2014 The CyanogenMod Project
+ * Copyright (C) 2018 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +17,11 @@
 
 package org.lineageos.hardware;
 
-import org.lineageos.internal.util.FileUtils;
-
 import android.util.Log;
 
+import org.lineageos.internal.util.FileUtils;
+import vendor.lineage.livedisplay.V1_0.Feature;
+
 /**
  * Facemelt mode!
  */
@@ -34,7 +36,7 @@ public class SunlightEnhancement {
     private static final String FILE_SRE = "/sys/class/graphics/fb0/sre";
 
     private static final boolean sHasNativeSupport =
-            LiveDisplayVendorImpl.hasNativeFeature(LiveDisplayVendorImpl.OUTDOOR_MODE);
+            LiveDisplayVendorImpl.getInstance().hasNativeFeature(Feature.OUTDOOR_MODE);
 
     private static String getFacemeltPath() {
         if (FileUtils.fileExists(FILE_HBM)) {
@@ -74,7 +76,7 @@ public class SunlightEnhancement {
     public static boolean isEnabled() {
         try {
             if (sHasNativeSupport) {
-                return LiveDisplayVendorImpl.native_isOutdoorModeEnabled();
+                return LiveDisplayVendorImpl.getInstance().isOutdoorModeEnabled();
             }
             return Integer.parseInt(FileUtils.readOneLine(FACEMELT_PATH)) > 0;
         } catch (Exception e) {
@@ -92,7 +94,7 @@ public class SunlightEnhancement {
      */
     public static boolean setEnabled(boolean status) {
         if (sHasNativeSupport) {
-            return LiveDisplayVendorImpl.native_setOutdoorModeEnabled(status);
+            return LiveDisplayVendorImpl.getInstance().setOutdoorModeEnabled(status);
         }
 
         return FileUtils.writeLine(FACEMELT_PATH, status ? FACEMELT_MODE : "0");
diff --git a/src/org/lineageos/hardware/Utils.java b/src/org/lineageos/hardware/Utils.java
new file mode 100644
index 0000000..68db903
--- /dev/null
+++ b/src/org/lineageos/hardware/Utils.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.hardware;
+
+import android.util.Range;
+
+import lineageos.hardware.DisplayMode;
+import lineageos.hardware.HSIC;
+
+import java.util.ArrayList;
+
+class Utils {
+    public static DisplayMode[] HIDLModeListToArray(
+            ArrayList<vendor.lineage.livedisplay.V1_0.DisplayMode> modes) {
+        int size = modes.size();
+        DisplayMode[] r = new DisplayMode[size];
+        for (int i = 0; i < size; i++) {
+            vendor.lineage.livedisplay.V1_0.DisplayMode m = modes.get(i);
+            r[i] = new DisplayMode(m.id, m.name);
+        }
+        return r;
+    }
+
+    public static DisplayMode fromHIDLMode(vendor.lineage.livedisplay.V1_0.DisplayMode mode) {
+        return new DisplayMode(mode.id, mode.name);
+    }
+
+    public static HSIC fromHIDLHSIC(vendor.lineage.livedisplay.V1_0.HSIC hsic) {
+        return new HSIC((float) hsic.hue, hsic.saturation, hsic.intensity,
+                hsic.contrast, hsic.saturationThreshold);
+    }
+
+    public static vendor.lineage.livedisplay.V1_0.HSIC toHIDLHSIC(HSIC hsic) {
+        vendor.lineage.livedisplay.V1_0.HSIC h = new vendor.lineage.livedisplay.V1_0.HSIC();
+        h.hue = (int) hsic.getHue();
+        h.saturation = hsic.getSaturation();
+        h.intensity = hsic.getIntensity();
+        h.contrast = hsic.getContrast();
+        h.saturationThreshold = hsic.getSaturationThreshold();
+        return h;
+    }
+
+    public static Range<Integer> fromHIDLRange(vendor.lineage.livedisplay.V1_0.Range range) {
+        return new Range(range.min, range.max);
+    }
+
+    public static Range<Float> fromHIDLIntRange(vendor.lineage.livedisplay.V1_0.Range range) {
+        return new Range((float) range.min, (float) range.max);
+    }
+
+    public static Range<Float> fromHIDLRange(vendor.lineage.livedisplay.V1_0.FloatRange range) {
+        return new Range(range.min, range.max);
+    }
+}
-- 
2.15.1

