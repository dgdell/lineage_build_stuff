From 2ba788a0c54975e4e9f01d35078a0333f6b12f7a Mon Sep 17 00:00:00 2001
From: Rashed Abdel-Tawab <rashed@linux.com>
Date: Thu, 19 Jul 2018 16:02:18 -0700
Subject: [PATCH 12/12] stache: Add default ext4 crypto implementation

Change-Id: Ibb29ab4f86f22814c3ffe11f13dd5c7b990e550d
---
 stache/1.0/default/Android.bp                 |  47 +++
 stache/1.0/default/SecureStorage.cpp          | 100 ++++++
 stache/1.0/default/Utils.cpp                  |  61 ++++
 stache/1.0/default/crypto-helper.c            |  57 +++
 stache/1.0/default/include/SecureStorage.h    |  59 ++++
 stache/1.0/default/include/Utils.h            |  45 +++
 stache/1.0/default/include/crypto-helper.h    |  50 +++
 stache/1.0/default/include/key-helper.h       |  47 +++
 stache/1.0/default/include/keyutils.h         |  15 +
 stache/1.0/default/include/linux/fs.h         |  47 +++
 stache/1.0/default/include/policy-helper.h    |  22 ++
 stache/1.0/default/include/sha512.h           |  34 ++
 stache/1.0/default/key-helper.c               |  99 ++++++
 stache/1.0/default/policy-helper.c            |  56 +++
 stache/1.0/default/service.cpp                |  64 ++++
 stache/1.0/default/sha512.c                   | 326 ++++++++++++++++++
 .../vendor.lineage.stache@1.0-service.rc      |   7 +
 stache/Android.bp                             |   1 +
 18 files changed, 1137 insertions(+)
 create mode 100644 stache/1.0/default/Android.bp
 create mode 100644 stache/1.0/default/SecureStorage.cpp
 create mode 100644 stache/1.0/default/Utils.cpp
 create mode 100644 stache/1.0/default/crypto-helper.c
 create mode 100644 stache/1.0/default/include/SecureStorage.h
 create mode 100644 stache/1.0/default/include/Utils.h
 create mode 100644 stache/1.0/default/include/crypto-helper.h
 create mode 100644 stache/1.0/default/include/key-helper.h
 create mode 100644 stache/1.0/default/include/keyutils.h
 create mode 100644 stache/1.0/default/include/linux/fs.h
 create mode 100644 stache/1.0/default/include/policy-helper.h
 create mode 100644 stache/1.0/default/include/sha512.h
 create mode 100644 stache/1.0/default/key-helper.c
 create mode 100644 stache/1.0/default/policy-helper.c
 create mode 100644 stache/1.0/default/service.cpp
 create mode 100644 stache/1.0/default/sha512.c
 create mode 100644 stache/1.0/default/vendor.lineage.stache@1.0-service.rc

diff --git a/stache/1.0/default/Android.bp b/stache/1.0/default/Android.bp
new file mode 100644
index 0000000..7313d05
--- /dev/null
+++ b/stache/1.0/default/Android.bp
@@ -0,0 +1,47 @@
+/**
+ * Copyright (C) 2018 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+cc_binary {
+    name: "vendor.lineage.stache@1.0-service",
+    init_rc: ["vendor.lineage.stache@1.0-service.rc"],
+    relative_install_path: "hw",
+    defaults: ["hidl_defaults"],
+    proprietary: true,
+    local_include_dirs: ["include"],
+    srcs: [
+        "crypto-helper.c",
+        "key-helper.c",
+        "policy-helper.c",
+        "service.cpp",
+        "SecureStorage.cpp",
+        "sha512.c",
+        "Utils.cpp"
+    ],
+    shared_libs: [
+        "libbase",
+        "libbinder",
+        "libcutils",
+        "libhardware",
+        "libhidlbase",
+        "libhidltransport",
+        "libutils",
+        "vendor.lineage.stache@1.0",
+    ],
+    cflags: [
+        "-Wno-unused-function",
+        "-Wno-unused-parameter"
+    ],
+}
diff --git a/stache/1.0/default/SecureStorage.cpp b/stache/1.0/default/SecureStorage.cpp
new file mode 100644
index 0000000..dc815a9
--- /dev/null
+++ b/stache/1.0/default/SecureStorage.cpp
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ * Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <log/log.h>
+
+#include "linux/fs.h"
+
+#include "crypto-helper.h"
+#include "key-helper.h"
+#include "policy-helper.h"
+#include "SecureStorage.h"
+
+namespace vendor {
+namespace lineage {
+namespace stache {
+namespace V1_0 {
+namespace implementation {
+
+// Methods from ISecureStorage follow.
+Return<int32_t> SecureStorage::getContainerStatus(const hidl_string& dirPath) {
+    // TODO implement
+    return int32_t {};
+}
+
+Return<bool> SecureStorage::createContainer(const hidl_string& dirPath, const CryptOptions& options) {
+    int errno;
+    mode_t mode = 0755; // TODO: Don't hardcode this
+
+    errno = mkdir(dirPath.c_str(), mode);
+    if (errno != 0) {
+         ALOGE("Failed to create container %s (%d): %s", dirPath.c_str(), errno, strerror(errno));
+         return false;
+    }
+    // As Kernel version 4.9, the only policy field that has multiple valid
+    // options is "flags", which sets the amount of zero padding on filenames.
+    struct fscrypt_policy policy = {
+        .version = 0,
+        .contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS,
+        .filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS,
+        // Use maximum zero-padding to leak less info about filename length
+        .flags = FS_POLICY_FLAGS_PAD_32
+    };
+    policy.contents_encryption_mode = string_to_mode(options.contentsCipher.c_str());
+    policy.filenames_encryption_mode = string_to_mode(options.filenameCipher.c_str());
+    policy.flags = options.filenamePadding;
+
+    // Copy the descriptor into the policy, requires changing format.
+    if (key_descriptor_to_bytes(options.keyDescriptor.c_str(), policy.master_key_descriptor)) {
+        ALOGE("Invalid descriptor: %s", options.keyDescriptor.c_str());
+        return false;
+    }
+
+    errno = set_policy(dirPath.c_str(), &policy);
+    if (errno != 0) {
+        ALOGE("Failed to set policy for container %s (%d): %s", dirPath.c_str(), errno, strerror(errno));
+        return false;
+    }
+
+    return true;
+}
+
+Return<bool> SecureStorage::attachContainer(const hidl_string& dirPath, const CryptOptions& options) {
+    // TODO implement
+    return bool {};
+}
+
+Return<bool> SecureStorage::detachContainer(const hidl_string& dirPath) {
+    // TODO implement
+    return bool {};
+}
+
+
+// Methods from ::android::hidl::base::V1_0::IBase follow.
+
+//ISecureStorage* HIDL_FETCH_ISecureStorage(const char* /* name */) {
+//    return new SecureStorage();
+//}
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace stache
+}  // namespace lineage
+}  // namespace vendor
diff --git a/stache/1.0/default/Utils.cpp b/stache/1.0/default/Utils.cpp
new file mode 100644
index 0000000..de7332b
--- /dev/null
+++ b/stache/1.0/default/Utils.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ * Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "Utils.h"
+
+#if !defined(__ANDROID__)
+#include <fstab.h>
+#endif
+#include <sys/utsname.h>
+
+namespace vendor {
+namespace lineage {
+namespace stache {
+namespace V1_0 {
+namespace implementation {
+
+using ::android::NO_INIT;
+using ::android::OK;
+using ::android::status_t;
+
+#if !defined(__ANDROID__)
+status_t Utils::getFilesystemType(std::string& fsType, std::string mountPoint) {
+    struct fstab *userdataFstab = getfsfile(mountPoint);
+    if (userdataFstab == NULL) {
+        return NO_INIT;
+    }
+    fsType = userdataFstab->fs_vfstype;
+    return OK;
+}
+#endif
+
+status_t Utils::getKernelVersion(std::string& kernelVersion) {
+    struct utsname sysinfo;
+    status_t ret = OK;
+    int error = uname(&sysinfo);
+    if (error == 0) {
+        kernelVersion = sysinfo.release;
+    }
+    ret = error;
+    return ret;
+}
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace stache
+}  // namespace lineage
+}  // namespace vendor
diff --git a/stache/1.0/default/crypto-helper.c b/stache/1.0/default/crypto-helper.c
new file mode 100644
index 0000000..bdb892d
--- /dev/null
+++ b/stache/1.0/default/crypto-helper.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Modifications Copyright (C) 2018 The LineageOS Project
+ * Modifications Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "crypto-helper.h"
+
+/*
+ * Converts str to an encryption mode. Returns 0 (FS_ENCRYPTION_MODE_INVALID) if
+ * the string does not correspond to an encryption mode.
+ */
+static uint8_t string_to_mode(const char *str) {
+    uint8_t i;
+    for (i = 1; i < NUM_ENCRYPTION_MODES; ++i) {
+        if (strcmp(str, mode_strings[i]) == 0)
+            return i;
+    }
+    return 0;
+}
+
+/*
+ * Converts the encryption mode to a human-readable string. Returns "INVALID" if
+ * the mode is not a valid encryption mode.
+ */
+static const char *mode_to_string(uint8_t mode) {
+    if (mode >= NUM_ENCRYPTION_MODES)
+        mode = 0;
+    return mode_strings[mode];
+}
+
+/*
+ * Converts an amount of padding (as a string) into the appropriate padding
+ * flag. Returns -1 if the flag is invalid.
+ */
+static int string_to_padding_flag(const char *str) {
+    int i, padding = atoi(str);
+    for (i = 0; i < NUM_PADDING_VALUES; ++i) {
+        if (padding == padding_values[i])
+            return i;
+    }
+    return -1;
+}
diff --git a/stache/1.0/default/include/SecureStorage.h b/stache/1.0/default/include/SecureStorage.h
new file mode 100644
index 0000000..f228404
--- /dev/null
+++ b/stache/1.0/default/include/SecureStorage.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ * Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VENDOR_LINEAGE_STACHE_V1_0_SECURESTORAGE_H
+#define VENDOR_LINEAGE_STACHE_V1_0_SECURESTORAGE_H
+
+#include <vendor/lineage/stache/1.0/ISecureStorage.h>
+#include <hidl/MQDescriptor.h>
+#include <hidl/Status.h>
+
+namespace vendor {
+namespace lineage {
+namespace stache {
+namespace V1_0 {
+namespace implementation {
+
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_memory;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::sp;
+
+struct SecureStorage : public ISecureStorage {
+    // Methods from ISecureStorage follow.
+    Return<int32_t> getContainerStatus(const hidl_string& dirPath) override;
+    Return<bool> createContainer(const hidl_string& dirPath, const CryptOptions& options) override;
+    Return<bool> attachContainer(const hidl_string& dirPath, const CryptOptions& options) override;
+    Return<bool> detachContainer(const hidl_string& dirPath) override;
+
+    // Methods from ::android::hidl::base::V1_0::IBase follow.
+
+};
+
+// FIXME: most likely delete, this is only for passthrough implementations
+// extern "C" ISecureStorage* HIDL_FETCH_ISecureStorage(const char* name);
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace stache
+}  // namespace lineage
+}  // namespace vendor
+
+#endif  // VENDOR_LINEAGE_STACHE_V1_0_SECURESTORAGE_H
diff --git a/stache/1.0/default/include/Utils.h b/stache/1.0/default/include/Utils.h
new file mode 100644
index 0000000..013d2b4
--- /dev/null
+++ b/stache/1.0/default/include/Utils.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ * Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VENDOR_LINEAGE_STACHE_V1_0_UTILS_H
+#define VENDOR_LINEAGE_STACHE_V1_0_UTILS_H
+
+#include <string>
+#include <utils/Errors.h>
+
+namespace vendor {
+namespace lineage {
+namespace stache {
+namespace V1_0 {
+namespace implementation {
+
+class Utils {
+  public:
+#if !defined(__ANDROID__)
+    static android::status_t getFilesystemType(std::string& fsType, std::string mountPoint);
+#endif
+
+    static android::status_t getKernelVersion(std::string& kernelVersion);
+};
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace stache
+}  // namespace lineage
+}  // namespace vendor
+
+#endif  // VENDOR_LINEAGE_STACHE_V1_0_UTILS_H
diff --git a/stache/1.0/default/include/crypto-helper.h b/stache/1.0/default/include/crypto-helper.h
new file mode 100644
index 0000000..f82f656
--- /dev/null
+++ b/stache/1.0/default/include/crypto-helper.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Modifications Copyright (C) 2018 The LineageOS Project
+ * Modifications Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __CRYPTO_HELPER_H__
+#define __CRYPTO_HELPER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+// Human-readable strings for encryption modes, indexed by the encryption mode
+#define NUM_ENCRYPTION_MODES 7
+const char *const mode_strings[NUM_ENCRYPTION_MODES] = {
+    "INVALID",     "AES-256-XTS", "AES-256-GCM", "AES-256-CBC",
+    "AES-256-CTS", "AES-128-CBC", "AES-128-CTS"};
+
+// Valid amounts of filename padding, indexed by the padding flag
+#define NUM_PADDING_VALUES 4
+const int padding_values[NUM_PADDING_VALUES] = {4, 8, 16, 32};
+
+static uint8_t string_to_mode(const char *str);
+static const char *mode_to_string(uint8_t mode);
+static int string_to_padding_flag(const char *str);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__CRYPTO_HELPER_H__
diff --git a/stache/1.0/default/include/key-helper.h b/stache/1.0/default/include/key-helper.h
new file mode 100644
index 0000000..02de6ba
--- /dev/null
+++ b/stache/1.0/default/include/key-helper.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Modifications Copyright (C) 2018 The LineageOS Project
+ * Modifications Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __KEY_HELPER_H__
+#define __KEY_HELPER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "keyutils.h"
+#include "sha512.h"
+#include <stdio.h>
+
+static void key_descriptor_to_hex(const uint8_t bytes[FS_KEY_DESCRIPTOR_SIZE],
+                                  char hex[FS_KEY_DESCRIPTOR_HEX_SIZE]);
+static int key_descriptor_to_bytes(const char *hex,
+                                   uint8_t bytes[FS_KEY_DESCRIPTOR_SIZE]);
+static int read_key(uint8_t key[FS_MAX_KEY_SIZE]);
+static void compute_descriptor(const uint8_t key[FS_MAX_KEY_SIZE],
+                               char descriptor[FS_KEY_DESCRIPTOR_HEX_SIZE]);
+static int insert_logon_key(const uint8_t key_data[FS_MAX_KEY_SIZE],
+                            const char descriptor[FS_KEY_DESCRIPTOR_HEX_SIZE],
+                            const char *service_prefix);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__KEY_HELPER_H__
diff --git a/stache/1.0/default/include/keyutils.h b/stache/1.0/default/include/keyutils.h
new file mode 100644
index 0000000..eaacaa5
--- /dev/null
+++ b/stache/1.0/default/include/keyutils.h
@@ -0,0 +1,15 @@
+#include <sys/syscall.h>
+
+typedef int32_t key_serial_t;
+
+#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
+#define KEY_SPEC_SESSION_KEYRING	-3	/* current session keyring */
+
+key_serial_t add_key(const char *type, const char *description,
+                     const void *payload, size_t plen, key_serial_t ringid) {
+    return syscall(__NR_add_key, type, description, payload, plen, ringid);
+}
+
+key_serial_t keyctl_get_keyring_ID(key_serial_t id, int create) {
+    return syscall(__NR_keyctl, KEYCTL_GET_KEYRING_ID, id, create);
+}
diff --git a/stache/1.0/default/include/linux/fs.h b/stache/1.0/default/include/linux/fs.h
new file mode 100644
index 0000000..9cb0eb5
--- /dev/null
+++ b/stache/1.0/default/include/linux/fs.h
@@ -0,0 +1,47 @@
+#include <stdint.h>
+#include <unistd.h>
+
+#define FS_MAX_KEY_SIZE	64
+
+struct fscrypt_key {
+    uint32_t mode;
+    uint8_t raw[FS_MAX_KEY_SIZE];
+    uint32_t size;
+} __attribute__((packed));
+
+#define FS_KEY_DESCRIPTOR_SIZE		8
+#define FS_KEY_DESCRIPTOR_HEX_SIZE	((2 * FS_KEY_DESCRIPTOR_SIZE) + 1)
+
+// Amount of padding
+#define FS_POLICY_FLAGS_PAD_4		0x00
+#define FS_POLICY_FLAGS_PAD_8		0x01
+#define FS_POLICY_FLAGS_PAD_16		0x02
+#define FS_POLICY_FLAGS_PAD_32		0x03
+#define FS_POLICY_FLAGS_PAD_MASK	0x03
+
+// Encryption algorithms
+#define FS_ENCRYPTION_MODE_INVALID	0
+#define FS_ENCRYPTION_MODE_AES_256_XTS	1
+#define FS_ENCRYPTION_MODE_AES_256_GCM	2
+#define FS_ENCRYPTION_MODE_AES_256_CBC	3
+#define FS_ENCRYPTION_MODE_AES_256_CTS	4
+#define FS_ENCRYPTION_MODE_AES_128_CBC	5
+#define FS_ENCRYPTION_MODE_AES_128_CTS	6
+
+// Policy provided via an ioctl on the topmost directory
+struct fscrypt_policy {
+    uint8_t version;
+    uint8_t contents_encryption_mode;
+    uint8_t filenames_encryption_mode;
+    uint8_t flags;
+    uint8_t master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+} __attribute__((packed));
+
+#define FS_IOC_SET_ENCRYPTION_POLICY _IOR('f', 19, struct fscrypt_policy)
+#define FS_IOC_GET_ENCRYPTION_POLICY _IOW('f', 21, struct fscrypt_policy)
+
+// Service prefixes for encryption keys
+#define FS_KEY_DESC_PREFIX		"fscrypt:"
+#define EXT4_KEY_DESC_PREFIX		"ext4:"  // For ext4 before 4.8 kernel
+#define F2FS_KEY_DESC_PREFIX		"f2fs:"  // For f2fs before 4.6 kernel
+#define MAX_KEY_DESC_PREFIX_SIZE	8
diff --git a/stache/1.0/default/include/policy-helper.h b/stache/1.0/default/include/policy-helper.h
new file mode 100644
index 0000000..b5d5901
--- /dev/null
+++ b/stache/1.0/default/include/policy-helper.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Modifications Copyright (C) 2018 The LineageOS Project
+ * Modifications Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+static int get_policy(const char *path, struct fscrypt_policy *policy);
+static int set_policy(const char *path, const struct fscrypt_policy *policy);
diff --git a/stache/1.0/default/include/sha512.h b/stache/1.0/default/include/sha512.h
new file mode 100644
index 0000000..9089418
--- /dev/null
+++ b/stache/1.0/default/include/sha512.h
@@ -0,0 +1,34 @@
+/*
+ * sha512.h - interface to mbedTLS SHA512 hash function.
+ *
+ * Copyright 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+#ifndef SHA512_H
+#define SHA512_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define SHA512_DIGEST_LENGTH 64
+
+extern void SHA512(const uint8_t* in, size_t n,
+                   uint8_t out[SHA512_DIGEST_LENGTH]);
+
+// Zero the memory pointed to by v; this will not be optimized away.
+extern void secure_wipe(uint8_t* v, uint32_t n);
+
+#endif /* SHA512_H */
diff --git a/stache/1.0/default/key-helper.c b/stache/1.0/default/key-helper.c
new file mode 100644
index 0000000..8704ebd
--- /dev/null
+++ b/stache/1.0/default/key-helper.c
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Modifications Copyright (C) 2018 The LineageOS Project
+ * Modifications Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "linux/fs.h"
+
+#include "key-helper.h"
+
+// Takes an input key descriptor as a byte array and outputs a hex string.
+static void key_descriptor_to_hex(const uint8_t bytes[FS_KEY_DESCRIPTOR_SIZE],
+                                  char hex[FS_KEY_DESCRIPTOR_HEX_SIZE]) {
+    int i;
+    for (i = 0; i < FS_KEY_DESCRIPTOR_SIZE; ++i)
+        sprintf(hex + 2 * i, "%02x", bytes[i]);
+}
+
+// Takes an input key descriptor as a hex string and outputs a bytes array.
+// Returns non-zero if the provided hex string is not formatted correctly.
+static int key_descriptor_to_bytes(const char *hex,
+                                   uint8_t bytes[FS_KEY_DESCRIPTOR_SIZE]) {
+    if (strlen(hex) != FS_KEY_DESCRIPTOR_HEX_SIZE - 1)
+        return -1;
+
+    int i, bytes_converted, chars_read;
+    for (i = 0; i < FS_KEY_DESCRIPTOR_SIZE; ++i) {
+        // We must read two hex characters of input into one byte of buffer.
+        bytes_converted = sscanf(hex + 2 * i, "%2hhx%n", bytes + i, &chars_read);
+        if (bytes_converted != 1 || chars_read != 2)
+            return -1;
+    }
+    return 0;
+}
+
+// Reads key data from stdin into the provided data buffer. Return 0 on success.
+static int read_key(uint8_t key[FS_MAX_KEY_SIZE]) {
+    size_t rc = fread(key, 1, FS_MAX_KEY_SIZE, stdin);
+    int end = fgetc(stdin);
+    // We should read exactly FS_MAX_KEY_SIZE bytes, then hit EOF
+    if (rc == FS_MAX_KEY_SIZE && end == EOF && feof(stdin))
+        return 0;
+
+    fprintf(stderr, "error: input key must be %d bytes\n", FS_MAX_KEY_SIZE);
+    return -1;
+}
+
+// The descriptor is just the first 8 bytes of a double application of SHA512
+// formatted as hex (so 16 characters).
+static void compute_descriptor(const uint8_t key[FS_MAX_KEY_SIZE],
+                               char descriptor[FS_KEY_DESCRIPTOR_HEX_SIZE]) {
+    uint8_t digest1[SHA512_DIGEST_LENGTH];
+    SHA512(key, FS_MAX_KEY_SIZE, digest1);
+
+    uint8_t digest2[SHA512_DIGEST_LENGTH];
+    SHA512(digest1, SHA512_DIGEST_LENGTH, digest2);
+
+    key_descriptor_to_hex(digest2, descriptor);
+    secure_wipe(digest1, SHA512_DIGEST_LENGTH);
+    secure_wipe(digest2, SHA512_DIGEST_LENGTH);
+}
+
+// Inserts the key into the current session keyring with type logon and the
+// service specified by service_prefix.
+static int insert_logon_key(const uint8_t key_data[FS_MAX_KEY_SIZE],
+                            const char descriptor[FS_KEY_DESCRIPTOR_HEX_SIZE],
+                            const char *service_prefix) {
+    // We cannot add directly to KEY_SPEC_SESSION_KEYRING, as that will make a new
+    // session keyring if one does not exist, rather than adding it to the user
+    // session keyring.
+    int keyring_id = keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, 0);
+    if (keyring_id < 0)
+        return -1;
+
+    char description[MAX_KEY_DESC_PREFIX_SIZE + FS_KEY_DESCRIPTOR_HEX_SIZE];
+    sprintf(description, "%s%s", service_prefix, descriptor);
+
+    struct fscrypt_key key = {.mode = 0, .size = FS_MAX_KEY_SIZE};
+    memcpy(key.raw, key_data, FS_MAX_KEY_SIZE);
+
+    int ret = add_key("logon", description, &key, sizeof(key), keyring_id) < 0 ? -1 : 0;
+
+    secure_wipe(key.raw, FS_MAX_KEY_SIZE);
+    return ret;
+}
diff --git a/stache/1.0/default/policy-helper.c b/stache/1.0/default/policy-helper.c
new file mode 100644
index 0000000..80e9ddd
--- /dev/null
+++ b/stache/1.0/default/policy-helper.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ * Author: Joe Richey (joerichey@google.com)
+ *
+ * Modifications Copyright (C) 2018 The LineageOS Project
+ * Modifications Author: Rashed Abdel-Tawab (rashed@linux.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include "linux/fs.h"
+#include "policy-helper.h"
+
+static int get_policy(const char *path, struct fscrypt_policy *policy) {
+    // We can query the policy for a directory or a file in that directory.
+    int fd = open(path, O_RDONLY);
+    if (fd < 0)
+        return -1;
+
+    int ret = ioctl(fd, FS_IOC_GET_ENCRYPTION_POLICY, policy);
+    close(fd);
+
+    if (ret < 0) {
+        // Kernels prior to v4.11 returned ENOENT if the file did not have an
+        // encryption policy, newer kernels properly return ENODATA. This lets us
+        // print the right error in policy_error regardless of kernel version.
+        if (errno == ENOENT)
+            errno = ENODATA;
+    }
+    return ret;
+}
+
+static int set_policy(const char *path, const struct fscrypt_policy *policy) {
+    // Policies can only be set on directories
+    int fd = open(path, O_RDONLY | O_DIRECTORY);
+    if (fd < 0)
+        return -1;
+
+    int ret = ioctl(fd, FS_IOC_SET_ENCRYPTION_POLICY, policy);
+    close(fd);
+
+    return ret;
+}
diff --git a/stache/1.0/default/service.cpp b/stache/1.0/default/service.cpp
new file mode 100644
index 0000000..70c5667
--- /dev/null
+++ b/stache/1.0/default/service.cpp
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "vendor.lineage.stache@1.0-service-ext4"
+
+#include <android-base/logging.h>
+#include <binder/ProcessState.h>
+#include <hidl/HidlTransportSupport.h>
+
+#include "SecureStorage.h"
+
+using android::hardware::configureRpcThreadpool;
+using android::hardware::joinRpcThreadpool;
+using android::OK;
+using android::sp;
+using android::status_t;
+
+using ::vendor::lineage::stache::V1_0::ISecureStorage;
+using ::vendor::lineage::stache::V1_0::implementation::SecureStorage;
+
+int main() {
+    status_t status;
+
+    LOG(INFO) << "Stache HAL service is starting.";
+
+    // The Stache HAL may communicate to other vendor components via /dev/vndbinder
+    android::ProcessState::initWithDriver("/dev/vndbinder");
+
+    android::sp<ISecureStorage> service = new SecureStorage();
+    if (service == nullptr) {
+        LOG(ERROR) << "Can not create an instance of Stache HAL Iface, exiting.";
+        goto shutdown;
+    }
+
+    configureRpcThreadpool(1, true /*callerWillJoin*/);
+
+    status = service->registerAsService();
+    if (status != OK) {
+        LOG(ERROR) << "Could not register service for Stache HAL Iface (" << status << ")";
+        goto shutdown;
+    }
+
+    LOG(INFO) << "Stache HAL service is ready.";
+    joinRpcThreadpool();
+// Should not pass this line
+
+shutdown:
+    // In normal operation, we don't expect the thread pool to exit
+    LOG(ERROR) << "Stache HAL service is shutting down.";
+    return 1;
+}
diff --git a/stache/1.0/default/sha512.c b/stache/1.0/default/sha512.c
new file mode 100644
index 0000000..7c3536f
--- /dev/null
+++ b/stache/1.0/default/sha512.c
@@ -0,0 +1,326 @@
+/*
+ * sha512.c - mbed TLS (formerly known as PolarSSL) implementation of SHA512
+ *
+ * Modifications Copyright 2017 Google Inc.
+ * Modifications Author: Joe Richey (joerichey@google.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+/*
+ *  FIPS-180-2 compliant SHA-512 implementation
+ *
+ *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of mbed TLS (https://tls.mbed.org)
+ */
+/*
+ *  The SHA-512 Secure Hash Standard was published by NIST in 2002.
+ *
+ *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
+ */
+
+#include "sha512.h"
+
+#include <string.h>  // (memset_s or explicit_bzero if available)
+
+#if defined(_MSC_VER) || defined(__WATCOMC__)
+#define UL64(x) x##ui64
+#else
+#define UL64(x) x##ULL
+#endif
+
+/* We either use dedicated memory clearing functions or volatile dereference. */
+void secure_wipe(uint8_t *v, uint32_t n) {
+#if defined memset_s
+  memset_s(v, n, 0, n);
+#elif defined explicit_bzero
+  explicit_bzero(v, n);
+#else
+  volatile uint8_t *p = v;
+  while (n--) *p++ = 0;
+#endif
+}
+
+/*
+ * SHA-512 context structure
+ */
+typedef struct {
+  uint64_t total[2];         /*!< number of bytes processed  */
+  uint64_t state[8];         /*!< intermediate digest state  */
+  unsigned char buffer[128]; /*!< data block being processed */
+} mbedtls_sha512_context;
+
+/*
+ * 64-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT64_BE
+#define GET_UINT64_BE(n, b, i)                                              \
+  {                                                                         \
+    (n) = ((uint64_t)(b)[(i)] << 56) | ((uint64_t)(b)[(i) + 1] << 48) |     \
+          ((uint64_t)(b)[(i) + 2] << 40) | ((uint64_t)(b)[(i) + 3] << 32) | \
+          ((uint64_t)(b)[(i) + 4] << 24) | ((uint64_t)(b)[(i) + 5] << 16) | \
+          ((uint64_t)(b)[(i) + 6] << 8) | ((uint64_t)(b)[(i) + 7]);         \
+  }
+#endif /* GET_UINT64_BE */
+
+#ifndef PUT_UINT64_BE
+#define PUT_UINT64_BE(n, b, i)                 \
+  {                                            \
+    (b)[(i)] = (unsigned char)((n) >> 56);     \
+    (b)[(i) + 1] = (unsigned char)((n) >> 48); \
+    (b)[(i) + 2] = (unsigned char)((n) >> 40); \
+    (b)[(i) + 3] = (unsigned char)((n) >> 32); \
+    (b)[(i) + 4] = (unsigned char)((n) >> 24); \
+    (b)[(i) + 5] = (unsigned char)((n) >> 16); \
+    (b)[(i) + 6] = (unsigned char)((n) >> 8);  \
+    (b)[(i) + 7] = (unsigned char)((n));       \
+  }
+#endif /* PUT_UINT64_BE */
+
+static void mbedtls_sha512_init(mbedtls_sha512_context *ctx) {
+  memset(ctx, 0, sizeof(mbedtls_sha512_context));
+}
+
+/*
+ * SHA-512 context setup
+ */
+static void mbedtls_sha512_starts(mbedtls_sha512_context *ctx) {
+  ctx->total[0] = 0;
+  ctx->total[1] = 0;
+
+  ctx->state[0] = UL64(0x6A09E667F3BCC908);
+  ctx->state[1] = UL64(0xBB67AE8584CAA73B);
+  ctx->state[2] = UL64(0x3C6EF372FE94F82B);
+  ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
+  ctx->state[4] = UL64(0x510E527FADE682D1);
+  ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
+  ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
+  ctx->state[7] = UL64(0x5BE0CD19137E2179);
+}
+
+/*
+ * Round constants
+ */
+static const uint64_t K[80] = {
+    UL64(0x428A2F98D728AE22), UL64(0x7137449123EF65CD),
+    UL64(0xB5C0FBCFEC4D3B2F), UL64(0xE9B5DBA58189DBBC),
+    UL64(0x3956C25BF348B538), UL64(0x59F111F1B605D019),
+    UL64(0x923F82A4AF194F9B), UL64(0xAB1C5ED5DA6D8118),
+    UL64(0xD807AA98A3030242), UL64(0x12835B0145706FBE),
+    UL64(0x243185BE4EE4B28C), UL64(0x550C7DC3D5FFB4E2),
+    UL64(0x72BE5D74F27B896F), UL64(0x80DEB1FE3B1696B1),
+    UL64(0x9BDC06A725C71235), UL64(0xC19BF174CF692694),
+    UL64(0xE49B69C19EF14AD2), UL64(0xEFBE4786384F25E3),
+    UL64(0x0FC19DC68B8CD5B5), UL64(0x240CA1CC77AC9C65),
+    UL64(0x2DE92C6F592B0275), UL64(0x4A7484AA6EA6E483),
+    UL64(0x5CB0A9DCBD41FBD4), UL64(0x76F988DA831153B5),
+    UL64(0x983E5152EE66DFAB), UL64(0xA831C66D2DB43210),
+    UL64(0xB00327C898FB213F), UL64(0xBF597FC7BEEF0EE4),
+    UL64(0xC6E00BF33DA88FC2), UL64(0xD5A79147930AA725),
+    UL64(0x06CA6351E003826F), UL64(0x142929670A0E6E70),
+    UL64(0x27B70A8546D22FFC), UL64(0x2E1B21385C26C926),
+    UL64(0x4D2C6DFC5AC42AED), UL64(0x53380D139D95B3DF),
+    UL64(0x650A73548BAF63DE), UL64(0x766A0ABB3C77B2A8),
+    UL64(0x81C2C92E47EDAEE6), UL64(0x92722C851482353B),
+    UL64(0xA2BFE8A14CF10364), UL64(0xA81A664BBC423001),
+    UL64(0xC24B8B70D0F89791), UL64(0xC76C51A30654BE30),
+    UL64(0xD192E819D6EF5218), UL64(0xD69906245565A910),
+    UL64(0xF40E35855771202A), UL64(0x106AA07032BBD1B8),
+    UL64(0x19A4C116B8D2D0C8), UL64(0x1E376C085141AB53),
+    UL64(0x2748774CDF8EEB99), UL64(0x34B0BCB5E19B48A8),
+    UL64(0x391C0CB3C5C95A63), UL64(0x4ED8AA4AE3418ACB),
+    UL64(0x5B9CCA4F7763E373), UL64(0x682E6FF3D6B2B8A3),
+    UL64(0x748F82EE5DEFB2FC), UL64(0x78A5636F43172F60),
+    UL64(0x84C87814A1F0AB72), UL64(0x8CC702081A6439EC),
+    UL64(0x90BEFFFA23631E28), UL64(0xA4506CEBDE82BDE9),
+    UL64(0xBEF9A3F7B2C67915), UL64(0xC67178F2E372532B),
+    UL64(0xCA273ECEEA26619C), UL64(0xD186B8C721C0C207),
+    UL64(0xEADA7DD6CDE0EB1E), UL64(0xF57D4F7FEE6ED178),
+    UL64(0x06F067AA72176FBA), UL64(0x0A637DC5A2C898A6),
+    UL64(0x113F9804BEF90DAE), UL64(0x1B710B35131C471B),
+    UL64(0x28DB77F523047D84), UL64(0x32CAAB7B40C72493),
+    UL64(0x3C9EBE0A15C9BEBC), UL64(0x431D67C49C100D4C),
+    UL64(0x4CC5D4BECB3E42B6), UL64(0x597F299CFC657E2A),
+    UL64(0x5FCB6FAB3AD6FAEC), UL64(0x6C44198C4A475817)};
+
+static void mbedtls_sha512_process(mbedtls_sha512_context *ctx,
+                                   const unsigned char data[128]) {
+  int i;
+  uint64_t temp1, temp2, W[80];
+  uint64_t A, B, C, D, E, F, G, H;
+
+#define SHR(x, n) (x >> n)
+#define ROTR(x, n) (SHR(x, n) | (x << (64 - n)))
+
+#define S0(x) (ROTR(x, 1) ^ ROTR(x, 8) ^ SHR(x, 7))
+#define S1(x) (ROTR(x, 19) ^ ROTR(x, 61) ^ SHR(x, 6))
+
+#define S2(x) (ROTR(x, 28) ^ ROTR(x, 34) ^ ROTR(x, 39))
+#define S3(x) (ROTR(x, 14) ^ ROTR(x, 18) ^ ROTR(x, 41))
+
+#define F0(x, y, z) ((x & y) | (z & (x | y)))
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+
+#define P(a, b, c, d, e, f, g, h, x, K)      \
+  {                                          \
+    temp1 = h + S3(e) + F1(e, f, g) + K + x; \
+    temp2 = S2(a) + F0(a, b, c);             \
+    d += temp1;                              \
+    h = temp1 + temp2;                       \
+  }
+
+  for (i = 0; i < 16; i++) {
+    GET_UINT64_BE(W[i], data, i << 3);
+  }
+
+  for (; i < 80; i++) {
+    W[i] = S1(W[i - 2]) + W[i - 7] + S0(W[i - 15]) + W[i - 16];
+  }
+
+  A = ctx->state[0];
+  B = ctx->state[1];
+  C = ctx->state[2];
+  D = ctx->state[3];
+  E = ctx->state[4];
+  F = ctx->state[5];
+  G = ctx->state[6];
+  H = ctx->state[7];
+  i = 0;
+
+  do {
+    P(A, B, C, D, E, F, G, H, W[i], K[i]);
+    i++;
+    P(H, A, B, C, D, E, F, G, W[i], K[i]);
+    i++;
+    P(G, H, A, B, C, D, E, F, W[i], K[i]);
+    i++;
+    P(F, G, H, A, B, C, D, E, W[i], K[i]);
+    i++;
+    P(E, F, G, H, A, B, C, D, W[i], K[i]);
+    i++;
+    P(D, E, F, G, H, A, B, C, W[i], K[i]);
+    i++;
+    P(C, D, E, F, G, H, A, B, W[i], K[i]);
+    i++;
+    P(B, C, D, E, F, G, H, A, W[i], K[i]);
+    i++;
+  } while (i < 80);
+
+  ctx->state[0] += A;
+  ctx->state[1] += B;
+  ctx->state[2] += C;
+  ctx->state[3] += D;
+  ctx->state[4] += E;
+  ctx->state[5] += F;
+  ctx->state[6] += G;
+  ctx->state[7] += H;
+}
+
+/*
+ * SHA-512 process buffer
+ */
+static void mbedtls_sha512_update(mbedtls_sha512_context *ctx,
+                                  const unsigned char *input, size_t ilen) {
+  size_t fill;
+  unsigned int left;
+
+  if (ilen == 0) return;
+
+  left = (unsigned int)(ctx->total[0] & 0x7F);
+  fill = 128 - left;
+
+  ctx->total[0] += (uint64_t)ilen;
+
+  if (ctx->total[0] < (uint64_t)ilen) ctx->total[1]++;
+
+  if (left && ilen >= fill) {
+    memcpy((void *)(ctx->buffer + left), input, fill);
+    mbedtls_sha512_process(ctx, ctx->buffer);
+    input += fill;
+    ilen -= fill;
+    left = 0;
+  }
+
+  while (ilen >= 128) {
+    mbedtls_sha512_process(ctx, input);
+    input += 128;
+    ilen -= 128;
+  }
+
+  if (ilen > 0) memcpy((void *)(ctx->buffer + left), input, ilen);
+}
+
+static const unsigned char sha512_padding[128] = {
+    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/*
+ * SHA-512 final digest
+ */
+static void mbedtls_sha512_finish(mbedtls_sha512_context *ctx,
+                                  unsigned char output[64]) {
+  size_t last, padn;
+  uint64_t high, low;
+  unsigned char msglen[16];
+
+  high = (ctx->total[0] >> 61) | (ctx->total[1] << 3);
+  low = (ctx->total[0] << 3);
+
+  PUT_UINT64_BE(high, msglen, 0);
+  PUT_UINT64_BE(low, msglen, 8);
+
+  last = (size_t)(ctx->total[0] & 0x7F);
+  padn = (last < 112) ? (112 - last) : (240 - last);
+
+  mbedtls_sha512_update(ctx, sha512_padding, padn);
+  mbedtls_sha512_update(ctx, msglen, 16);
+
+  PUT_UINT64_BE(ctx->state[0], output, 0);
+  PUT_UINT64_BE(ctx->state[1], output, 8);
+  PUT_UINT64_BE(ctx->state[2], output, 16);
+  PUT_UINT64_BE(ctx->state[3], output, 24);
+  PUT_UINT64_BE(ctx->state[4], output, 32);
+  PUT_UINT64_BE(ctx->state[5], output, 40);
+  PUT_UINT64_BE(ctx->state[6], output, 48);
+  PUT_UINT64_BE(ctx->state[7], output, 56);
+}
+
+/*
+ * output = SHA-512( input buffer )
+ */
+void SHA512(const uint8_t *in, size_t n, uint8_t out[SHA512_DIGEST_LENGTH]) {
+  mbedtls_sha512_context ctx;
+
+  mbedtls_sha512_init(&ctx);
+  mbedtls_sha512_starts(&ctx);
+  mbedtls_sha512_update(&ctx, in, n);
+  mbedtls_sha512_finish(&ctx, out);
+  secure_wipe((uint8_t *)&ctx, sizeof(ctx));
+}
diff --git a/stache/1.0/default/vendor.lineage.stache@1.0-service.rc b/stache/1.0/default/vendor.lineage.stache@1.0-service.rc
new file mode 100644
index 0000000..da9ef81
--- /dev/null
+++ b/stache/1.0/default/vendor.lineage.stache@1.0-service.rc
@@ -0,0 +1,7 @@
+service stache-hal-1-0 /vendor/bin/hw/vendor.lineage.stache@1.0-service
+    class hal
+    user system
+    group system
+
+on property:vold.decrypt=trigger_restart_framework
+    restart stache-hal-1-0
diff --git a/stache/Android.bp b/stache/Android.bp
index bbb3e4b..ba90f2c 100644
--- a/stache/Android.bp
+++ b/stache/Android.bp
@@ -1,4 +1,5 @@
 // This is an autogenerated file, do not edit.
 subdirs = [
     "1.0",
+    "1.0/default",
 ]
-- 
2.17.1

