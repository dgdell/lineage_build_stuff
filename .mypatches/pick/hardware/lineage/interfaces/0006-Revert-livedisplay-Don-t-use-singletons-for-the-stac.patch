From b62d8ebbe7406343cb8e4402e9a8ebace4793507 Mon Sep 17 00:00:00 2001
From: dianlujitao <dianlujitao@lineageos.org>
Date: Thu, 14 Jun 2018 10:39:06 +0200
Subject: [PATCH 6/6] Revert "livedisplay: Don't use singletons for the stack"

 * Broke livedisplay on multiple devices.

This reverts commit 18f4e8d82033f0f68c64f785f7733e188a7578f0.

Change-Id: I81cf3574028d006c3c56bf1d0fad153d03528f1d
---
 .../default/controller/LegacyMMController.cpp |  16 ++-
 .../1.0/default/controller/SDMController.cpp  |  16 ++-
 livedisplay/1.0/default/impl/LegacyMM.cpp     | 106 +++++++++---------
 livedisplay/1.0/default/impl/SDM.cpp          |  44 ++++----
 livedisplay/1.0/default/include/Color.h       |  14 ++-
 .../1.0/default/include/ColorBackend.h        |   2 +
 .../include/controller/LegacyMMController.h   |   6 +-
 .../include/controller/SDMController.h        |   7 +-
 .../1.0/default/include/impl/LegacyMM.h       |   8 +-
 livedisplay/1.0/default/include/impl/SDM.h    |   8 +-
 livedisplay/1.0/default/service.cpp           |   9 +-
 livedisplay/1.0/default/src/Color.cpp         |  60 +++++-----
 12 files changed, 170 insertions(+), 126 deletions(-)

diff --git a/livedisplay/1.0/default/controller/LegacyMMController.cpp b/livedisplay/1.0/default/controller/LegacyMMController.cpp
index 403692b..12a8e13 100644
--- a/livedisplay/1.0/default/controller/LegacyMMController.cpp
+++ b/livedisplay/1.0/default/controller/LegacyMMController.cpp
@@ -74,6 +74,13 @@ namespace V1_0 {
 namespace implementation {
 
 LegacyMMController::LegacyMMController() {
+    mHandle = openlib();
+    if (mHandle != nullptr) {
+        FOR_EACH_FUNCTION(LOAD_MM_FUNCTION)
+    }
+}
+
+std::shared_ptr<void> LegacyMMController::openlib() {
     std::shared_ptr<void> handle(dlopen(kFilename, RTLD_NOW), [this](void* p) {
         FOR_EACH_FUNCTION(CLOSE_MM_FUNCTION)
         if (p != nullptr) {
@@ -86,11 +93,14 @@ LegacyMMController::LegacyMMController() {
     });
     if (handle == nullptr) {
         LOG(ERROR) << "DLOPEN failed for " << kFilename << " (" << dlerror() << ")";
-        return;
+        return nullptr;
     }
-    mHandle = handle;
+    return handle;
+}
 
-    FOR_EACH_FUNCTION(LOAD_MM_FUNCTION);
+LegacyMMController& LegacyMMController::getInstance() {
+    static LegacyMMController instance{};
+    return instance;
 }
 
 int32_t LegacyMMController::init(int32_t initialize) {
diff --git a/livedisplay/1.0/default/controller/SDMController.cpp b/livedisplay/1.0/default/controller/SDMController.cpp
index 1355ce2..31e0ec7 100644
--- a/livedisplay/1.0/default/controller/SDMController.cpp
+++ b/livedisplay/1.0/default/controller/SDMController.cpp
@@ -72,6 +72,13 @@ namespace V1_0 {
 namespace implementation {
 
 SDMController::SDMController() {
+    mHandle = openlib();
+    if (mHandle != nullptr) {
+        FOR_EACH_FUNCTION(LOAD_SDM_FUNCTION)
+    }
+}
+
+std::shared_ptr<void> SDMController::openlib() {
     std::shared_ptr<void> handle(dlopen(kFilename, RTLD_NOW), [this](void* p) {
         FOR_EACH_FUNCTION(CLOSE_SDM_FUNCTION)
         if (p != nullptr) {
@@ -84,11 +91,14 @@ SDMController::SDMController() {
     });
     if (handle == nullptr) {
         LOG(ERROR) << "DLOPEN failed for " << kFilename << " (" << dlerror() << ")";
-        return;
+        return nullptr;
     }
-    mHandle = handle;
+    return handle;
+}
 
-    FOR_EACH_FUNCTION(LOAD_SDM_FUNCTION)
+SDMController& SDMController::getInstance() {
+    static SDMController instance{};
+    return instance;
 }
 
 int32_t SDMController::init(uint64_t* hctx, uint32_t flags) {
diff --git a/livedisplay/1.0/default/impl/LegacyMM.cpp b/livedisplay/1.0/default/impl/LegacyMM.cpp
index aa317b6..c28a593 100644
--- a/livedisplay/1.0/default/impl/LegacyMM.cpp
+++ b/livedisplay/1.0/default/impl/LegacyMM.cpp
@@ -63,52 +63,11 @@ using android::OK;
 using android::sp;
 using android::status_t;
 
-LegacyMM::LegacyMM() {
-    mController = std::make_unique<LegacyMMController>();
-    if (mController == nullptr) {
-        LOG(ERROR) << "%s: Failed to create LegacyMMController";
-        return;
-    }
-
-    status_t rc = mController->init(0);
-    if (rc != OK) {
-        LOG(ERROR) << "%s: Failed to initialize LegacyMMController";
-        return;
-    }
-
-    if (hasFeature(Feature::DISPLAY_MODES)) {
-        int32_t id;
-        // Get the initial mode from Utils
-        rc = Utils::readInitialModeId(&id);
-        if (rc != OK || id < 0) {
-            // Get controller default mode and save it
-            rc = mController->get_default_display_mode(0, &id);
-            if (rc == OK && id >= 0) {
-                Utils::writeInitialModeId(id);
-            } else {
-                Utils::writeInitialModeId(0);
-            }
-        }
-
-        auto mode = getDefaultDisplayMode();
-        if (mode != nullptr) {
-            setDisplayMode(mode->id, false);
-        }
-    }
-}
-
-LegacyMM::~LegacyMM() {
-    status_t rc = mController->init(1);
-    if (rc != OK) {
-        LOG(ERROR) << "%s: Failed to deinitialize LegacyMMController";
-    }
-}
-
 status_t LegacyMM::getColorBalanceRange(Range& range) {
     struct mm_range r;
     memset(&r, 0, sizeof(struct mm_range));
 
-    status_t rc = mController->get_color_balance_range(0, &r);
+    status_t rc = LegacyMMController::getInstance().get_color_balance_range(0, &r);
     if (rc == OK) {
         range.min = r.min;
         range.max = r.max;
@@ -117,12 +76,12 @@ status_t LegacyMM::getColorBalanceRange(Range& range) {
 }
 
 status_t LegacyMM::setColorBalance(int32_t balance) {
-    return mController->set_color_balance(0, balance);
+    return LegacyMMController::getInstance().set_color_balance(0, balance);
 }
 
 int32_t LegacyMM::getColorBalance() {
     int32_t value = 0;
-    if (mController->get_color_balance(0, &value) != 0) {
+    if (LegacyMMController::getInstance().get_color_balance(0, &value) != 0) {
         value = 0;
     }
     return value;
@@ -152,7 +111,7 @@ status_t LegacyMM::getDisplayModes(std::vector<sp<disp_mode>>& profiles) {
 
     d_mode tmp[count];
 
-    rc = mController->get_display_modes(0, 0, tmp, count);
+    rc = LegacyMMController::getInstance().get_display_modes(0, 0, tmp, count);
     if (rc == 0) {
         for (uint32_t i = 0; i < count; i++) {
             const sp<disp_mode> m = new disp_mode;
@@ -177,11 +136,11 @@ status_t LegacyMM::setDisplayMode(int32_t modeID, bool makeDefault) {
         return BAD_VALUE;
     }
 
-    if (mController->set_active_display_mode(0, modeID) != 0) {
+    if (LegacyMMController::getInstance().set_active_display_mode(0, modeID) != 0) {
         return BAD_VALUE;
     }
 
-    if (makeDefault && mController->set_default_display_mode(0, modeID) != 0) {
+    if (makeDefault && LegacyMMController::getInstance().set_default_display_mode(0, modeID) != 0) {
         return BAD_VALUE;
     }
 
@@ -197,7 +156,7 @@ sp<disp_mode> LegacyMM::getCurrentDisplayMode() {
     int32_t id = 0;
     uint32_t mask = 0;
 
-    status_t rc = mController->get_active_display_mode(0, &id, &mask);
+    status_t rc = LegacyMMController::getInstance().get_active_display_mode(0, &id, &mask);
     if (rc == OK && id >= 0) {
         return getDisplayModeById(id);
     }
@@ -215,7 +174,7 @@ sp<disp_mode> LegacyMM::getDefaultDisplayMode() {
         return getDisplayModeById(id);
     }
 
-    status_t rc = mController->get_default_display_mode(0, &id);
+    status_t rc = LegacyMMController::getInstance().get_default_display_mode(0, &id);
     if (rc == OK && id >= 0) {
         return getDisplayModeById(id);
     }
@@ -227,7 +186,7 @@ status_t LegacyMM::getPictureAdjustmentRanges(HSICRanges& ranges) {
     struct mm_pa_range r;
     memset(&r, 0, sizeof(struct mm_pa_range));
 
-    status_t rc = mController->get_pa_range(0, &r);
+    status_t rc = LegacyMMController::getInstance().get_pa_range(0, &r);
     if (rc == OK) {
         ranges.hue.min = r.min.hue;
         ranges.hue.max = r.max.hue;
@@ -252,7 +211,7 @@ status_t LegacyMM::getPictureAdjustment(HSIC& hsic) {
     struct mm_pa_config config;
     memset(&config, 0, sizeof(struct mm_pa_config));
 
-    status_t rc = mController->get_pa_config(0, &config);
+    status_t rc = LegacyMMController::getInstance().get_pa_config(0, &config);
     if (rc == OK) {
         hsic.hue = config.data.hue;
         hsic.saturation = config.data.saturation;
@@ -278,7 +237,46 @@ status_t LegacyMM::setPictureAdjustment(const HSIC& hsic) {
     config.data.contrast = hsic.contrast;
     config.data.saturationThreshold = hsic.saturationThreshold;
 
-    return mController->set_pa_config(0, &config);
+    return LegacyMMController::getInstance().set_pa_config(0, &config);
+}
+
+status_t LegacyMM::initialize() {
+    status_t rc = NO_INIT;
+    rc = LegacyMMController::getInstance().init(0);
+    if (rc != OK) {
+        LOG(ERROR) << "%s: Failed to initialize LegacyMMController";
+        return rc;
+    }
+
+    if (hasFeature(Feature::DISPLAY_MODES)) {
+        int32_t id;
+        // Get the initial mode from Utils
+        rc = Utils::readInitialModeId(&id);
+        if (rc != OK || id < 0) {
+            // Get controller default mode and save it
+            rc = LegacyMMController::getInstance().get_default_display_mode(0, &id);
+            if (rc == OK && id >= 0) {
+                Utils::writeInitialModeId(id);
+            } else {
+                Utils::writeInitialModeId(0);
+            }
+        }
+
+        auto mode = getDefaultDisplayMode();
+        if (mode != nullptr) {
+            setDisplayMode(mode->id, false);
+        }
+    }
+    return OK;
+}
+
+status_t LegacyMM::deinitialize() {
+    status_t rc = NO_INIT;
+    rc = LegacyMMController::getInstance().init(1);
+    if (rc != OK) {
+        return rc;
+    }
+    return OK;
 }
 
 bool LegacyMM::hasFeature(Feature feature) {
@@ -297,7 +295,7 @@ bool LegacyMM::hasFeature(Feature feature) {
             return false;
     }
 
-    if (mController->supported(0, id)) {
+    if (LegacyMMController::getInstance().supported(0, id)) {
         // display modes and color balance depend on each other
         if (feature == Feature::DISPLAY_MODES || feature == Feature::COLOR_BALANCE) {
             if (getNumDisplayModes() > 0) {
@@ -324,7 +322,7 @@ bool LegacyMM::hasFeature(Feature feature) {
 
 uint32_t LegacyMM::getNumDisplayModes() {
     uint32_t count = 0;
-    if (mController->get_num_display_modes(0, 0, &count) != 0) {
+    if (LegacyMMController::getInstance().get_num_display_modes(0, 0, &count) != 0) {
         count = 0;
     }
     return count;
diff --git a/livedisplay/1.0/default/impl/SDM.cpp b/livedisplay/1.0/default/impl/SDM.cpp
index 7a448c6..62a7ffe 100644
--- a/livedisplay/1.0/default/impl/SDM.cpp
+++ b/livedisplay/1.0/default/impl/SDM.cpp
@@ -92,23 +92,21 @@ using ::android::OK;
 using ::android::sp;
 using ::android::status_t;
 
-SDM::SDM() : mActiveModeId(-1) {
-    mController = std::make_unique<SDMController>();
-    if (mController == nullptr) {
-        LOG(ERROR) << "Failed to create SDMController";
-        return;
-    }
+status_t SDM::initialize() {
+    status_t rc = NO_INIT;
 
-    status_t rc = mController->init(&mHandle, 0);
+    rc = SDMController::getInstance().init(&mHandle, 0);
     if (rc != OK) {
-        return;
+        return rc;
     }
 
+    mActiveModeId = -1;
+
     if (hasFeature(Feature::DISPLAY_MODES)) {
         rc = saveInitialDisplayMode();
         if (rc != OK) {
             LOG(ERROR) << "Failed to save initial display mode! err=" << rc;
-            return;
+            return rc;
         }
         sp<disp_mode> defMode = getDefaultDisplayMode();
         if (defMode != nullptr) {
@@ -117,16 +115,20 @@ SDM::SDM() : mActiveModeId(-1) {
     }
 
     mFOSSEnabled = android::base::GetBoolProperty(kFossProperty, false);
+
+    return OK;
 }
 
-SDM::~SDM() {
-    mController->deinit(mHandle, 0);
+status_t SDM::deinitialize() {
+    SDMController::getInstance().deinit(mHandle, 0);
+    mHandle = 0;
+    return OK;
 }
 
 uint32_t SDM::getNumSDMDisplayModes() {
     uint32_t flags = 0;
     int32_t count = 0;
-    if (mController->get_num_display_modes(mHandle, 0, 0, &count, &flags)) {
+    if (SDMController::getInstance().get_num_display_modes(mHandle, 0, 0, &count, &flags)) {
         count = 0;
     }
     return count;
@@ -170,11 +172,11 @@ status_t SDM::setModeState(sp<disp_mode> mode, bool state) {
         }
     } else if (mode->privFlags == PRIV_MODE_FLAG_SDM) {
         if (state) {
-            return mController->set_active_display_mode(mHandle, 0, mode->id, 0);
+            return SDMController::getInstance().set_active_display_mode(mHandle, 0, mode->id, 0);
         } else {
             if (Utils::readInitialModeId(&id) == OK) {
                 LOG(VERBOSE) << "set sdm mode to default: id" << id;
-                return mController->set_active_display_mode(mHandle, 0, id, 0);
+                return SDMController::getInstance().set_active_display_mode(mHandle, 0, id, 0);
             }
         }
     }
@@ -214,7 +216,7 @@ status_t SDM::getDisplayModes(std::vector<sp<disp_mode>>& profiles) {
         sdm_mode tmp[sdm_count];
 
         uint32_t flags = 0;
-        rc = mController->get_display_modes(mHandle, 0, 0, tmp, sdm_count, &flags);
+        rc = SDMController::getInstance().get_display_modes(mHandle, 0, 0, tmp, sdm_count, &flags);
         if (rc == 0) {
             for (uint32_t i = 0; i < sdm_count; i++) {
                 const sp<disp_mode> m = new disp_mode;
@@ -281,7 +283,7 @@ status_t SDM::getPictureAdjustmentRanges(HSICRanges& ranges) {
     hsic_ranges r;
     memset(&r, 0, sizeof(struct hsic_ranges));
 
-    status_t rc = mController->get_global_pa_range(mHandle, 0, &r);
+    status_t rc = SDMController::getInstance().get_global_pa_range(mHandle, 0, &r);
     if (rc == OK) {
         ranges.hue.min = r.hue.min;
         ranges.hue.max = r.hue.max;
@@ -326,7 +328,7 @@ bool SDM::hasFeature(Feature feature) {
             return false;
     }
 
-    if (mController->get_feature_version(mHandle, id, &v, &flags) != OK) {
+    if (SDMController::getInstance().get_feature_version(mHandle, id, &v, &flags) != OK) {
         return false;
     }
 
@@ -350,7 +352,7 @@ status_t SDM::saveInitialDisplayMode() {
     int32_t id = 0;
     uint32_t flags = 0;
     if (Utils::readInitialModeId(&id) != OK || id < 0) {
-        if (mController->get_default_display_mode(mHandle, 0, &id, &flags) == OK &&
+        if (SDMController::getInstance().get_default_display_mode(mHandle, 0, &id, &flags) == OK &&
             id >= 0) {
             return Utils::writeInitialModeId(id);
         } else {
@@ -365,7 +367,7 @@ status_t SDM::getPictureAdjustment(HSIC& hsic) {
     hsic_config config;
     memset(&config, 0, sizeof(struct hsic_config));
 
-    status_t rc = mController->get_global_pa_config(mHandle, 0, &enable, &config);
+    status_t rc = SDMController::getInstance().get_global_pa_config(mHandle, 0, &enable, &config);
     if (rc == OK) {
         hsic.hue = config.data.hue;
         hsic.saturation = config.data.saturation;
@@ -413,7 +415,7 @@ status_t SDM::setDisplayMode(int32_t modeID, bool makeDefault) {
                 return rc;
             }
             if (mode->privFlags == PRIV_MODE_FLAG_SDM) {
-                rc = mController->set_default_display_mode(mHandle, 0, mode->id, 0);
+                rc = SDMController::getInstance().set_default_display_mode(mHandle, 0, mode->id, 0);
                 if (rc != OK) {
                     LOG(ERROR) << "failed to save mode! err=" << rc;
                     return rc;
@@ -468,7 +470,7 @@ status_t SDM::setPictureAdjustment(const HSIC& hsic) {
     config.data.contrast = hsic.contrast;
     config.data.saturationThreshold = hsic.saturationThreshold;
 
-    return mController->set_global_pa_config(mHandle, 0, 1, &config);
+    return SDMController::getInstance().set_global_pa_config(mHandle, 0, 1, &config);
 }
 
 HSIC SDM::getDefaultPictureAdjustment() {
diff --git a/livedisplay/1.0/default/include/Color.h b/livedisplay/1.0/default/include/Color.h
index 74d0234..e6fca65 100644
--- a/livedisplay/1.0/default/include/Color.h
+++ b/livedisplay/1.0/default/include/Color.h
@@ -40,7 +40,7 @@ class ColorBackend;
 
 class Color : public IColor {
   public:
-    Color();
+    static android::sp<Color> getInstance();
 
     Return<Features> getSupportedFeatures() override;
 
@@ -72,14 +72,18 @@ class Color : public IColor {
     ~Color();
 
   private:
-    void connect();
-    void disconnect();
+    bool connect();
+    void reset();
+
+    Color();
+    static android::sp<Color> sInstance;
 
     uint32_t mFeatures;
     bool mConnected;
 
-    bool check(Feature f);
-
+    bool check(Feature f) {
+        return connect() && (mFeatures & (uint32_t)f);
+    }
     void error(const char* msg = NULL);
 
     void addFeature(Feature f) {
diff --git a/livedisplay/1.0/default/include/ColorBackend.h b/livedisplay/1.0/default/include/ColorBackend.h
index c5d06fa..4abd11b 100644
--- a/livedisplay/1.0/default/include/ColorBackend.h
+++ b/livedisplay/1.0/default/include/ColorBackend.h
@@ -49,6 +49,8 @@ class ColorBackend {
     virtual HSIC getDefaultPictureAdjustment() = 0;
     virtual android::status_t setPictureAdjustment(const HSIC& hsic) = 0;
 
+    virtual android::status_t initialize() = 0;
+    virtual android::status_t deinitialize() = 0;
     virtual bool hasFeature(Feature feature) = 0;
 
     virtual ~ColorBackend() {
diff --git a/livedisplay/1.0/default/include/controller/LegacyMMController.h b/livedisplay/1.0/default/include/controller/LegacyMMController.h
index 8265001..48bb403 100644
--- a/livedisplay/1.0/default/include/controller/LegacyMMController.h
+++ b/livedisplay/1.0/default/include/controller/LegacyMMController.h
@@ -29,7 +29,7 @@ namespace implementation {
 
 class LegacyMMController {
   public:
-    LegacyMMController();
+    static LegacyMMController& getInstance();
 
     int32_t init(int32_t init);
     int32_t get_color_balance_range(int32_t disp_id, void* range);
@@ -47,6 +47,10 @@ class LegacyMMController {
     int32_t supported(int32_t disp_id, uint32_t feature_id);
 
   private:
+    LegacyMMController();
+
+    std::shared_ptr<void> openlib();
+
     typedef int32_t (*disp_api_init)(int32_t);
     typedef int32_t (*disp_api_get_color_balance_range)(int32_t, void*);
     typedef int32_t (*disp_api_set_color_balance)(int32_t, int32_t);
diff --git a/livedisplay/1.0/default/include/controller/SDMController.h b/livedisplay/1.0/default/include/controller/SDMController.h
index 2e634de..e44591a 100644
--- a/livedisplay/1.0/default/include/controller/SDMController.h
+++ b/livedisplay/1.0/default/include/controller/SDMController.h
@@ -28,9 +28,14 @@ namespace V1_0 {
 namespace implementation {
 
 class SDMController {
-  public:
+  private:
     SDMController();
 
+    std::shared_ptr<void> openlib();
+
+  public:
+    static SDMController& getInstance();
+
     int32_t init(uint64_t* hctx, uint32_t flags);
     int32_t deinit(uint64_t hctx, uint32_t flags);
     int32_t get_global_color_balance_range(uint64_t hctx, uint32_t disp_id, void* range);
diff --git a/livedisplay/1.0/default/include/impl/LegacyMM.h b/livedisplay/1.0/default/include/impl/LegacyMM.h
index f7bcc41..7484f41 100644
--- a/livedisplay/1.0/default/include/impl/LegacyMM.h
+++ b/livedisplay/1.0/default/include/impl/LegacyMM.h
@@ -25,13 +25,8 @@ namespace livedisplay {
 namespace V1_0 {
 namespace implementation {
 
-class LegacyMMController;
-
 class LegacyMM : public ColorBackend {
   public:
-    LegacyMM();
-    ~LegacyMM();
-
     virtual android::status_t setAdaptiveBacklightEnabled(bool /* enabled */) override {
         return android::NO_INIT;
     }
@@ -62,13 +57,14 @@ class LegacyMM : public ColorBackend {
     virtual HSIC getDefaultPictureAdjustment() override;
     virtual android::status_t setPictureAdjustment(const HSIC& hsic) override;
 
+    virtual android::status_t initialize() override;
+    virtual android::status_t deinitialize() override;
     virtual bool hasFeature(Feature feature) override;
 
   private:
     uint32_t getNumDisplayModes();
     android::sp<disp_mode> getDisplayModeById(int32_t id);
 
-    std::unique_ptr<LegacyMMController> mController;
     HSIC mDefaultPictureAdjustment;
 };
 
diff --git a/livedisplay/1.0/default/include/impl/SDM.h b/livedisplay/1.0/default/include/impl/SDM.h
index 805172c..b7fd02b 100644
--- a/livedisplay/1.0/default/include/impl/SDM.h
+++ b/livedisplay/1.0/default/include/impl/SDM.h
@@ -28,13 +28,8 @@ namespace livedisplay {
 namespace V1_0 {
 namespace implementation {
 
-class SDMController;
-
 class SDM : public ColorBackend {
   public:
-    SDM();
-    ~SDM();
-
     virtual android::status_t getDisplayModes(std::vector<android::sp<disp_mode>>& profiles) override;
     virtual android::sp<disp_mode> getCurrentDisplayMode() override;
     virtual android::sp<disp_mode> getDefaultDisplayMode() override;
@@ -66,6 +61,8 @@ class SDM : public ColorBackend {
     virtual HSIC getDefaultPictureAdjustment() override;
 
     virtual bool hasFeature(Feature f);
+    virtual android::status_t initialize();
+    virtual android::status_t deinitialize();
 
   private:
     android::status_t saveInitialDisplayMode();
@@ -77,7 +74,6 @@ class SDM : public ColorBackend {
     android::sp<disp_mode> getLocalSRGBMode();
     android::sp<disp_mode> getLocalDCIP3Mode();
 
-    std::unique_ptr<SDMController> mController;
     uint64_t mHandle;
     bool mFOSSEnabled;
     bool mCachedFOSSStatus;
diff --git a/livedisplay/1.0/default/service.cpp b/livedisplay/1.0/default/service.cpp
index 026c26c..b8f5cb5 100644
--- a/livedisplay/1.0/default/service.cpp
+++ b/livedisplay/1.0/default/service.cpp
@@ -39,14 +39,21 @@ using ::vendor::lineage::livedisplay::V1_0::implementation::Color;
 
 int main() {
     status_t status;
+    android::sp<IColor> service = nullptr;
+
     LOG(INFO) << "LiveDisplay HAL service is starting.";
 
     // The LiveDisplay HAL may communicate to other vendor components via /dev/vndbinder
     android::ProcessState::initWithDriver("/dev/vndbinder");
 
+    service = Color::getInstance();
+    if (service == nullptr) {
+        LOG(ERROR) << "Can not create an instance of LiveDisplay HAL Iface, exiting.";
+        goto shutdown;
+    }
+
     configureRpcThreadpool(1, true /*callerWillJoin*/);
 
-    android::sp<IColor> service = new Color();
     status = service->registerAsService();
     if (status != OK) {
         LOG(ERROR) << "Could not register service for LiveDisplay HAL Iface (" << status << ")";
diff --git a/livedisplay/1.0/default/src/Color.cpp b/livedisplay/1.0/default/src/Color.cpp
index 550099e..accd1d3 100644
--- a/livedisplay/1.0/default/src/Color.cpp
+++ b/livedisplay/1.0/default/src/Color.cpp
@@ -60,47 +60,51 @@ using ::android::OK;
 using ::android::sp;
 using ::android::status_t;
 
-Color::Color() : mFeatures(0), mConnected(false), mBackend(nullptr) {
-    connect();
+sp<Color> Color::sInstance = nullptr;
+
+Color::Color() : mConnected(false), mBackend(nullptr) {
+#if defined(COLOR_BACKEND_SDM)
+    mBackend = std::make_unique<SDM>();
+#elif defined(COLOR_BACKEND_LEGACYMM)
+    mBackend = std::make_unique<LegacyMM>();
+#endif
+    LOG(DEBUG) << "Loaded LiveDisplay native interface";
 }
 
 Color::~Color() {
-    disconnect();
+    reset();
 }
 
-void Color::disconnect() {
+void Color::reset() {
     if (mConnected) {
-        mBackend = nullptr;
+        mBackend->deinitialize();
     }
     mFeatures = 0;
     mConnected = false;
 }
 
-bool Color::check(Feature f) {
-    if (!mConnected) {
-        connect();
-    }
-
-    return (mFeatures & (uint32_t)f);
-}
-
 void Color::error(const char* msg) {
     if (msg != NULL) {
         LOG(ERROR) << msg;
     }
 
-    disconnect();
+    reset();
 }
 
-void Color::connect() {
-#if defined(COLOR_BACKEND_SDM)
-    mBackend.reset(new SDM());
-#elif defined(COLOR_BACKEND_LEGACYMM)
-    mBackend.reset(new LegacyMM());
-#endif
+bool Color::connect() {
+    if (mConnected) {
+        return true;
+    }
+
+    mFeatures = 0;
+
     if (mBackend == nullptr) {
+        return false;
+    }
+
+    if (mBackend->initialize() != OK) {
         LOG(ERROR) << "Failed to initialize backend!";
-        return;
+        return false;
     }
 
     for (uint32_t i = 1; i <= (uint32_t)Feature::MAX; i <<= 1) {
@@ -109,14 +113,20 @@ void Color::connect() {
             addFeature(f);
         }
     }
-
     mConnected = true;
+
+    return mFeatures > 0;
 }
 
-Return<Features> Color::getSupportedFeatures() {
-    if (!mConnected) {
-        connect();
+sp<Color> Color::getInstance() {
+    if (sInstance == nullptr) {
+        sInstance = new Color();
     }
+    return sInstance;
+}
+
+Return<Features> Color::getSupportedFeatures() {
+    connect();
     return mFeatures;
 }
 
-- 
2.17.1

