From a81c4b24c6412a28eefe18e73f220438acbb6334 Mon Sep 17 00:00:00 2001
From: Ethan Chen <intervigil@gmail.com>
Date: Sun, 29 Apr 2018 18:11:05 -0700
Subject: [PATCH 7/9] livedisplay: Port mm-disp implementation

Change-Id: Ib36ddfbbb920b720d6fce68c52cc063529c4bb9f
---
 livedisplay/1.0/default/Android.bp            |  11 +
 .../default/controller/LegacyMMController.cpp | 169 +++++++++
 livedisplay/1.0/default/impl/LegacyMM.cpp     | 348 ++++++++++++++++++
 .../include/controller/LegacyMMController.h   |  93 +++++
 .../1.0/default/include/impl/LegacyMM.h       |  78 ++++
 livedisplay/1.0/default/service.cpp           |   6 +-
 livedisplay/1.0/default/src/Color.cpp         |  16 +-
 ...ineage.livedisplay@1.0-service-legacymm.rc |   4 +
 8 files changed, 718 insertions(+), 7 deletions(-)
 create mode 100644 livedisplay/1.0/default/controller/LegacyMMController.cpp
 create mode 100644 livedisplay/1.0/default/impl/LegacyMM.cpp
 create mode 100644 livedisplay/1.0/default/include/controller/LegacyMMController.h
 create mode 100644 livedisplay/1.0/default/include/impl/LegacyMM.h
 create mode 100644 livedisplay/1.0/default/vendor.lineage.livedisplay@1.0-service-legacymm.rc

diff --git a/livedisplay/1.0/default/Android.bp b/livedisplay/1.0/default/Android.bp
index 39c95a4..4fef10e 100644
--- a/livedisplay/1.0/default/Android.bp
+++ b/livedisplay/1.0/default/Android.bp
@@ -35,6 +35,17 @@ cc_defaults {
     ],
 }
 
+cc_binary {
+    name: "vendor.lineage.livedisplay@1.0-service-legacymm",
+    init_rc: ["vendor.lineage.livedisplay@1.0-service-legacymm.rc"],
+    defaults: ["livedisplay_defaults"],
+    cflags: ["-DCOLOR_BACKEND_LEGACYMM"],
+    srcs: [
+        "impl/LegacyMM.cpp",
+        "controller/LegacyMMController.cpp",
+    ],
+}
+
 cc_binary {
     name: "vendor.lineage.livedisplay@1.0-service-sdm",
     init_rc: ["vendor.lineage.livedisplay@1.0-service-sdm.rc"],
diff --git a/livedisplay/1.0/default/controller/LegacyMMController.cpp b/livedisplay/1.0/default/controller/LegacyMMController.cpp
new file mode 100644
index 0000000..b1b5483
--- /dev/null
+++ b/livedisplay/1.0/default/controller/LegacyMMController.cpp
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// #define LOG_NDEBUG 0
+
+#define LOG_TAG "LiveDisplay-LegacyMM-Impl"
+
+#include "controller/LegacyMMController.h"
+
+#include <android-base/logging.h>
+
+#include <dlfcn.h>
+
+#define LOAD_SDM_FUNCTION(name) \
+    mFn_##name = loadFunction<disp_api_##name>(mHandle, "disp_api_" #name);
+
+#define CLOSE_SDM_FUNCTION(name) mFn_##name = nullptr;
+
+#define FOR_EACH_FUNCTION(MACRO)    \
+    MACRO(init)                     \
+    MACRO(get_color_balance_range)  \
+    MACRO(set_color_balance)        \
+    MACRO(get_color_balance)        \
+    MACRO(get_num_display_modes)    \
+    MACRO(get_display_modes)        \
+    MACRO(get_active_display_mode)  \
+    MACRO(set_active_display_mode)  \
+    MACRO(set_default_display_mode) \
+    MACRO(get_default_display_mode) \
+    MACRO(get_pa_range)             \
+    MACRO(get_pa_config)            \
+    MACRO(set_pa_config)            \
+    MACRO(supported)
+
+#define CONTROLLER_CHECK(function, ...)    \
+    if (mFn_##function == nullptr) {       \
+        return -1;                         \
+    }                                      \
+    int err = mFn_##function(__VA_ARGS__); \
+    if (err != 0) {                        \
+        return err;                        \
+    }                                      \
+    return 0;
+
+namespace {
+constexpr char kFilename[] = "libmm-disp-apis.so";
+template <typename Function>
+Function loadFunction(std::shared_ptr<void> handle, const char* name) {
+    void* fn = dlsym(handle.get(), name);
+    if (fn == nullptr) {
+        LOG(ERROR) << "loadFunction -- failed to load function " << name;
+    }
+    return reinterpret_cast<Function>(fn);
+}
+}  // anonymous namespace
+
+namespace vendor {
+namespace lineage {
+namespace livedisplay {
+namespace V1_0 {
+namespace implementation {
+
+LegacyMMController::LegacyMMController() {
+    mHandle = openlib();
+    if (mHandle != nullptr) {
+        FOR_EACH_FUNCTION(LOAD_SDM_FUNCTION)
+    }
+}
+
+std::shared_ptr<void> LegacyMMController::openlib() {
+    std::shared_ptr<void> handle(dlopen(kFilename, RTLD_NOW), [this](void* p) {
+        FOR_EACH_FUNCTION(CLOSE_SDM_FUNCTION)
+        if (p != nullptr) {
+            int err = dlclose(p);
+            p = nullptr;
+            if (err != 0) {
+                LOG(ERROR) << "DLCLOSE failed for " << kFilename;
+            }
+        }
+    });
+    if (handle == nullptr) {
+        LOG(ERROR) << "DLOPEN failed for " << kFilename << " (" << dlerror() << ")";
+        return nullptr;
+    }
+    return handle;
+}
+
+LegacyMMController& LegacyMMController::getInstance() {
+    static LegacyMMController instance{};
+    return instance;
+}
+
+int32_t LegacyMMController::init(int32_t initialize) {
+    CONTROLLER_CHECK(init, initialize);
+}
+
+int32_t LegacyMMController::get_color_balance_range(int32_t disp_id, void* range) {
+    CONTROLLER_CHECK(get_color_balance_range, disp_id, range);
+}
+
+int32_t LegacyMMController::set_color_balance(int32_t disp_id, int32_t warmness) {
+    CONTROLLER_CHECK(set_color_balance, disp_id, warmness);
+}
+
+int32_t LegacyMMController::get_color_balance(int32_t disp_id, int32_t* warmness) {
+    CONTROLLER_CHECK(get_color_balance, disp_id, warmness);
+}
+
+int32_t LegacyMMController::get_num_display_modes(int32_t disp_id, int32_t mode_type,
+                                                  uint32_t* mode_cnt) {
+    CONTROLLER_CHECK(get_num_display_modes, disp_id, mode_type, mode_cnt);
+}
+
+int32_t LegacyMMController::get_display_modes(int32_t disp_id, int32_t mode_type, void* modes,
+                                              int32_t mode_cnt) {
+    CONTROLLER_CHECK(get_display_modes, disp_id, mode_type, modes, mode_cnt);
+}
+
+int32_t LegacyMMController::get_active_display_mode(int32_t disp_id, int32_t* mode_id,
+                                                    uint32_t* mask) {
+    CONTROLLER_CHECK(get_active_display_mode, disp_id, mode_id, mask);
+}
+
+int32_t LegacyMMController::set_active_display_mode(int32_t disp_id, int32_t mode_id) {
+    CONTROLLER_CHECK(set_active_display_mode, disp_id, mode_id);
+}
+
+int32_t LegacyMMController::set_default_display_mode(int32_t disp_id, int32_t mode_id) {
+    CONTROLLER_CHECK(set_default_display_mode, disp_id, mode_id);
+}
+
+int32_t LegacyMMController::get_default_display_mode(int32_t disp_id, int32_t* mode_id) {
+    CONTROLLER_CHECK(get_default_display_mode, disp_id, mode_id);
+}
+
+int32_t LegacyMMController::get_pa_range(int32_t disp_id, void* range) {
+    CONTROLLER_CHECK(get_pa_range, disp_id, range);
+}
+
+int32_t LegacyMMController::get_pa_config(int32_t disp_id, void* cfg) {
+    CONTROLLER_CHECK(get_pa_config, disp_id, cfg);
+}
+
+int32_t LegacyMMController::set_pa_config(int32_t disp_id, void* cfg) {
+    CONTROLLER_CHECK(set_pa_config, disp_id, cfg);
+}
+
+int32_t LegacyMMController::supported(int32_t disp_id, uint32_t feature_id) {
+    CONTROLLER_CHECK(supported, disp_id, feature_id);
+}
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace livedisplay
+}  // namespace lineage
+}  // namespace vendor
diff --git a/livedisplay/1.0/default/impl/LegacyMM.cpp b/livedisplay/1.0/default/impl/LegacyMM.cpp
new file mode 100644
index 0000000..1fa2c57
--- /dev/null
+++ b/livedisplay/1.0/default/impl/LegacyMM.cpp
@@ -0,0 +1,348 @@
+/*
+** Copyright 2016, The CyanogenMod Project
+** Copyright (C) 2017-2018 The LineageOS Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+// #define LOG_NDEBUG 0
+
+#define LOG_TAG "LiveDisplay-LegacyMM"
+
+#include "impl/LegacyMM.h"
+
+#include "Utils.h"
+
+#include <android-base/logging.h>
+
+namespace {
+struct mm_pa_data {
+    int hue;
+    int saturation;
+    int intensity;
+    int contrast;
+    int saturationThreshold;
+};
+
+struct mm_pa_config {
+    int flags;
+    struct mm_pa_data data;
+};
+
+struct mm_pa_range {
+    struct mm_pa_data max;
+    struct mm_pa_data min;
+};
+
+struct mm_range {
+    int max;
+    int min;
+};
+}  // anonymous namespace
+
+namespace vendor {
+namespace lineage {
+namespace livedisplay {
+namespace V1_0 {
+namespace implementation {
+
+using android::BAD_VALUE;
+using android::NO_INIT;
+using android::OK;
+using android::sp;
+using android::status_t;
+
+status_t LegacyMM::getColorBalanceRange(Range& range) {
+    struct mm_range r;
+    memset(&r, 0, sizeof(struct mm_range));
+
+    status_t rc = LegacyMMController::getInstance().get_color_balance_range(0, &r);
+    if (rc == OK) {
+        range.min = r.min;
+        range.max = r.max;
+    }
+    return rc;
+}
+
+status_t LegacyMM::setColorBalance(int32_t balance) {
+    return LegacyMMController::getInstance().set_color_balance(0, balance);
+}
+
+int32_t LegacyMM::getColorBalance() {
+    int32_t value = 0;
+    if (LegacyMMController::getInstance().get_color_balance(0, &value) != 0) {
+        value = 0;
+    }
+    return value;
+}
+
+status_t LegacyMM::getDisplayModes(std::vector<sp<disp_mode>>& profiles) {
+    status_t rc = OK;
+
+    uint32_t count = getNumDisplayModes();
+
+    if (!count) {
+        return rc;
+    }
+
+    struct d_mode {
+        int id;
+        char* name;
+        uint32_t len;
+        int32_t type;
+        d_mode() : id(-1), len(128), type(0) {
+            name = new char[128];
+        }
+        ~d_mode() {
+            delete name;
+        }
+    };
+
+    d_mode tmp[count];
+
+    rc = LegacyMMController::getInstance().get_display_modes(0, 0, tmp, count);
+    if (rc == 0) {
+        for (uint32_t i = 0; i < count; i++) {
+            const sp<disp_mode> m = new disp_mode;
+            m->id = tmp[i].id;
+            m->name = tmp[i].name;
+            m->privFlags = 0;  // TODO: fix flag
+            profiles.push_back(m);
+        }
+    }
+
+    return rc;
+}
+
+status_t LegacyMM::setDisplayMode(int32_t modeID, bool makeDefault) {
+    auto currentMode = getCurrentDisplayMode();
+    if (currentMode != nullptr && currentMode->id == modeID) {
+        return OK;
+    }
+
+    auto mode = getDisplayModeById(modeID);
+    if (mode == nullptr) {
+        return BAD_VALUE;
+    }
+
+    if (LegacyMMController::getInstance().set_active_display_mode(0, modeID) != 0) {
+        return BAD_VALUE;
+    }
+
+    if (makeDefault && LegacyMMController::getInstance().set_default_display_mode(0, modeID) != 0) {
+        return BAD_VALUE;
+    }
+
+    HSIC tmp;
+    if (getPictureAdjustment(tmp) == OK) {
+        mDefaultPictureAdjustment = tmp;
+    }
+
+    return OK;
+}
+
+sp<disp_mode> LegacyMM::getCurrentDisplayMode() {
+    int32_t id = 0;
+    uint32_t mask = 0;
+
+    status_t rc = LegacyMMController::getInstance().get_active_display_mode(0, &id, &mask);
+    if (rc == OK && id >= 0) {
+        return getDisplayModeById(id);
+    }
+
+    return nullptr;
+}
+
+sp<disp_mode> LegacyMM::getDefaultDisplayMode() {
+    int32_t id = 0;
+
+    if (Utils::readLocalModeId(&id) == OK && id >= 0) {
+        return getDisplayModeById(id);
+    }
+    if (Utils::readInitialModeId(&id) == OK && id >= 0) {
+        return getDisplayModeById(id);
+    }
+
+    status_t rc = LegacyMMController::getInstance().get_default_display_mode(0, &id);
+    if (rc == OK && id >= 0) {
+        return getDisplayModeById(id);
+    }
+
+    return nullptr;
+}
+
+status_t LegacyMM::getPictureAdjustmentRanges(HSICRanges& ranges) {
+    struct mm_pa_range r;
+    memset(&r, 0, sizeof(struct mm_pa_range));
+
+    status_t rc = LegacyMMController::getInstance().get_pa_range(0, &r);
+    if (rc == OK) {
+        ranges.hue.min = r.min.hue;
+        ranges.hue.max = r.max.hue;
+        ranges.hue.step = 1;
+        ranges.saturation.min = r.min.saturation;
+        ranges.saturation.max = r.max.saturation;
+        ranges.saturation.step = 1;
+        ranges.intensity.min = r.min.intensity;
+        ranges.intensity.max = r.max.intensity;
+        ranges.intensity.step = 1;
+        ranges.contrast.min = r.min.contrast;
+        ranges.contrast.max = r.max.contrast;
+        ranges.contrast.step = 1;
+        ranges.saturationThreshold.min = r.min.saturationThreshold;
+        ranges.saturationThreshold.max = r.max.saturationThreshold;
+        ranges.saturationThreshold.step = 1;
+    }
+    return rc;
+}
+
+status_t LegacyMM::getPictureAdjustment(HSIC& hsic) {
+    struct mm_pa_config config;
+    memset(&config, 0, sizeof(struct mm_pa_config));
+
+    status_t rc = LegacyMMController::getInstance().get_pa_config(0, &config);
+    if (rc == OK) {
+        hsic.hue = config.data.hue;
+        hsic.saturation = config.data.saturation;
+        hsic.intensity = config.data.intensity;
+        hsic.contrast = config.data.contrast;
+        hsic.saturationThreshold = config.data.saturationThreshold;
+    }
+    return rc;
+}
+
+HSIC LegacyMM::getDefaultPictureAdjustment() {
+    return mDefaultPictureAdjustment;
+}
+
+status_t LegacyMM::setPictureAdjustment(const HSIC& hsic) {
+    struct mm_pa_config config;
+    memset(&config, 0, sizeof(struct mm_pa_config));
+
+    config.flags = 0x0F;  // lower 4 bits
+    config.data.hue = hsic.hue;
+    config.data.saturation = hsic.saturation;
+    config.data.intensity = hsic.intensity;
+    config.data.contrast = hsic.contrast;
+    config.data.saturationThreshold = hsic.saturationThreshold;
+
+    return LegacyMMController::getInstance().set_pa_config(0, &config);
+}
+
+status_t LegacyMM::initialize() {
+    status_t rc = NO_INIT;
+    rc = LegacyMMController::getInstance().init(0);
+    if (rc != OK) {
+        LOG(ERROR) << "%s: Failed to initialize LegacyMMController";
+        return rc;
+    }
+
+    if (hasFeature(Feature::DISPLAY_MODES)) {
+        int32_t id;
+        // Get the initial mode from Utils
+        rc = Utils::readInitialModeId(&id);
+        if (rc != OK || id < 0) {
+            // Get controller default mode and save it
+            rc = LegacyMMController::getInstance().get_default_display_mode(0, &id);
+            if (rc == OK && id >= 0) {
+                Utils::writeInitialModeId(id);
+            } else {
+                Utils::writeInitialModeId(0);
+            }
+        }
+
+        auto mode = getDefaultDisplayMode();
+        if (mode != nullptr) {
+            setDisplayMode(mode->id, false);
+        }
+    }
+    return OK;
+}
+
+status_t LegacyMM::deinitialize() {
+    status_t rc = NO_INIT;
+    rc = LegacyMMController::getInstance().init(1);
+    if (rc != OK) {
+        return rc;
+    }
+    return OK;
+}
+
+bool LegacyMM::hasFeature(Feature feature) {
+    uint32_t id;
+    switch (feature) {
+        case Feature::COLOR_BALANCE:
+            id = 0;
+            break;
+        case Feature::DISPLAY_MODES:
+            id = 1;
+            break;
+        case Feature::PICTURE_ADJUSTMENT:
+            id = 4;
+            break;
+        default:
+            return false;
+    }
+
+    if (LegacyMMController::getInstance().supported(0, id)) {
+        // display modes and color balance depend on each other
+        if (feature == Feature::DISPLAY_MODES || feature == Feature::COLOR_BALANCE) {
+            if (getNumDisplayModes() > 0) {
+                // make sure the range isn't zero
+                if (feature == Feature::COLOR_BALANCE) {
+                    Range r;
+                    if (getColorBalanceRange(r) == OK && isNonZero(r)) {
+                        return true;
+                    }
+                    return false;
+                }
+                return true;
+            }
+        }
+        if (feature == Feature::PICTURE_ADJUSTMENT) {
+            HSICRanges r;
+            if (getPictureAdjustmentRanges(r) == OK && r.isValid()) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+uint32_t LegacyMM::getNumDisplayModes() {
+    uint32_t count = 0;
+    if (LegacyMMController::getInstance().get_num_display_modes(0, 0, &count) != 0) {
+        count = 0;
+    }
+    return count;
+}
+
+sp<disp_mode> LegacyMM::getDisplayModeById(int32_t id) {
+    std::vector<sp<disp_mode>> profiles;
+    status_t rc = getDisplayModes(profiles);
+    if (rc == OK) {
+        for (const auto& mode : profiles) {
+            if (id == mode->id) {
+                return mode;
+            }
+        }
+    }
+
+    return nullptr;
+}
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace livedisplay
+}  // namespace lineage
+}  // namespace vendor
diff --git a/livedisplay/1.0/default/include/controller/LegacyMMController.h b/livedisplay/1.0/default/include/controller/LegacyMMController.h
new file mode 100644
index 0000000..48bb403
--- /dev/null
+++ b/livedisplay/1.0/default/include/controller/LegacyMMController.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2018 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VENDOR_LINEAGE_LIVEDISPLAY_V1_0_LEGACYMMCONTROLLER_H
+#define VENDOR_LINEAGE_LIVEDISPLAY_V1_0_LEGACYMMCONTROLLER_H
+
+#include <memory>
+
+#include <stdint.h>
+
+namespace vendor {
+namespace lineage {
+namespace livedisplay {
+namespace V1_0 {
+namespace implementation {
+
+class LegacyMMController {
+  public:
+    static LegacyMMController& getInstance();
+
+    int32_t init(int32_t init);
+    int32_t get_color_balance_range(int32_t disp_id, void* range);
+    int32_t set_color_balance(int32_t disp_id, int32_t warmness);
+    int32_t get_color_balance(int32_t disp_id, int32_t* warmness);
+    int32_t get_num_display_modes(int32_t disp_id, int32_t mode_type, uint32_t* mode_cnt);
+    int32_t get_display_modes(int32_t disp_id, int32_t mode_type, void* modes, int32_t mode_cnt);
+    int32_t get_active_display_mode(int32_t disp_id, int32_t* mode_id, uint32_t* mask);
+    int32_t set_active_display_mode(int32_t disp_id, int32_t mode_id);
+    int32_t set_default_display_mode(int32_t disp_id, int32_t mode_id);
+    int32_t get_default_display_mode(int32_t disp_id, int32_t* mode_id);
+    int32_t get_pa_range(int32_t disp_id, void* range);
+    int32_t get_pa_config(int32_t disp_id, void* cfg);
+    int32_t set_pa_config(int32_t disp_id, void* cfg);
+    int32_t supported(int32_t disp_id, uint32_t feature_id);
+
+  private:
+    LegacyMMController();
+
+    std::shared_ptr<void> openlib();
+
+    typedef int32_t (*disp_api_init)(int32_t);
+    typedef int32_t (*disp_api_get_color_balance_range)(int32_t, void*);
+    typedef int32_t (*disp_api_set_color_balance)(int32_t, int32_t);
+    typedef int32_t (*disp_api_get_color_balance)(int32_t, int32_t*);
+    typedef int32_t (*disp_api_get_num_display_modes)(int32_t, int32_t, uint32_t*);
+    typedef int32_t (*disp_api_get_display_modes)(int32_t, int32_t, void*, int32_t);
+    typedef int32_t (*disp_api_get_active_display_mode)(int32_t, int32_t*, uint32_t*);
+    typedef int32_t (*disp_api_set_active_display_mode)(int32_t, int32_t);
+    typedef int32_t (*disp_api_set_default_display_mode)(int32_t, int32_t);
+    typedef int32_t (*disp_api_get_default_display_mode)(int32_t, int32_t*);
+    typedef int32_t (*disp_api_get_pa_range)(int32_t, void*);
+    typedef int32_t (*disp_api_get_pa_config)(int32_t, void*);
+    typedef int32_t (*disp_api_set_pa_config)(int32_t, void*);
+    typedef int32_t (*disp_api_supported)(int32_t, uint32_t);
+
+    std::shared_ptr<void> mHandle;
+
+    disp_api_init mFn_init;
+    disp_api_get_color_balance_range mFn_get_color_balance_range;
+    disp_api_set_color_balance mFn_set_color_balance;
+    disp_api_get_color_balance mFn_get_color_balance;
+    disp_api_get_num_display_modes mFn_get_num_display_modes;
+    disp_api_get_display_modes mFn_get_display_modes;
+    disp_api_get_active_display_mode mFn_get_active_display_mode;
+    disp_api_set_active_display_mode mFn_set_active_display_mode;
+    disp_api_set_default_display_mode mFn_set_default_display_mode;
+    disp_api_get_default_display_mode mFn_get_default_display_mode;
+    disp_api_get_pa_range mFn_get_pa_range;
+    disp_api_get_pa_config mFn_get_pa_config;
+    disp_api_set_pa_config mFn_set_pa_config;
+    disp_api_supported mFn_supported;
+};
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace livedisplay
+}  // namespace lineage
+}  // namespace vendor
+
+#endif  // VENDOR_LINEAGE_LIVEDISPLAY_V1_0_LEGACYMMCONTROLLER_H
diff --git a/livedisplay/1.0/default/include/impl/LegacyMM.h b/livedisplay/1.0/default/include/impl/LegacyMM.h
new file mode 100644
index 0000000..2c9800f
--- /dev/null
+++ b/livedisplay/1.0/default/include/impl/LegacyMM.h
@@ -0,0 +1,78 @@
+/*
+** Copyright 2016, The CyanogenMod Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef VENDOR_LINEAGE_LIVEDISPLAY_V1_0_LEGACYMM_H
+#define VENDOR_LINEAGE_LIVEDISPLAY_V1_0_LEGACYMM_H
+
+#include "ColorBackend.h"
+#include "controller/LegacyMMController.h"
+
+namespace vendor {
+namespace lineage {
+namespace livedisplay {
+namespace V1_0 {
+namespace implementation {
+
+class LegacyMM : public ColorBackend {
+  public:
+    virtual android::status_t setAdaptiveBacklightEnabled(bool /* enabled */) override {
+        return android::NO_INIT;
+    }
+
+    virtual bool isAdaptiveBacklightEnabled() override {
+        return false;
+    }
+
+    virtual android::status_t setOutdoorModeEnabled(bool /* enabled */) override {
+        return android::NO_INIT;
+    }
+
+    virtual bool isOutdoorModeEnabled() override {
+        return false;
+    }
+
+    virtual android::status_t getColorBalanceRange(Range& range) override;
+    virtual android::status_t setColorBalance(int32_t balance) override;
+    virtual int32_t getColorBalance() override;
+
+    virtual android::status_t getDisplayModes(std::vector<android::sp<disp_mode>>& profiles) override;
+    virtual android::status_t setDisplayMode(int32_t modeID, bool makeDefault) override;
+    virtual android::sp<disp_mode> getCurrentDisplayMode() override;
+    virtual android::sp<disp_mode> getDefaultDisplayMode() override;
+
+    virtual android::status_t getPictureAdjustmentRanges(HSICRanges& ranges) override;
+    virtual android::status_t getPictureAdjustment(HSIC& hsic) override;
+    virtual HSIC getDefaultPictureAdjustment() override;
+    virtual android::status_t setPictureAdjustment(const HSIC& hsic) override;
+
+    virtual android::status_t initialize() override;
+    virtual android::status_t deinitialize() override;
+    virtual bool hasFeature(Feature feature) override;
+
+  private:
+    uint32_t getNumDisplayModes();
+    android::sp<disp_mode> getDisplayModeById(int32_t id);
+
+    HSIC mDefaultPictureAdjustment;
+};
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace livedisplay
+}  // namespace lineage
+}  // namespace vendor
+
+#endif  // VENDOR_LINEAGE_LIVEDISPLAY_V1_0_LEGACYMM_H
diff --git a/livedisplay/1.0/default/service.cpp b/livedisplay/1.0/default/service.cpp
index 1ce6eb6..026c26c 100644
--- a/livedisplay/1.0/default/service.cpp
+++ b/livedisplay/1.0/default/service.cpp
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
-#ifdef COLOR_BACKEND_SDM
+#if defined(COLOR_BACKEND_SDM)
 #define LOG_TAG "vendor.lineage.livedisplay@1.0-service-sdm"
+#elif defined(COLOR_BACKEND_LEGACYMM)
+#define LOG_TAG "vendor.lineage.livedisplay@1.0-service-legacymm"
 #else
 #error "Color backend undefined!"
 #endif
@@ -53,7 +55,7 @@ int main() {
 
     LOG(INFO) << "LiveDisplay HAL service is ready.";
     joinRpcThreadpool();
-    // Should not pass this line
+// Should not pass this line
 
 shutdown:
     // In normal operation, we don't expect the thread pool to exit
diff --git a/livedisplay/1.0/default/src/Color.cpp b/livedisplay/1.0/default/src/Color.cpp
index 6ef0fdf..77ecae1 100644
--- a/livedisplay/1.0/default/src/Color.cpp
+++ b/livedisplay/1.0/default/src/Color.cpp
@@ -20,10 +20,11 @@
 
 #include "Color.h"
 
-#ifdef COLOR_BACKEND_SDM
+#include "ColorBackend.h"
+#if defined(COLOR_BACKEND_SDM)
 #include "impl/SDM.h"
-#else
-#error "Color backend undefined!"
+#elif defined(COLOR_BACKEND_LEGACYMM)
+#include "impl/LegacyMM.h"
 #endif
 
 namespace {
@@ -54,8 +55,13 @@ namespace implementation {
 using ::android::NO_INIT;
 using ::android::OK;
 
-Color::Color() : mFeatures(0), mConnected(false), mBackend(nullptr) {
-    connect();
+Color::Color() : mConnected(false), mBackend(nullptr) {
+#if defined(COLOR_BACKEND_SDM)
+    mBackend = std::make_unique<SDM>();
+#elif defined(COLOR_BACKEND_LEGACYMM)
+    mBackend = std::make_unique<LegacyMM>();
+#endif
+    LOG(DEBUG) << "Loaded LiveDisplay native interface";
 }
 
 Color::~Color() {
diff --git a/livedisplay/1.0/default/vendor.lineage.livedisplay@1.0-service-legacymm.rc b/livedisplay/1.0/default/vendor.lineage.livedisplay@1.0-service-legacymm.rc
new file mode 100644
index 0000000..4cc81ca
--- /dev/null
+++ b/livedisplay/1.0/default/vendor.lineage.livedisplay@1.0-service-legacymm.rc
@@ -0,0 +1,4 @@
+service livedisplay-hal-1-0 /vendor/bin/hw/vendor.lineage.livedisplay@1.0-service-legacymm
+    class hal
+    user system
+    group system
-- 
2.17.0

