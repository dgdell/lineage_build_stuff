From 79d25d5c559f725415facdbe35b9f408e461f6f9 Mon Sep 17 00:00:00 2001
From: Paul Keith <javelinanddart@gmail.com>
Date: Sat, 31 Mar 2018 09:59:44 +0200
Subject: [PATCH 01/24] wacom: Follow-up from gestures patch

* Add a macro to convert keycode to gesture bit
* Use unsigned types for bitmask and keycode
* Don't store keycode in struct, return it
* Use s16 for x and y coords, matching last_[x/y]
* Use s64 for dt, which is what ktime_to_ms returns

Change-Id: I1e7be0d1f42f3f96b6f3f47b453190a0ea7819b4
Signed-off-by: Paul Keith <javelinanddart@gmail.com>
---
 .../input/touchscreen/wacom/wacom_i2c_func.c  | 34 ++++++++-----------
 include/linux/wacom_i2c.h                     |  8 ++---
 2 files changed, 19 insertions(+), 23 deletions(-)

diff --git a/drivers/input/touchscreen/wacom/wacom_i2c_func.c b/drivers/input/touchscreen/wacom/wacom_i2c_func.c
index 782c8334e48..f9250eeba00 100644
--- a/drivers/input/touchscreen/wacom/wacom_i2c_func.c
+++ b/drivers/input/touchscreen/wacom/wacom_i2c_func.c
@@ -907,28 +907,27 @@ void wacom_i2c_softkey(struct wacom_i2c *wac_i2c, s16 key, s16 pressed)
 }
 #endif
 
-static void handle_gestures(int x, int y, ktime_t end, struct wacom_i2c *wac_i2c)
+static u16 compute_gesture(s16 x, s16 y, ktime_t end, struct wacom_i2c *wac_i2c)
 {
-	int dx = x - wac_i2c->gesture_start_x;
-	int dy = y - wac_i2c->gesture_start_y;
-	int dt = ktime_to_ms(ktime_sub(end, wac_i2c->gesture_start_time));
+	s32 dx = x - wac_i2c->gesture_start_x;
+	s32 dy = y - wac_i2c->gesture_start_y;
+	s64 dt = ktime_to_ms(ktime_sub(end, wac_i2c->gesture_start_time));
 
 	if (abs(dy) > abs(dx)) {
 		if (abs(dy) > MIN_GEST_DIST) {
-			wac_i2c->gesture_key = dy < 0 ? KEY_PEN_DTU : KEY_PEN_UTD;
-			return;
+			return dy < 0 ? KEY_PEN_DTU : KEY_PEN_UTD;
 		}
 	} else {
 		if (abs(dx) > MIN_GEST_DIST) {
-			wac_i2c->gesture_key = dx < 0 ? KEY_PEN_RTL : KEY_PEN_LTR;
-			return;
+			return dx < 0 ? KEY_PEN_RTL : KEY_PEN_LTR;
 		}
 	}
 
 	if (dt >= LONG_PRESS_TIME) {
-		wac_i2c->gesture_key = KEY_PEN_LP;
-		return;
+		return KEY_PEN_LP;
 	}
+
+	return 0;
 }
 
 int wacom_i2c_coord(struct wacom_i2c *wac_i2c)
@@ -940,6 +939,7 @@ int wacom_i2c_coord(struct wacom_i2c *wac_i2c)
 	static s16 x, y, pressure;
 	static s16 tmp;
 	int rdy = 0;
+	u16 key;
 
 #if defined(WACOM_USE_GAIN)
 	u8 gain = 0;
@@ -1166,7 +1166,6 @@ int wacom_i2c_coord(struct wacom_i2c *wac_i2c)
 				dev_info(&wac_i2c->client->dev,
 						"%s: side on\n",
 						__func__);
-				wac_i2c->gesture_key = -1;
 				wac_i2c->gesture_start_x = x;
 				wac_i2c->gesture_start_y = y;
 				wac_i2c->gesture_start_time = ktime_get();
@@ -1174,15 +1173,12 @@ int wacom_i2c_coord(struct wacom_i2c *wac_i2c)
 				dev_info(&wac_i2c->client->dev,
 						"%s: side off\n",
 						__func__);
-				handle_gestures(x, y, ktime_get(), wac_i2c);
-				if (wac_i2c->gesture_key > -1 &&
-						(wac_i2c->enabled_gestures &
-						(1 << (wac_i2c->gesture_key - 0x2f1)))) {
-					input_report_key(wac_i2c->input_dev,
-							wac_i2c->gesture_key, 1);
+				key = compute_gesture(x, y, ktime_get(), wac_i2c);
+				if (key && (wac_i2c->enabled_gestures
+						& GEST_KEY2BIT(key))) {
+					input_report_key(wac_i2c->input_dev, key, 1);
 					input_sync(wac_i2c->input_dev);
-					input_report_key(wac_i2c->input_dev,
-							wac_i2c->gesture_key, 0);
+					input_report_key(wac_i2c->input_dev, key, 0);
 					input_sync(wac_i2c->input_dev);
 				}
 			}
diff --git a/include/linux/wacom_i2c.h b/include/linux/wacom_i2c.h
index cf20b6bb051..b3f1e364603 100644
--- a/include/linux/wacom_i2c.h
+++ b/include/linux/wacom_i2c.h
@@ -217,6 +217,7 @@ struct wacom_g5_callbacks {
 
 #define LONG_PRESS_TIME 500
 #define MIN_GEST_DIST 384
+#define GEST_KEY2BIT(x) (1 << (x - 0x2f1))
 
 /*Parameters for i2c driver*/
 struct wacom_i2c {
@@ -306,10 +307,9 @@ struct wacom_i2c {
 #endif
 	bool enabled;
 
-	int enabled_gestures;
-	int gesture_key;
-	int gesture_start_x;
-	int gesture_start_y;
+	u8 enabled_gestures;
+	s16 gesture_start_x;
+	s16 gesture_start_y;
 	ktime_t gesture_start_time;
 };
 
-- 
2.17.0

