From 0b9d5bbd5083b08b2863684f8f01d9b13ec71c27 Mon Sep 17 00:00:00 2001
From: Tharun Kumar Merugu <mtharu@codeaurora.org>
Date: Tue, 30 Jan 2018 15:43:36 +0530
Subject: [PATCH 27/52] msm: ADSPRPC: Use ID in response to get context pointer

Send context ID in rpc header instead of context pointer.
Validate context ID received in response and get context pointer.

Bug: 74237782
Change-Id: I9cfd10d0c1b25c3085b8e15c7ca1c8ff214bf10d
Acked-by: Viswanatham Paduchuri <vpaduchu@qti.qualcomm.com>
Signed-off-by: Tharun Kumar Merugu <mtharu@codeaurora.org>
Signed-off-by: Steve Pfetsch <spfetsch@google.com>
[haggertk: Backport to 3.4/msm8974]
CVE-2018-3597
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 drivers/char/adsprpc.c        | 71 +++++++++++++++++++++++++++++++++--
 drivers/char/adsprpc_shared.h |  4 +-
 2 files changed, 69 insertions(+), 6 deletions(-)

diff --git a/drivers/char/adsprpc.c b/drivers/char/adsprpc.c
index c9c43016a71..3e5b6b8ca4a 100644
--- a/drivers/char/adsprpc.c
+++ b/drivers/char/adsprpc.c
@@ -57,6 +57,9 @@
 				up_read(&current->mm->mmap_sem);\
 		} while (0)
 
+#define FASTRPC_CTX_MAGIC (0xbeeddeed)
+#define FASTRPC_CTX_MAX (256)
+#define FASTRPC_CTXID_MASK (0xFF0)
 
 #define IS_CACHE_ALIGNED(x) (((x) & ((L1_CACHE_BYTES)-1)) == 0)
 
@@ -86,6 +89,13 @@ static inline uint32_t buf_page_size(uint32_t size)
 	return sz > PAGE_SIZE ? sz : PAGE_SIZE;
 }
 
+static inline uint64_t ptr_to_uint64(void *ptr)
+{
+	uint64_t addr = (uint64_t)((uintptr_t)ptr);
+
+	return addr;
+}
+
 static inline int buf_get_pages(void *addr, int sz, int nr_pages, int access,
 				  struct smq_phy_page *pages, int nr_elems)
 {
@@ -153,6 +163,8 @@ struct smq_invoke_ctx {
 	int nbufs;
 	bool smmu;
 	uint32_t sc;
+	unsigned int magic;
+	uint64_t ctxid;
 };
 
 struct smq_context_list {
@@ -187,6 +199,8 @@ struct fastrpc_apps {
 	spinlock_t wrlock;
 	spinlock_t hlock;
 	struct hlist_head htbl[RPC_HASH_SZ];
+	spinlock_t ctxlock;
+	struct smq_invoke_ctx *ctxtable[FASTRPC_CTX_MAX];
 };
 
 struct fastrpc_mmap {
@@ -362,9 +376,10 @@ static int context_alloc(struct fastrpc_apps *me, uint32_t kernel,
 				int cid,
 				struct smq_invoke_ctx **po)
 {
-	int err = 0, bufs, size = 0;
+	int err = 0, bufs, ii, size = 0;
 	struct smq_invoke_ctx *ctx = 0;
 	struct smq_context_list *clst = &me->clst;
+
 	struct fastrpc_ioctl_invoke *invoke = &invokefd->inv;
 
 	bufs = REMOTE_SCALARS_INBUFS(invoke->sc) +
@@ -411,10 +426,26 @@ static int context_alloc(struct fastrpc_apps *me, uint32_t kernel,
 	ctx->pid = current->pid;
 	ctx->apps = me;
 	init_completion(&ctx->work);
+	ctx->magic = FASTRPC_CTX_MAGIC;
 	spin_lock(&clst->hlock);
 	hlist_add_head(&ctx->hn, &clst->pending);
 	spin_unlock(&clst->hlock);
 
+	spin_lock(&me->ctxlock);
+	for (ii = 0; ii < FASTRPC_CTX_MAX; ii++) {
+		if (!me->ctxtable[ii]) {
+			me->ctxtable[ii] = ctx;
+			ctx->ctxid = (ptr_to_uint64(ctx) & ~0xFFF)|(ii << 4);
+			break;
+		}
+	}
+	spin_unlock(&me->ctxlock);
+	VERIFY(err, ii < FASTRPC_CTX_MAX);
+	if (err) {
+		pr_err("adsprpc: out of context memory\n");
+		goto bail;
+	}
+
 	*po = ctx;
 bail:
 	if(ctx && err)
@@ -438,6 +469,7 @@ static void context_free(struct smq_invoke_ctx *ctx, bool lock)
 	struct smq_context_list *clst = &ctx->apps->clst;
 	struct fastrpc_apps *apps = ctx->apps; 
 	struct fastrpc_buf *b;
+	struct fastrpc_apps *me = &gfa;
 	int i, bufs;
 	if (ctx->smmu) {
 		bufs = REMOTE_SCALARS_INBUFS(ctx->sc) + REMOTE_SCALARS_OUTBUFS(ctx->sc);
@@ -457,6 +489,17 @@ static void context_free(struct smq_invoke_ctx *ctx, bool lock)
 		free_mem(b, ctx->cid);
 	
 	kfree(ctx->abufs);
+	ctx->magic = 0;
+	ctx->ctxid = 0;
+
+	spin_lock(&me->ctxlock);
+	for (i = 0; i < FASTRPC_CTX_MAX; i++) {
+		if (me->ctxtable[i] == ctx) {
+			me->ctxtable[i] = NULL;
+			break;
+		}
+	}
+	spin_unlock(&me->ctxlock);
 	if (ctx->dev) {
 		add_dev(apps, ctx->dev);
 		if (ctx->obuf.handle != ctx->dev->buf.handle)
@@ -769,7 +812,7 @@ static int fastrpc_invoke_send(struct fastrpc_apps *me,
 	msg.tid = current->pid;
 	if (kernel)
 		msg.pid = 0;
-	msg.invoke.header.ctx = ctx;
+	msg.invoke.header.ctx = ctx->ctxid;
 	msg.invoke.header.handle = handle;
 	msg.invoke.header.sc = sc;
 	msg.invoke.page.addr = buf->phys;
@@ -799,8 +842,9 @@ static void fastrpc_deinit(void)
 static void fastrpc_read_handler(int cid)
 {
 	struct fastrpc_apps *me = &gfa;
-	struct smq_invoke_rsp rsp;
+	struct smq_invoke_rsp rsp = {0};
 	int err = 0;
+	uint32_t index;
 
 	do {
 		VERIFY(err, sizeof(rsp) == smd_read_from_cb(
@@ -808,9 +852,27 @@ static void fastrpc_read_handler(int cid)
 							&rsp, sizeof(rsp)));
 		if (err)
 			goto bail;
-		context_notify_user(rsp.ctx, rsp.retval);
+
+		index = (uint32_t)((rsp.ctx & FASTRPC_CTXID_MASK) >> 4);
+		VERIFY(err, index < FASTRPC_CTX_MAX);
+		if (err)
+			goto bail;
+
+		VERIFY(err, !IS_ERR_OR_NULL(me->ctxtable[index]));
+		if (err)
+			goto bail;
+
+		VERIFY(err, ((me->ctxtable[index]->ctxid == (rsp.ctx)) &&
+			me->ctxtable[index]->magic == FASTRPC_CTX_MAGIC));
+		if (err)
+			goto bail;
+
+		context_notify_user(me->ctxtable[index], rsp.retval);
 	} while (!err);
  bail:
+	if (err)
+		pr_err("adsprpc: invalid response or context\n");
+
 	return;
 }
 
@@ -842,6 +904,7 @@ static int fastrpc_init(void)
 
 	spin_lock_init(&me->hlock);
 	spin_lock_init(&me->wrlock);
+	spin_lock_init(&me->ctxlock);
 	mutex_init(&me->smd_mutex);
 	context_list_ctor(&me->clst);
 	for (i = 0; i < RPC_HASH_SZ; ++i)
diff --git a/drivers/char/adsprpc_shared.h b/drivers/char/adsprpc_shared.h
index f5d7450dd76..1eecf28e507 100644
--- a/drivers/char/adsprpc_shared.h
+++ b/drivers/char/adsprpc_shared.h
@@ -122,7 +122,7 @@ struct fastrpc_ioctl_mmap {
 };
 
 struct smq_null_invoke {
-	struct smq_invoke_ctx *ctx; /* invoke caller context */
+	uint64_t ctx;		    /* invoke caller context */
 	uint32_t handle;	    /* handle to invoke */
 	uint32_t sc;		    /* scalars structure describing the data */
 };
@@ -149,7 +149,7 @@ struct smq_msg {
 };
 
 struct smq_invoke_rsp {
-	struct smq_invoke_ctx *ctx;  /* invoke caller context */
+	uint64_t ctx;            /* invoke caller context */
 	int retval;	             /* invoke return value */
 };
 
-- 
2.17.1

