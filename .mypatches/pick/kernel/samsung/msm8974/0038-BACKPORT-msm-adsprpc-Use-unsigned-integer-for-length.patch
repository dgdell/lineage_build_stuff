From cfad504fcb01d3d03c4032ea24dbc473704f7d4b Mon Sep 17 00:00:00 2001
From: Dennis Cagle <dcagle@codeaurora.org>
Date: Fri, 13 Apr 2018 11:49:03 -0700
Subject: [PATCH 38/60] BACKPORT: msm: adsprpc: Use unsigned integer for length
 values

As the length datatype is signed, an attacker can both overflow
the calculation or supply a negative number to trick the check
into returning an chosen chunk. This can have undesired
consequences. Always use unsigned integer types for length
values.

Change-Id: Ifde2f0d35129014b976507f7723a319c53fabddf
Acked-by: Thyagarajan Venkatanarayanan <venkatan@qti.qualcomm.com>
Signed-off-by: Tharun Kumar Merugu <mtharu@codeaurora.org>
Bug: 63165135
CRs-Fixed: 2139538
Signed-off-by: Dennis Cagle <dcagle@codeaurora.org>
(cherry picked from commit c29e11c774b3c59660c1c599b73b7fabf1492d43)
Signed-off-by: David Lin <dtwlin@google.com>
CVE-2018-3586
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
---
 drivers/char/adsprpc.c        | 64 ++++++++++++++++++-----------------
 drivers/char/adsprpc_shared.h | 15 ++++----
 2 files changed, 41 insertions(+), 38 deletions(-)

diff --git a/drivers/char/adsprpc.c b/drivers/char/adsprpc.c
index 33d22ced1d5..950230e1b6b 100644
--- a/drivers/char/adsprpc.c
+++ b/drivers/char/adsprpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2014, 2018 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -72,7 +72,7 @@ static inline uint32_t buf_page_offset(void *buf)
 	return offset;
 }
 
-static inline int buf_num_pages(void *buf, int len)
+static inline int buf_num_pages(void *buf, size_t len)
 {
 	uint32_t start = buf_page_start(buf) >> PAGE_SHIFT;
 	uint32_t end = (((uint32_t) buf + len - 1) & PAGE_MASK) >> PAGE_SHIFT;
@@ -130,7 +130,7 @@ struct fastrpc_buf {
 	struct ion_handle *handle;
 	void *virt;
 	ion_phys_addr_t phys;
-	int size;
+	size_t size;
 	int used;
 };
 
@@ -196,7 +196,7 @@ struct fastrpc_mmap {
 	ion_phys_addr_t phys;
 	uint32_t vaddrin;
 	uint32_t vaddrout;
-	int size;
+	size_t size;
 };
 
 struct file_data {
@@ -243,10 +243,10 @@ static void free_mem(struct fastrpc_buf *buf, int cid)
 		}
 		if (!IS_ERR_OR_NULL(buf->virt)) {
 			ion_unmap_kernel(me->iclient, buf->handle);
-			buf->virt = 0;
+			buf->virt = NULL;
 		}
 		ion_free(me->iclient, buf->handle);
-		buf->handle = 0;
+		buf->handle = NULL;
 	}
 }
 
@@ -261,11 +261,11 @@ static void free_map(struct fastrpc_mmap *map, int cid)
 		}
 		if (!IS_ERR_OR_NULL(map->virt)) {
 			ion_unmap_kernel(me->iclient, map->handle);
-			map->virt = 0;
+			map->virt = NULL;
 		}
 		ion_free(me->iclient, map->handle);
 	}
-	map->handle = 0;
+	map->handle = NULL;
 }
 
 static int alloc_mem(struct fastrpc_buf *buf, int cid)
@@ -276,8 +276,8 @@ static int alloc_mem(struct fastrpc_buf *buf, int cid)
 	int err = 0;
 	unsigned int heap;
 	unsigned long len;
-	buf->handle = 0;
-	buf->virt = 0;
+	buf->handle = NULL;
+	buf->virt = NULL;
 	buf->phys = 0;
 	heap = me->channel[cid].smmu.enabled ? ION_HEAP(ION_IOMMU_HEAP_ID) :
 		ION_HEAP(ION_ADSP_HEAP_ID) | ION_HEAP(ION_AUDIO_HEAP_ID);
@@ -318,7 +318,7 @@ static void context_list_ctor(struct smq_context_list *me)
 static void context_free(struct smq_invoke_ctx *ctx, bool lock);
 
 static void context_list_dtor(struct fastrpc_apps *me, struct smq_context_list *clst) {
-	struct smq_invoke_ctx *ictx = 0;
+	struct smq_invoke_ctx *ictx = NULL;
 	struct hlist_node *pos, *n;
 	spin_lock(&clst->hlock);
 	hlist_for_each_entry_safe(ictx, pos, n, &clst->interrupted, hn) {
@@ -335,7 +335,7 @@ static int context_restore_interrupted(struct fastrpc_apps *me,
 				int cid, struct smq_invoke_ctx **po)
 {
 	int err = 0;
-	struct smq_invoke_ctx *ctx = 0, *ictx = 0;
+	struct smq_invoke_ctx *ctx = NULL, *ictx = NULL;
 	struct hlist_node *pos, *n;
 	struct fastrpc_ioctl_invoke *invoke = &invokefd->inv;
 	spin_lock(&me->clst.hlock);
@@ -364,7 +364,7 @@ static int context_alloc(struct fastrpc_apps *me, uint32_t kernel,
 				struct smq_invoke_ctx **po)
 {
 	int err = 0, bufs, size = 0;
-	struct smq_invoke_ctx *ctx = 0;
+	struct smq_invoke_ctx *ctx = NULL;
 	struct smq_context_list *clst = &me->clst;
 	struct fastrpc_ioctl_invoke *invoke = &invokefd->inv;
 
@@ -377,7 +377,7 @@ static int context_alloc(struct fastrpc_apps *me, uint32_t kernel,
 				bufs * sizeof(*ctx->handles);
 	}
 
-	VERIFY(err, 0 != (ctx = kzalloc(sizeof(*ctx) + size, GFP_KERNEL)));
+	VERIFY(err, NULL != (ctx = kzalloc(sizeof(*ctx) + size, GFP_KERNEL)));
 	if (err)
 		goto bail;
 
@@ -481,7 +481,7 @@ static void context_notify_user(struct smq_invoke_ctx *me, int retval)
 
 static void context_notify_all_users(struct smq_context_list *me, int cid)
 {
-	struct smq_invoke_ctx *ictx = 0;
+	struct smq_invoke_ctx *ictx = NULL;
 	struct hlist_node *pos, *n;
 	spin_lock(&me->hlock);
 	hlist_for_each_entry_safe(ictx, pos, n, &me->pending, hn) {
@@ -503,7 +503,8 @@ static int get_page_list(uint32_t kernel, uint32_t sc, remote_arg_t *pra,
 {
 	struct smq_phy_page *pgstart, *pages;
 	struct smq_invoke_buf *list;
-	int i, rlen, err = 0;
+	size_t rlen;
+	int i, err = 0;
 	int inbufs = REMOTE_SCALARS_INBUFS(sc);
 	int outbufs = REMOTE_SCALARS_OUTBUFS(sc);
 
@@ -527,7 +528,7 @@ static int get_page_list(uint32_t kernel, uint32_t sc, remote_arg_t *pra,
 	for (i = 0; i < inbufs + outbufs; ++i) {
 		void *buf;
 		int num;
-		ssize_t len;
+		size_t len;
 
 		list[i].num = 0;
 		list[i].pgidx = 0;
@@ -579,10 +580,11 @@ static int get_args(uint32_t kernel, uint32_t sc, remote_arg_t *pra,
 {
 	struct fastrpc_apps *me = &gfa;
 	struct smq_invoke_buf *list;
-	struct fastrpc_buf *pbuf = ibuf, *obufs = 0;
+	struct fastrpc_buf *pbuf = ibuf, *obufs = NULL;
 	struct smq_phy_page *pages;
 	void *args;
-	int i, rlen, size, used, inh, bufs = 0, err = 0;
+	size_t rlen, used, size;
+	int i, inh, bufs = 0, err = 0;
 	int inbufs = REMOTE_SCALARS_INBUFS(sc);
 	int outbufs = REMOTE_SCALARS_OUTBUFS(sc);
 	unsigned long len;
@@ -889,7 +891,7 @@ static void free_dev(struct fastrpc_device *dev, int cid)
 static int alloc_dev(struct fastrpc_device **dev, int cid)
 {
 	int err = 0;
-	struct fastrpc_device *fd = 0;
+	struct fastrpc_device *fd = NULL;
 
 	VERIFY(err, 0 != try_module_get(THIS_MODULE));
 	if (err)
@@ -917,7 +919,7 @@ static int get_dev(struct fastrpc_apps *me, int cid,
 			struct fastrpc_device **rdev)
 {
 	struct hlist_head *head;
-	struct fastrpc_device *dev = 0, *devfree = 0;
+	struct fastrpc_device *dev = NULL, *devfree = NULL;
 	struct hlist_node *pos, *n;
 	uint32_t h = hash_32(current->tgid, RPC_HASH_BITS);
 	int err = 0;
@@ -962,7 +964,7 @@ static int fastrpc_internal_invoke(struct fastrpc_apps *me, uint32_t mode,
 			uint32_t kernel, struct fastrpc_ioctl_invoke_fd *invokefd,
 			int cid)
 {
-	struct smq_invoke_ctx *ctx = 0;
+	struct smq_invoke_ctx *ctx = NULL;
 	struct fastrpc_ioctl_invoke *invoke = &invokefd->inv;
 	int interrupted = 0;
 	int err = 0;
@@ -1129,7 +1131,7 @@ static int fastrpc_munmap_on_dsp(struct fastrpc_apps *me,
 	struct {
 		int pid;
 		uint32_t vaddrout;
-		int size;
+		size_t size;
 	} inargs;
 
 	inargs.pid = current->tgid;
@@ -1185,8 +1187,8 @@ static int fastrpc_internal_mmap(struct fastrpc_apps *me,
 				 struct fastrpc_ioctl_mmap *mmap)
 {
 	struct ion_client *clnt = gfa.iclient;
-	struct fastrpc_mmap *map = 0;
-	struct smq_phy_page *pages = 0;
+	struct fastrpc_mmap *map = NULL;
+	struct smq_phy_page *pages = NULL;
 	struct ion_handle *handles;
 	void *buf;
 	unsigned long len;
@@ -1261,7 +1263,7 @@ static void cleanup_current_dev(int cid)
 	struct fastrpc_device *dev, *devfree;
 
  rnext:
-	devfree = dev = 0;
+	devfree = dev = NULL;
 	spin_lock(&me->hlock);
 	head = &me->htbl[h];
 	hlist_for_each_entry_safe(dev, pos, n, head, hn) {
@@ -1303,7 +1305,7 @@ static int fastrpc_device_release(struct inode *inode, struct file *file)
 	(void)fastrpc_release_current_dsp_process(cid);
 	cleanup_current_dev(cid);
 	if (fdata) {
-		struct fastrpc_mmap *map = 0;
+		struct fastrpc_mmap *map = NULL;
 		struct hlist_node *pos, *n;
 		file->private_data = 0;
 		hlist_for_each_entry_safe(map, pos, n, &fdata->hlst, hn) {
@@ -1345,9 +1347,9 @@ static int fastrpc_device_open(struct inode *inode, struct file *filp)
 	}
 	mutex_unlock(&me->smd_mutex);
 
-	filp->private_data = 0;
+	filp->private_data = NULL;
 	if (0 != try_module_get(THIS_MODULE)) {
-		struct file_data *fdata = 0;
+		struct file_data *fdata = NULL;
 		/* This call will cause a dev to be created
 		 * which will addref this module
 		 */
@@ -1377,7 +1379,7 @@ bail:
 
 completion_bail:
 	smd_close(me->channel[cid].chan);
-	me->channel[cid].chan = 0;
+	me->channel[cid].chan = NULL;
 smd_bail:
 	mutex_unlock(&me->smd_mutex);
 	return err;
@@ -1399,7 +1401,7 @@ static long fastrpc_device_ioctl(struct file *file, unsigned int ioctl_num,
 	switch (ioctl_num) {
 	case FASTRPC_IOCTL_INVOKE_FD:
 	case FASTRPC_IOCTL_INVOKE:
-		invokefd.fds = 0;
+		invokefd.fds = NULL;
 		size = (ioctl_num == FASTRPC_IOCTL_INVOKE) ?
 				sizeof(*invoke) : sizeof(invokefd);
 		VERIFY(err, 0 == copy_from_user(&invokefd, param, size));
diff --git a/drivers/char/adsprpc_shared.h b/drivers/char/adsprpc_shared.h
index f5d7450dd76..bf1ab1fdccc 100644
--- a/drivers/char/adsprpc_shared.h
+++ b/drivers/char/adsprpc_shared.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2013,2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -88,7 +88,7 @@ do {\
 
 struct remote_buf {
 	void *pv;		/* buffer pointer */
-	int len;		/* length of buffer */
+	size_t len;		/* length of buffer */
 };
 
 union remote_arg {
@@ -109,7 +109,7 @@ struct fastrpc_ioctl_invoke_fd {
 
 struct fastrpc_ioctl_munmap {
 	uint32_t vaddrout;	/* address to unmap */
-	int  size;		/* size */
+	size_t  size;		/* size */
 };
 
 
@@ -117,7 +117,7 @@ struct fastrpc_ioctl_mmap {
 	int fd;			/* ion fd */
 	uint32_t flags;		/* flags for dsp to map with */
 	uint32_t vaddrin;	/* optional virtual address */
-	int  size;		/* size */
+	size_t size;		/* size */
 	uint32_t vaddrout;	/* dsps virtual address */
 };
 
@@ -129,7 +129,7 @@ struct smq_null_invoke {
 
 struct smq_phy_page {
 	uint32_t addr;		/* physical address */
-	uint32_t size;		/* size of contiguous region */
+	size_t size;		/* size of contiguous region */
 };
 
 struct smq_invoke_buf {
@@ -156,14 +156,15 @@ struct smq_invoke_rsp {
 static inline struct smq_invoke_buf *smq_invoke_buf_start(remote_arg_t *pra,
 							uint32_t sc)
 {
-	int len = REMOTE_SCALARS_LENGTH(sc);
+	unsigned int len = REMOTE_SCALARS_LENGTH(sc);
+
 	return (struct smq_invoke_buf *)(&pra[len]);
 }
 
 static inline struct smq_phy_page *smq_phy_page_start(uint32_t sc,
 						struct smq_invoke_buf *buf)
 {
-	int nTotal = REMOTE_SCALARS_INBUFS(sc) + REMOTE_SCALARS_OUTBUFS(sc);
+	uint32_t nTotal = REMOTE_SCALARS_INBUFS(sc)+REMOTE_SCALARS_OUTBUFS(sc);
 	return (struct smq_phy_page *)(&buf[nTotal]);
 }
 
-- 
2.17.1

