From af84f8f62ad0509e17a35993807421f909aa04b6 Mon Sep 17 00:00:00 2001
From: nx111 <gd.zhangdz@gmail.com>
Date: Tue, 16 Oct 2018 23:35:35 +0800
Subject: [PATCH 50/51] f/b: port more to privacy guard. [DNM]

Change-Id: I1a3ba16e5226c923a7bdd9b8d25b645dec023918
---
 core/java/android/app/AppOpsManager.java      | 166 ++++++-
 core/java/android/provider/Settings.java      |  25 +
 .../android/internal/app/IAppOpsService.aidl  |   8 +
 core/res/res/drawable/stat_notify_trust.xml   |  26 ++
 core/res/res/values/cm_strings.xml            |  86 ++++
 core/res/res/values/lineage_symbols.xml       |  17 +
 core/res/res/values/symbols.xml               |   4 +
 .../java/com/android/server/AppOpsPolicy.java | 440 ++++++++++++++++++
 .../com/android/server/AppOpsService.java     | 354 +++++++++++++-
 .../android/server/BasePermissionDialog.java  |  84 ++++
 .../com/android/server/PermissionDialog.java  | 147 ++++++
 .../server/PermissionDialogReqQueue.java      |  88 ++++
 .../server/am/ActivityManagerService.java     |  64 +++
 .../com/android/server/am/ActivityRecord.java |  29 ++
 .../server/am/ActivityStackSupervisor.java    |   5 +
 .../server/pm/PackageManagerService.java      |  16 +
 16 files changed, 1557 insertions(+), 2 deletions(-)
 create mode 100644 core/res/res/drawable/stat_notify_trust.xml
 create mode 100644 services/core/java/com/android/server/AppOpsPolicy.java
 create mode 100644 services/core/java/com/android/server/BasePermissionDialog.java
 create mode 100644 services/core/java/com/android/server/PermissionDialog.java
 create mode 100644 services/core/java/com/android/server/PermissionDialogReqQueue.java

diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index 98e2001e543..9533cd8d14c 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -31,6 +31,7 @@ import android.os.Parcel;
 import android.os.Parcelable;
 import android.os.Process;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.os.UserManager;
 import android.util.ArrayMap;
 
@@ -1104,6 +1105,92 @@ public class AppOpsManager {
             UserManager.DISALLOW_SU, //SU TODO: this should really be investigated.
     };
 
+    /**
+     * This specifies if operation is in strict mode.
+     */
+    private final static boolean[] sOpStrictMode = new boolean[] {
+            true, //COARSE_LOCATION
+            true, //FINE_LOCATION
+            false, //GPS
+            false, //VIBRATE
+            false, //READ_CONTACTS
+            false, //WRITE_CONTACTS
+            false, //READ_CALL_LOG
+            false, //WRITE_CALL_LOG
+            false, //READ_CALENDAR
+            false, //WRITE_CALENDAR
+            true, //WIFI_SCAN
+            false, //POST_NOTIFICATION
+            false, //NEIGHBORING_CELLS
+            false, //CALL_PHONE
+            false, //READ_SMS
+            false, //WRITE_SMS
+            false, //RECEIVE_SMS
+            false, //RECEIVE_EMERGECY_SMS
+            false, //RECEIVE_MMS
+            false, //RECEIVE_WAP_PUSH
+            false, //SEND_SMS
+            false, //READ_ICC_SMS
+            false, //WRITE_ICC_SMS
+            false, //WRITE_SETTINGS
+            true, //SYSTEM_ALERT_WINDOW
+            false, //ACCESS_NOTIFICATIONS
+            false, //CAMERA
+            false, //RECORD_AUDIO
+            false, //PLAY_AUDIO
+            false, //READ_CLIPBOARD
+            false, //WRITE_CLIPBOARD
+            false, //TAKE_MEDIA_BUTTONS
+            false, //TAKE_AUDIO_FOCUS
+            false, //AUDIO_MASTER_VOLUME
+            false, //AUDIO_VOICE_VOLUME
+            false, //AUDIO_RING_VOLUME
+            false, //AUDIO_MEDIA_VOLUME
+            false, //AUDIO_ALARM_VOLUME
+            false, //AUDIO_NOTIFICATION_VOLUME
+            false, //AUDIO_BLUETOOTH_VOLUME
+            false, //WAKE_LOCK
+            false, //MONITOR_LOCATION
+            false, //MONITOR_HIGH_POWER_LOCATION
+            false, //GET_USAGE_STATS
+            false, //MUTE_MICROPHONE
+            true, //TOAST_WINDOW
+            false, //PROJECT_MEDIA
+            false, //ACTIVATE_VPN
+            false, //WALLPAPER
+            false, //ASSIST_STRUCTURE
+            false, //ASSIST_SCREENSHOT
+            false, //READ_PHONE_STATE
+            false, //ADD_VOICEMAIL
+            false, // USE_SIP
+            false, // PROCESS_OUTGOING_CALLS
+            false, // USE_FINGERPRINT
+            false, // BODY_SENSORS
+            false, // READ_CELL_BROADCASTS
+            false, // MOCK_LOCATION
+            false, // READ_EXTERNAL_STORAGE
+            false, // WRITE_EXTERNAL_STORAGE
+            false, // TURN_ON_SCREEN
+            false, // GET_ACCOUNTS
+            false, // RUN_IN_BACKGROUND
+            false, // AUDIO_ACCESSIBILITY_VOLUME
+            false, // READ_PHONE_NUMBERS
+            false, // REQUEST_INSTALL_PACKAGES
+            false, // ENTER_PICTURE_IN_PICTURE_ON_HIDE
+            false, // INSTANT_APP_START_FOREGROUND
+            false, // ANSWER_PHONE_CALLS
+            false, // OP_RUN_ANY_IN_BACKGROUND
+            false, // OP_CHANGE_WIFI_STATE
+            false, // OP_REQUEST_DELETE_PACKAGES
+            false, // OP_BIND_ACCESSIBILITY_SERVICE
+            false, // ACCEPT_HANDOVER
+            false, // MANAGE_IPSEC_HANDOVERS
+            false, // START_FOREGROUND
+            true, // BLUETOOTH_SCAN
+            true, // BOOT_COMPLETED
+            false, // SU
+    };
+
     /**
      * This specifies whether each option should allow the system
      * (and system ui) to bypass the user restriction when active.
@@ -1517,7 +1604,10 @@ public class AppOpsManager {
      * Retrieve the default mode for the operation.
      * @hide
      */
-    public static int opToDefaultMode(int op) {
+    public static int opToDefaultMode(int op, boolean isStrict) {
+        if (isStrict) {
+            return sOpDefaultStrictMode[op];
+        }
         return sOpDefaultMode[op];
     }
 
@@ -2626,6 +2716,54 @@ public class AppOpsManager {
         }
     }
 
+    /** @hide */
+    public static boolean isStrictEnable() {
+        return SystemProperties.getBoolean("persist.sys.strict_op_enable", false);
+    }
+
+    /**
+     * Check if op in strict mode
+     * @hide
+     */
+    public static boolean isStrictOp(int code) {
+        return sOpStrictMode[code];
+    }
+
+
+    /** @hide */
+    public static int stringToMode(String permission) {
+        if ("allowed".equalsIgnoreCase(permission)) {
+            return AppOpsManager.MODE_ALLOWED;
+        } else if ("ignored".equalsIgnoreCase(permission)) {
+            return AppOpsManager.MODE_IGNORED;
+        } else if ("foreground".equalsIgnoreCase(permission)) {
+            return AppOpsManager.MODE_FOREGROUND;
+        } else if ("ask".equalsIgnoreCase(permission)) {
+            return AppOpsManager.MODE_ASK;
+        }
+        return AppOpsManager.MODE_ERRORED;
+    }
+
+    /** @hide */
+    public static int stringOpToOp (String op) {
+        Integer val = sOpStrToOp.get(op);
+        if (val == null) {
+            val = OP_NONE;
+        }
+        return val;
+    }
+
+
+    /** @hide */
+    public boolean isControlAllowed(int op, String packageName) {
+        boolean isShow = true;
+        try {
+            isShow = mService.isControlAllowed(op, packageName);
+        } catch (RemoteException e) {
+        }
+        return isShow;
+    }
+
     /**
      * Returns all supported operation names.
      * @hide
@@ -2648,4 +2786,30 @@ public class AppOpsManager {
         }
         return time;
     }
+
+    /** @hide */
+    public boolean getPrivacyGuardSettingForPackage(int uid, String packageName) {
+        try {
+            return mService.getPrivacyGuardSettingForPackage(uid, packageName);
+        } catch (RemoteException e) {
+        }
+        return false;
+    }
+
+    /** @hide */
+    public void setPrivacyGuardSettingForPackage(int uid, String packageName,
+            boolean state) {
+        try {
+            mService.setPrivacyGuardSettingForPackage(uid, packageName, state);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /** @hide */
+    public void resetCounters() {
+        try {
+            mService.resetCounters();
+        } catch (RemoteException e) {
+        }
+    }
 }
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index b8f5f27bcc2..1e57fd9fc1b 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -897,6 +897,31 @@ public final class Settings {
     public static final String ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS =
             "android.settings.IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS";
 
+    /**
+     * @hide
+     * Activity Action: Show the "app ops" details screen.
+     * <p>
+     * Input: The Intent's data URI specifies the application package name
+     * to be shown, with the "package" scheme.  That is "package:com.my.app".
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APP_OPS_DETAILS_SETTINGS =
+            "android.settings.APP_OPS_DETAILS_SETTINGS";
+
+    /**
+     * @hide
+     * Activity Action: Show the "app ops" settings screen.
+     * <p>
+     * Input: Nothing.
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APP_OPS_SETTINGS =
+            "android.settings.APP_OPS_SETTINGS";
+
     /**
      * @hide
      * Activity Action: Show the "app ops" settings screen.
diff --git a/core/java/com/android/internal/app/IAppOpsService.aidl b/core/java/com/android/internal/app/IAppOpsService.aidl
index 0ed97247712..2a2cf0697cb 100644
--- a/core/java/com/android/internal/app/IAppOpsService.aidl
+++ b/core/java/com/android/internal/app/IAppOpsService.aidl
@@ -54,6 +54,14 @@ interface IAppOpsService {
     void startWatchingActive(in int[] ops, IAppOpsActiveCallback callback);
     void stopWatchingActive(IAppOpsActiveCallback callback);
     boolean isOperationActive(int code, int uid, String packageName);
+    boolean isControlAllowed(int code, String packageName);
 
     void startWatchingModeWithFlags(int op, String packageName, int flags, IAppOpsCallback callback);
+
+    // Privacy guard methods
+    boolean getPrivacyGuardSettingForPackage(int uid, String packageName);
+    void setPrivacyGuardSettingForPackage(int uid, String packageName, boolean state);
+
+    // AppOps accounting
+    void resetCounters();
 }
diff --git a/core/res/res/drawable/stat_notify_trust.xml b/core/res/res/drawable/stat_notify_trust.xml
new file mode 100644
index 00000000000..426fb9dd660
--- /dev/null
+++ b/core/res/res/drawable/stat_notify_trust.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2018 The LineageOS Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+
+    <path
+        android:fillColor="@android:color/white"
+        android:pathData="M5,3L19,3C20.105,3 21,3.895 21,5L21,12C21,16.971 16.971,21 12,21C7.029,21 3,16.971 3,12L3,5C3,3.895 3.895,3 5,3ZM18.902,13.168C18.994,12.624 18.627,12.108 18.082,12.016C17.538,11.925 17.022,12.292 16.93,12.837C16.528,15.225 14.45,17 12,17C9.55,17 7.472,15.226 7.069,12.838C6.978,12.294 6.462,11.927 5.917,12.018C5.373,12.11 5.005,12.626 5.097,13.171C5.661,16.517 8.57,19 12,19C15.43,19 18.339,16.516 18.902,13.168ZM11.046,5.698L9.127,11.297C9.045,11.516 9,11.753 9,12C9,13.104 9.895,14 11,14C11.01,14 11.019,14 11.029,14L13,14C13.55,14 14.05,13.78 14.41,13.41C14.78,13.05 15,12.55 15,12L12.6,12L11,11.999L11.438,10.724L11.646,10.116L12.938,6.346C12.978,6.238 13,6.121 13,6C13,5.448 12.552,5 12,5C11.553,5 11.174,5.293 11.046,5.698Z" />
+</vector>
\ No newline at end of file
diff --git a/core/res/res/values/cm_strings.xml b/core/res/res/values/cm_strings.xml
index a5a33bc633d..82bc570bf65 100644
--- a/core/res/res/values/cm_strings.xml
+++ b/core/res/res/values/cm_strings.xml
@@ -25,4 +25,90 @@
     <!-- ADB notification message-->
     <string name="adb_active_generic_notification_message">Touch to disable debugging.</string>
 
+    <!-- Privacy Guard -->
+    <string name="permlab_changePrivacyGuardState">enable or disable Privacy Guard</string>
+    <string name="permdesc_changePrivacyGuardState">Allows the app to change whether another app runs with Privacy Guard. When an app is running with Privacy Guard, it will not have access to personal data such as contacts, call logs, or messages.</string>
+    <string name="privacy_guard_notification">Privacy Guard active</string>
+    <string name="privacy_guard_notification_detail"><xliff:g id="app">%1$s</xliff:g> will not be able to access personal data</string>
+    <string name="privacy_guard_dialog_title">Privacy Guard</string>
+    <string name="privacy_guard_dialog_summary"><xliff:g id="app">%1$s</xliff:g> would like to <xliff:g id="op">%2$s</xliff:g>.</string>
+
+    <!-- Text of the checkbox for the permission confirmation dialog to remember the user's choice. [CHAR LIMIT=40] -->
+    <string name="permission_remember_choice">Remember my choice</string>
+
+    <!-- App ops requests -->
+    <string name="app_ops_access_camera">access the camera</string>
+    <string name="app_ops_access_location">access your location</string>
+    <string name="app_ops_access_notifications">read your notifications</string>
+    <string name="app_ops_activate_vpn">activate a VPN</string>
+    <string name="app_ops_add_voicemail">add a voicemail</string>
+    <string name="app_ops_app_start_foreground">start instant app in foreground</string>
+    <string name="app_ops_assist_screenshot">take a screenshot</string>
+    <string name="app_ops_assist_structure">use assist structure</string>
+    <string name="app_ops_audio_accessibility_volume">audio accessibility volume</string>
+    <string name="app_ops_auto_start">start at power up</string>
+    <string name="app_ops_change_wallpaper">change the wallpaper</string>
+    <string name="app_ops_delete_call_log">delete your call log</string>
+    <string name="app_ops_delete_contacts">delete your contacts</string>
+    <string name="app_ops_delete_mms">delete your MMS messages</string>
+    <string name="app_ops_delete_sms">delete your SMS messages</string>
+    <string name="app_ops_draw_on_top">draw windows on top</string>
+    <string name="app_ops_get_accounts">get device accounts</string>
+    <string name="app_ops_get_usage_stats">get app usage stats</string>
+    <string name="app_ops_install_packages">install packages</string>
+    <string name="app_ops_keep_device_awake">keep your device awake</string>
+    <string name="app_ops_make_phone_call">make a phone call</string>
+    <string name="app_ops_mock_location">mock your location</string>
+    <string name="app_ops_modify_calendar">update your calendar</string>
+    <string name="app_ops_modify_call_log">update the call log</string>
+    <string name="app_ops_modify_clipboard">modify the clipboard</string>
+    <string name="app_ops_modify_contacts">update your contacts</string>
+    <string name="app_ops_modify_settings">update system settings</string>
+    <string name="app_ops_mute_unmute_microphone">mute/unmute the microphone</string>
+    <string name="app_ops_phone_calls">answer phone calls</string>
+    <string name="app_ops_picture_in_picture">use picture in picture</string>
+    <string name="app_ops_play_audio">play audio</string>
+    <string name="app_ops_post_notification">post a notification</string>
+    <string name="app_ops_project_media">project media</string>
+    <string name="app_ops_read_calendar">read your calendar</string>
+    <string name="app_ops_read_call_log">read the call log</string>
+    <string name="app_ops_read_cell_broadcasts">read cell broadcasts</string>
+    <string name="app_ops_read_clipboard">read the clipboard</string>
+    <string name="app_ops_read_contacts">read your contacts</string>
+    <string name="app_ops_read_external_storage">read external storage</string>
+    <string name="app_ops_read_mms">read your MMS messages</string>
+    <string name="app_ops_read_phone_numbers">read phone numbers</string>
+    <string name="app_ops_read_phone_state">access phone state</string>
+    <string name="app_ops_read_sms">read your SMS messages</string>
+    <string name="app_ops_receive_sms">receive an SMS message</string>
+    <string name="app_ops_record_audio">record audio</string>
+    <string name="app_ops_run_in_background">run in background</string>
+    <string name="app_ops_scan_wifi">scan Wi-Fi networks</string>
+    <string name="app_ops_send_mms">send an MMS message</string>
+    <string name="app_ops_send_sms">send an SMS message</string>
+    <string name="app_ops_start_at_bootup">start at power up</string>
+    <string name="app_ops_su">get root access</string>
+    <string name="app_ops_toast_window">display toast messages</string>
+    <string name="app_ops_toggle_bluetooth">toggle Bluetooth</string>
+    <string name="app_ops_toggle_mobile_data">toggle cellular data</string>
+    <string name="app_ops_toggle_nfc">toggle NFC</string>
+    <string name="app_ops_toggle_wifi">toggle Wi-Fi</string>
+    <string name="app_ops_turn_on_screen">turn the screen on</string>
+    <string name="app_ops_use_alarm_volume">control alarm volume</string>
+    <string name="app_ops_use_audio_focus">control the audio focus</string>
+    <string name="app_ops_use_bluetooth_volume">control the Bluetooth volume</string>
+    <string name="app_ops_use_body_sensors">use body sensors</string>
+    <string name="app_ops_use_fingerprint">use fingerprint</string>
+    <string name="app_ops_use_master_volume">control the master volume</string>
+    <string name="app_ops_use_media_buttons">use the media buttons</string>
+    <string name="app_ops_use_media_volume">control the media volume</string>
+    <string name="app_ops_use_notification_volume">control the notification volume</string>
+    <string name="app_ops_use_ring_volume">control the ringtone volume</string>
+    <string name="app_ops_use_vibrate">use haptic feedback</string>
+    <string name="app_ops_use_voice_volume">control the voice call volume</string>
+    <string name="app_ops_wifi_change">change Wi-Fi state</string>
+    <string name="app_ops_write_external_storage">write external storage</string>
+    <string name="app_ops_write_mms">write an MMS message</string>
+    <string name="app_ops_write_sms">write an SMS message</string>
+
  </resources>
diff --git a/core/res/res/values/lineage_symbols.xml b/core/res/res/values/lineage_symbols.xml
index a34d8bdbc37..2776d8ab959 100644
--- a/core/res/res/values/lineage_symbols.xml
+++ b/core/res/res/values/lineage_symbols.xml
@@ -24,6 +24,23 @@
     <java-symbol type="integer" name="config_buttonBrightnessSettingDefault" />
     <java-symbol type="bool" name="config_deviceHasVariableButtonBrightness" />
 
+    <!-- Privacy Guard -->
+    <java-symbol type="drawable" name="permission_dialog_trust" />
+    <java-symbol type="drawable" name="stat_notify_trust" />
+    <java-symbol type="string" name="privacy_guard_notification" />
+    <java-symbol type="string" name="privacy_guard_notification_detail" />
+    <java-symbol type="string" name="privacy_guard_dialog_title" />
+    <java-symbol type="string" name="privacy_guard_dialog_summary" />
+    <java-symbol type="id" name="permission_text" />
+    <java-symbol type="id" name="permission_remember_layout" />
+    <java-symbol type="id" name="permission_remember_choice_checkbox" />
+    <java-symbol type="id" name="permission_remember_choice_text" />
+    <java-symbol type="string" name="allow" />
+    <java-symbol type="string" name="deny" />
+    <java-symbol type="layout" name="permission_confirmation_dialog" />
+    <java-symbol type="array" name="app_ops_labels" />
+    <java-symbol type="string" name="status_bar_su" />
+
     <!-- Rotation sensor -->
     <java-symbol type="bool" name="config_useSystemClockforRotationSensor" />
 
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 8ba7ae499fb..6f4ca802ba5 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -2287,6 +2287,10 @@
   <!-- From PinyinIME(!!!) -->
   <java-symbol type="string" name="inputMethod" />
 
+  <!-- From privacyGuard -->
+  <java-symbol type="string" name="privacy_guard_notification" />
+  <java-symbol type="string" name="privacy_guard_notification_detail" />
+
   <!-- From Chromium-WebView -->
   <java-symbol type="attr" name="actionModeWebSearchDrawable" />
   <java-symbol type="string" name="websearch" />
diff --git a/services/core/java/com/android/server/AppOpsPolicy.java b/services/core/java/com/android/server/AppOpsPolicy.java
new file mode 100644
index 00000000000..94624b8b38d
--- /dev/null
+++ b/services/core/java/com/android/server/AppOpsPolicy.java
@@ -0,0 +1,440 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.android.server;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.app.AppOpsManager;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.util.Xml;
+
+import com.android.internal.util.XmlUtils;
+
+public class AppOpsPolicy {
+    static final String TAG = "AppOpsPolicy";
+    static final boolean DEBUG = false;
+    final File mFile;
+    final Context mContext;
+    public static final int CONTROL_SHOW = 0;
+
+    public static final int CONTROL_NOSHOW = 1;
+
+    public static final int CONTROL_UNKNOWN = 2;
+
+    // Rate limiting thresholds for ask operations
+    public static final int RATE_LIMIT_OP_COUNT = 3;
+    public static final int RATE_LIMIT_OPS_TOTAL_PKG_COUNT = 4;
+    public static final int RATE_LIMIT_OP_DELAY_CEILING = 10;
+
+    public static int stringToControl(String show) {
+        if ("true".equalsIgnoreCase(show)) {
+            return CONTROL_SHOW;
+        } else if ("false".equalsIgnoreCase(show)) {
+            return CONTROL_NOSHOW;
+        }
+        return CONTROL_UNKNOWN;
+    }
+
+    HashMap<String, PolicyPkg> mPolicy = new HashMap<String, PolicyPkg>();
+
+    public AppOpsPolicy(File file, Context context) {
+        super();
+        mFile = file;
+        mContext = context;
+    }
+
+    public final static class PolicyPkg extends SparseArray<PolicyOp> {
+        public String packageName;
+        public int mode;
+        public int show;
+        public String type;
+
+        public PolicyPkg(String packageName, int mode, int show, String type) {
+            this.packageName = packageName;
+            this.mode = mode;
+            this.show = show;
+            this.type = type;
+        }
+
+        @Override
+        public String toString() {
+            return "PolicyPkg [packageName=" + packageName + ", mode=" + mode
+                    + ", show=" + show + ", type=" + type + "]";
+        }
+
+    }
+
+    public final static class PolicyOp {
+        public int op;
+        public int mode;
+        public int show;
+
+        public PolicyOp(int op, int mode, int show) {
+            this.op = op;
+            this.mode = mode;
+            this.show = show;
+        }
+
+        @Override
+        public String toString() {
+            return "PolicyOp [op=" + op + ", mode=" + mode + ", show=" + show
+                    + "]";
+        }
+    }
+
+    void readPolicy() {
+        FileInputStream stream;
+        synchronized (mFile) {
+            try {
+                stream = new FileInputStream(mFile);
+            } catch (FileNotFoundException e) {
+                Slog.i(TAG, "App ops policy file (" + mFile.getPath()
+                        + ") not found; Skipping.");
+                return;
+            }
+            boolean success = false;
+            try {
+                XmlPullParser parser = Xml.newPullParser();
+                parser.setInput(stream, null);
+                int type;
+                success = true;
+                while ((type = parser.next()) != XmlPullParser.START_TAG
+                        && type != XmlPullParser.END_DOCUMENT) {
+                    ;
+                }
+                if (type != XmlPullParser.START_TAG) {
+                    throw new IllegalStateException("no start tag found");
+                }
+
+                int outerDepth = parser.getDepth();
+                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                        && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
+                    if (type == XmlPullParser.END_TAG
+                            || type == XmlPullParser.TEXT) {
+                        continue;
+                    }
+
+                    String tagName = parser.getName();
+                    if (tagName.equals("user-app")
+                            || tagName.equals("system-app")) {
+                        readDefaultPolicy(parser, tagName);
+                    } else if (tagName.equals("application")) {
+                        readApplicationPolicy(parser);
+                    } else {
+                        Slog.w(TAG, "Unknown element under <appops-policy>: "
+                                + parser.getName());
+                        XmlUtils.skipCurrentTag(parser);
+                    }
+                }
+            } catch (IllegalStateException e) {
+                Slog.w(TAG, "Failed parsing " + e);
+            } catch (NullPointerException e) {
+                Slog.w(TAG, "Failed parsing " + e);
+            } catch (NumberFormatException e) {
+                Slog.w(TAG, "Failed parsing " + e);
+            } catch (XmlPullParserException e) {
+                Slog.w(TAG, "Failed parsing " + e);
+            } catch (IOException e) {
+                Slog.w(TAG, "Failed parsing " + e);
+            } catch (IndexOutOfBoundsException e) {
+                Slog.w(TAG, "Failed parsing " + e);
+            } finally {
+                if (!success) {
+                    mPolicy.clear();
+                }
+                try {
+                    stream.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+    }
+
+    private void readDefaultPolicy(XmlPullParser parser, String packageName)
+            throws NumberFormatException, XmlPullParserException, IOException {
+        if (!"user-app".equalsIgnoreCase(packageName)
+                && !"system-app".equalsIgnoreCase(packageName)) {
+            return;
+        }
+        int mode = AppOpsManager.stringToMode(parser.getAttributeValue(null,
+                "permission"));
+        int show = stringToControl(parser.getAttributeValue(null, "show"));
+        if (mode == AppOpsManager.MODE_ERRORED && show == CONTROL_UNKNOWN) {
+            return;
+        }
+        PolicyPkg pkg = this.mPolicy.get(packageName);
+        if (pkg == null) {
+            pkg = new PolicyPkg(packageName, mode, show, packageName);
+            this.mPolicy.put(packageName, pkg);
+        } else {
+            Slog.w(TAG, "Duplicate policy found for package: " + packageName
+                    + " of type: " + packageName);
+            pkg.mode = mode;
+            pkg.show = show;
+        }
+    }
+
+    private void readApplicationPolicy(XmlPullParser parser)
+            throws NumberFormatException, XmlPullParserException, IOException {
+        int outerDepth = parser.getDepth();
+        int type;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
+            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                continue;
+            }
+            String tagName = parser.getName();
+            if (tagName.equals("pkg")) {
+                readPkgPolicy(parser);
+            } else {
+                Slog.w(TAG,
+                        "Unknown element under <application>: "
+                                + parser.getName());
+                XmlUtils.skipCurrentTag(parser);
+            }
+        }
+    }
+
+    private void readPkgPolicy(XmlPullParser parser)
+            throws NumberFormatException, XmlPullParserException, IOException {
+        String packageName = parser.getAttributeValue(null, "name");
+        if (packageName == null) {
+            return;
+        }
+        String appType = parser.getAttributeValue(null, "type");
+        if (appType == null) {
+            return;
+        }
+        int mode = AppOpsManager.stringToMode(parser.getAttributeValue(null,
+                "permission"));
+        int show = stringToControl(parser.getAttributeValue(null, "show"));
+        String key = packageName + "." + appType;
+        PolicyPkg pkg = this.mPolicy.get(key);
+        if (pkg == null) {
+            pkg = new PolicyPkg(packageName, mode, show, appType);
+            this.mPolicy.put(key, pkg);
+        } else {
+            Slog.w(TAG, "Duplicate policy found for package: " + packageName
+                    + " of type: " + appType);
+            pkg.mode = mode;
+            pkg.show = show;
+        }
+
+        int outerDepth = parser.getDepth();
+        int type;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
+            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                continue;
+            }
+            String tagName = parser.getName();
+            if (tagName.equals("op")) {
+                readOpPolicy(parser, pkg);
+            } else {
+                Slog.w(TAG, "Unknown element under <pkg>: " + parser.getName());
+                XmlUtils.skipCurrentTag(parser);
+            }
+        }
+    }
+
+    private void readOpPolicy(XmlPullParser parser, PolicyPkg pkg)
+            throws NumberFormatException, XmlPullParserException, IOException {
+        if (pkg == null) {
+            return;
+        }
+        String opName = parser.getAttributeValue(null, "name");
+        if (opName == null) {
+            Slog.w(TAG, "Op name is null");
+            return;
+        }
+        int code = AppOpsManager.stringOpToOp(opName);
+        if (code == AppOpsManager.OP_NONE) {
+            Slog.w(TAG, "Unknown Op: " + opName);
+            return;
+        }
+        int mode = AppOpsManager.stringToMode(parser.getAttributeValue(null,
+                "permission"));
+        int show = stringToControl(parser.getAttributeValue(null, "show"));
+        if (mode == AppOpsManager.MODE_ERRORED && show == CONTROL_UNKNOWN) {
+            return;
+        }
+        PolicyOp op = pkg.get(code);
+        if (op == null) {
+            op = new PolicyOp(code, mode, show);
+            pkg.put(code, op);
+        } else {
+            Slog.w(TAG, "Duplicate policy found for package: "
+                    + pkg.packageName + " type: " + pkg.type + " op: " + op.op);
+            op.mode = mode;
+            op.show = show;
+        }
+    }
+
+    void debugPoilcy() {
+        Iterator<Map.Entry<String, PolicyPkg>> iterator = mPolicy.entrySet()
+                .iterator();
+        while (iterator.hasNext()) {
+            String key = iterator.next().getKey();
+            if (DEBUG) Slog.d(TAG, "Key: " + key);
+            PolicyPkg pkg = mPolicy.get(key);
+            if (pkg == null) {
+                if (DEBUG)
+                    Slog.d(TAG, "Pkg is null for key: " + key);
+                continue;
+            }
+            if (DEBUG) Slog.d(TAG, pkg.toString());
+            for (int i = 0; i < pkg.size(); i++) {
+                PolicyOp op = pkg.valueAt(i);
+                if (DEBUG) Slog.d(TAG, op.toString());
+            }
+        }
+    }
+
+    private String getAppType(String packageName) {
+        String appType = null;
+        ApplicationInfo appInfo = null;
+        if (mContext != null) {
+            try {
+                appInfo = mContext.getPackageManager().getApplicationInfo(
+                        packageName, 0);
+            } catch (NameNotFoundException e) {
+                appInfo = null;
+            }
+            if (appInfo != null) {
+                if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                    appType = "system-app";
+                } else {
+                    appType = "user-app";
+                }
+            }
+        } else {
+            Slog.e(TAG, "Context is null");
+        }
+        return appType;
+    }
+
+    public boolean isControlAllowed(int code, String packageName) {
+        boolean isShow = true;
+        int show = CONTROL_UNKNOWN;
+        PolicyPkg pkg;
+        String key;
+        String type;
+
+        if (mPolicy == null) {
+            return isShow;
+        }
+
+        type = getAppType(packageName);
+        if (type != null) {
+            key = type;
+            pkg = mPolicy.get(key);
+            if (pkg != null && pkg.show != CONTROL_UNKNOWN) {
+                show = pkg.show;
+            }
+        }
+        key = packageName;
+        if (type != null) {
+            key = key + "." + type;
+        }
+        pkg = mPolicy.get(key);
+        if (pkg != null) {
+            if (pkg.show != CONTROL_UNKNOWN) {
+                show = pkg.show;
+            }
+            PolicyOp op = pkg.get(code);
+            if (op != null) {
+                if (op.show != CONTROL_UNKNOWN) {
+                    show = op.show;
+                }
+            }
+        }
+        if (show == CONTROL_NOSHOW) {
+            isShow = false;
+        }
+        return isShow;
+    }
+
+    public int getDefualtMode(int code, String packageName) {
+        int mode = AppOpsManager.MODE_ERRORED;
+        PolicyPkg pkg;
+        String key;
+        String type;
+
+        if (mPolicy == null) {
+            return mode;
+        }
+        if (DEBUG) Slog.d(TAG, "Default mode requested for op=" + code + " package="
+                + packageName);
+        type = getAppType(packageName);
+        if (type != null) {
+            // Get value based on 'type'
+            key = type;
+            pkg = mPolicy.get(key);
+            if (pkg != null && pkg.mode != AppOpsManager.MODE_ERRORED) {
+                if (DEBUG) Slog.d(TAG, "Setting value based on type: " + pkg);
+                mode = pkg.mode;
+            }
+        }
+        // Get value based on 'pkg'.
+        key = packageName;
+        if (type != null) {
+            key = key + "." + type;
+        }
+        pkg = mPolicy.get(key);
+        if (pkg != null) {
+            if (pkg.mode != AppOpsManager.MODE_ERRORED) {
+                if (DEBUG) Slog.d(TAG, "Setting value based on packageName: " + pkg);
+                mode = pkg.mode;
+            }
+            // Get value base on 'op'
+            PolicyOp op = pkg.get(code);
+            if (op != null) {
+                if (op.mode != AppOpsManager.MODE_ERRORED) {
+                    if (DEBUG) Slog.d(TAG, "Setting value based on op: " + op);
+                    mode = op.mode;
+                }
+            }
+        }
+        if (DEBUG) Slog.d(TAG, "Returning mode=" + mode);
+        return mode;
+    }
+}
diff --git a/services/core/java/com/android/server/AppOpsService.java b/services/core/java/com/android/server/AppOpsService.java
index 6589dd0df69..c6d6d9a377f 100644
--- a/services/core/java/com/android/server/AppOpsService.java
+++ b/services/core/java/com/android/server/AppOpsService.java
@@ -22,8 +22,11 @@ import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.AppOpsManager;
 import android.app.AppOpsManagerInternal;
+import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageManager;
@@ -37,6 +40,8 @@ import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
+import android.os.PowerManager;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.ResultReceiver;
@@ -52,6 +57,7 @@ import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.AtomicFile;
 import android.util.KeyValueListParser;
+import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
@@ -70,6 +76,7 @@ import com.android.internal.util.FastXmlSerializer;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.XmlUtils;
 import com.android.internal.util.function.pooled.PooledLambda;
+import com.android.server.PermissionDialogReqQueue.PermissionDialogReq;
 
 import libcore.util.EmptyArray;
 
@@ -116,6 +123,9 @@ public class AppOpsService extends IAppOpsService.Stub {
     // Write at most every 30 minutes.
     static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;
 
+    // Location of policy file.
+    static final String DEFAULT_POLICY_FILE = "/system/etc/appops_policy.xml";
+
     // Constant meaning that any UID should be matched when dispatching callbacks
     private static final int UID_ANY = -2;
 
@@ -173,6 +183,10 @@ public class AppOpsService extends IAppOpsService.Stub {
     Context mContext;
     final AtomicFile mFile;
     final Handler mHandler;
+    final Looper mLooper;
+    final boolean mStrictEnable;
+    AppOpsPolicy mPolicy;
+    private PowerManager mPowerManager;
 
     private final AppOpsManagerInternalImpl mAppOpsManagerInternal
             = new AppOpsManagerInternalImpl();
@@ -406,15 +420,25 @@ public class AppOpsService extends IAppOpsService.Stub {
         int duration;
         long time[] = new long[_NUM_UID_STATE];
         long rejectTime[] = new long[_NUM_UID_STATE];
+        public PermissionDialogReqQueue dialogReqQueue;
+        final ArrayList<IBinder> clientTokens;
+        public int nesting;
         int startNesting;
         long startRealtime;
+        public int noteOpCount;
+        public int startOpCount;
+        public int allowedCount;
+        public int ignoredCount;
+        public int delayedCount;
 
         Op(UidState _uidState, String _packageName, int _op) {
             uidState = _uidState;
             uid = _uidState.uid;
             packageName = _packageName;
             op = _op;
+            dialogReqQueue = new PermissionDialogReqQueue();
             mode = AppOpsManager.opToDefaultMode(op);
+            clientTokens = new ArrayList<IBinder>();
         }
 
         boolean hasAnyTime() {
@@ -681,8 +705,43 @@ public class AppOpsService extends IAppOpsService.Stub {
                                 || mountMode == Zygote.MOUNT_EXTERNAL_WRITE;
                     }
                 });
+        mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        mContext.registerReceiver(mIntentReceiver, filter);
     }
 
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                synchronized (this) {
+                    for (int i = mUidStates.size() - 1; i >= 0; i--) {
+                        UidState uidState = mUidStates.valueAt(i);
+
+                        ArrayMap<String, Ops> packages = uidState.pkgOps;
+                        if (packages == null) {
+                            continue;
+                        }
+
+                        Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();
+                        while (it.hasNext()) {
+                            Map.Entry<String, Ops> ent = it.next();
+                            Ops pkgOps = ent.getValue();
+                            for (int j = pkgOps.size() - 1; j >= 0; j--) {
+                                Op curOp = pkgOps.valueAt(j);
+                                if (DEBUG) Log.d(TAG, "Ignoring " + curOp.packageName + " request "
+                                        + curOp.op);
+                                curOp.dialogReqQueue.ignore();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    };
+
     public void packageRemoved(int uid, String packageName) {
         synchronized (this) {
             UidState uidState = mUidStates.get(uid);
@@ -1564,6 +1623,7 @@ public class AppOpsService extends IAppOpsService.Stub {
 
     private int noteOperationUnchecked(int code, int uid, String packageName,
             int proxyUid, String proxyPackageName) {
+        PermissionDialogReq req = null;
         synchronized (this) {
             final Ops ops = getOpsRawLocked(uid, packageName, true /* edit */,
                     false /* uidMismatchExpected */);
@@ -1598,12 +1658,68 @@ public class AppOpsService extends IAppOpsService.Stub {
             } else {
                 final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
                 final int mode = switchOp.getMode();
-                if (mode != AppOpsManager.MODE_ALLOWED) {
+                if (mode != AppOpsManager.MODE_ALLOWED
+                      && mode != AppOpsManager.MODE_ASK) {
                     if (DEBUG) Slog.d(TAG, "noteOperation: reject #" + mode + " for code "
                             + switchCode + " (" + code + ") uid " + uid + " package "
                             + packageName);
                     op.rejectTime[uidState.state] = System.currentTimeMillis();
                     return mode;
+                } else if (mode == AppOpsManager.MODE_ASK) {
+                    if (Looper.myLooper() == mLooper) {
+                        Log.e(TAG,
+                                "noteOperation: This method will deadlock if called from the main thread. (Code: "
+                                        + code
+                                        + " uid: "
+                                        + uid
+                                        + " package: "
+                                        + packageName + ")");
+                        return mode;
+                    }
+
+                    if (DEBUG) {
+                            Log.d(TAG, "Package " + op.packageName + " has " + op.noteOpCount
+                                    + " requests and " + op.startOpCount + " start requests with "
+                                    + op.ignoredCount + " ignored at " + op.time +
+                                    " with a duration of "
+                                    + op.duration + " while being delayed " + op.delayedCount +
+                                    " times");
+                            Log.d(TAG, "Total pkops for " + ops.packageName + " "
+                                    + ops.uidState.pkgOps.size());
+                    }
+
+                    // First drop all request events if the device is not interactive, next
+                    // check what the global pkg ops count for the package,
+                    // then check op scoped count. High frequency request ops will be delayed until
+                    // their delay count ceiling is met. This is to mitigate the overloading the
+                    // main activity manager service handler and having watchdog kill our service.
+                    // Google play services likes to share its uid with numerous packages to avoid
+                    // having to grant permissions from the users perspective and thus is the worst
+                    // example of overloading this queue -- so, to not encourage bad behavior,
+                    // we move them to the back of the line. NOTE: these values are magic, and may need
+                    // tuning. Ideally we'd want a ringbuffer or token bucket here to do proper rate
+                    // limiting.
+                    final boolean isInteractive = mPowerManager.isInteractive();
+                    if (isInteractive &&
+                            (ops.uidState.pkgOps.size() < AppOpsPolicy.RATE_LIMIT_OPS_TOTAL_PKG_COUNT
+                            && op.noteOpCount < AppOpsPolicy.RATE_LIMIT_OP_COUNT
+                            || op.delayedCount > AppOpsPolicy.RATE_LIMIT_OP_DELAY_CEILING)) {
+
+                        // Reset delayed count, most ops will never need this
+                        if (op.delayedCount > 0) {
+                            if (DEBUG) Log.d(TAG, "Resetting delayed count for " + op.packageName);
+                            op.delayedCount = 0;
+                        }
+
+                        op.noteOpCount++;
+                        req = askOperationLocked(code, uid, packageName, switchOp);
+                    } else {
+                        if (isInteractive) {
+                            op.delayedCount++;
+                        }
+                        op.ignoredCount++;
+                        return AppOpsManager.MODE_IGNORED;
+                    }
                 }
             }
             if (DEBUG) Slog.d(TAG, "noteOperation: allowing code " + code + " uid " + uid
@@ -1696,6 +1812,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             if (uidState.opModes != null && uidState.opModes.indexOfKey(switchCode) >= 0) {
                 final int uidMode = uidState.evalMode(uidState.opModes.get(switchCode));
                 if (uidMode != AppOpsManager.MODE_ALLOWED
+                        && uidMode != AppOpsManager.MODE_ASK
                         && (!startIfModeDefault || uidMode != AppOpsManager.MODE_DEFAULT)) {
                     if (DEBUG) Slog.d(TAG, "noteOperation: uid reject #" + uidMode + " for code "
                             + switchCode + " (" + code + ") uid " + uid + " package "
@@ -3582,6 +3699,174 @@ public class AppOpsService extends IAppOpsService.Stub {
         }
     }
 
+    final class AskRunnable implements Runnable {
+        final int code;
+        final int uid;
+        final String packageName;
+        final Op op;
+        final PermissionDialogReq request;
+
+        public AskRunnable(int code, int uid, String packageName, Op op,
+                PermissionDialogReq request) {
+            super();
+            this.code = code;
+            this.uid = uid;
+            this.packageName = packageName;
+            this.op = op;
+            this.request = request;
+        }
+
+        @Override
+        public void run() {
+            PermissionDialog permDialog = null;
+            synchronized (AppOpsService.this) {
+                Log.e(TAG, "Creating dialog box");
+                op.dialogReqQueue.register(request);
+                if (op.dialogReqQueue.getDialog() == null) {
+                    permDialog = new PermissionDialog(mContext,
+                            AppOpsService.this, code, uid, packageName);
+                    op.dialogReqQueue.setDialog(permDialog);
+                }
+            }
+            if (permDialog != null) {
+                permDialog.show();
+            }
+        }
+    }
+
+    private PermissionDialogReq askOperationLocked(int code, int uid,
+            String packageName, Op op) {
+        PermissionDialogReq request = new PermissionDialogReq();
+        mHandler.post(new AskRunnable(code, uid, packageName, op, request));
+        return request;
+    }
+
+    private int getDefaultMode(int code, int uid, String packageName) {
+        int mode = AppOpsManager.opToDefaultMode(code,
+                isStrict(code, uid, packageName));
+        if (AppOpsManager.isStrictOp(code) && mPolicy != null) {
+            int policyMode = mPolicy.getDefualtMode(code, packageName);
+            if (policyMode != AppOpsManager.MODE_ERRORED) {
+                mode = policyMode;
+            }
+        }
+        return mode;
+    }
+
+    private boolean isStrict(int code, int uid, String packageName) {
+        if (!mStrictEnable)
+            return false;
+
+        return UserHandle.isApp(uid);
+    }
+
+    private void printOperationLocked(Op op, int mode, String operation) {
+        if(op != null) {
+            int switchCode = AppOpsManager.opToSwitch(op.op);
+            if (mode == AppOpsManager.MODE_IGNORED) {
+                if (DEBUG) Log.d(TAG, operation + ": reject #" + mode + " for code "
+                        + switchCode + " (" + op.op + ") uid " + op.uid + " package "
+                        + op.packageName);
+            } else if (mode == AppOpsManager.MODE_ALLOWED) {
+                if (DEBUG) Log.d(TAG, operation + ": allowing code " + op.op + " uid "
+                    + op.uid
+                    + " package " + op.packageName);
+            }
+        }
+    }
+
+    private void recordOperationLocked(int code, int uid, String packageName,
+                                    int mode) {
+        Op op = getOpLocked(code, uid, packageName, false);
+        if (op != null) {
+            if (op.noteOpCount != 0) {
+                printOperationLocked(op, mode, "noteOperartion");
+            }
+            if (op.startOpCount != 0) {
+                printOperationLocked(op, mode, "startOperation");
+            }
+            if (mode == AppOpsManager.MODE_IGNORED) {
+                op.rejectTime = System.currentTimeMillis();
+            } else if (mode == AppOpsManager.MODE_ALLOWED) {
+                if (op.noteOpCount != 0) {
+                    op.time = System.currentTimeMillis();
+                    op.rejectTime = 0;
+                }
+                if (op.startOpCount != 0) {
+                    if (op.nesting == 0) {
+                        op.time = System.currentTimeMillis();
+                        op.rejectTime = 0;
+                        op.duration = -1;
+                    }
+                    op.nesting = op.nesting + op.startOpCount;
+                    while (op.clientTokens.size() != 0) {
+                        IBinder clientToken = op.clientTokens.get(0);
+                        ClientState client = mClients.get(clientToken);
+                        if (client != null) {
+                            if (client.mStartedOps != null) {
+                                client.mStartedOps.add(op);
+                            }
+                        }
+                        op.clientTokens.remove(0);
+                    }
+                }
+            }
+            op.clientTokens.clear();
+            op.startOpCount = 0;
+            op.noteOpCount = 0;
+        }
+    }
+
+    public void notifyOperation(int code, int uid, String packageName,
+            int mode, boolean remember) {
+        verifyIncomingUid(uid);
+        verifyIncomingOp(code);
+        ArrayList<ModeCallback> repCbs = null;
+        int switchCode = AppOpsManager.opToSwitch(code);
+        synchronized (this) {
+            recordOperationLocked(code, uid, packageName, mode);
+            Op op = getOpLocked(switchCode, uid, packageName, true);
+            if (op != null) {
+                // Send result to all waiting client
+                if (op.dialogReqQueue.getDialog() != null) {
+                    op.dialogReqQueue.notifyAll(mode);
+                    op.dialogReqQueue.setDialog(null);
+                }
+                if (remember && op.mode != mode) {
+                    op.mode = mode;
+                    ArraySet<ModeCallback> cbs = mOpModeWatchers.get(switchCode);
+                    if (cbs != null) {
+                        if (repCbs == null) {
+                            repCbs = new ArrayList<ModeCallback>();
+                        }
+                        repCbs.addAll(cbs);
+                    }
+                    cbs = mPackageModeWatchers.get(packageName);
+                    if (cbs != null) {
+                        if (repCbs == null) {
+                            repCbs = new ArrayList<ModeCallback>();
+                        }
+                        repCbs.addAll(cbs);
+                    }
+                    if (mode == getDefaultMode(op.op, op.uid, op.packageName)) {
+                        // If going into the default mode, prune this op
+                        // if there is nothing else interesting in it.
+                        pruneOp(op, uid, packageName);
+                    }
+                    scheduleWriteLocked();
+                }
+            }
+        }
+        if (repCbs != null) {
+            for (int i = 0; i < repCbs.size(); i++) {
+                try {
+                    repCbs.get(i).mCallback.opChanged(switchCode, uid, packageName);
+                } catch (RemoteException e) {
+                }
+            }
+        }
+    }
+
     private static String resolvePackageName(int uid, String packageName)  {
         if (uid == Process.ROOT_UID) {
             return "root";
@@ -3792,4 +4077,71 @@ public class AppOpsService extends IAppOpsService.Stub {
             }
         }
     }
+
+    private void readPolicy() {
+        if (mStrictEnable) {
+            mPolicy = new AppOpsPolicy(new File(DEFAULT_POLICY_FILE), mContext);
+            mPolicy.readPolicy();
+            mPolicy.debugPoilcy();
+        } else {
+            mPolicy = null;
+        }
+    }
+
+    public boolean isControlAllowed(int code, String packageName) {
+        boolean isShow = true;
+        if (mPolicy != null) {
+            isShow = mPolicy.isControlAllowed(code, packageName);
+        }
+        return isShow;
+    }
+
+    @Override
+    public boolean getPrivacyGuardSettingForPackage(int uid, String packageName) {
+        for (int op : AppOpsManager.PRIVACY_GUARD_OP_STATES) {
+            int switchOp = AppOpsManager.opToSwitch(op);
+            int mode = checkOperation(op, uid, packageName);
+            if (mode != AppOpsManager.MODE_ALLOWED && mode != AppOpsManager.MODE_IGNORED) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void setPrivacyGuardSettingForPackage(int uid, String packageName, boolean state) {
+        for (int op : AppOpsManager.PRIVACY_GUARD_OP_STATES) {
+            int switchOp = AppOpsManager.opToSwitch(op);
+            setMode(switchOp, uid, packageName, state
+                    ? AppOpsManager.MODE_ASK : AppOpsManager.MODE_ALLOWED);
+        }
+    }
+
+    @Override
+    public void resetCounters() {
+        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,
+                Binder.getCallingPid(), Binder.getCallingUid(), null);
+        synchronized (this) {
+            for (int i = 0; i < mUidStates.size(); i++) {
+                final UidState uidState = mUidStates.valueAt(i);
+                if (uidState.pkgOps == null || uidState.pkgOps.isEmpty())
+                    continue;
+                for (Map.Entry<String, Ops> ent : uidState.pkgOps.entrySet()) {
+                    if (ent == null)
+                        continue;
+                    String packageName = ent.getKey();
+                    Ops pkgOps = ent.getValue();
+                    for (int j = 0; j < pkgOps.size(); j++) {
+                        Op curOp = pkgOps.valueAt(j);
+                        if (curOp == null)
+                            continue;
+                        curOp.allowedCount = 0;
+                        curOp.ignoredCount = 0;
+                    }
+                }
+            }
+            // ensure the counter reset persists
+            scheduleWriteLocked();
+        }
+    }
 }
diff --git a/services/core/java/com/android/server/BasePermissionDialog.java b/services/core/java/com/android/server/BasePermissionDialog.java
new file mode 100644
index 00000000000..e3dbcdabcd1
--- /dev/null
+++ b/services/core/java/com/android/server/BasePermissionDialog.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Message;
+import android.view.KeyEvent;
+import android.view.WindowManager;
+import android.widget.Button;
+
+import com.android.internal.R;
+
+public class BasePermissionDialog extends AlertDialog {
+    public BasePermissionDialog(Context context) {
+        super(context, com.android.internal.R.style.Theme_Dialog_AppError);
+        getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+        WindowManager.LayoutParams attrs = getWindow().getAttributes();
+        attrs.setTitle("Permission Dialog");
+        getWindow().setAttributes(attrs);
+        setIconAttribute(R.attr.alertDialogIcon);
+    }
+
+    public void onStart() {
+        super.onStart();
+        setEnabled(false);
+        mHandler.sendMessage(mHandler.obtainMessage(0));
+    }
+
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if (mConsuming) {
+            // Slog.i(TAG, "Consuming: " + event);
+            return true;
+        }
+        // Slog.i(TAG, "Dispatching: " + event);
+        return super.dispatchKeyEvent(event);
+    }
+
+    private void setEnabled(boolean enabled) {
+        Button b = (Button) findViewById(R.id.button1);
+        if (b != null) {
+            b.setEnabled(enabled);
+        }
+        b = (Button) findViewById(R.id.button2);
+        if (b != null) {
+            b.setEnabled(enabled);
+        }
+        b = (Button) findViewById(R.id.button3);
+        if (b != null) {
+            b.setEnabled(enabled);
+        }
+    }
+
+    private Handler mHandler = new Handler() {
+        public void handleMessage(Message msg) {
+            if (msg.what == 0) {
+                mConsuming = false;
+                setEnabled(true);
+            }
+        }
+    };
+
+    private boolean mConsuming = true;
+}
diff --git a/services/core/java/com/android/server/PermissionDialog.java b/services/core/java/com/android/server/PermissionDialog.java
new file mode 100644
index 00000000000..7da5a5af0b2
--- /dev/null
+++ b/services/core/java/com/android/server/PermissionDialog.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.AppOpsManager;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Resources;
+import android.os.Handler;
+import android.os.Message;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.CheckBox;
+import android.widget.TextView;
+
+public class PermissionDialog extends BasePermissionDialog {
+    private final static String TAG = "PermissionDialog";
+
+    private final AppOpsService mService;
+    private final String mPackageName;
+    private final int mCode;
+    private View  mView;
+    private CheckBox mChoice;
+    private int mUid;
+    final CharSequence[] mOpLabels;
+    private Context mContext;
+
+    // Event 'what' codes
+    static final int ACTION_ALLOWED = 0x2;
+    static final int ACTION_IGNORED = 0x4;
+    static final int ACTION_IGNORED_TIMEOUT = 0x8;
+
+    // 15s timeout, then we automatically dismiss the permission
+    // dialog. Otherwise, it may cause watchdog timeout sometimes.
+    static final long DISMISS_TIMEOUT = 1000 * 15 * 1;
+
+    public PermissionDialog(Context context, AppOpsService service,
+            int code, int uid, String packageName) {
+        super(context);
+
+        mContext = context;
+        Resources res = context.getResources();
+
+        mService = service;
+        mCode = code;
+        mPackageName = packageName;
+        mUid = uid;
+        mOpLabels = res.getTextArray(
+            com.android.internal.R.array.app_ops_labels);
+
+        setCancelable(false);
+
+        setButton(DialogInterface.BUTTON_POSITIVE,
+                  res.getString(com.android.internal.R.string.allow), mHandler.obtainMessage(ACTION_ALLOWED));
+
+        setButton(DialogInterface.BUTTON_NEGATIVE,
+                    res.getString(com.android.internal.R.string.deny), mHandler.obtainMessage(ACTION_IGNORED));
+
+        setTitle(res.getString(com.android.internal.R.string.privacy_guard_dialog_title));
+        WindowManager.LayoutParams attrs = getWindow().getAttributes();
+        attrs.setTitle("Permission info: " + getAppName(mPackageName));
+        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR
+                | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        getWindow().setAttributes(attrs);
+
+        mView = getLayoutInflater().inflate(
+             com.android.internal.R.layout.permission_confirmation_dialog,
+             null);
+        TextView tv = (TextView) mView.findViewById(
+            com.android.internal.R.id.permission_text);
+        mChoice = (CheckBox) mView.findViewById(
+            com.android.internal.R.id.permission_remember_choice_checkbox);
+        String name = getAppName(mPackageName);
+        if(name == null)
+            name = mPackageName;
+        tv.setText(mContext.getString(com.android.internal.R.string.privacy_guard_dialog_summary,
+                name, mOpLabels[mCode]));
+        setView(mView);
+
+        setIcon(com.android.internal.R.drawable.permission_dialog_trust);
+
+        // After the timeout, pretend the user clicked the quit button
+        mHandler.sendMessageDelayed(
+                mHandler.obtainMessage(ACTION_IGNORED_TIMEOUT), DISMISS_TIMEOUT);
+    }
+
+    public void ignore() {
+        mHandler.sendMessage(mHandler.obtainMessage(ACTION_IGNORED_TIMEOUT));
+    }
+
+    private String getAppName(String packageName) {
+        ApplicationInfo appInfo = null;
+        PackageManager pm = mContext.getPackageManager();
+        try {
+            appInfo = pm.getApplicationInfo(packageName,
+                      PackageManager.GET_DISABLED_COMPONENTS
+                      | PackageManager.GET_UNINSTALLED_PACKAGES);
+        } catch (final NameNotFoundException e) {
+            return null;
+        }
+        if(appInfo != null) {
+            return  (String)pm.getApplicationLabel(appInfo);
+        }
+        return null;
+    }
+
+    private final Handler mHandler = new Handler() {
+        public void handleMessage(Message msg) {
+            int mode;
+            boolean remember = mChoice.isChecked();
+            switch(msg.what) {
+                case ACTION_ALLOWED:
+                    mode = AppOpsManager.MODE_ALLOWED;
+                    break;
+                case ACTION_IGNORED:
+                    mode = AppOpsManager.MODE_IGNORED;
+                    break;
+                default:
+                    mode = AppOpsManager.MODE_IGNORED;
+                    remember = false;
+            }
+            mService.notifyOperation(mCode, mUid, mPackageName, mode,
+                remember);
+            dismiss();
+        }
+    };
+}
diff --git a/services/core/java/com/android/server/PermissionDialogReqQueue.java b/services/core/java/com/android/server/PermissionDialogReqQueue.java
new file mode 100644
index 00000000000..5b602e33a60
--- /dev/null
+++ b/services/core/java/com/android/server/PermissionDialogReqQueue.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PermissionDialogReqQueue {
+    public PermissionDialog getDialog() {
+        return mDialog;
+    }
+
+    public void setDialog(PermissionDialog mDialog) {
+        this.mDialog = mDialog;
+    }
+
+    public final static class PermissionDialogReq {
+        public void set(int res) {
+            synchronized (this) {
+                mHasResult = true;
+                mResult = res;
+                notifyAll();
+            }
+        }
+
+        public int get() {
+            synchronized (this) {
+                while (!mHasResult) {
+                    try {
+                        wait();
+                    } catch (InterruptedException e) {
+                    }
+                }
+            }
+            return mResult;
+        }
+
+        boolean mHasResult = false;
+        int mResult;
+    }
+
+    private PermissionDialog mDialog;
+    private List<PermissionDialogReq> resultList;
+
+    public PermissionDialogReqQueue() {
+        mDialog = null;
+        resultList = new ArrayList<PermissionDialogReq>();
+    }
+
+    public void register(PermissionDialogReq res) {
+        synchronized (this) {
+            resultList.add(res);
+        }
+    }
+
+    public void notifyAll(int mode) {
+        synchronized (this) {
+            while (resultList.size() != 0) {
+                PermissionDialogReq res = resultList.get(0);
+                res.set(mode);
+                resultList.remove(0);
+            }
+        }
+    }
+
+    public void ignore() {
+        if (mDialog != null) {
+            mDialog.ignore();
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index eeab1b6cd28..1fd1feb4aaa 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -1938,6 +1938,9 @@ public class ActivityManagerService extends IActivityManager.Stub
     static final int SERVICE_FOREGROUND_CRASH_MSG = 69;
     static final int DISPATCH_OOM_ADJ_OBSERVER_MSG = 70;
 
+    static final int POST_PRIVACY_NOTIFICATION_MSG = 90;
+    static final int CANCEL_PRIVACY_NOTIFICATION_MSG = 91;
+
     static final int FIRST_ACTIVITY_STACK_MSG = 100;
     static final int FIRST_BROADCAST_QUEUE_MSG = 200;
     static final int FIRST_COMPAT_MODE_MSG = 300;
@@ -2572,6 +2575,67 @@ public class ActivityManagerService extends IActivityManager.Stub
                 // it is finished we make sure it is reset to its default.
                 mUserIsMonkey = false;
             } break;
+            case POST_PRIVACY_NOTIFICATION_MSG: {
+                INotificationManager inm = NotificationManager.getService();
+                if (inm == null) {
+                    return;
+                }
+
+                ActivityRecord root = (ActivityRecord) msg.obj;
+                ProcessRecord process = root.app;
+                if (process == null) {
+                    return;
+                }
+
+                try {
+                    Context context = mContext.createPackageContext(process.info.packageName, 0);
+                    String text = mContext.getString(R.string.privacy_guard_notification_detail,
+                            context.getApplicationInfo().loadLabel(context.getPackageManager()));
+                    String title = mContext.getString(R.string.privacy_guard_notification);
+
+                    Intent infoIntent = new Intent(Settings.ACTION_APP_OPS_DETAILS_SETTINGS,
+                            Uri.fromParts("package", root.packageName, null));
+
+                    Notification.Builder builder = new Notification.Builder(mContext,
+                            SystemNotificationChannels.SECURITY);
+                    builder.setSmallIcon(com.android.internal.R.drawable.stat_notify_trust)
+                            .setOngoing(true)
+                            .setPriority(Notification.PRIORITY_LOW)
+                            .setContentTitle(title)
+                            .setContentText(text)
+                            .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0,
+                                    infoIntent, PendingIntent.FLAG_CANCEL_CURRENT, null,
+                                    new UserHandle(root.userId)));
+                    Notification notification = builder.build();
+
+                    try {
+                        int[] outId = new int[1];
+                        inm.enqueueNotificationWithTag("android", "android", null,
+                                R.string.privacy_guard_notification,
+                                notification, root.userId);
+                    } catch (RuntimeException e) {
+                        Slog.w(ActivityManagerService.TAG,
+                                "Error showing notification for privacy guard", e);
+                    } catch (RemoteException e) {
+                    }
+                } catch (NameNotFoundException e) {
+                    Slog.w(TAG, "Unable to create context for privacy guard notification", e);
+                }
+            } break;
+            case CANCEL_PRIVACY_NOTIFICATION_MSG: {
+                INotificationManager inm = NotificationManager.getService();
+                if (inm == null) {
+                    return;
+                }
+                try {
+                    inm.cancelNotificationWithTag("android", null,
+                            R.string.privacy_guard_notification,  msg.arg1);
+                } catch (RuntimeException e) {
+                    Slog.w(ActivityManagerService.TAG,
+                            "Error canceling notification for service", e);
+                } catch (RemoteException e) {
+                }
+            } break;
             case IDLE_UIDS_MSG: {
                 idleUids();
             } break;
diff --git a/services/core/java/com/android/server/am/ActivityRecord.java b/services/core/java/com/android/server/am/ActivityRecord.java
index c721b7e34f3..9c9632aafa3 100644
--- a/services/core/java/com/android/server/am/ActivityRecord.java
+++ b/services/core/java/com/android/server/am/ActivityRecord.java
@@ -191,6 +191,8 @@ import com.android.server.wm.AppWindowContainerListener;
 import com.android.server.wm.ConfigurationContainer;
 import com.android.server.wm.TaskWindowContainerController;
 
+import lineageos.providers.LineageSettings;
+
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlSerializer;
@@ -1889,6 +1891,33 @@ final class ActivityRecord extends ConfigurationContainer implements AppWindowCo
             // pause and then resume again later, which will result in a double life-cycle event.
             stack.checkReadyForSleep();
         }
+
+        updatePrivacyGuardNotificationLocked();
+    }
+
+    private final void updatePrivacyGuardNotificationLocked() {
+        String privacyGuardPackageName = mStackSupervisor.mPrivacyGuardPackageName;
+        if (privacyGuardPackageName != null && privacyGuardPackageName.equals(this.packageName)) {
+            return;
+        }
+
+        boolean privacy = service.mAppOpsService.getPrivacyGuardSettingForPackage(
+                this.app.uid, this.packageName);
+        boolean privacyNotification = (LineageSettings.Secure.getInt(
+                service.mContext.getContentResolver(),
+                LineageSettings.Secure.PRIVACY_GUARD_NOTIFICATION, 1) == 1);
+
+        if (privacyGuardPackageName != null && !privacy) {
+            Message msg = service.mHandler.obtainMessage(
+                    ActivityManagerService.CANCEL_PRIVACY_NOTIFICATION_MSG, this.userId);
+            msg.sendToTarget();
+            mStackSupervisor.mPrivacyGuardPackageName = null;
+        } else if (privacy && privacyNotification) {
+            Message msg = service.mHandler.obtainMessage(
+                    ActivityManagerService.POST_PRIVACY_NOTIFICATION_MSG, this);
+            msg.sendToTarget();
+            mStackSupervisor.mPrivacyGuardPackageName = this.packageName;
+        }
     }
 
     final void activityStoppedLocked(Bundle newIcicle, PersistableBundle newPersistentState,
diff --git a/services/core/java/com/android/server/am/ActivityStackSupervisor.java b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
index e034b824dc5..73c85af4982 100644
--- a/services/core/java/com/android/server/am/ActivityStackSupervisor.java
+++ b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
@@ -391,6 +391,11 @@ public class ActivityStackSupervisor extends ConfigurationContainer implements D
      * is being brought in front of us. */
     boolean mUserLeaving = false;
 
+    /**
+     * Is the privacy guard currently enabled? Shared between ActivityStacks
+     */
+    String mPrivacyGuardPackageName = null;
+
     /** Set when a power hint has started, but not ended. */
     private boolean mPowerHintSent;
 
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index 2faf95d7709..dd4804ade8e 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -271,6 +271,8 @@ import android.util.jar.StrictJarFile;
 import android.util.proto.ProtoOutputStream;
 import android.view.Display;
 
+import lineageos.providers.LineageSettings;
+
 import com.android.internal.R;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.app.IMediaContainerService;
@@ -1239,6 +1241,8 @@ public class PackageManagerService extends IPackageManager.Stub
 
     ArrayList<ComponentName> mDisabledComponentsList;
 
+    private AppOpsManager mAppOps;
+
     // Set of pending broadcasts for aggregating enable/disable of components.
     static class PendingPackageBroadcasts {
         // for each user id, a map of <package name -> components within that package>
@@ -2154,6 +2158,18 @@ public class PackageManagerService extends IPackageManager.Stub
                 }
             }
 
+            if (!update && !isSystemApp(res.pkg)) {
+                boolean privacyGuard = LineageSettings.Secure.getIntForUser(
+                        mContext.getContentResolver(),
+                        LineageSettings.Secure.PRIVACY_GUARD_DEFAULT,
+                        0, UserHandle.USER_CURRENT) == 1;
+                if (privacyGuard) {
+                    mAppOps.setPrivacyGuardSettingForPackage(
+                    res.pkg.applicationInfo.uid,
+                    res.pkg.applicationInfo.packageName, true);
+                }
+            }
+
             if (allNewUsers && !update) {
                 notifyPackageAdded(packageName);
             }
-- 
2.17.1

