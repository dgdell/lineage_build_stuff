diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 37faa2e..9cea491 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -2215,6 +2215,28 @@ public class ApplicationPackageManager extends PackageManager {
     }
 
     @Override
+    public void setComponentProtectedSetting(ComponentName componentName, boolean newState) {
+        try {
+            mPM.setComponentProtectedSetting(componentName, newState, mContext.getUserId());
+        } catch (RemoteException re) {
+            Log.e(TAG, "Failed to set component protected setting", re);
+        }
+    }
+
+    /** @hide */
+    @Override
+    public boolean isComponentProtected(String callingPackage, int callingUid,
+            ComponentName componentName) {
+        try {
+            return mPM.isComponentProtected(callingPackage, callingUid, componentName,
+                    mContext.getUserId());
+        } catch (RemoteException re) {
+            Log.e(TAG, "Failed to get component protected setting", re);
+            return false;
+        }
+    }
+
+    @Override
     public PackageInstaller getPackageInstaller() {
         synchronized (mLock) {
             if (mInstaller == null) {
diff --git a/core/java/android/content/pm/ApplicationInfo.java b/core/java/android/content/pm/ApplicationInfo.java
index cf30f0c..1d9f139 100644
--- a/core/java/android/content/pm/ApplicationInfo.java
+++ b/core/java/android/content/pm/ApplicationInfo.java
@@ -777,6 +777,13 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
      */
     public int networkSecurityConfigRes;
 
+    /**
+     * When true, indicates that any one component within this application is
+     * protected.
+     * @hide
+     */
+    public boolean protect = false;
+
     public void dump(Printer pw, String prefix) {
         dump(pw, prefix, DUMP_FLAG_ALL);
     }
@@ -940,6 +947,7 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
         backupAgentName = orig.backupAgentName;
         fullBackupContent = orig.fullBackupContent;
         networkSecurityConfigRes = orig.networkSecurityConfigRes;
+        protect = orig.protect;
     }
 
     public String toString() {
@@ -997,6 +1005,7 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
         dest.writeInt(uiOptions);
         dest.writeInt(fullBackupContent);
         dest.writeInt(networkSecurityConfigRes);
+        dest.writeInt(protect ? 1 : 0);
     }
 
     public static final Parcelable.Creator<ApplicationInfo> CREATOR
@@ -1054,6 +1063,7 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
         uiOptions = source.readInt();
         fullBackupContent = source.readInt();
         networkSecurityConfigRes = source.readInt();
+        protect = source.readInt() != 0;
     }
 
     /**
diff --git a/core/java/android/content/pm/IPackageManager.aidl b/core/java/android/content/pm/IPackageManager.aidl
index 11f0eb6..7417bac 100644
--- a/core/java/android/content/pm/IPackageManager.aidl
+++ b/core/java/android/content/pm/IPackageManager.aidl
@@ -573,4 +573,12 @@ interface IPackageManager {
     boolean isPackageDeviceAdminOnAnyUser(String packageName);
 
     List<String> getPreviousCodePaths(in String packageName);
+
+    /** Protected Apps */
+    void setComponentProtectedSetting(in ComponentName componentName,
+    in boolean newState, int userId);
+
+    /** Protected Apps */
+    boolean isComponentProtected(in String callingPackage, in int callingUid,
+    in ComponentName componentName, int userId);
 }
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index a75f111..0263431 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -2379,6 +2379,20 @@ public abstract class PackageManager {
             = "android.content.pm.extra.REQUEST_PERMISSIONS_RESULTS";
 
     /**
+     * Flag for {@link #setComponentProtectedSetting(android.content.ComponentName, boolean)}:
+     * This component or application has set to protected status
+     * @hide
+     */
+    public static final boolean COMPONENT_PROTECTED_STATUS = false;
+
+    /**
+     * Flag for {@link #setComponentProtectedSetting(android.content.ComponentName, boolean)}:
+     * This component or application has been explicitly set to visible status
+     * @hide
+     */
+    public static final boolean COMPONENT_VISIBLE_STATUS = true;
+
+    /**
      * String extra for {@link PackageInstallObserver} in the 'extras' Bundle in case of
      * {@link #INSTALL_FAILED_DUPLICATE_PERMISSION}.  This extra names the package which provides
      * the existing definition for the permission.
@@ -5611,6 +5625,19 @@ public abstract class PackageManager {
     public abstract @NonNull PackageInstaller getPackageInstaller();
 
     /**
+     * Update Component protection state
+     * @hide
+     */
+    public abstract void setComponentProtectedSetting(ComponentName componentName, boolean newState);
+
+    /**
+     * Return whether or not a specific component is protected
+     * @hide
+     */
+    public abstract boolean isComponentProtected(String callingPackage, int callingUid,
+            ComponentName componentName);
+
+    /**
      * Adds a {@code CrossProfileIntentFilter}. After calling this method all
      * intents sent from the user with id sourceUserId can also be be resolved
      * by activities in the user with id targetUserId if they match the
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index b89263f..187da41 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -5404,6 +5404,12 @@ public class PackageParser {
                 && p.usesLibraryFiles != null) {
             return true;
         }
+        if (state.protectedComponents != null) {
+            boolean protect = state.protectedComponents.size() > 0;
+            if (p.applicationInfo.protect != protect) {
+                return true;
+            }
+        }
         return false;
     }
 
@@ -5442,6 +5448,9 @@ public class PackageParser {
             ai.enabled = false;
         }
         ai.enabledSetting = state.enabled;
+        if (state.protectedComponents != null) {
+            ai.protect = state.protectedComponents.size() > 0;
+        }
     }
 
     public static ApplicationInfo generateApplicationInfo(Package p, int flags,
diff --git a/core/java/android/content/pm/PackageUserState.java b/core/java/android/content/pm/PackageUserState.java
index 995d2cc..e64e4c4 100644
--- a/core/java/android/content/pm/PackageUserState.java
+++ b/core/java/android/content/pm/PackageUserState.java
@@ -50,6 +50,8 @@ public class PackageUserState {
 
     public ArraySet<String> disabledComponents;
     public ArraySet<String> enabledComponents;
+    public ArraySet<String> protectedComponents;
+    public ArraySet<String> visibleComponents;
 
     public PackageUserState() {
         installed = true;
@@ -74,6 +76,11 @@ public class PackageUserState {
         appLinkGeneration = o.appLinkGeneration;
         disabledComponents = ArrayUtils.cloneOrNull(o.disabledComponents);
         enabledComponents = ArrayUtils.cloneOrNull(o.enabledComponents);
+        protectedComponents = o.protectedComponents != null
+                ? new ArraySet<String>(o.protectedComponents) : null;
+        visibleComponents = o.visibleComponents != null
+                ? new ArraySet<String>(o.visibleComponents) : null;
+
     }
 
     /**
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 62e06ef..5bd45da 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -6322,6 +6322,11 @@ public final class Settings {
          */
         public static final String SLEEP_TIMEOUT = "sleep_timeout";
 
+         /** Protected Components
+         * @hide
+         */
+        public static final String PROTECTED_COMPONENTS = "protected_components";
+
         /**
          * Controls whether double tap to wake is enabled.
          * @hide
diff --git a/core/res/res/drawable/stat_notify_protected.xml b/core/res/res/drawable/stat_notify_protected.xml
new file mode 100644
index 0000000..d67a348
--- /dev/null
+++ b/core/res/res/drawable/stat_notify_protected.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright (C) 2016 The CyanogenMod Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="26dp"
+        android:height="24dp"
+        android:viewportWidth="26"
+        android:viewportHeight="24">
+
+    <path
+            android:pathData="M0 0h24v24H0z" />
+    <path
+            android:fillColor="#000000"
+            android:pathData="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" />
+</vector>
\ No newline at end of file
diff --git a/core/res/res/values/cm_strings.xml b/core/res/res/values/cm_strings.xml
index ef2dab5..bcb789c 100644
--- a/core/res/res/values/cm_strings.xml
+++ b/core/res/res/values/cm_strings.xml
@@ -136,4 +136,8 @@
     <string name="app_ops_run_in_background">run in background</string>
     <string name="app_ops_wifi_change">change WiFI state</string>
     <string name="app_ops_su">get Superuser access</string>
+
+    <!-- Protected Apps Notification -->
+    <string name="notify_package_component_protected_title">Activity launch blocked</string>
+    <string name="notify_package_component_protected_text"><xliff:g id="app_name">%1$s</xliff:g> is protected from being launched. Tap to authenticate and launch the application.</string>
 </resources>
diff --git a/core/res/res/values/cm_symbols.xml b/core/res/res/values/cm_symbols.xml
index 455fdc2..fb78cba 100644
--- a/core/res/res/values/cm_symbols.xml
+++ b/core/res/res/values/cm_symbols.xml
@@ -61,4 +61,9 @@
 
     <!-- Carrier Apps -->
     <java-symbol type="array" name="config_enabledPreinstalledCarrierApps" />
+
+    <!-- Protected Apps -->
+    <java-symbol type="drawable" name="stat_notify_protected" />
+    <java-symbol type="string" name="notify_package_component_protected_title" />
+    <java-symbol type="string" name="notify_package_component_protected_text" />
 </resources>
diff --git a/core/tests/coretests/src/android/content/pm/PackageManagerTests.java b/core/tests/coretests/src/android/content/pm/PackageManagerTests.java
index b5f0617..7decc0a 100644
--- a/core/tests/coretests/src/android/content/pm/PackageManagerTests.java
+++ b/core/tests/coretests/src/android/content/pm/PackageManagerTests.java
@@ -27,6 +27,7 @@ import static android.system.OsConstants.S_IXOTH;
 
 import android.app.PackageInstallObserver;
 import android.content.BroadcastReceiver;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
@@ -3869,4 +3870,21 @@ public class PackageManagerTests extends AndroidTestCase {
      * how to do tests on updated system apps?
      * verify updates to system apps cannot be installed on the sdcard.
      */
+
+    //CM Tests
+    public void testIsComponentProtectedFromSamePackage() {
+        ComponentName testComponentName = new ComponentName("com.android.test",
+                "com.android.test.component.protected");
+        getPm().setComponentProtectedSetting(testComponentName, true);
+        assertFalse(getPm().isComponentProtected(testComponentName.getPackageName(),
+                testComponentName));
+    }
+
+    public void testIsComponentProtectedFromManagers() {
+        ComponentName testComponentName = new ComponentName("com.android.test",
+                "com.android.test.component.protected");
+        getPm().setComponentProtectedSetting(testComponentName, true);
+        assertFalse(getPm().isComponentProtected(testComponentName.getPackageName(),
+                testComponentName));
+    }
 }
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index c8d7287..3c1b6d4 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -1573,6 +1573,8 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     static final int POST_PRIVACY_NOTIFICATION_MSG = 90;
     static final int CANCEL_PRIVACY_NOTIFICATION_MSG = 91;
+    static final int POST_COMPONENT_PROTECTED_MSG = 92;
+    static final int CANCEL_PROTECTED_APP_NOTIFICATION = 93;
 
     static final int FIRST_ACTIVITY_STACK_MSG = 100;
     static final int FIRST_BROADCAST_QUEUE_MSG = 200;
@@ -2469,6 +2471,87 @@ public final class ActivityManagerService extends ActivityManagerNative
                             r.info.getComponentName(), false);
                 }
             } break;
+            case POST_COMPONENT_PROTECTED_MSG: {
+                INotificationManager inm = NotificationManager.getService();
+                if (inm == null) {
+                    return;
+                }
+
+                Intent targetIntent = (Intent) msg.obj;
+                if (targetIntent == null) {
+                    return;
+                }
+
+                int currentUserId = mUserController.getCurrentUserIdLocked();
+                int targetUserId = targetIntent.getIntExtra(
+                        "com.android.settings.PROTECTED_APPS_USER_ID", currentUserId);
+                // Resolve for labels and whatnot
+                ActivityInfo root = resolveActivityInfo(targetIntent, targetIntent.getFlags(),
+                        targetUserId);
+
+                try {
+                    Intent protectedAppIntent = new Intent();
+                    protectedAppIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
+                    protectedAppIntent.setComponent(
+                            new ComponentName("com.android.settings",
+                                    "com.android.settings.applications.ProtectedAppsActivity"));
+                    protectedAppIntent.putExtra(
+                            "com.android.settings.PROTECTED_APP_TARGET_INTENT",
+                            targetIntent);
+                    Context context = mContext.createPackageContext("com.android.settings", 0);
+                    String title = mContext.getString(
+                            com.android.internal.R.string
+                                    .notify_package_component_protected_title);
+                    String text = mContext.getString(
+                            com.android.internal.R.string
+                                    .notify_package_component_protected_text,
+                            root.applicationInfo.loadLabel(mContext.getPackageManager()));
+                    Notification notification = new Notification.Builder(context)
+                            .setSmallIcon(com.android.internal.R.drawable.stat_notify_protected)
+                            .setWhen(0)
+                            .setTicker(title)
+                            .setColor(mContext.getColor(
+                                    com.android.internal.R.color
+                                            .system_notification_accent_color))
+                            .setContentTitle(title)
+                            .setContentText(text)
+                            .setDefaults(Notification.DEFAULT_VIBRATE)
+                            .setPriority(Notification.PRIORITY_MAX)
+                            .setStyle(new Notification.BigTextStyle().bigText(text))
+                            .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0,
+                                    protectedAppIntent, PendingIntent.FLAG_CANCEL_CURRENT, null,
+                                    new UserHandle(currentUserId)))
+                            .build();
+                    try {
+                        int[] outId = new int[1];
+                        inm.cancelNotificationWithTag("android", null,
+                                R.string.notify_package_component_protected_title, msg.arg1);
+                        inm.enqueueNotificationWithTag("android", "android", null,
+                                R.string.notify_package_component_protected_title,
+                                notification, outId, currentUserId);
+                    } catch (RuntimeException e) {
+                        Slog.w(ActivityManagerService.TAG,
+                                "Error showing notification for protected app component", e);
+                    } catch (RemoteException e) {
+                    }
+                } catch (NameNotFoundException e) {
+                    Slog.w(TAG, "Unable to create context for protected app notification", e);
+                }
+            } break;
+            case CANCEL_PROTECTED_APP_NOTIFICATION: {
+                INotificationManager inm = NotificationManager.getService();
+                if (inm == null) {
+                    return;
+                }
+                try {
+                    inm.cancelNotificationWithTag("android", null,
+                            R.string.notify_package_component_protected_title, msg.arg1);
+                } catch (RuntimeException e) {
+                    Slog.w(ActivityManagerService.TAG,
+                            "Error canceling notification for service", e);
+                } catch (RemoteException e) {
+                }
+            } break;
             }
         }
     };
@@ -18185,7 +18268,6 @@ public final class ActivityManagerService extends ActivityManagerNative
                         + callingPid + ", uid=" + callingUid;
                 Slog.w(TAG, msg);
                 throw new SecurityException(msg);
-
             } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)
                     || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
                 // Special case for compatibility: we don't want apps to send this,
@@ -18440,6 +18522,15 @@ public final class ActivityManagerService extends ActivityManagerNative
                     }
                     // Lie; we don't want to crash the app.
                     return ActivityManager.BROADCAST_SUCCESS;
+                case cyanogenmod.content.Intent.ACTION_PROTECTED_CHANGED:
+                    final boolean state =
+                            intent.getBooleanExtra(
+                                    cyanogenmod.content.Intent.EXTRA_PROTECTED_STATE, false);
+                    if (state == PackageManager.COMPONENT_PROTECTED_STATUS) {
+                        mRecentTasks.cleanupProtectedComponentTasksLocked(
+                                mUserController.getCurrentUserIdLocked());
+                    }
+                    break;
             }
         }
 
diff --git a/services/core/java/com/android/server/am/ActivityStack.java b/services/core/java/com/android/server/am/ActivityStack.java
index 712e3f2..191dd74 100644
--- a/services/core/java/com/android/server/am/ActivityStack.java
+++ b/services/core/java/com/android/server/am/ActivityStack.java
@@ -117,6 +117,7 @@ import android.os.SystemClock;
 import android.os.Trace;
 import android.os.UserHandle;
 import android.service.voice.IVoiceInteractionSession;
+import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.EventLog;
 import android.util.Log;
@@ -363,6 +364,9 @@ final class ActivityStack {
         }
     }
 
+    private static final String PROTECTED_APPS_TARGET_VALIDATION_COMPONENT =
+            "com.android.settings/com.android.settings.applications.ProtectedAppsActivity";
+
     final Handler mHandler;
 
     static final ActivityTrigger mActivityTrigger = new ActivityTrigger();
@@ -1470,6 +1474,7 @@ final class ActivityStack {
         }
 
         updatePrivacyGuardNotificationLocked(next);
+        updateProtectedAppNotificationLocked(next);
     }
 
     private void setVisible(ActivityRecord r, boolean visible) {
@@ -2709,6 +2714,16 @@ final class ActivityStack {
         updateTaskMovement(task, true);
     }
 
+    private final void updateProtectedAppNotificationLocked(ActivityRecord next) {
+        ComponentName componentName = ComponentName.unflattenFromString(next.shortComponentName);
+        if (TextUtils.equals(componentName.flattenToString(),
+                PROTECTED_APPS_TARGET_VALIDATION_COMPONENT)) {
+            Message msg = mService.mHandler.obtainMessage(
+                    ActivityManagerService.CANCEL_PROTECTED_APP_NOTIFICATION, next);
+            msg.sendToTarget();
+        }
+    }
+
     private final void updatePrivacyGuardNotificationLocked(ActivityRecord next) {
 
         String privacyGuardPackageName = mStackSupervisor.mPrivacyGuardPackageName;
diff --git a/services/core/java/com/android/server/am/ActivityStarter.java b/services/core/java/com/android/server/am/ActivityStarter.java
index 06d8e48..2aca406 100644
--- a/services/core/java/com/android/server/am/ActivityStarter.java
+++ b/services/core/java/com/android/server/am/ActivityStarter.java
@@ -102,6 +102,7 @@ import android.os.Binder;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.IBinder;
+import android.os.Message;
 import android.os.PowerManagerInternal;
 import android.os.Process;
 import android.os.RemoteException;
@@ -362,6 +363,28 @@ class ActivityStarter {
             }
         }
 
+        if (err == ActivityManager.START_SUCCESS && intent.getComponent() != null) {
+            try {
+                boolean isProtected = AppGlobals.getPackageManager().isComponentProtected(
+                        callingPackage, callingUid, intent.getComponent(), userId) &&
+                        (launchFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) == 0;
+
+                if (isProtected) {
+                    Message msg = mService.mHandler.obtainMessage(
+                            ActivityManagerService.POST_COMPONENT_PROTECTED_MSG);
+                    // Store launch flags, userid
+                    intent.setFlags(launchFlags);
+                    intent.putExtra("com.android.settings.PROTECTED_APPS_USER_ID", userId);
+                    msg.obj = intent;
+                    mService.mHandler.sendMessage(msg);
+                    err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;
+                }
+            } catch (RemoteException e) {
+                Slog.w(TAG, "Failure checking protected apps status", e);
+                err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;
+            }
+        }
+
         final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;
 
         if (err != START_SUCCESS) {
@@ -768,6 +791,29 @@ class ActivityStarter {
                 // Cannot start a child activity if the parent is not resumed.
                 return ActivityManager.START_CANCELED;
             }
+
+            try {
+                //TODO: This needs to be a flushed out API in the future.
+                boolean isProtected = intent.getComponent() != null
+                        && AppGlobals.getPackageManager()
+                        .isComponentProtected(callingPackage, callingUid,
+                                intent.getComponent(), userId) &&
+                        (intent.getFlags()&Intent.FLAG_GRANT_READ_URI_PERMISSION) == 0;
+
+                if (isProtected) {
+                    Message msg = mService.mHandler.obtainMessage(
+                            ActivityManagerService.POST_COMPONENT_PROTECTED_MSG);
+                    //Store start flags, userid
+                    intent.setFlags(startFlags);
+                    intent.putExtra("com.android.settings.PROTECTED_APPS_USER_ID", userId);
+                    msg.obj = intent;
+                    mService.mHandler.sendMessage(msg);
+                    return ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;
+                }
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+
             final int realCallingPid = Binder.getCallingPid();
             final int realCallingUid = Binder.getCallingUid();
             int callingPid;
diff --git a/services/core/java/com/android/server/am/RecentTasks.java b/services/core/java/com/android/server/am/RecentTasks.java
index beb863b..f9531a6 100644
--- a/services/core/java/com/android/server/am/RecentTasks.java
+++ b/services/core/java/com/android/server/am/RecentTasks.java
@@ -110,6 +110,7 @@ class RecentTasks extends ArrayList<TaskRecord> {
             Slog.i(TAG, "Loading recents for user " + userId + " into memory.");
             addAll(mTaskPersister.restoreTasksForUserLocked(userId));
             cleanupLocked(userId);
+            cleanupProtectedComponentTasksLocked(userId);
             mUsersWithRecentsLoaded.put(userId, true);
         }
     }
@@ -272,6 +273,35 @@ class RecentTasks extends ArrayList<TaskRecord> {
     }
 
     /**
+     * Clear out protected tasks from the list
+     */
+    void cleanupProtectedComponentTasksLocked(int userId) {
+        int recentsCount = size();
+        if (recentsCount == 0) {
+            // Happens when called from the packagemanager broadcast before boot,
+            // or just any empty list.
+            return;
+        }
+
+        final IPackageManager pm = AppGlobals.getPackageManager();
+        for (int i = recentsCount - 1; i >= 0; i--) {
+            final TaskRecord task = get(i);
+            if (userId != UserHandle.USER_ALL && task.userId != userId) {
+                // Only look at tasks for the user ID of interest.
+                continue;
+            }
+            try {
+                if (task.realActivity != null &&
+                        pm.isComponentProtected(null, -1, task.realActivity, userId)) {
+                    remove(i);
+                    task.removedFromRecents();
+                }
+            } catch (RemoteException e) {
+            }
+        }
+    }
+
+    /**
      * Update the recent tasks lists: make sure tasks should still be here (their
      * applications / activities still exist), update their availability, fix-up ordering
      * of affiliations.
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index 971c595..edd658e 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -372,6 +372,7 @@ public class PackageManagerService extends IPackageManager.Stub {
     private static final boolean DEBUG_EPHEMERAL = Build.IS_DEBUGGABLE;
     private static final boolean DEBUG_TRIAGED_MISSING = false;
     private static final boolean DEBUG_APP_DATA = false;
+    private static final boolean DEBUG_PROTECTED = false;
 
     static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
 
@@ -524,6 +525,9 @@ public class PackageManagerService extends IPackageManager.Stub {
     /** Special library name that skips shared libraries check during compilation. */
     private static final String SKIP_SHARED_LIBRARY_CHECK = "&";
 
+    private static final String PROTECTED_APPS_TARGET_VALIDATION_COMPONENT =
+            "com.android.settings/com.android.settings.applications.ProtectedAppsActivity";
+
     final ServiceThread mHandlerThread;
 
     final PackageHandler mHandler;
@@ -10559,8 +10563,26 @@ public class PackageManagerService extends IPackageManager.Stub {
                 int userId) {
             if (!sUserManager.exists(userId)) return null;
             mFlags = flags;
-            return super.queryIntent(intent, resolvedType,
+            List<ResolveInfo> list = super.queryIntent(intent, resolvedType,
                     (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId);
+            // Remove protected Application components if they're explicitly queried for.
+            // Implicit intent queries will be gated when the returned component is acted upon.
+            int callingUid = Binder.getCallingUid();
+            List<String> packages = Arrays.asList(getPackagesForUid(callingUid));
+            final boolean isNotSystem = callingUid != Process.SYSTEM_UID &&
+                    (getFlagsForUid(callingUid) & ApplicationInfo.FLAG_SYSTEM) == 0;
+
+            if (isNotSystem && intent.getComponent() != null) {
+               Iterator<ResolveInfo> itr = list.iterator();
+                while (itr.hasNext()) {
+                    ActivityInfo activityInfo = itr.next().activityInfo;
+                    if (activityInfo.applicationInfo.protect && (packages == null
+                            || !packages.contains(activityInfo.packageName))) {
+                        itr.remove();
+                    }
+                }
+            }
+            return list;
         }
 
         public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType,
@@ -16587,7 +16609,8 @@ public class PackageManagerService extends IPackageManager.Stub {
                     false /*installed*/, true /*stopped*/, true /*notLaunched*/,
                     false /*hidden*/, false /*suspended*/, null, null, null,
                     false /*blockUninstall*/,
-                    ps.readUserState(nextUserId).domainVerificationStatus, 0);
+                    ps.readUserState(nextUserId).domainVerificationStatus, 0,
+                    null, null);
         }
     }
 
@@ -20829,6 +20852,140 @@ Slog.v(TAG, ":: stepped forward, applying functor at tag " + parser.getName());
     }
 
     @Override
+    public void setComponentProtectedSetting(ComponentName componentName, boolean newState,
+            int userId) {
+        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "set protected");
+
+        String packageName = componentName.getPackageName();
+        String className = componentName.getClassName();
+
+        PackageSetting pkgSetting;
+        ArrayList<String> components;
+
+        synchronized (mPackages) {
+            pkgSetting = mSettings.mPackages.get(packageName);
+
+            if (pkgSetting == null) {
+                if (className == null) {
+                    throw new IllegalArgumentException(
+                            "Unknown package: " + packageName);
+                }
+                throw new IllegalArgumentException(
+                        "Unknown component: " + packageName
+                                + "/" + className);
+            }
+
+            //Protection levels must be applied at the Component Level!
+            if (className == null) {
+                throw new IllegalArgumentException(
+                        "Must specify Component Class name."
+                );
+            } else {
+                PackageParser.Package pkg = pkgSetting.pkg;
+                if (pkg == null || !pkg.hasComponentClassName(className)) {
+                    if (pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
+                        throw new IllegalArgumentException("Component class " + className
+                                + " does not exist in " + packageName);
+                    } else {
+                        Slog.w(TAG, "Failed setComponentProtectedSetting: component class "
+                                + className + " does not exist in " + packageName);
+                    }
+                }
+
+                pkgSetting.protectComponentLPw(className, newState, userId);
+                mSettings.writePackageRestrictionsLPr(userId);
+
+                components = mPendingBroadcasts.get(userId, packageName);
+                final boolean newPackage = components == null;
+                if (newPackage) {
+                    components = new ArrayList<String>();
+                }
+                if (!components.contains(className)) {
+                    components.add(className);
+                }
+            }
+        }
+
+        long callingId = Binder.clearCallingIdentity();
+        try {
+            int packageUid = UserHandle.getUid(userId, pkgSetting.appId);
+        } finally {
+            Binder.restoreCallingIdentity(callingId);
+        }
+    }
+
+    @Override
+    public boolean isComponentProtected(String callingPackage, int callingUid,
+            ComponentName componentName, int userId) {
+        if (DEBUG_PROTECTED) Log.d(TAG, "Checking if component is protected "
+                + componentName.flattenToShortString() + " from calling package " + callingPackage
+                + " and callinguid " + callingUid);
+
+        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "set protected");
+
+        //Allow managers full access
+        List<String> protectedComponentManagers =
+                CMSettings.Secure.getDelimitedStringAsList(mContext.getContentResolver(),
+                        CMSettings.Secure.PROTECTED_COMPONENT_MANAGERS, "|");
+        if (protectedComponentManagers.contains(callingPackage)) {
+            if (DEBUG_PROTECTED) Log.d(TAG, "Calling package is a protected manager, allow");
+            return false;
+        }
+
+        String packageName = componentName.getPackageName();
+        String className = componentName.getClassName();
+
+        //If this component is launched from the same package, allow it.
+        if (TextUtils.equals(packageName, callingPackage)) {
+            if (DEBUG_PROTECTED) Log.d(TAG, "Calling package is same as target, allow");
+            return false;
+        }
+
+        //If this component is launched from a validation component, allow it.
+        if (TextUtils.equals(PROTECTED_APPS_TARGET_VALIDATION_COMPONENT,
+                componentName.flattenToString()) && callingUid == Process.SYSTEM_UID) {
+            return false;
+        }
+
+        //If this component is launched from the system or a uid of a protected component, allow it.
+        boolean fromProtectedComponentUid = false;
+        for (String protectedComponentManager : protectedComponentManagers) {
+            int packageUid = getPackageUid(protectedComponentManager,
+                    MATCH_DEBUG_TRIAGED_MISSING, userId);
+            if (packageUid != -1 && callingUid == packageUid) {
+                fromProtectedComponentUid = true;
+            }
+        }
+
+        if (TextUtils.equals(callingPackage, "android") && callingUid == Process.SYSTEM_UID
+                || callingPackage == null && fromProtectedComponentUid) {
+            if (DEBUG_PROTECTED) Log.d(TAG, "Calling package is android or manager, allow");
+            return false;
+        }
+
+        PackageSetting pkgSetting;
+        ArraySet<String> components;
+
+        synchronized (mPackages) {
+            pkgSetting = mSettings.mPackages.get(packageName);
+
+            if (pkgSetting == null) {
+                if (className == null) {
+                    throw new IllegalArgumentException(
+                            "Unknown package: " + packageName);
+                }
+                throw new IllegalArgumentException(
+                        "Unknown component: " + packageName
+                                + "/" + className);
+            }
+            // Get all the protected components
+            components = pkgSetting.getProtectedComponents(userId);
+            if (DEBUG_PROTECTED) Log.d(TAG, "Got " + components.size() + " protected components");
+            return components.size() > 0;
+        }
+    }
+
+    @Override
     public boolean isStorageLow() {
         final long token = Binder.clearCallingIdentity();
         try {
diff --git a/services/core/java/com/android/server/pm/PackageSettingBase.java b/services/core/java/com/android/server/pm/PackageSettingBase.java
index 851f085..75427a8 100644
--- a/services/core/java/com/android/server/pm/PackageSettingBase.java
+++ b/services/core/java/com/android/server/pm/PackageSettingBase.java
@@ -19,6 +19,7 @@ package com.android.server.pm;
 import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
 import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
 import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
+import static android.content.pm.PackageManager.COMPONENT_VISIBLE_STATUS;
 
 import android.content.pm.IntentFilterVerificationInfo;
 import android.content.pm.PackageManager;
@@ -378,7 +379,8 @@ abstract class PackageSettingBase extends SettingBase {
             boolean notLaunched, boolean hidden, boolean suspended,
             String lastDisableAppCaller, ArraySet<String> enabledComponents,
             ArraySet<String> disabledComponents, boolean blockUninstall, int domainVerifState,
-            int linkGeneration) {
+            int linkGeneration,
+            ArraySet<String> protectedComponents, ArraySet<String> visibleComponents) {
         PackageUserState state = modifyUserState(userId);
         state.ceDataInode = ceDataInode;
         state.enabled = enabled;
@@ -393,6 +395,8 @@ abstract class PackageSettingBase extends SettingBase {
         state.blockUninstall = blockUninstall;
         state.domainVerificationStatus = domainVerifState;
         state.appLinkGeneration = linkGeneration;
+        state.protectedComponents = protectedComponents;
+        state.visibleComponents = visibleComponents;
     }
 
     ArraySet<String> getEnabledComponents(int userId) {
@@ -432,6 +436,17 @@ abstract class PackageSettingBase extends SettingBase {
         return state;
     }
 
+    PackageUserState modifyUserStateComponents(int userId) {
+        PackageUserState state = modifyUserState(userId);
+        if (state.protectedComponents == null) {
+           state.protectedComponents = new ArraySet<String>(1);
+        }
+        if (state.visibleComponents == null) {
+            state.visibleComponents = new ArraySet<String>(1);
+        }
+        return state;
+    }
+
     void addDisabledComponent(String componentClassName, int userId) {
         modifyUserStateComponents(userId, true, false).disabledComponents.add(componentClassName);
     }
@@ -477,6 +492,27 @@ abstract class PackageSettingBase extends SettingBase {
         }
     }
 
+    boolean protectComponentLPw(String componentClassName, boolean protect, int userId) {
+        PackageUserState state = modifyUserStateComponents(userId);
+        boolean changed = false;
+        if (protect == COMPONENT_VISIBLE_STATUS) {
+            changed = state.protectedComponents != null
+                    ? state.protectedComponents.remove(componentClassName) : false;
+            changed |= state.visibleComponents.add(componentClassName);
+        } else {
+            changed = state.visibleComponents != null
+                    ? state.visibleComponents.remove(componentClassName) : false;
+            changed |= state.protectedComponents.add(componentClassName);
+        }
+
+        return changed;
+    }
+
+    ArraySet<String> getProtectedComponents(int userId) {
+        PackageUserState state = modifyUserStateComponents(userId);
+        return state.protectedComponents;
+    }
+
     void removeUser(int userId) {
         userState.delete(userId);
     }
diff --git a/services/core/java/com/android/server/pm/Settings.java b/services/core/java/com/android/server/pm/Settings.java
old mode 100644
new mode 100755
index 7e3cd0a..285b5bb
--- a/services/core/java/com/android/server/pm/Settings.java
+++ b/services/core/java/com/android/server/pm/Settings.java
@@ -192,6 +192,9 @@ final class Settings {
     private static final String TAG_DEFAULT_DIALER = "default-dialer";
     private static final String TAG_VERSION = "version";
 
+    private static final String TAG_PROTECTED_COMPONENTS = "protected-components";
+    private static final String TAG_VISIBLE_COMPONENTS = "visible-components";
+
     private static final String ATTR_NAME = "name";
     private static final String ATTR_USER = "user";
     private static final String ATTR_CODE = "code";
@@ -808,7 +811,10 @@ final class Settings {
                                     false, // suspended
                                     null, null, null,
                                     false, // blockUninstall
-                                    INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0);
+                                    INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0,
+                                    null,
+                                    null
+                                    );
                             writePackageRestrictionsLPr(user.id);
                         }
                     }
@@ -1609,7 +1615,10 @@ final class Settings {
                                 false,  // suspended
                                 null, null, null,
                                 false, // blockUninstall
-                                INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0);
+                                INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0,
+                                null,
+                                null
+                                );
                     }
                     return;
                 }
@@ -1692,6 +1701,8 @@ final class Settings {
 
                     ArraySet<String> enabledComponents = null;
                     ArraySet<String> disabledComponents = null;
+                    ArraySet<String> protectedComponents = null;
+                    ArraySet<String> visibleComponents = null;
 
                     int packageDepth = parser.getDepth();
                     while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
@@ -1706,12 +1717,17 @@ final class Settings {
                             enabledComponents = readComponentsLPr(parser);
                         } else if (tagName.equals(TAG_DISABLED_COMPONENTS)) {
                             disabledComponents = readComponentsLPr(parser);
+                        } else if (tagName.equals(TAG_PROTECTED_COMPONENTS)) {
+                            protectedComponents = readComponentsLPr(parser);
+                        } else if (tagName.equals(TAG_VISIBLE_COMPONENTS)) {
+                            visibleComponents = readComponentsLPr(parser);
                         }
                     }
 
                     ps.setUserState(userId, ceDataInode, enabled, installed, stopped, notLaunched,
                             hidden, suspended, enabledCaller, enabledComponents, disabledComponents,
-                            blockUninstall, verifState, linkGeneration);
+                            blockUninstall, verifState, linkGeneration,
+                            protectedComponents, visibleComponents);
                 } else if (tagName.equals("preferred-activities")) {
                     readPreferredActivitiesLPw(parser, userId);
                 } else if (tagName.equals(TAG_PERSISTENT_PREFERRED_ACTIVITIES)) {
@@ -2017,6 +2033,25 @@ final class Settings {
                     serializer.endTag(null, TAG_DISABLED_COMPONENTS);
                 }
 
+                if (!ArrayUtils.isEmpty(ustate.protectedComponents)) {
+                    serializer.startTag(null, TAG_PROTECTED_COMPONENTS);
+                    for (final String name : ustate.protectedComponents) {
+                        serializer.startTag(null, TAG_ITEM);
+                        serializer.attribute(null, ATTR_NAME, name);
+                        serializer.endTag(null, TAG_ITEM);
+                    }
+                    serializer.endTag(null, TAG_PROTECTED_COMPONENTS);
+                }
+                if (!ArrayUtils.isEmpty(ustate.visibleComponents)) {
+                    serializer.startTag(null, TAG_VISIBLE_COMPONENTS);
+                    for (final String name : ustate.visibleComponents) {
+                        serializer.startTag(null, TAG_ITEM);
+                        serializer.attribute(null, ATTR_NAME, name);
+                        serializer.endTag(null, TAG_ITEM);
+                    }
+                    serializer.endTag(null, TAG_VISIBLE_COMPONENTS);
+                }
+
                 serializer.endTag(null, TAG_PACKAGE);
             }
 
diff --git a/test-runner/src/android/test/mock/MockPackageManager.java b/test-runner/src/android/test/mock/MockPackageManager.java
index 330dbab..31cacfb 100644
--- a/test-runner/src/android/test/mock/MockPackageManager.java
+++ b/test-runner/src/android/test/mock/MockPackageManager.java
@@ -998,6 +998,23 @@ public class MockPackageManager extends PackageManager {
      * @hide
      */
     @Override
+    public void setComponentProtectedSetting(ComponentName componentName, boolean newState) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public boolean isComponentProtected(String callingPackage, int callingUid,
+            ComponentName componentName) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * @hide
+     */
+    @Override
     public VerifierDeviceIdentity getVerifierDeviceIdentity() {
         throw new UnsupportedOperationException();
     }
