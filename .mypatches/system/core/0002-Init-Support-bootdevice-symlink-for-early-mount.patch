From c98f4e2a6d7ab8191007a1151ead829060d28f86 Mon Sep 17 00:00:00 2001
From: Adarsh Reddy <padarshr@codeaurora.org>
Date: Wed, 24 May 2017 19:55:56 +0530
Subject: [PATCH 2/2] Init: Support bootdevice symlink for early mount.

Read the bootdevice value from kernel cmdline(passed by bootloader),
and use that value to create bootdevice symlink. This is needed because,
the previous logic of reading the ro.boot.bootdevice property will
not help us during early mount stage, as, at this stage init would not
have parsed and converted cmdline key-value pairs to properties.
So, to support bootdevice early mount, parse cmdline, and save the
bootdevice value.

Change-Id: I753bb71d19c42ddadf4d5c1a9e9310e7f5642a09
---
 init/devices.cpp | 43 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 42 insertions(+), 1 deletion(-)

diff --git a/init/devices.cpp b/init/devices.cpp
index 13cf991..0a53e60 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -29,10 +29,15 @@
 #include <private/android_filesystem_config.h>
 #include <selinux/android.h>
 #include <selinux/selinux.h>
+#include <string.h>
 
 #include "ueventd.h"
 #include "util.h"
 
+static std::string boot_device;
+static bool is_cmdline_parsed = false;
+static bool bootdevice_symlink_done = false;
+
 #ifdef _INIT_INIT_H
 #error "Do not include init.h in files used by ueventd or watchdogd; it will expose init's globals"
 #endif
@@ -296,11 +301,37 @@ void SanitizePartitionName(std::string* string) {
     }
 }
 
+static bool make_link_init(const char* oldpath, const char* newpath) {
+  const char* slash = strrchr(newpath, '/');
+  if (!slash) return false;
+
+  if (mkdir_recursive(Dirname(newpath), 0755, selinux_android_file_context_handle())) {
+    PLOG(ERROR) << "Failed to create directory " << Dirname(newpath);
+    return false;
+  }
+
+  if (symlink(oldpath, newpath) && errno != EEXIST) {
+    PLOG(ERROR) << "Failed to symlink " << oldpath << " to " << newpath;
+    return false;
+  }
+  return true;
+}
+
+static void get_bootdevice_from_cmdline(const std::string& key, const std::string& value,
+        bool for_emulator)
+{
+    is_cmdline_parsed = true;
+    if (android::base::EndsWith(key, "bootdevice")) {
+        boot_device = value;
+    }
+}
+
 std::vector<std::string> DeviceHandler::GetBlockDeviceSymlinks(const Uevent& uevent) const {
     std::string device;
     std::string type;
 
-    if (FindPlatformDevice(uevent.path, &device)) {
+    bool foundPlatformDevice = FindPlatformDevice(uevent.path, &device);
+    if (foundPlatformDevice) {
         // Skip /devices/platform or /devices/ if present
         static const std::string devices_platform_prefix = "/devices/platform/";
         static const std::string devices_prefix = "/devices/";
@@ -343,6 +374,16 @@ std::vector<std::string> DeviceHandler::GetBlockDeviceSymlinks(const Uevent& uev
     auto last_slash = uevent.path.rfind('/');
     links.emplace_back(link_path + "/" + uevent.path.substr(last_slash + 1));
 
+    if (!is_cmdline_parsed) {
+        // Parse the kernel cmdline only once, and get the bootdevice that we use to create
+        // the bootdevice symlink to support early mount.
+        import_kernel_cmdline(false, get_bootdevice_from_cmdline);
+    }
+
+    if (foundPlatformDevice && !boot_device.empty() && strstr(device.c_str(), boot_device.c_str()) && !bootdevice_symlink_done) {
+        bootdevice_symlink_done = make_link_init(link_path.c_str(), "/dev/block/bootdevice");
+    }
+
     return links;
 }
 
-- 
2.7.4

