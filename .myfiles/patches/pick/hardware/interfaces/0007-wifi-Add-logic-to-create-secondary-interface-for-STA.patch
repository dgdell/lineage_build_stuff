From 97cb6c3f32e63f69ec316d756ca0f8bbf4a24d03 Mon Sep 17 00:00:00 2001
From: Purushottam Kushwaha <pkushwah@codeaurora.org>
Date: Wed, 27 Jun 2018 11:00:26 +0530
Subject: [PATCH 7/7] wifi: Add logic to create secondary interface for STA
 mode too.

Previously we introduced dynamic interface create/remove logic for
SAP interface where wlan.concurrent.interface was given first
preference for SAP interface.

Remove this preference and fallback to use the default order of
choosing interface names. Also add create/remove logic for secondary
interface in STA mode too.

Change-Id: Iec5c4492096327a18e67f5129736a9bd3c8533f0
CRs-Fixed: 2268421
---
 wifi/1.2/default/wifi_chip.cpp | 47 +++++++++++++++++-----------------
 wifi/1.2/default/wifi_chip.h   |  2 +-
 2 files changed, 25 insertions(+), 24 deletions(-)

diff --git a/wifi/1.2/default/wifi_chip.cpp b/wifi/1.2/default/wifi_chip.cpp
index 27252070..1f15fe47 100644
--- a/wifi/1.2/default/wifi_chip.cpp
+++ b/wifi/1.2/default/wifi_chip.cpp
@@ -598,6 +598,7 @@ void WifiChip::invalidateAndRemoveAllIfaces() {
     invalidateAndClearAll(p2p_ifaces_);
     invalidateAndClearAll(sta_ifaces_);
     invalidateAndClearAll(created_ap_ifaces_);
+    invalidateAndClearAll(created_sta_ifaces_);
     // Since all the ifaces are invalid now, all RTT controller objects
     // using those ifaces also need to be invalidated.
     for (const auto& rtt : rtt_controllers_) {
@@ -747,13 +748,8 @@ std::pair<WifiStatus, sp<IWifiApIface>> WifiChip::createApIfaceInternal() {
         return {createWifiStatus(WifiStatusCode::ERROR_NOT_AVAILABLE), {}};
     }
 
-    std::string ifname = "";
     bool iface_created = false;
-    if (feature_flags_.lock()->isDualInterfaceSupported())
-        ifname = qcAllocateApIfaceName();
-    else
-        ifname = allocateApOrStaIfaceName();
-
+    std::string ifname = allocateApOrStaIfaceName();
     if (!if_nametoindex(ifname.c_str())) {
         legacy_hal::wifi_error legacy_status =
             legacy_hal_.lock()->QcAddInterface(getWlan0IfaceName(), ifname,
@@ -914,9 +910,22 @@ std::pair<WifiStatus, sp<IWifiStaIface>> WifiChip::createStaIfaceInternal() {
     if (!canCurrentModeSupportIfaceOfType(IfaceType::STA)) {
         return {createWifiStatus(WifiStatusCode::ERROR_NOT_AVAILABLE), {}};
     }
+    bool iface_created = false;
     std::string ifname = allocateApOrStaIfaceName();
+    if (!if_nametoindex(ifname.c_str())) {
+        legacy_hal::wifi_error legacy_status =
+            legacy_hal_.lock()->QcAddInterface(getWlan0IfaceName(), ifname,
+                                               (uint32_t)IfaceType::STA);
+        if (legacy_status != legacy_hal::WIFI_SUCCESS) {
+            LOG(ERROR) << "Failed to add interface: " << ifname << " "
+                       << legacyErrorToString(legacy_status);
+            return {createWifiStatusFromLegacyError(legacy_status), {}};
+        }
+        iface_created = true;
+    }
     sp<WifiStaIface> iface = new WifiStaIface(ifname, legacy_hal_);
     sta_ifaces_.push_back(iface);
+    if (iface_created) created_sta_ifaces_.push_back(iface);
     for (const auto& callback : event_cb_handler_.getCallbacks()) {
         if (!callback->onIfaceAdded(IfaceType::STA, ifname).isOk()) {
             LOG(ERROR) << "Failed to invoke onIfaceAdded callback";
@@ -947,6 +956,15 @@ WifiStatus WifiChip::removeStaIfaceInternal(const std::string& ifname) {
     if (!iface.get()) {
         return createWifiStatus(WifiStatusCode::ERROR_INVALID_ARGS);
     }
+    if (findUsingName(created_sta_ifaces_, ifname) != nullptr) {
+        legacy_hal::wifi_error legacy_status =
+            legacy_hal_.lock()->QcRemoveInterface(getWlan0IfaceName(), ifname);
+        if (legacy_status != legacy_hal::WIFI_SUCCESS) {
+            LOG(ERROR) << "Failed to remove interface: " << ifname << " "
+                       << legacyErrorToString(legacy_status);
+        }
+        invalidateAndClear(created_sta_ifaces_, iface);
+    }
     invalidateAndClear(sta_ifaces_, iface);
     for (const auto& callback : event_cb_handler_.getCallbacks()) {
         if (!callback->onIfaceRemoved(IfaceType::STA, ifname).isOk()) {
@@ -1428,23 +1446,6 @@ std::string WifiChip::allocateApOrStaIfaceName() {
     return {};
 }
 
-// Return "wlan1", if "wlan1" is not already in use, else return "wlan0".
-// This is based on the assumption that we'll have a max of 2 concurrent
-// AP ifaces.
-std::string WifiChip::qcAllocateApIfaceName() {
-    auto ap_iface = findUsingName(ap_ifaces_, getWlan1IfaceName());
-    if (!ap_iface.get()) {
-        return getWlan1IfaceName();
-    }
-    ap_iface = findUsingName(ap_ifaces_, getWlan0IfaceName());
-    if (!ap_iface.get()) {
-        return getWlan0IfaceName();
-    }
-    // This should never happen. We screwed up somewhere if it did.
-    CHECK(0) << "wlan0 and wlan1 in use already!";
-    return {};
-}
-
 bool WifiChip::writeRingbufferFilesInternal() {
     if (!removeOldFilesInternal()) {
         LOG(ERROR) << "Error occurred while deleting old tombstone files";
diff --git a/wifi/1.2/default/wifi_chip.h b/wifi/1.2/default/wifi_chip.h
index 94e55e82..23087477 100644
--- a/wifi/1.2/default/wifi_chip.h
+++ b/wifi/1.2/default/wifi_chip.h
@@ -216,7 +216,6 @@ class WifiChip : public V1_2::IWifiChip {
     bool canCurrentModeSupportIfaceOfType(IfaceType type);
     bool isValidModeId(ChipModeId mode_id);
     std::string allocateApOrStaIfaceName();
-    std::string qcAllocateApIfaceName();
     bool writeRingbufferFilesInternal();
 
     ChipId chip_id_;
@@ -241,6 +240,7 @@ class WifiChip : public V1_2::IWifiChip {
         event_cb_handler_;
 
     std::vector<sp<WifiApIface>> created_ap_ifaces_;
+    std::vector<sp<WifiStaIface>> created_sta_ifaces_;
 
     DISALLOW_COPY_AND_ASSIGN(WifiChip);
 };
-- 
2.17.1

