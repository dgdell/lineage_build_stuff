From 171177177aa50bc0eecc28a87ef16ed4378b6797 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 6 Nov 2018 14:56:49 +0100
Subject: [PATCH 2/2] [SQUSH][DNM] Merge tag 'android-9.0.0_r16' into
 lineage-16.0

commit a384019d9db1baa9ebf37ea64f525ecc709fd2e4
Merge: 81f5766d2 e8ff4eb8c
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Tue Aug 21 03:08:02 2018 +0000

    Snap for 4966094 from e8ff4eb8cce6b32b8e246dd658284bde20000f5b to pi-qpr1-release

    Change-Id: Ie8b52c41533bde1ae9a43051a36dfeb8909cfcf3

commit e8ff4eb8cce6b32b8e246dd658284bde20000f5b
Merge: 76ff480a2 89bd27114
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Mon Aug 20 18:36:07 2018 +0000

    Merge "hal: add sdm710 to the list of supproted platforms" into pi-dev

commit 81f5766d2e27ec165f29927a33bf902c499a1f75
Merge: f9abeb56e 76ff480a2
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Aug 17 03:13:09 2018 +0000

    Snap for 4959688 from 76ff480a26a82fc7ac393b8531bb51a384b7d070 to pi-qpr1-release

    Change-Id: I222df1d66a0b324934ad269b16edd615b2925ba5

commit 76ff480a26a82fc7ac393b8531bb51a384b7d070
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Mon Aug 6 15:30:50 2018 -0700

    hal: Add ABR enabled flag to LDAC config

    Add a member to notify audio driver whether ABR
    is enabled for LDAC codec.

    Bug: 112197037
    Test: Manual testing with LDAC headset
    Change-Id: I76b23a2789b59d4e95535608971a6e99f601b5a6

commit 89bd271145e00abc6b7b80d1dffb15e7594e821f
Author: yixuanjiang <yixuanjiang@google.com>
Date:   Wed Aug 15 17:43:11 2018 +0800

    hal: add sdm710 to the list of supproted platforms

    Test: build pass
    BUG:112018755
    Change-Id: I1ae8b906b29c5866a01edf4e519f0f1cf7d9e00f
    Signed-off-by: yixuanjiang <yixuanjiang@google.com>

commit f9abeb56ebd3e022afa80d412bcd5bf5b5fb7a81
Merge: 7964549ea cb9b39f61
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Tue Aug 7 03:08:44 2018 +0000

    Snap for 4937098 from cb9b39f61b14bcefc4ae37b999c6e00701d2589d to pi-qpr1-release

    Change-Id: I3d3ca9c07e442d3b8e3d332d611addf7f6fcfc91

commit cb9b39f61b14bcefc4ae37b999c6e00701d2589d
Merge: 66c4ecfa8 e56cd4bc6
Author: Bubble Fang <bubblefang@google.com>
Date:   Tue Aug 7 00:53:34 2018 +0000

    Merge "hal: enable audio_hw flag for sdm710 platform" into pi-dev

commit 66c4ecfa84116e12c5cb3b430208365cdfb0b2c9
Author: juyuchen <juyuchen@google.com>
Date:   Mon Aug 6 15:39:34 2018 +0800

    audio: fix static noise on speaker path when enable incall-music

    Bug: 111107345
    Test: manual audio test

    Change-Id: I8da727326b0d5dd1d89623dae55e33f2b39830df
    Signed-off-by: juyuchen <juyuchen@google.com>
    Signed-off-by: David Lin <dtwlin@google.com>

commit e56cd4bc673e7068d59803b9ac02f660e6bfd14e
Author: vincenttew <vincenttew@google.com>
Date:   Thu Aug 2 15:39:33 2018 +0800

    hal: enable audio_hw flag for sdm710 platform

    Test: build pass
    BUG:112018755
    Change-Id: I98fc64fc972dd073cde394aa59dafbde892ba06a
    Signed-off-by: vincenttew <vincenttew@google.com>

commit 7964549ea0dd5a0115d0e6562c7daa167986457c
Merge: 5790f3eb0 72a3ceab0
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Wed Jul 18 20:55:43 2018 +0000

    Merge "visualizer: Pass sound card and capture device from audio HAL" into pi-dev

commit 5790f3eb018b092a0fcb3ef9e55d5d3b04373a70
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Wed Jun 20 14:41:26 2018 -0700

    hal: Configure frame size of AAC encoded output

    BT sink devices have a limitation on the packet sizes
    they can receive and handle from BT sources. AAC encoder
    can produce output frames which can vary in size based on
    content being encoded. If frame size exceeds MTU size of
    BT sink device, it will lead to incorrect decoding of
    frames in BT sink.
    Solve this problem by sending a frame configuration parameter
    (MTU/Peak bitrate) while starting A2DP playback on AAC.
    Parameter is passed by bthost_ipc to audio HAL which passes
    it to DSP during AAC encoder configuration.

    Bug: 78907438
    Test: Manual testing with AAC headset
    Change-Id: I58e30e7e0a486065a95bc7d7463c45e1c5c3e6eb

commit 72a3ceab00258fef500f0b6f3c41870c806cefdf
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Fri Apr 6 13:56:37 2018 -0700

    visualizer: Pass sound card and capture device from audio HAL

    Sound card number and capture device id were hardcoded in
    visualizer. Fix this by passing card number and capture
    device id while starting visualizer output from audio HAL.

    Bug: 65263761
    Change-Id: Icc5c33e35d836f524918900b3bfdf2a587465505
    (cherry picked from commit 90c3646a8b97158c2c3f33677815909219cc8f03)

commit 702c15751ca43c51781ed31491741c56c6122be3
Author: Kevin Rocard <krocard@google.com>
Date:   Wed Jul 11 20:52:03 2018 -0700

    A2DP set_parameter: return correct status value

    The A2DP offload set_parameter code was returning the value
    of a temporary variable use to parse the value pairs
    instead of the status of the operation.

    This mean that an error was wrongly returned when
    setting the value of any key that was not
    AUDIO_PARAMETER_RECONFIG_A2DP (the last one parsed).

    Test: vts-tradefed run commandAndExit vts -m VtsHalAudioV4_0Target
    Bug: 111113768
    Change-Id: Ic32bdaafb8d048322d1c560f4f4c3deefeba63df
    Signed-off-by: Kevin Rocard <krocard@google.com>

commit 41b4fe4c5750792a2c7afbc479bd742034f9a4df
Author: David Lin <dtwlin@google.com>
Date:   Sun Jul 8 16:14:24 2018 -0700

    hal: speaker protect: Add deinit function to clean up

    This patch adds a deinit function for speaker protection module to
    perform any clean ups needed. This as well implements the deinit for
    Cirrus Logic speaker protection module to wait for the threads to
    finish.

    Bug: 111113768
    Test: VtsHalAudioV4_0Target
    Change-Id: I3c89f173d726e265ce64ea4a7e43b49210f8721c
    Signed-off-by: David Lin <dtwlin@google.com>

commit 4d2221b1b98e4e57bcafb8875456ed5e6a0aa810
Author: juyuchen <juyuchen@google.com>
Date:   Fri Jul 6 14:26:22 2018 +0800

    audio: Add a build flag to enable cirrus speaker calibration.

    Enable cirrus's speaker calibration function when define the build CIRRUS_FACTORY_CALIBRATION flag.

    Bug: 111113768
    Bug: 111239347
    Test: manual audio test

    Change-Id: Ie59dd2ffb5ab6d54e29ac10131fffc90193152df
    Signed-off-by: juyuchen <juyuchen@google.com>

commit eedbcac379a26bd7cce9225df33ba6c73ccd34b9
Author: Aniket Kumar Lata <alata@codeaurora.org>
Date:   Thu Jun 21 16:46:50 2018 -0700

    hal: Reset A2DP backend before SCO is started

    SCO and A2DP share the same Slimbus backend.
    During A2DP to SCO transition, A2DP sound device in
    audio HAL if disabled after SCO audio route is enabled
    overwrites SCO backend config with A2DP reset config.
    Reset A2DP config with A2DP suspension rather than
    wait for it to be handled from stop playback.
    Don't reset backend if stop playback is called
    while A2DP is suspended.
    Also, set/reset slimbus TX config only when usecase is
    LDAC ABR.

    Bug: 80647629
    Test: Manual
    Change-Id: Idc80617aabb6d94d325dc7cad75099272a4582e5

commit 6d945d2847901bcff560dcd3108cfac0cca5f43d
Author: Jasmine Cha <chajasmine@google.com>
Date:   Tue Jun 19 09:49:04 2018 -0700

    audio: Load maxx_conf.ini by snd factor

    bug: 110378172
    Test: media playback test

    Change-Id: If3fa6a671eb48b84e17e7dcb287dd9f704a772ce
    Signed-off-by: Jasmine Cha <chajasmine@google.com>

commit c1b7608539dbe41d75c19a6e242cbcbb906c705a
Merge: 50fcc10af f76dae505
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Sat Jun 16 03:11:13 2018 +0000

    Merge "audio: Notify sthal of pending record as part of device enable" into pi-dev

commit 50fcc10afc171b179151538572c0994b13a7b780
Merge: 3f81b3b12 220b32e5e
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jun 15 03:10:19 2018 +0000

    Merge "audio: fix app type's acdb transfer to kernel driver" into pi-dev

commit f76dae505a2b39b49ccefb58839c393584a3760d
Author: Haynes Mathew George <hgeorge@codeaurora.org>
Date:   Wed Jun 13 16:06:19 2018 -0700

    audio: Notify sthal of pending record as part of device enable

    sthal by default disables soundtrigger
    sessions when an audio record session is
    started. The record hint is processed
    in the sthal as part of enabling the record
    audio route. This is insufficient as controls
    enabled as part of audio record device enable
    may be reset when the soundtrigger session
    is reset in sthal. Provide hint to sthal
    before enabling the record device to fix this.

    Bug: 109700532
    Change-Id: Idec8563e55107828ac48a1fb7cdde3b45ef0c07a

commit 3f81b3b12dbbdef65cc9a9b7efe8184c859f61de
Merge: 84757f372 88512e973
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jun 15 00:07:08 2018 +0000

    Merge "audio: hal: check routing after stop_output_stream" into pi-dev

commit 84757f37228aea0b0a1582910c0bb276c768c230
Author: Bhalchandra Gajare <gajare@codeaurora.org>
Date:   Mon Jun 11 18:18:30 2018 -0700

    hal: poll for SLPI subsystem status

    Add support to poll for SLPI(Sensor Low Power Island) subsystem
    offline and online status events and pass to sound trigger hal.

    Bug: 109833647
    Test: stream audio, restart SLPI, audio continues to stream
    Change-Id: I667a050aca7d8547e4f42776fae5185b2861a77f

commit 88512e9730f2db1820ce8c38a7cd1d14e9859fe6
Author: HW Lee <hwlee@google.com>
Date:   Tue Jun 12 15:26:09 2018 +0800

    audio: hal: check routing after stop_output_stream

    In case of voip playback during the music playback through speaker, the
    music will be switched to handset because it is the primary output of
    the voip. Once the voip playback has finished, the music playback should
    be switched back to speaker if the music is still being played.

    Bug: 80404632
    Test: manual audio test
    Change-Id: I91916c0913da5137d04433d4d69506bda030affa

commit 220b32e5ef138054e60c29273d1d93c305f80b71
Author: juyuchen <juyuchen@google.com>
Date:   Thu May 31 16:14:26 2018 +0800

    audio: fix app type's acdb transfer to kernel driver

    Bug: 80403838
    Test: manual audio test

    Change-Id: I7da41f866651026c3153cde5b9f93b5969227adc
    Signed-off-by: juyuchen <juyuchen@google.com>

Change-Id: I3403dc590eae729ab2865e30490eaf1561afa6cb

# Conflicts:
#	Android.mk
---
 hal/Android.mk                   |  11 ++-
 hal/audio_extn/a2dp.c            | 138 ++++++++++++++++++++-----------
 hal/audio_extn/audio_extn.h      |   3 +
 hal/audio_extn/cirrus_playback.c | 108 +++++++++++++++++++++++-
 hal/audio_extn/maxxaudio.c       |  24 ++++--
 hal/audio_extn/sndmonitor.c      |  44 +++++++++-
 hal/audio_extn/soundtrigger.c    |  20 ++++-
 hal/audio_extn/spkr_protection.c |   5 ++
 hal/audio_extn/utils.c           |  37 ++++++---
 hal/audio_hw.c                   |  43 +++++++---
 hal/audio_hw.h                   |   2 +-
 hal/msm8916/platform.c           |   4 +
 hal/msm8916/platform.h           |   1 +
 hal/msm8974/platform.c           |  17 ++--
 hal/msm8974/platform.h           |   1 +
 post_proc/Android.mk             |   4 +-
 visualizer/Android.mk            |   8 --
 visualizer/offload_visualizer.c  |  25 ++++--
 18 files changed, 384 insertions(+), 111 deletions(-)

diff --git a/hal/Android.mk b/hal/Android.mk
index 95e38f9d4..44278e473 100644
--- a/hal/Android.mk
+++ b/hal/Android.mk
@@ -10,7 +10,7 @@ AUDIO_PLATFORM := $(TARGET_BOARD_PLATFORM)
 ifneq ($(filter msm8960,$(TARGET_BOARD_PLATFORM)),)
   LOCAL_CFLAGS += -DMAX_TARGET_SPECIFIC_CHANNEL_CNT="2"
 endif
-ifneq ($(filter msm8974 msm8226 msm8084 msm8992 msm8994 msm8996 msm8998 sdm845,$(TARGET_BOARD_PLATFORM)),)
+ifneq ($(filter msm8974 msm8226 msm8084 msm8992 msm8994 msm8996 msm8998 sdm845 sdm710,$(TARGET_BOARD_PLATFORM)),)
   # B-family platform uses msm8974 code base
   AUDIO_PLATFORM = msm8974
 ifneq ($(filter msm8974,$(TARGET_BOARD_PLATFORM)),)
@@ -55,6 +55,13 @@ ifneq ($(filter sdm845,$(TARGET_BOARD_PLATFORM)),)
   LOCAL_CFLAGS += -DINCALL_STEREO_CAPTURE_ENABLED
   MULTIPLE_HW_VARIANTS_ENABLED := true
 endif
+ifneq ($(filter sdm710,$(TARGET_BOARD_PLATFORM)),)
+  LOCAL_CFLAGS := -DPLATFORM_SDM710
+  LOCAL_CFLAGS += -DMAX_TARGET_SPECIFIC_CHANNEL_CNT="4"
+  LOCAL_CFLAGS += -DINCALL_MUSIC_ENABLED
+  LOCAL_CFLAGS += -DINCALL_STEREO_CAPTURE_ENABLED
+  MULTIPLE_HW_VARIANTS_ENABLED := true
+endif
 endif
 
 ifneq ($(filter msm8916 msm8909 msm8952,$(TARGET_BOARD_PLATFORM)),)
@@ -171,7 +178,7 @@ ifeq ($(strip $(AUDIO_FEATURE_ENABLED_A2DP_OFFLOAD)),true)
     LOCAL_SRC_FILES += audio_extn/a2dp.c
 endif
 
-ifneq ($(filter msm8992 msm8994 msm8996 msm8998 sdm845,$(TARGET_BOARD_PLATFORM)),)
+ifneq ($(filter msm8992 msm8994 msm8996 msm8998 sdm845 sdm710,$(TARGET_BOARD_PLATFORM)),)
   # push codec/mad calibration to HW dep node
   # applicable to msm8992/8994 or newer platforms
   LOCAL_CFLAGS += -DHWDEP_CAL_ENABLED
diff --git a/hal/audio_extn/a2dp.c b/hal/audio_extn/a2dp.c
index d1671a8d1..18d93352e 100644
--- a/hal/audio_extn/a2dp.c
+++ b/hal/audio_extn/a2dp.c
@@ -159,6 +159,11 @@ typedef enum {
     IMC_ENABLE,
 } imc_status_t;
 
+typedef enum {
+    MTU_SIZE,
+    PEAK_BIT_RATE,
+} frame_control_type_t;
+
 /* PCM config for ABR Feedback hostless front end */
 static struct pcm_config pcm_config_abr = {
     .channels = 1,
@@ -288,12 +293,25 @@ struct imc_dec_enc_info {
     uint32_t comm_instance;
 };
 
+/* Structure to control frame size of AAC encoded frames. */
+struct aac_frame_size_control_t {
+    /* Type of frame size control: MTU_SIZE / PEAK_BIT_RATE*/
+    uint32_t ctl_type;
+    /* Control value
+     * MTU_SIZE: MTU size in bytes
+     * PEAK_BIT_RATE: Peak bitrate in bits per second.
+     */
+    uint32_t ctl_value;
+};
+
 /* Structure used for ABR config of AFE encoder and decoder. */
 struct abr_enc_cfg_t {
     /* Link quality level to bitrate mapping info sent to DSP. */
     struct quality_level_to_bitrate_info mapping_info;
     /* Information to set up IMC between decoder and encoder */
     struct imc_dec_enc_info imc_info;
+    /* Flag to indicate whether ABR is enabled */
+    bool is_abr_enabled;
 }  __attribute__ ((packed));
 
 /* Structure to send configuration for decoder introduced
@@ -310,10 +328,7 @@ struct abr_dec_cfg_t {
  * These values should match with DSP interface defintion
  */
 
-/* AAC encoder configuration structure. */
-typedef struct aac_enc_cfg_t aac_enc_cfg_t;
-
-struct aac_enc_cfg_t {
+struct aac_cfg_blk_t {
     /* Encoder media format for AAC */
     uint32_t      enc_format;
 
@@ -333,6 +348,14 @@ struct aac_enc_cfg_t {
     uint32_t      sample_rate;
 } __attribute__ ((packed));
 
+/* AAC encoder configuration structure. */
+typedef struct aac_enc_cfg_t aac_enc_cfg_t;
+
+struct aac_enc_cfg_t {
+    struct aac_cfg_blk_t aac_cfg;
+    struct aac_frame_size_control_t frame_ctl;
+} __attribute__ ((packed));
+
 /* SBC encoder configuration structure. */
 typedef struct sbc_enc_cfg_t sbc_enc_cfg_t;
 
@@ -493,6 +516,7 @@ typedef struct {
     uint32_t sampling_rate;
     uint32_t bitrate;
     uint32_t bits_per_sample;
+    struct aac_frame_size_control_t frame_ctl;
 } audio_aac_encoder_config;
 
 /* Information about Bluetooth LDAC encoder configuration
@@ -807,20 +831,21 @@ static int a2dp_set_backend_cfg()
     }
 
     // Set Tx backend sample rate
-    if (a2dp.abr_config.is_abr_enabled)
+    if (a2dp.abr_config.is_abr_enabled) {
         rate_str = ABR_TX_SAMPLE_RATE;
 
-    ALOGV("%s: set backend tx sample rate = %s", __func__, rate_str);
-    ctl_sample_rate = mixer_get_ctl_by_name(a2dp.adev->mixer,
-                                        MIXER_SAMPLE_RATE_TX);
-    if (!ctl_sample_rate) {
-        ALOGE("%s: ERROR backend sample rate mixer control not identifed", __func__);
-        return -ENOSYS;
-    }
-    if (mixer_ctl_set_enum_by_string(ctl_sample_rate, rate_str) != 0) {
-        ALOGE("%s: Failed to set backend sample rate = %s",
-                                    __func__, rate_str);
-        return -ENOSYS;
+        ALOGV("%s: set backend tx sample rate = %s", __func__, rate_str);
+        ctl_sample_rate = mixer_get_ctl_by_name(a2dp.adev->mixer,
+                                            MIXER_SAMPLE_RATE_TX);
+        if (!ctl_sample_rate) {
+            ALOGE("%s: ERROR backend sample rate mixer control not identifed", __func__);
+            return -ENOSYS;
+        }
+        if (mixer_ctl_set_enum_by_string(ctl_sample_rate, rate_str) != 0) {
+            ALOGE("%s: Failed to set backend sample rate = %s",
+                                        __func__, rate_str);
+            return -ENOSYS;
+        }
     }
 
     // Configure AFE input channels
@@ -901,15 +926,17 @@ static int a2dp_reset_backend_cfg()
         return -ENOSYS;
     }
 
-    ctl_sample_rate_tx = mixer_get_ctl_by_name(a2dp.adev->mixer,
-                                        MIXER_SAMPLE_RATE_TX);
-    if (!ctl_sample_rate_tx) {
-        ALOGE("%s: ERROR Tx backend sample rate mixer control not identifed", __func__);
-        return -ENOSYS;
-    }
-    if (mixer_ctl_set_enum_by_string(ctl_sample_rate_tx, rate_str) != 0) {
-        ALOGE("%s: Failed to reset Tx backend sample rate = %s", __func__, rate_str);
-        return -ENOSYS;
+    if (a2dp.abr_config.is_abr_enabled) {
+        ctl_sample_rate_tx = mixer_get_ctl_by_name(a2dp.adev->mixer,
+                                            MIXER_SAMPLE_RATE_TX);
+        if (!ctl_sample_rate_tx) {
+            ALOGE("%s: ERROR Tx backend sample rate mixer control not identifed", __func__);
+            return -ENOSYS;
+        }
+        if (mixer_ctl_set_enum_by_string(ctl_sample_rate_tx, rate_str) != 0) {
+            ALOGE("%s: Failed to reset Tx backend sample rate = %s", __func__, rate_str);
+            return -ENOSYS;
+        }
     }
 
     // Reset AFE input channels
@@ -1184,23 +1211,25 @@ static bool configure_aac_enc_format(audio_aac_encoder_config *aac_bt_cfg)
         goto exit;
     }
     memset(&aac_dsp_cfg, 0x0, sizeof(aac_dsp_cfg));
-    aac_dsp_cfg.enc_format = ENC_MEDIA_FMT_AAC;
-    aac_dsp_cfg.bit_rate = aac_bt_cfg->bitrate;
-    aac_dsp_cfg.sample_rate = aac_bt_cfg->sampling_rate;
+    aac_dsp_cfg.aac_cfg.enc_format = ENC_MEDIA_FMT_AAC;
+    aac_dsp_cfg.aac_cfg.bit_rate = aac_bt_cfg->bitrate;
+    aac_dsp_cfg.aac_cfg.sample_rate = aac_bt_cfg->sampling_rate;
     switch (aac_bt_cfg->enc_mode) {
         case 0:
-            aac_dsp_cfg.enc_mode = MEDIA_FMT_AAC_AOT_LC;
+            aac_dsp_cfg.aac_cfg.enc_mode = MEDIA_FMT_AAC_AOT_LC;
             break;
         case 2:
-            aac_dsp_cfg.enc_mode = MEDIA_FMT_AAC_AOT_PS;
+            aac_dsp_cfg.aac_cfg.enc_mode = MEDIA_FMT_AAC_AOT_PS;
             break;
         case 1:
         default:
-            aac_dsp_cfg.enc_mode = MEDIA_FMT_AAC_AOT_SBR;
+            aac_dsp_cfg.aac_cfg.enc_mode = MEDIA_FMT_AAC_AOT_SBR;
             break;
     }
-    aac_dsp_cfg.aac_fmt_flag = aac_bt_cfg->format_flag;
-    aac_dsp_cfg.channel_cfg = aac_bt_cfg->channels;
+    aac_dsp_cfg.aac_cfg.aac_fmt_flag = aac_bt_cfg->format_flag;
+    aac_dsp_cfg.aac_cfg.channel_cfg = aac_bt_cfg->channels;
+    aac_dsp_cfg.frame_ctl.ctl_type = aac_bt_cfg->frame_ctl.ctl_type;
+    aac_dsp_cfg.frame_ctl.ctl_value = aac_bt_cfg->frame_ctl.ctl_value;
     ret = mixer_ctl_set_array(ctl_enc_data, (void *)&aac_dsp_cfg,
                               sizeof(aac_dsp_cfg));
     if (ret != 0) {
@@ -1218,7 +1247,7 @@ static bool configure_aac_enc_format(audio_aac_encoder_config *aac_bt_cfg)
     a2dp.enc_sampling_rate = aac_bt_cfg->sampling_rate;
     a2dp.enc_channels = aac_bt_cfg->channels;
     ALOGV("%s: Successfully updated AAC enc format with sampling rate: %d channels:%d",
-           __func__, aac_dsp_cfg.sample_rate, aac_dsp_cfg.channel_cfg);
+           __func__, aac_dsp_cfg.aac_cfg.sample_rate, aac_dsp_cfg.aac_cfg.channel_cfg);
 exit:
     return is_configured;
 }
@@ -1269,6 +1298,7 @@ static bool configure_ldac_enc_format(audio_ldac_encoder_config *ldac_bt_cfg)
         ldac_dsp_cfg.abr_cfg.imc_info.enable = IMC_ENABLE;
         ldac_dsp_cfg.abr_cfg.imc_info.purpose = IMC_PURPOSE_ID_BT_INFO;
         ldac_dsp_cfg.abr_cfg.imc_info.comm_instance = a2dp.abr_config.imc_instance;
+        ldac_dsp_cfg.abr_cfg.is_abr_enabled = ldac_bt_cfg->is_abr_enabled;
     }
 
     ret = mixer_ctl_set_array(ldac_enc_data, (void *)&ldac_dsp_cfg,
@@ -1457,6 +1487,15 @@ static int reset_a2dp_dec_config_params()
     return ret;
 }
 
+static void reset_a2dp_config() {
+    reset_a2dp_enc_config_params();
+    reset_a2dp_dec_config_params();
+    a2dp_reset_backend_cfg();
+    if (a2dp.abr_config.is_abr_enabled && a2dp.abr_config.abr_started)
+        stop_abr();
+    a2dp.abr_config.is_abr_enabled = false;
+}
+
 int audio_extn_a2dp_stop_playback()
 {
     int ret = 0;
@@ -1479,12 +1518,8 @@ int audio_extn_a2dp_stop_playback()
             ALOGE("%s: stop stream to Bluetooth IPC lib failed", __func__);
         else
             ALOGV("%s: stop steam to Bluetooth IPC lib successful", __func__);
-        reset_a2dp_enc_config_params();
-        reset_a2dp_dec_config_params();
-        a2dp_reset_backend_cfg();
-        if (a2dp.abr_config.is_abr_enabled && a2dp.abr_config.abr_started)
-            stop_abr();
-        a2dp.abr_config.is_abr_enabled = false;
+        if (!a2dp.a2dp_suspended)
+            reset_a2dp_config();
         a2dp.a2dp_started = false;
     }
     ALOGD("%s: Stop A2DP playback total active sessions :%d", __func__,
@@ -1495,13 +1530,14 @@ int audio_extn_a2dp_stop_playback()
 int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
 {
      int ret = 0, val;
+     int status = 0;
      char value[32] = {0};
      struct audio_usecase *uc_info;
      struct listnode *node;
 
      if (a2dp.is_a2dp_offload_enabled == false) {
         ALOGV("%s: No supported encoders identified,ignoring A2DP setparam", __func__);
-        ret = -EINVAL;
+        status = -EINVAL;
         goto param_handled;
      }
 
@@ -1549,8 +1585,7 @@ int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
                         pthread_mutex_lock(&a2dp.adev->lock);
                     }
                 }
-                reset_a2dp_enc_config_params();
-                reset_a2dp_dec_config_params();
+                reset_a2dp_config();
                 if (a2dp.audio_stream_suspend) {
                    a2dp.audio_stream_suspend();
                 }
@@ -1580,12 +1615,23 @@ int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
                 if (a2dp.a2dp_total_active_session_request > 0) {
                     ALOGD("%s: Calling Bluetooth IPC lib start post suspend state", __func__);
                     if (a2dp.audio_stream_start) {
-                        ret =  a2dp.audio_stream_start();
-                        if (ret != 0) {
+                        status =  a2dp.audio_stream_start();
+                        if (status != 0) {
                             ALOGE("%s: Bluetooth controller start failed", __func__);
                             a2dp.a2dp_started = false;
+                        } else {
+                            if (!configure_a2dp_encoder_format()) {
+                                ALOGE("%s: Encoder params configuration failed post suspend", __func__);
+                                a2dp.a2dp_started = false;
+                                status = -ETIMEDOUT;
+                            }
                         }
                     }
+                    if (a2dp.a2dp_started) {
+                        a2dp_set_backend_cfg();
+                        if (a2dp.abr_config.is_abr_enabled)
+                            start_abr();
+                    }
                 }
                 list_for_each(node, &a2dp.adev->usecase_list) {
                     uc_info = node_to_item(node, struct audio_usecase, list);
@@ -1613,7 +1659,7 @@ int audio_extn_a2dp_set_parameters(struct str_parms *parms, bool *reconfig)
 
 param_handled:
      ALOGV("%s: end of A2DP setparam", __func__);
-     return ret;
+     return status;
 }
 
 void audio_extn_a2dp_set_handoff_mode(bool is_on)
diff --git a/hal/audio_extn/audio_extn.h b/hal/audio_extn/audio_extn.h
index b1c701d7d..1c28b6b65 100644
--- a/hal/audio_extn/audio_extn.h
+++ b/hal/audio_extn/audio_extn.h
@@ -42,6 +42,7 @@ void audio_extn_set_snd_card_split(const char* in_snd_card_name);
 #define audio_extn_spkr_prot_stop_processing(snd_device)     (0)
 #define audio_extn_spkr_prot_is_enabled() (false)
 #define audio_extn_get_spkr_prot_snd_device(snd_device) (snd_device)
+#define audio_extn_spkr_prot_deinit(adev)       (0)
 #else
 void audio_extn_spkr_prot_init(void *adev);
 int audio_extn_spkr_prot_start_processing(snd_device_t snd_device);
@@ -49,6 +50,8 @@ void audio_extn_spkr_prot_stop_processing(snd_device_t snd_device);
 bool audio_extn_spkr_prot_is_enabled();
 int audio_extn_get_spkr_prot_snd_device(snd_device_t snd_device);
 void audio_extn_spkr_prot_calib_cancel(void *adev);
+void audio_extn_spkr_prot_deinit(void *adev);
+
 #endif
 
 #ifndef HFP_ENABLED
diff --git a/hal/audio_extn/cirrus_playback.c b/hal/audio_extn/cirrus_playback.c
index 21dbc10ed..25fe258d7 100644
--- a/hal/audio_extn/cirrus_playback.c
+++ b/hal/audio_extn/cirrus_playback.c
@@ -155,7 +155,11 @@ static struct pcm_config pcm_config_cirrus_rx = {
 
 static struct cirrus_playback_session handle;
 
+#ifdef CIRRUS_FACTORY_CALIBRATION
 static void *audio_extn_cirrus_calibration_thread();
+#else
+static void *audio_extn_cirrus_config_thread();
+#endif
 
 #ifdef ENABLE_CIRRUS_DETECTION
 static void *audio_extn_cirrus_failure_detect_thread();
@@ -175,11 +179,30 @@ void audio_extn_spkr_prot_init(void *adev) {
 
     pthread_mutex_init(&handle.fb_prot_mutex, NULL);
 
+#ifdef CIRRUS_FACTORY_CALIBRATION
     (void)pthread_create(&handle.calibration_thread,
                 (const pthread_attr_t *) NULL,
                 audio_extn_cirrus_calibration_thread, &handle);
+#else
+    (void)pthread_create(&handle.calibration_thread,
+                (const pthread_attr_t *) NULL,
+                audio_extn_cirrus_config_thread, &handle);
+#endif
+}
+
+void audio_extn_spkr_prot_deinit(void *adev __unused) {
+    ALOGV("%s: Entry", __func__);
+
+#ifdef ENABLE_CIRRUS_DETECTION
+    pthread_join(handle.failure_detect_thread, NULL);
+#endif
+    pthread_join(handle.calibration_thread, NULL);
+    pthread_mutex_destroy(&handle.fb_prot_mutex);
+
+    ALOGV("%s: Exit", __func__);
 }
 
+#ifdef CIRRUS_FACTORY_CALIBRATION
 static int audio_extn_cirrus_run_calibration() {
     struct audio_device *adev = handle.adev_handle;
     struct crus_sp_ioctl_header header;
@@ -282,7 +305,6 @@ static int audio_extn_cirrus_run_calibration() {
         if (ret < 0)
             goto exit;
 
-#ifdef ENABLED_CIRRUS_WRITE_CAL_FILE
         cal_file = fopen(CRUS_CAL_FILE, "wb");
         if (cal_file == NULL) {
             ALOGE("%s: Cannot create Cirrus SP calibration file (%s)",
@@ -305,7 +327,6 @@ static int audio_extn_cirrus_run_calibration() {
 
         ALOGI("%s: Cirrus calibration file successfully written",
               __func__);
-#endif
     }
 
     header.size = sizeof(header);
@@ -531,6 +552,89 @@ exit:
     return NULL;
 }
 
+#else
+static void *audio_extn_cirrus_config_thread(void) {
+    struct audio_device *adev = handle.adev_handle;
+    struct crus_sp_ioctl_header header;
+    struct cirrus_cal_result_t result;
+    struct mixer_ctl *ctl_config = NULL;
+    FILE *cal_file = NULL;
+    int ret = 0, dev_file = -1;
+
+    ALOGI("%s: ++", __func__);
+
+    memset(&result, 0, sizeof(result));
+
+    dev_file = open(CRUS_SP_FILE, O_RDWR | O_NONBLOCK);
+    if (dev_file < 0) {
+        ALOGE("%s: Failed to open Cirrus Playback IOCTL (%d)",
+              __func__, dev_file);
+        ret = -EINVAL;
+        goto exit;
+    }
+
+    cal_file = fopen(CRUS_CAL_FILE, "r");
+    if (cal_file) {
+        ret = fread(&result, sizeof(result), 1, cal_file);
+
+        if (ret != 1) {
+            ALOGE("%s: Cirrus SP calibration file cannot be read , read size: %lu file error: %d",
+                 __func__, (unsigned long)ret * sizeof(result), ferror(cal_file));
+            ret = -EINVAL;
+            goto exit;
+        }
+    }
+
+    header.size = sizeof(header);
+    header.module_id = CRUS_MODULE_ID_TX;
+    header.param_id = 0;
+    header.data_length = sizeof(result);
+    header.data = &result;
+
+    ret = ioctl(dev_file, CRUS_SP_IOCTL_SET_CALIB, &header);
+
+    if (ret < 0) {
+        ALOGE("%s: Cirrus SP calibration IOCTL failure", __func__);
+        goto exit;
+    }
+
+    ctl_config = mixer_get_ctl_by_name(adev->mixer,
+                       CRUS_SP_LOAD_CONF_MIXER);
+    if (!ctl_config) {
+        ALOGE("%s: Could not get ctl for mixer commands", __func__);
+        ret = -EINVAL;
+        goto exit;
+    }
+
+    ret = mixer_ctl_set_value(ctl_config, 0, 2);
+    if (ret < 0) {
+        ALOGE("%s load tx config failed", __func__);
+        goto exit;
+    }
+
+    ret = mixer_ctl_set_value(ctl_config, 0, 1);
+    if (ret < 0) {
+        ALOGE("%s load rx config failed", __func__);
+        goto exit;
+    }
+
+    ret = mixer_ctl_set_value(ctl_config, 0, 0);
+    if (ret < 0) {
+        ALOGE("%s set idle state failed", __func__);
+        goto exit;
+    }
+
+exit:
+    if (dev_file >= 0)
+        close(dev_file);
+    if (cal_file)
+        fclose(cal_file);
+
+    ALOGI("%s: ret: %d --", __func__, ret);
+    return NULL;
+}
+#endif
+
 #ifdef ENABLE_CIRRUS_DETECTION
 void *audio_extn_cirrus_failure_detect_thread() {
     struct audio_device *adev = handle.adev_handle;
diff --git a/hal/audio_extn/maxxaudio.c b/hal/audio_extn/maxxaudio.c
index 9007da7c7..fc6533230 100644
--- a/hal/audio_extn/maxxaudio.c
+++ b/hal/audio_extn/maxxaudio.c
@@ -37,7 +37,7 @@
 #define PRESET_PATH "/vendor/etc"
 #define MPS_BASE_STRING "default"
 #define USER_PRESET_PATH ""
-#define CONFIG_PATH "/vendor/etc/maxx_conf.ini"
+#define CONFIG_BASE_STRING "maxx_conf"
 #define CAL_PRESIST_STR "cal_persist"
 #define CAL_SAMPLERATE_STR "cal_samplerate"
 
@@ -344,6 +344,7 @@ void audio_extn_ma_init(void *platform)
     int ret = 0;
     char lib_path[128] = {0};
     char mps_path[128] = {0};
+    char cnf_path[128] = {0};
     struct snd_card_split *snd_split_handle = NULL;
     snd_split_handle = audio_extn_get_snd_card_split();
 
@@ -427,8 +428,17 @@ void audio_extn_ma_init(void *platform)
                  PRESET_PATH, MPS_BASE_STRING, snd_split_handle->form_factor);
     }
 
+    /* get config files */
+    if (snd_split_handle == NULL) {
+        snprintf(cnf_path, sizeof(cnf_path), "%s/%s.ini",
+                 PRESET_PATH, CONFIG_BASE_STRING);
+    } else {
+        snprintf(cnf_path, sizeof(cnf_path), "%s/%s_%s.ini",
+                 PRESET_PATH, CONFIG_BASE_STRING, snd_split_handle->form_factor);
+    }
+
     /* check file */
-    if (access(mps_path, F_OK) < 0) {
+    if (access(mps_path, R_OK) < 0) {
         ALOGW("%s: file %s isn't existed.", __func__, mps_path);
         goto error;
     } else
@@ -440,16 +450,18 @@ void audio_extn_ma_init(void *platform)
         goto error;
     }
     */
-    if (access(CONFIG_PATH, F_OK) < 0) {
-        ALOGW("%s: file %s isn't existed.", __func__, CONFIG_PATH);
+
+    if (access(cnf_path, R_OK) < 0) {
+        ALOGW("%s: file %s isn't existed.", __func__, cnf_path);
         goto error;
-    }
+    } else
+        ALOGD("%s: Loading ini file: %s", __func__, cnf_path);
 
     /* init ma parameter */
     if (my_data->ma_param_init(&g_ma_audio_cal_handle,
                                mps_path,
                                USER_PRESET_PATH, /* unused */
-                               CONFIG_PATH,
+                               cnf_path,
                                &set_audio_cal)) {
         if (!g_ma_audio_cal_handle) {
             ALOGE("%s: ma parameters initialize failed", __func__);
diff --git a/hal/audio_extn/sndmonitor.c b/hal/audio_extn/sndmonitor.c
index 6e06d0363..2e8fd43fb 100644
--- a/hal/audio_extn/sndmonitor.c
+++ b/hal/audio_extn/sndmonitor.c
@@ -51,6 +51,11 @@
 #define MAX_CPE_SLEEP_RETRY 2
 #define CPE_SLEEP_WAIT 100
 
+#define SPLI_STATE_PATH "/proc/wcd-spi-ac/svc-state"
+#define SLPI_MAGIC_NUM 0x3000
+#define MAX_SLPI_SLEEP_RETRY 2
+#define SLPI_SLEEP_WAIT_MS 100
+
 #define MAX_SLEEP_RETRY 100
 #define AUDIO_INIT_SLEEP_WAIT 100 /* 100 ms */
 
@@ -245,6 +250,31 @@ static int enum_sndcards()
     if (line)
         free(line);
     fclose(fp);
+
+    /* Add fd to query for SLPI status */
+    if (access(SPLI_STATE_PATH, R_OK) < 0) {
+        ALOGV("access to %s failed: %s", SPLI_STATE_PATH, strerror(errno));
+    } else {
+        tries = MAX_SLPI_SLEEP_RETRY;
+        ALOGV("Open %s", SPLI_STATE_PATH);
+        while (tries--) {
+            if ((fd = open(SPLI_STATE_PATH, O_RDONLY)) < 0) {
+                ALOGW("Open %s failed %s, retry", SPLI_STATE_PATH,
+                      strerror(errno));
+                usleep(SLPI_SLEEP_WAIT_MS * 1000);
+                continue;
+            }
+            break;
+        }
+        if (fd >= 0) {
+            ret = add_new_sndcard(SLPI_MAGIC_NUM, fd);
+            if (ret != 0)
+                close(fd);
+            else
+                num_cards++;
+        }
+    }
+
     ALOGV("sndmonitor registerer num_cards %d", num_cards);
     sndmonitor.num_cards = num_cards;
     return num_cards ? 0 : -1;
@@ -383,7 +413,6 @@ bool on_sndcard_state_update(sndcard_t * s)
 
     ALOGV("card num %d, new state %s", s->card, rd_buf);
 
-    bool is_cpe = (s->card >= CPE_MAGIC_NUM);
     if (strstr(rd_buf, "OFFLINE"))
         status = CARD_STATUS_OFFLINE;
     else if (strstr(rd_buf, "ONLINE"))
@@ -404,11 +433,18 @@ bool on_sndcard_state_update(sndcard_t * s)
         return -1;
 
     char val[32] = {0};
-    // cpe actual card num is (card - MAGIC_NUM). so subtract accordingly
-    snprintf(val, sizeof(val), "%d,%s", s->card - (is_cpe ? CPE_MAGIC_NUM : 0),
+    bool is_cpe = ((s->card >= CPE_MAGIC_NUM) && (s->card < SLPI_MAGIC_NUM));
+    bool is_slpi = (s->card == SLPI_MAGIC_NUM);
+    /*
+     * cpe actual card num is (card - CPE_MAGIC_NUM), so subtract accordingly.
+     * SLPI actual fd num is (card - SLPI_MAGIC_NUM), so subtract accordingly.
+     */
+    snprintf(val, sizeof(val), "%d,%s",
+        s->card - (is_cpe ? CPE_MAGIC_NUM : (is_slpi ? SLPI_MAGIC_NUM : 0)),
                  status == CARD_STATUS_ONLINE ? "ONLINE" : "OFFLINE");
 
-    if (str_parms_add_str(params, is_cpe ? "CPE_STATUS" : "SND_CARD_STATUS",
+    if (str_parms_add_str(params,
+            is_cpe ? "CPE_STATUS" : (is_slpi ? "SLPI_STATUS" : "SND_CARD_STATUS"),
                           val) < 0)
         return -1;
 
diff --git a/hal/audio_extn/soundtrigger.c b/hal/audio_extn/soundtrigger.c
index c11e74721..063a7babe 100644
--- a/hal/audio_extn/soundtrigger.c
+++ b/hal/audio_extn/soundtrigger.c
@@ -78,7 +78,9 @@ typedef enum {
     SND_CARD_STATUS_OFFLINE,
     SND_CARD_STATUS_ONLINE,
     CPE_STATUS_OFFLINE,
-    CPE_STATUS_ONLINE
+    CPE_STATUS_ONLINE,
+    SLPI_STATUS_OFFLINE,
+    SLPI_STATUS_ONLINE,
 } ssr_event_status_t;
 
 struct sound_trigger_session_info {
@@ -362,9 +364,6 @@ void audio_extn_sound_trigger_update_device_status(snd_device_t snd_device,
     if (!st_dev)
        return;
 
-    if (st_dev->sthal_prop_api_version >= STHAL_PROP_API_VERSION_1_0)
-        return;
-
     if (snd_device >= SND_DEVICE_OUT_BEGIN &&
         snd_device < SND_DEVICE_OUT_END) {
         device_type = PCM_PLAYBACK;
@@ -484,6 +483,19 @@ void audio_extn_sound_trigger_set_parameters(struct audio_device *adev __unused,
         event.u.value = val;
         st_dev->st_callback(AUDIO_EVENT_NUM_ST_SESSIONS, &event);
     }
+
+    ret = str_parms_get_str(params, "SLPI_STATUS", value, sizeof(value));
+    if (ret > 0) {
+        if (strstr(value, "OFFLINE")) {
+            event.u.status = SLPI_STATUS_OFFLINE;
+            st_dev->st_callback(AUDIO_EVENT_SSR, &event);
+        } else if (strstr(value, "ONLINE")) {
+            event.u.status = SLPI_STATUS_ONLINE;
+            st_dev->st_callback(AUDIO_EVENT_SSR, &event);
+        } else {
+            ALOGE("%s: unknown SLPI status", __func__);
+        }
+    }
 }
 
 int audio_extn_sound_trigger_init(struct audio_device *adev)
diff --git a/hal/audio_extn/spkr_protection.c b/hal/audio_extn/spkr_protection.c
index 8c09a295f..dba69a076 100644
--- a/hal/audio_extn/spkr_protection.c
+++ b/hal/audio_extn/spkr_protection.c
@@ -780,6 +780,11 @@ void audio_extn_spkr_prot_init(void *adev)
     }
 }
 
+void audio_extn_spkr_prot_deinit(void *adev __unused)
+{
+    ALOGV("%s: Entry", __func__);
+}
+
 int audio_extn_get_spkr_prot_snd_device(snd_device_t snd_device)
 {
     if (!handle.spkr_prot_enable)
diff --git a/hal/audio_extn/utils.c b/hal/audio_extn/utils.c
index 1751a30e1..73de0abaa 100644
--- a/hal/audio_extn/utils.c
+++ b/hal/audio_extn/utils.c
@@ -345,6 +345,8 @@ int audio_extn_utils_send_app_type_cfg(struct audio_device *adev,
     int sample_rate;
     int app_type;
     int acdb_dev_id;
+    int new_snd_device[2] = {0};
+    int i = 0, num_devices = 1;
     size_t app_type_cfg[MAX_LENGTH_MIXER_CONTROL_IN_INT] = {0};
     char mixer_ctl_name[MAX_LENGTH_MIXER_CONTROL_IN_INT] = {0};
     int pcm_device_id;
@@ -379,18 +381,33 @@ int audio_extn_utils_send_app_type_cfg(struct audio_device *adev,
         return -1;
     }
 
-    acdb_dev_id = derive_acdb_dev_id(adev, usecase);
-    if (acdb_dev_id <= 0) {
-        ALOGE("%s: Couldn't get the acdb dev id", __func__);
-        return -1;
-    }
+    if (usecase->type == PCM_PLAYBACK) {
+        if (platform_can_split_snd_device(usecase->out_snd_device,
+                                          &num_devices, new_snd_device) < 0)
+            new_snd_device[0] = usecase->out_snd_device;
+
+    } else if (usecase->type == PCM_CAPTURE)
+        new_snd_device[0] = usecase->in_snd_device;
 
     pcm_device_id = platform_get_pcm_device_id(usecase->id, usecase->type);
-    set_stream_app_type_mixer_ctrl(adev, pcm_device_id, app_type, acdb_dev_id,
-                                   sample_rate,
-                                   usecase->type,
-                                   usecase->type == PCM_PLAYBACK ? usecase->out_snd_device :
-                                                                   usecase->in_snd_device);
+
+    for (i = 0; i < num_devices; i++) {
+        acdb_dev_id = platform_get_snd_device_acdb_id(new_snd_device[i]);
+
+        if (acdb_dev_id < 0) {
+            ALOGE("%s: Could not find acdb id for device(%d)",
+                  __func__, new_snd_device[i]);
+            return -EINVAL;
+        }
+        ALOGV("%s: sending app type for snd_device(%d) acdb_id(%d) i %d",
+              __func__, new_snd_device[i], acdb_dev_id, i);
+
+        set_stream_app_type_mixer_ctrl(adev, pcm_device_id, app_type, acdb_dev_id,
+                                       sample_rate,
+                                       usecase->type,
+                                       new_snd_device[i]);
+    }
+
     return 0;
 }
 
diff --git a/hal/audio_hw.c b/hal/audio_hw.c
index 0a12cff5c..955957317 100644
--- a/hal/audio_hw.c
+++ b/hal/audio_hw.c
@@ -1373,6 +1373,10 @@ int select_devices(struct audio_device *adev,
             out_snd_device = SND_DEVICE_OUT_SPEAKER;
     }
 
+    if (usecase->id == USECASE_INCALL_MUSIC_UPLINK) {
+        out_snd_device = SND_DEVICE_OUT_VOICE_MUSIC_TX;
+    }
+
     if (out_snd_device != SND_DEVICE_NONE &&
             out_snd_device != adev->last_logged_snd_device[uc_id][0]) {
         ALOGD("%s: changing use case %s output device from(%d: %s, acdb %d) to (%d: %s, acdb %d)",
@@ -1954,6 +1958,8 @@ static int stop_output_stream(struct stream_out *out)
     int i, ret = 0;
     struct audio_usecase *uc_info;
     struct audio_device *adev = out->dev;
+    bool has_voip_usecase =
+        get_usecase_from_list(adev, USECASE_AUDIO_PLAYBACK_VOIP) != NULL;
 
     ALOGV("%s: enter: usecase(%d: %s)", __func__,
           out->usecase, use_case_table[out->usecase]);
@@ -1987,15 +1993,7 @@ static int stop_output_stream(struct stream_out *out)
     /* Must be called after removing the usecase from list */
     if (out->devices & AUDIO_DEVICE_OUT_AUX_DIGITAL)
         check_and_set_hdmi_channels(adev, DEFAULT_HDMI_OUT_CHANNELS);
-    else if (out->devices & AUDIO_DEVICE_OUT_SPEAKER_SAFE) {
-        struct listnode *node;
-        struct audio_usecase *usecase;
-        list_for_each(node, &adev->usecase_list) {
-            usecase = node_to_item(node, struct audio_usecase, list);
-            if (usecase->devices & AUDIO_DEVICE_OUT_SPEAKER)
-                select_devices(adev, usecase->id);
-        }
-    } else if (audio_is_usb_out_device(out->devices & AUDIO_DEVICE_OUT_ALL_USB)) {
+    else if (audio_is_usb_out_device(out->devices & AUDIO_DEVICE_OUT_ALL_USB)) {
         ret = check_and_set_usb_service_interval(adev, uc_info, false /*min*/);
         if (ret == 0) {
             /* default service interval was successfully updated,
@@ -2005,6 +2003,22 @@ static int stop_output_stream(struct stream_out *out)
         ret = 0;
     }
 
+    if (has_voip_usecase ||
+            out->devices & AUDIO_DEVICE_OUT_SPEAKER_SAFE) {
+        struct listnode *node;
+        struct audio_usecase *usecase;
+        list_for_each(node, &adev->usecase_list) {
+            usecase = node_to_item(node, struct audio_usecase, list);
+            if (usecase->type == PCM_CAPTURE || usecase == uc_info)
+                continue;
+
+            ALOGD("%s: select_devices at usecase(%d: %s) after removing the usecase(%d: %s)",
+                __func__, usecase->id, use_case_table[usecase->id],
+                out->usecase, use_case_table[out->usecase]);
+            select_devices(adev, usecase->id);
+        }
+    }
+
     free(uc_info);
     ALOGV("%s: exit: status(%d)", __func__, ret);
     return ret;
@@ -2105,8 +2119,13 @@ int start_output_stream(struct stream_out *out)
         if (out->offload_callback)
             compress_nonblock(out->compr, out->non_blocking);
 
-        if (adev->visualizer_start_output != NULL)
-            adev->visualizer_start_output(out->handle, out->pcm_device_id);
+        if (adev->visualizer_start_output != NULL) {
+            int capture_device_id =
+                platform_get_pcm_device_id(USECASE_AUDIO_RECORD_AFE_PROXY,
+                                           PCM_CAPTURE);
+            adev->visualizer_start_output(out->handle, out->pcm_device_id,
+                                          adev->snd_card, capture_device_id);
+        }
         if (adev->offload_effects_start_output != NULL)
             adev->offload_effects_start_output(out->handle, out->pcm_device_id);
     } else if (out->usecase == USECASE_AUDIO_PLAYBACK_MMAP) {
@@ -5608,7 +5627,7 @@ static int adev_open(const hw_module_t *module, const char *name,
     } else {
         ALOGV("%s: DLOPEN successful for %s", __func__, VISUALIZER_LIBRARY_PATH);
         adev->visualizer_start_output =
-                    (int (*)(audio_io_handle_t, int))dlsym(adev->visualizer_lib,
+                    (int (*)(audio_io_handle_t, int, int, int))dlsym(adev->visualizer_lib,
                                                     "visualizer_hal_start_output");
         adev->visualizer_stop_output =
                     (int (*)(audio_io_handle_t, int))dlsym(adev->visualizer_lib,
diff --git a/hal/audio_hw.h b/hal/audio_hw.h
index 921c249c9..637984409 100644
--- a/hal/audio_hw.h
+++ b/hal/audio_hw.h
@@ -337,7 +337,7 @@ struct audio_device {
     card_status_t card_status;
 
     void *visualizer_lib;
-    int (*visualizer_start_output)(audio_io_handle_t, int);
+    int (*visualizer_start_output)(audio_io_handle_t, int, int, int);
     int (*visualizer_stop_output)(audio_io_handle_t, int);
 
     /* The pcm_params use_case_table is loaded by adev_verify_devices() upon
diff --git a/hal/msm8916/platform.c b/hal/msm8916/platform.c
index d92243e90..f6508c31a 100644
--- a/hal/msm8916/platform.c
+++ b/hal/msm8916/platform.c
@@ -232,6 +232,7 @@ static const char * const device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_VCO_HEADPHONES] = "voice-tty-vco-headphones",
     [SND_DEVICE_OUT_VOICE_TTY_HCO_HANDSET] = "voice-tty-hco-handset",
     [SND_DEVICE_OUT_VOICE_TX] = "voice-tx",
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = "voice-music-tx",
     [SND_DEVICE_OUT_AFE_PROXY] = "afe-proxy",
     [SND_DEVICE_OUT_USB_HEADSET] = "usb-headphones",
     [SND_DEVICE_OUT_USB_HEADPHONES] = "usb-headphones",
@@ -326,6 +327,7 @@ static int acdb_device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_VCO_HEADPHONES] = 17,
     [SND_DEVICE_OUT_VOICE_TTY_HCO_HANDSET] = 37,
     [SND_DEVICE_OUT_VOICE_TX] = 45,
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = 3,
     [SND_DEVICE_OUT_AFE_PROXY] = 0,
     [SND_DEVICE_OUT_USB_HEADSET] = 45,
     [SND_DEVICE_OUT_VOICE_USB_HEADSET] = 45,
@@ -1205,6 +1207,8 @@ void platform_deinit(void *platform)
     struct operator_specific_device *device_item;
     struct listnode *node;
 
+    audio_extn_spkr_prot_deinit(my_data->adev);
+
     hw_info_deinit(my_data->hw_info);
 
     for (dev = 0; dev < SND_DEVICE_MAX; dev++) {
diff --git a/hal/msm8916/platform.h b/hal/msm8916/platform.h
index b69b6c9f7..5b4004f7e 100644
--- a/hal/msm8916/platform.h
+++ b/hal/msm8916/platform.h
@@ -78,6 +78,7 @@ enum {
     SND_DEVICE_OUT_VOICE_TTY_VCO_HEADPHONES,
     SND_DEVICE_OUT_VOICE_TTY_HCO_HANDSET,
     SND_DEVICE_OUT_VOICE_TX,
+    SND_DEVICE_OUT_VOICE_MUSIC_TX,
     SND_DEVICE_OUT_AFE_PROXY,
     SND_DEVICE_OUT_USB_HEADSET,
     SND_DEVICE_OUT_USB_HEADPHONES,
diff --git a/hal/msm8974/platform.c b/hal/msm8974/platform.c
index 429291cfb..a3462d1a4 100644
--- a/hal/msm8974/platform.c
+++ b/hal/msm8974/platform.c
@@ -30,7 +30,7 @@
 #include "platform.h"
 #include "audio_extn.h"
 #include <linux/msm_audio.h>
-#if defined (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845)
+#if defined (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845) || (PLATFORM_SDM710)
 #include <sound/devdep_params.h>
 #endif
 
@@ -143,7 +143,7 @@ struct platform_data {
     bool speaker_lr_swap;
 
     void *acdb_handle;
-#if defined (PLATFORM_MSM8994) || (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845)
+#if defined (PLATFORM_MSM8994) || (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845) || (PLATFORM_SDM710)
     acdb_init_v2_cvd_t acdb_init;
 #elif defined (PLATFORM_MSM8084)
     acdb_init_v2_t acdb_init;
@@ -271,6 +271,7 @@ static const char * const device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_FULL_USB] = "voice-tty-full-usb",
     [SND_DEVICE_OUT_VOICE_TTY_VCO_USB] = "voice-tty-vco-usb",
     [SND_DEVICE_OUT_VOICE_TX] = "voice-tx",
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = "voice-music-tx",
     [SND_DEVICE_OUT_USB_HEADSET] = "usb-headset",
     [SND_DEVICE_OUT_VOICE_USB_HEADSET] = "usb-headset",
     [SND_DEVICE_OUT_USB_HEADPHONES] = "usb-headphones",
@@ -393,6 +394,7 @@ static int acdb_device_table[SND_DEVICE_MAX] = {
     [SND_DEVICE_OUT_VOICE_TTY_FULL_USB] = 17,
     [SND_DEVICE_OUT_VOICE_TTY_VCO_USB] = 17,
     [SND_DEVICE_OUT_VOICE_TX] = 45,
+    [SND_DEVICE_OUT_VOICE_MUSIC_TX] = 3,
     [SND_DEVICE_OUT_USB_HEADSET] = 45,
     [SND_DEVICE_OUT_VOICE_USB_HEADSET] = 45,
     [SND_DEVICE_OUT_USB_HEADPHONES] = 45,
@@ -771,7 +773,7 @@ static const char *get_operator_specific_device_mixer_path(snd_device_t snd_devi
 
 inline bool platform_supports_app_type_cfg()
 {
-#if defined (PLATFORM_MSM8998) || (PLATFORM_SDM845)
+#if defined (PLATFORM_MSM8998) || (PLATFORM_SDM845) || (PLATFORM_SDM710)
     return true;
 #else
     return false;
@@ -1240,6 +1242,7 @@ static void set_platform_defaults(struct platform_data * my_data)
     hw_interface_table[SND_DEVICE_OUT_VOICE_HAC_HANDSET] = strdup("SLIMBUS_0_RX");
     hw_interface_table[SND_DEVICE_OUT_VOICE_SPEAKER] = strdup("SLIMBUS_0_RX");
     hw_interface_table[SND_DEVICE_OUT_VOICE_HEADPHONES] = strdup("SLIMBUS_0_RX");
+    hw_interface_table[SND_DEVICE_OUT_VOICE_MUSIC_TX] = strdup("VOICE_PLAYBACK_TX");
     hw_interface_table[SND_DEVICE_OUT_VOICE_LINE] = strdup("SLIMBUS_0_RX");
     hw_interface_table[SND_DEVICE_OUT_HDMI] = strdup("HDMI_RX");
     hw_interface_table[SND_DEVICE_OUT_SPEAKER_AND_HDMI] = strdup("SLIMBUS_0_RX-and-HDMI_RX");
@@ -1376,7 +1379,7 @@ static int platform_acdb_init(void *platform)
         return 0;
     }
 
-#if defined (PLATFORM_MSM8994) || (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845)
+#if defined (PLATFORM_MSM8994) || (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845) || (PLATFORM_SDM710)
     char *cvd_version = calloc(1, MAX_CVD_VERSION_STRING_SIZE);
     if (!cvd_version)
         ALOGE("failed to allocate cvd_version");
@@ -1745,7 +1748,7 @@ void *platform_init(struct audio_device *adev)
         configure_flicker_sensor_input(adev->mixer);
 #endif
 
-#if defined (PLATFORM_MSM8994) || (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845)
+#if defined (PLATFORM_MSM8994) || (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845) || (PLATFORM_SDM710)
         acdb_init_v2_cvd_t acdb_init_local;
         acdb_init_local = (acdb_init_v2_cvd_t)dlsym(my_data->acdb_handle,
                                               "acdb_loader_init_v2");
@@ -1834,6 +1837,8 @@ void platform_deinit(void *platform)
     struct platform_data *my_data = (struct platform_data *)platform;
     close_csd_client(my_data->csd);
 
+    audio_extn_spkr_prot_deinit(my_data->adev);
+
     hw_info_deinit(my_data->hw_info);
 
     for (dev = 0; dev < SND_DEVICE_MAX; dev++) {
@@ -4535,7 +4540,7 @@ int platform_set_sidetone(struct audio_device *adev,
 int platform_get_mmap_data_fd(void *platform __unused, int fe_dev __unused, int dir __unused,
                               int *fd __unused, uint32_t *size __unused)
 {
-#if defined (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845)
+#if defined (PLATFORM_MSM8996) || (PLATFORM_MSM8998) || (PLATFORM_SDM845) || (PLATFORM_SDM710)
     struct platform_data *my_data = (struct platform_data *)platform;
     struct audio_device *adev = my_data->adev;
     int hw_fd = -1;
diff --git a/hal/msm8974/platform.h b/hal/msm8974/platform.h
index 2c7eebf2d..8661fad74 100644
--- a/hal/msm8974/platform.h
+++ b/hal/msm8974/platform.h
@@ -89,6 +89,7 @@ enum {
     SND_DEVICE_OUT_VOICE_TTY_VCO_USB,
     SND_DEVICE_OUT_VOICE_HAC_HANDSET,
     SND_DEVICE_OUT_VOICE_TX,
+    SND_DEVICE_OUT_VOICE_MUSIC_TX,
     SND_DEVICE_OUT_SPEAKER_PROTECTED,
     SND_DEVICE_OUT_VOICE_SPEAKER_PROTECTED,
     SND_DEVICE_OUT_VOICE_SPEAKER_HFP,
diff --git a/post_proc/Android.mk b/post_proc/Android.mk
index 8ee77aca8..eceb37e71 100644
--- a/post_proc/Android.mk
+++ b/post_proc/Android.mk
@@ -1,4 +1,4 @@
-ifneq ($(filter msm8974 msm8226 msm8084 msm8992 msm8994 msm8996 msm8909 msm8998 sdm845,$(TARGET_BOARD_PLATFORM)),)
+ifneq ($(filter msm8974 msm8226 msm8084 msm8992 msm8994 msm8996 msm8909 msm8998 sdm845 sdm710,$(TARGET_BOARD_PLATFORM)),)
 
 LOCAL_PATH:= $(call my-dir)
 
@@ -46,7 +46,7 @@ endif
 
 ################################################################################
 
-ifneq ($(filter msm8992 msm8994 msm8996 msm8909 msm8998 sdm845,$(TARGET_BOARD_PLATFORM)),)
+ifneq ($(filter msm8992 msm8994 msm8996 msm8909 msm8998 sdm845 sdm710,$(TARGET_BOARD_PLATFORM)),)
 
 include $(CLEAR_VARS)
 
diff --git a/visualizer/Android.mk b/visualizer/Android.mk
index 7d7cfe982..13a45c734 100644
--- a/visualizer/Android.mk
+++ b/visualizer/Android.mk
@@ -27,14 +27,6 @@ LOCAL_SHARED_LIBRARIES := \
 	libdl \
 	libtinyalsa
 
-# HACK to set the right record proxy effect card number.
-# It should be retrieved from the primary hal USECASE_AUDIO_RECORD_AFE_PROXY.
-ifneq ($(filter msm8998,$(TARGET_BOARD_PLATFORM)),)
-  LOCAL_CFLAGS := -DCAPTURE_DEVICE=7
-else
-  LOCAL_CFLAGS := -DCAPTURE_DEVICE=8
-endif
-
 LOCAL_CFLAGS += \
     -Wall \
     -Werror \
diff --git a/visualizer/offload_visualizer.c b/visualizer/offload_visualizer.c
index 860dfce83..74beac733 100644
--- a/visualizer/offload_visualizer.c
+++ b/visualizer/offload_visualizer.c
@@ -145,6 +145,12 @@ const effect_descriptor_t *descriptors[] = {
         NULL,
 };
 
+struct pcm_capture_config {
+    int snd_card_num;
+    int capture_device_id;
+};
+
+struct pcm_capture_config capture_config;
 
 pthread_once_t once = PTHREAD_ONCE_INIT;
 int init_status;
@@ -172,16 +178,12 @@ bool exit_thread;
 /* 0 if the capture thread was created successfully */
 int thread_status;
 
-
 #define DSP_OUTPUT_LATENCY_MS 0 /* Fudge factor for latency after capture point in audio DSP */
 
 /* Retry for delay for mixer open */
 #define RETRY_NUMBER 10
 #define RETRY_US 500000
 
-#define MIXER_CARD 0
-#define SOUND_CARD 0
-
 /* Proxy port supports only MMAP read and those fixed parameters*/
 #define AUDIO_CAPTURE_CHANNEL_COUNT 2
 #define AUDIO_CAPTURE_SMP_RATE 48000
@@ -338,10 +340,10 @@ void *capture_thread_loop(void *arg __unused)
 
     pthread_mutex_lock(&lock);
 
-    mixer = mixer_open(MIXER_CARD);
+    mixer = mixer_open(capture_config.snd_card_num);
     while (mixer == NULL && retry_num < RETRY_NUMBER) {
         usleep(RETRY_US);
-        mixer = mixer_open(MIXER_CARD);
+        mixer = mixer_open(capture_config.snd_card_num);
         retry_num++;
     }
     if (mixer == NULL) {
@@ -357,7 +359,8 @@ void *capture_thread_loop(void *arg __unused)
             if (!capture_enabled) {
                 ret = configure_proxy_capture(mixer, 1);
                 if (ret == 0) {
-                    pcm = pcm_open(SOUND_CARD, CAPTURE_DEVICE,
+                    pcm = pcm_open(capture_config.snd_card_num,
+                                   capture_config.capture_device_id,
                                    PCM_IN|PCM_MMAP|PCM_NOIRQ, &pcm_config_capture);
                     if (pcm && !pcm_is_ready(pcm)) {
                         ALOGW("%s: %s", __func__, pcm_get_error(pcm));
@@ -427,7 +430,8 @@ void *capture_thread_loop(void *arg __unused)
  */
 
 __attribute__ ((visibility ("default")))
-int visualizer_hal_start_output(audio_io_handle_t output, int pcm_id) {
+int visualizer_hal_start_output(audio_io_handle_t output, int pcm_id,
+                                int card_number, int pcm_capture_id) {
     int ret = 0;
     struct listnode *node;
 
@@ -444,6 +448,11 @@ int visualizer_hal_start_output(audio_io_handle_t output, int pcm_id) {
         goto exit;
     }
 
+    ALOGV("%s card number %d pcm_capture_id %d",
+          __func__, card_number, pcm_capture_id);
+    capture_config.snd_card_num = card_number;
+    capture_config.capture_device_id = pcm_capture_id;
+
     output_context_t *out_ctxt = (output_context_t *)malloc(sizeof(output_context_t));
     out_ctxt->handle = output;
     list_init(&out_ctxt->effects_list);
-- 
2.17.1

