From 256d3f4aae632ef1d778ea40c186a4bfaccc5924 Mon Sep 17 00:00:00 2001
From: Sneh Bansal <snehb@codeaurora.org>
Date: Wed, 24 Jan 2018 15:57:05 +0530
Subject: [PATCH 07/14] Enable vendor Telephony plugin

- Add hooks to vendor components.
- Change access specifiers of members from private to protected.
- Override factory methods.
- Add support for HIDL service to implement vendor/OEM specific features.

CRs-Fixed: 2178879
Change-Id: I0b8369f88c05d56973c0adb6f08607460601302e
---
 .../internal/telephony/GsmCdmaPhone.java      |  2 +-
 .../internal/telephony/PhoneFactory.java      | 23 +++--
 .../internal/telephony/PhoneSwitcher.java     | 51 +++++-----
 .../com/android/internal/telephony/RIL.java   | 26 +++++-
 .../telephony/ServiceStateTracker.java        |  6 +-
 .../telephony/TelephonyComponentFactory.java  | 92 ++++++++++++++++++-
 .../telephony/dataconnection/DcTracker.java   | 26 +++---
 7 files changed, 174 insertions(+), 52 deletions(-)

diff --git a/src/java/com/android/internal/telephony/GsmCdmaPhone.java b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
index 97951c0f8..8c0caef72 100644
--- a/src/java/com/android/internal/telephony/GsmCdmaPhone.java
+++ b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
@@ -3268,7 +3268,7 @@ public class GsmCdmaPhone extends Phone {
         }
     }
 
-    private void phoneObjectUpdater(int newVoiceRadioTech) {
+    protected void phoneObjectUpdater(int newVoiceRadioTech) {
         logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
 
         // Check for a voice over lte replacement
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index ba777470f..512e8a87b 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -136,6 +136,8 @@ public class PhoneFactory {
                 }
 
                 sPhoneNotifier = new DefaultPhoneNotifier();
+                TelephonyComponentFactory telephonyComponentFactory
+                        = TelephonyComponentFactory.getInstance();
 
                 int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
                 Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
@@ -168,11 +170,11 @@ public class PhoneFactory {
                     networkModes[i] = RILConstants.PREFERRED_NETWORK_MODE;
 
                     Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
-                    sCommandsInterfaces[i] = new RIL(context, networkModes[i],
-                            cdmaSubscription, i);
+                    sCommandsInterfaces[i] = telephonyComponentFactory.makeRIL(context,
+                            networkModes[i], cdmaSubscription, i);
                 }
                 Rlog.i(LOG_TAG, "Creating SubscriptionController");
-                SubscriptionController.init(context, sCommandsInterfaces);
+                telephonyComponentFactory.initSubscriptionController(context, sCommandsInterfaces);
 
                 // Instantiate UiccController so that all other classes can just
                 // call getInstance()
@@ -188,15 +190,15 @@ public class PhoneFactory {
                     Phone phone = null;
                     int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
                     if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
-                        phone = new GsmCdmaPhone(context,
+                        phone = telephonyComponentFactory.makePhone(context,
                                 sCommandsInterfaces[i], sPhoneNotifier, i,
                                 PhoneConstants.PHONE_TYPE_GSM,
-                                TelephonyComponentFactory.getInstance());
+                                telephonyComponentFactory);
                     } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
-                        phone = new GsmCdmaPhone(context,
+                        phone = telephonyComponentFactory.makePhone(context,
                                 sCommandsInterfaces[i], sPhoneNotifier, i,
                                 PhoneConstants.PHONE_TYPE_CDMA_LTE,
-                                TelephonyComponentFactory.getInstance());
+                                telephonyComponentFactory);
                     }
                     Rlog.i(LOG_TAG, "Creating Phone with type = " + phoneType + " sub = " + i);
 
@@ -225,7 +227,7 @@ public class PhoneFactory {
                 sMadeDefaults = true;
 
                 Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
-                sSubInfoRecordUpdater = new SubscriptionInfoUpdater(
+                sSubInfoRecordUpdater = telephonyComponentFactory.makeSubscriptionInfoUpdater(
                         BackgroundThread.get().getLooper(), context, sPhones, sCommandsInterfaces);
                 SubscriptionController.getInstance().updatePhonesAvailability(sPhones);
 
@@ -243,7 +245,8 @@ public class PhoneFactory {
 
                 sSubscriptionMonitor = new SubscriptionMonitor(tr, sContext, sc, numPhones);
 
-                sPhoneSwitcher = new PhoneSwitcher(MAX_ACTIVE_PHONES, numPhones,
+                sPhoneSwitcher = telephonyComponentFactory.
+                        makePhoneSwitcher(MAX_ACTIVE_PHONES, numPhones,
                         sContext, sc, Looper.myLooper(), tr, sCommandsInterfaces,
                         sPhones);
 
@@ -260,6 +263,8 @@ public class PhoneFactory {
                             sPhoneSwitcher, sc, sSubscriptionMonitor, Looper.myLooper(),
                             sContext, i, sPhones[i].mDcTracker);
                 }
+                telephonyComponentFactory.makeExtTelephonyClasses(
+                        context, sPhones, sCommandsInterfaces);
             }
         }
     }
diff --git a/src/java/com/android/internal/telephony/PhoneSwitcher.java b/src/java/com/android/internal/telephony/PhoneSwitcher.java
index cd28b2b7a..be122bb4e 100644
--- a/src/java/com/android/internal/telephony/PhoneSwitcher.java
+++ b/src/java/com/android/internal/telephony/PhoneSwitcher.java
@@ -57,29 +57,32 @@ import java.util.List;
  * the active phones.  Note we don't wait for data attach (which may not happen anyway).
  */
 public class PhoneSwitcher extends Handler {
-    private final static String LOG_TAG = "PhoneSwitcher";
-    private final static boolean VDBG = false;
-
-    private final int mMaxActivePhones;
-    private final List<DcRequest> mPrioritizedDcRequests = new ArrayList<DcRequest>();
-    private final RegistrantList[] mActivePhoneRegistrants;
-    private final SubscriptionController mSubscriptionController;
-    private final int[] mPhoneSubscriptions;
-    private final CommandsInterface[] mCommandsInterfaces;
-    private final Context mContext;
-    private final PhoneState[] mPhoneStates;
-    private final int mNumPhones;
+    protected final static String LOG_TAG = "PhoneSwitcher";
+    protected final static boolean VDBG = false;
+
+    protected int mMaxActivePhones;
+    protected final List<DcRequest> mPrioritizedDcRequests = new ArrayList<DcRequest>();
+    protected final RegistrantList[] mActivePhoneRegistrants;
+    protected final SubscriptionController mSubscriptionController;
+    protected final int[] mPhoneSubscriptions;
+    protected final CommandsInterface[] mCommandsInterfaces;
+    protected final Context mContext;
+    protected final PhoneState[] mPhoneStates;
+    protected final int mNumPhones;
     private final Phone[] mPhones;
     private final LocalLog mLocalLog;
 
-    private int mDefaultDataSubscription;
+    protected int mDefaultDataSubscription;
 
-    private final static int EVENT_DEFAULT_SUBSCRIPTION_CHANGED = 101;
-    private final static int EVENT_SUBSCRIPTION_CHANGED         = 102;
+    protected final static int EVENT_DEFAULT_SUBSCRIPTION_CHANGED = 101;
+    protected final static int EVENT_SUBSCRIPTION_CHANGED         = 102;
     private final static int EVENT_REQUEST_NETWORK              = 103;
     private final static int EVENT_RELEASE_NETWORK              = 104;
     private final static int EVENT_EMERGENCY_TOGGLE             = 105;
     private final static int EVENT_RESEND_DATA_ALLOWED          = 106;
+    protected final static int EVENT_VOICE_CALL_ENDED           = 107;
+    protected static final int EVENT_UNSOL_MAX_DATA_ALLOWED_CHANGED = 108;
+    protected static final int EVENT_OEM_HOOK_SERVICE_READY     = 109;
 
     private final static int MAX_LOCAL_LOG_LINES = 30;
 
@@ -204,7 +207,7 @@ public class PhoneSwitcher extends Handler {
         }
     }
 
-    private boolean isEmergency() {
+    protected boolean isEmergency() {
         for (Phone p : mPhones) {
             if (p == null) continue;
             if (p.isInEcm() || p.isInEmergencyCall()) return true;
@@ -255,7 +258,7 @@ public class PhoneSwitcher extends Handler {
     }
 
     private static final boolean REQUESTS_CHANGED   = true;
-    private static final boolean REQUESTS_UNCHANGED = false;
+    protected static final boolean REQUESTS_UNCHANGED = false;
     /**
      * Re-evaluate things.
      * Do nothing if nothing's changed.
@@ -265,7 +268,7 @@ public class PhoneSwitcher extends Handler {
      * phones that aren't in the active phone list.  Finally, activate all
      * phones in the active phone list.
      */
-    private void onEvaluate(boolean requestsChanged, String reason) {
+    protected void onEvaluate(boolean requestsChanged, String reason) {
         StringBuilder sb = new StringBuilder(reason);
         if (isEmergency()) {
             log("onEvalute aborted due to Emergency");
@@ -326,12 +329,12 @@ public class PhoneSwitcher extends Handler {
         }
     }
 
-    private static class PhoneState {
+    protected static class PhoneState {
         public volatile boolean active = false;
         public long lastRequested = 0;
     }
 
-    private void deactivate(int phoneId) {
+    protected void deactivate(int phoneId) {
         PhoneState state = mPhoneStates[phoneId];
         if (state.active == false) return;
         state.active = false;
@@ -344,7 +347,7 @@ public class PhoneSwitcher extends Handler {
         mActivePhoneRegistrants[phoneId].notifyRegistrants();
     }
 
-    private void activate(int phoneId) {
+    protected void activate(int phoneId) {
         PhoneState state = mPhoneStates[phoneId];
         if (state.active == true) return;
         state.active = true;
@@ -366,7 +369,7 @@ public class PhoneSwitcher extends Handler {
         msg.sendToTarget();
     }
 
-    private void onResendDataAllowed(Message msg) {
+    protected void onResendDataAllowed(Message msg) {
         final int phoneId = msg.arg1;
         // Skip ALLOW_DATA for single SIM device
         if (mNumPhones > 1) {
@@ -374,7 +377,7 @@ public class PhoneSwitcher extends Handler {
         }
     }
 
-    private int phoneIdForRequest(NetworkRequest netRequest) {
+    protected int phoneIdForRequest(NetworkRequest netRequest) {
         NetworkSpecifier specifier = netRequest.networkCapabilities.getNetworkSpecifier();
         int subId;
 
@@ -427,7 +430,7 @@ public class PhoneSwitcher extends Handler {
         }
     }
 
-    private void log(String l) {
+    protected void log(String l) {
         Rlog.d(LOG_TAG, l);
         mLocalLog.log(l);
     }
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 98291f3ce..5a3347a0c 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -191,7 +191,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     private List<String> mOldRilFeatures;
 
     /* default work source which will blame phone process */
-    private WorkSource mRILDefaultWorkSource;
+    protected WorkSource mRILDefaultWorkSource;
 
     /* Worksource containing all applications causing wakelock to be held */
     private WorkSource mActiveWakelockWorkSource;
@@ -199,7 +199,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     /** Telephony metrics instance for logging metrics event */
     private TelephonyMetrics mMetrics = TelephonyMetrics.getInstance();
 
-    boolean mIsMobileNetworkSupported;
+    protected boolean mIsMobileNetworkSupported;
     RadioResponse mRadioResponse;
     RadioIndication mRadioIndication;
     volatile IRadio mRadioProxy = null;
@@ -349,7 +349,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void resetProxyAndRequestList() {
+    protected void resetProxyAndRequestList() {
         mRadioProxy = null;
         mOemHookProxy = null;
 
@@ -586,6 +586,12 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return rr;
     }
 
+    protected int obtainRequestSerial(int request, Message result, WorkSource workSource) {
+        RILRequest rr = RILRequest.obtain(request, result, workSource);
+        addRequest(rr);
+        return rr.mSerial;
+    }
+
     private void handleRadioProxyExceptionForRR(RILRequest rr, String caller, Exception e) {
         riljLoge(caller + ": " + e);
         resetProxyAndRequestList();
@@ -4265,6 +4271,15 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return rr;
     }
 
+    protected Message getMessageFromRequest(Object request) {
+        RILRequest rr = (RILRequest)request;
+        Message result = null;
+        if (rr != null) {
+                result = rr.mResult;
+        }
+        return result;
+    }
+
     /**
      * This is a helper function to be called at the end of all RadioResponse callbacks.
      * It takes care of sending error response, logging, decrementing wakelock if needed, and
@@ -4297,6 +4312,11 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
+    protected void processResponseDone(Object request, RadioResponseInfo responseInfo, Object ret) {
+        RILRequest rr = (RILRequest)request;
+        processResponseDone(rr, responseInfo, ret);
+    }
+
     /**
      * Function to send ack and acquire related wakelock
      */
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index db566ef3e..1bd9a2747 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -144,7 +144,7 @@ public class ServiceStateTracker extends Handler {
      * expected responses in this pollingContext.
      */
     @VisibleForTesting
-    public int[] mPollingContext;
+    protected int[] mPollingContext;
     private boolean mDesiredPowerState;
 
     /**
@@ -353,7 +353,7 @@ public class ServiceStateTracker extends Handler {
     };
 
     //Common
-    private final GsmCdmaPhone mPhone;
+    protected final GsmCdmaPhone mPhone;
 
     public CellLocation mCellLoc;
     private CellLocation mNewCellLoc;
@@ -1783,7 +1783,7 @@ public class ServiceStateTracker extends Handler {
         return cdmaRoaming && !isSameOperatorNameFromSimAndSS(s);
     }
 
-    void handlePollStateResultMessage(int what, AsyncResult ar) {
+    protected void handlePollStateResultMessage(int what, AsyncResult ar) {
         int ints[];
         switch (what) {
             case EVENT_POLL_STATE_REGISTRATION: {
diff --git a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
index 8ad5720de..bda132272 100644
--- a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
+++ b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
@@ -23,6 +23,7 @@ import android.os.IDeviceIdleController;
 import android.os.Looper;
 import android.os.ServiceManager;
 import android.telephony.AccessNetworkConstants.TransportType;
+import android.telephony.Rlog;
 
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
 import com.android.internal.telephony.cdma.EriManager;
@@ -30,38 +31,77 @@ import com.android.internal.telephony.dataconnection.DcTracker;
 import com.android.internal.telephony.imsphone.ImsExternalCallTracker;
 import com.android.internal.telephony.imsphone.ImsPhone;
 import com.android.internal.telephony.imsphone.ImsPhoneCallTracker;
+import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.uicc.IccCardStatus;
 import com.android.internal.telephony.uicc.UiccCard;
 import com.android.internal.telephony.uicc.UiccProfile;
 
+import dalvik.system.PathClassLoader;
+
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
 /**
  * This class has one-line methods to instantiate objects only. The purpose is to make code
  * unit-test friendly and use this class as a way to do dependency injection. Instantiating objects
  * this way makes it easier to mock them in tests.
  */
 public class TelephonyComponentFactory {
+    protected static String LOG_TAG = "TelephonyComponentFactory";
     private static TelephonyComponentFactory sInstance;
 
     public static TelephonyComponentFactory getInstance() {
         if (sInstance == null) {
-            sInstance = new TelephonyComponentFactory();
+            String fullClsName = "com.qualcomm.qti.internal.telephony.QtiTelephonyComponentFactory";
+            String libPath = "/system/framework/qti-telephony-common.jar";
+
+            PathClassLoader classLoader = new PathClassLoader(libPath,
+                    ClassLoader.getSystemClassLoader());
+            Rlog.d(LOG_TAG, "classLoader = " + classLoader);
+
+            if (fullClsName == null || fullClsName.length() == 0) {
+                Rlog.d(LOG_TAG, "no customized TelephonyPlugin available, fallback to default");
+                fullClsName = "com.android.internal.telephony.TelephonyComponentFactory";
+            }
+
+            Class<?> cls = null;
+            try {
+                cls = Class.forName(fullClsName, false, classLoader);
+                Rlog.d(LOG_TAG, "cls = " + cls);
+                Constructor custMethod = cls.getConstructor();
+                Rlog.d(LOG_TAG, "constructor method = " + custMethod);
+                sInstance = (TelephonyComponentFactory) custMethod.newInstance();
+            } catch (NoClassDefFoundError e) {
+                e.printStackTrace();
+                Rlog.e(LOG_TAG, "error loading TelephonyComponentFactory");
+                sInstance = new TelephonyComponentFactory();
+            } catch (Exception e) {
+                e.printStackTrace();
+                Rlog.e(LOG_TAG, "Error loading TelephonyComponentFactory");
+                sInstance = new TelephonyComponentFactory();
+            }
         }
         return sInstance;
     }
 
     public GsmCdmaCallTracker makeGsmCdmaCallTracker(GsmCdmaPhone phone) {
+        Rlog.d(LOG_TAG, "makeGsmCdmaCallTracker");
         return new GsmCdmaCallTracker(phone);
     }
 
     public SmsStorageMonitor makeSmsStorageMonitor(Phone phone) {
+        Rlog.d(LOG_TAG, "makeSmsStorageMonitor");
         return new SmsStorageMonitor(phone);
     }
 
     public SmsUsageMonitor makeSmsUsageMonitor(Context context) {
+        Rlog.d(LOG_TAG, "makeSmsUsageMonitor");
         return new SmsUsageMonitor(context);
     }
 
     public ServiceStateTracker makeServiceStateTracker(GsmCdmaPhone phone, CommandsInterface ci) {
+        Rlog.d(LOG_TAG, "makeServiceStateTracker");
         return new ServiceStateTracker(phone, ci);
     }
 
@@ -77,6 +117,7 @@ public class TelephonyComponentFactory {
     }
 
     public DcTracker makeDcTracker(Phone phone) {
+        Rlog.d(LOG_TAG, "makeDcTracker");
         return new DcTracker(phone, TransportType.WWAN);
     }
 
@@ -93,10 +134,12 @@ public class TelephonyComponentFactory {
     }
 
     public IccPhoneBookInterfaceManager makeIccPhoneBookInterfaceManager(Phone phone) {
+        Rlog.d(LOG_TAG, "makeIccPhoneBookInterfaceManager");
         return new IccPhoneBookInterfaceManager(phone);
     }
 
     public IccSmsInterfaceManager makeIccSmsInterfaceManager(Phone phone) {
+        Rlog.d(LOG_TAG, "makeIccSmsInterfaceManager");
         return new IccSmsInterfaceManager(phone);
     }
 
@@ -109,10 +152,12 @@ public class TelephonyComponentFactory {
     }
 
     public EriManager makeEriManager(Phone phone, Context context, int eriFileSource) {
+        Rlog.d(LOG_TAG, "makeEriManager");
         return new EriManager(phone, context, eriFileSource);
     }
 
     public WspTypeDecoder makeWspTypeDecoder(byte[] pdu) {
+        Rlog.d(LOG_TAG, "makeWspTypeDecoder");
         return new WspTypeDecoder(pdu);
     }
 
@@ -122,6 +167,7 @@ public class TelephonyComponentFactory {
     public InboundSmsTracker makeInboundSmsTracker(byte[] pdu, long timestamp, int destPort,
             boolean is3gpp2, boolean is3gpp2WapPdu, String address, String displayAddr,
             String messageBody) {
+        Rlog.d(LOG_TAG, "makeInboundSmsTracker");
         return new InboundSmsTracker(pdu, timestamp, destPort, is3gpp2, is3gpp2WapPdu, address,
                 displayAddr, messageBody);
     }
@@ -132,6 +178,7 @@ public class TelephonyComponentFactory {
     public InboundSmsTracker makeInboundSmsTracker(byte[] pdu, long timestamp, int destPort,
             boolean is3gpp2, String address, String displayAddr, int referenceNumber, int sequenceNumber,
             int messageCount, boolean is3gpp2WapPdu, String messageBody) {
+        Rlog.d(LOG_TAG, "makeInboundSmsTracker");
         return new InboundSmsTracker(pdu, timestamp, destPort, is3gpp2, address, displayAddr,
                 referenceNumber, sequenceNumber, messageCount, is3gpp2WapPdu, messageBody);
     }
@@ -140,10 +187,12 @@ public class TelephonyComponentFactory {
      * Create a tracker from a row of raw table
      */
     public InboundSmsTracker makeInboundSmsTracker(Cursor cursor, boolean isCurrentFormat3gpp2) {
+        Rlog.d(LOG_TAG, "makeInboundSmsTracker");
         return new InboundSmsTracker(cursor, isCurrentFormat3gpp2);
     }
 
     public ImsPhoneCallTracker makeImsPhoneCallTracker(ImsPhone imsPhone) {
+        Rlog.d(LOG_TAG, "makeImsPhoneCallTracker");
         return new ImsPhoneCallTracker(imsPhone);
     }
 
@@ -166,14 +215,55 @@ public class TelephonyComponentFactory {
     public CdmaSubscriptionSourceManager
     getCdmaSubscriptionSourceManagerInstance(Context context, CommandsInterface ci, Handler h,
                                              int what, Object obj) {
+        Rlog.d(LOG_TAG, "getCdmaSubscriptionSourceManagerInstance");
         return CdmaSubscriptionSourceManager.getInstance(context, ci, h, what, obj);
     }
 
     public IDeviceIdleController getIDeviceIdleController() {
+        Rlog.d(LOG_TAG, "getIDeviceIdleController");
         return IDeviceIdleController.Stub.asInterface(
                 ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
     }
 
+    public Phone makePhone(Context context, CommandsInterface ci, PhoneNotifier notifier,
+            int phoneId, int precisePhoneType,
+            TelephonyComponentFactory telephonyComponentFactory) {
+        Rlog.d(LOG_TAG, "makePhone");
+        return new GsmCdmaPhone(context, ci, notifier, phoneId, precisePhoneType,
+                telephonyComponentFactory);
+    }
+
+    public SubscriptionController initSubscriptionController(Context c, CommandsInterface[] ci) {
+        Rlog.d(LOG_TAG, "initSubscriptionController");
+        return SubscriptionController.init(c, ci);
+    }
+
+    public SubscriptionInfoUpdater makeSubscriptionInfoUpdater(Looper looper, Context context,
+            Phone[] phones, CommandsInterface[] ci) {
+        Rlog.d(LOG_TAG, "makeSubscriptionInfoUpdater");
+        return new SubscriptionInfoUpdater(looper, context, phones, ci);
+    }
+
+    public void makeExtTelephonyClasses(Context context,
+            Phone[] phones, CommandsInterface[] commandsInterfaces) {
+        Rlog.d(LOG_TAG, "makeExtTelephonyClasses");
+    }
+
+    public PhoneSwitcher makePhoneSwitcher(int maxActivePhones, int numPhones, Context context,
+            SubscriptionController subscriptionController, Looper looper, ITelephonyRegistry tr,
+            CommandsInterface[] cis, Phone[] phones) {
+        Rlog.d(LOG_TAG, "makePhoneSwitcher");
+        return new PhoneSwitcher(maxActivePhones,numPhones,
+                context, subscriptionController, looper, tr, cis,
+                phones);
+    }
+
+    public RIL makeRIL(Context context, int preferredNetworkType,
+            int cdmaSubscription, Integer instanceId) {
+        Rlog.d(LOG_TAG, "makeRIL");
+        return new RIL(context, preferredNetworkType, cdmaSubscription, instanceId);
+    }
+
     public LocaleTracker makeLocaleTracker(Phone phone, Looper looper) {
         return new LocaleTracker(phone, looper);
     }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 38d3852b1..962f7ae2d 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -114,8 +114,8 @@ import java.util.concurrent.atomic.AtomicReference;
  * {@hide}
  */
 public class DcTracker extends Handler {
-    private static final String LOG_TAG = "DCT";
-    private static final boolean DBG = true;
+    protected String LOG_TAG = "DCT";
+    protected static final boolean DBG = true;
     private static final boolean VDBG = false; // STOPSHIP if true
     private static final boolean VDBG_STALL = false; // STOPSHIP if true
     private static final boolean RADIO_TESTS = false;
@@ -441,7 +441,7 @@ public class DcTracker extends Handler {
     private RegistrantList mAllDataDisconnectedRegistrants = new RegistrantList();
 
     // member variables
-    private final Phone mPhone;
+    protected final Phone mPhone;
     private final UiccController mUiccController;
     private final AtomicReference<IccRecords> mIccRecords = new AtomicReference<IccRecords>();
     private DctConstants.Activity mActivity = DctConstants.Activity.NONE;
@@ -476,7 +476,7 @@ public class DcTracker extends Handler {
     private PendingIntent mReconnectIntent = null;
 
     // When false we will not auto attach and manually attaching is required.
-    private boolean mAutoAttachOnCreationConfig = false;
+    protected boolean mAutoAttachOnCreationConfig = false;
     private AtomicBoolean mAutoAttachOnCreation = new AtomicBoolean(false);
 
     // State of screen
@@ -1211,6 +1211,10 @@ public class DcTracker extends Handler {
         setupDataOnConnectableApns(Phone.REASON_DATA_ATTACHED);
     }
 
+    protected boolean getAttachedStatus() {
+        return mAttached.get();
+    }
+
     /**
      * Check if it is allowed to make a data connection (without checking APN context specific
      * conditions).
@@ -1244,7 +1248,7 @@ public class DcTracker extends Handler {
 
         // Step 1: Get all environment conditions.
         final boolean internalDataEnabled = mDataEnabledSettings.isInternalDataEnabled();
-        boolean attachedState = mAttached.get();
+        boolean attachedState = getAttachedStatus();
         boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
         boolean radioStateFromCarrier = mPhone.getServiceStateTracker().getPowerStateFromCarrier();
         // TODO: Remove this hack added by ag/641832.
@@ -1387,7 +1391,7 @@ public class DcTracker extends Handler {
         ONLY_ON_CHANGE
     };
 
-    private void setupDataOnConnectableApns(String reason) {
+    protected void setupDataOnConnectableApns(String reason) {
         setupDataOnConnectableApns(reason, RetryFailures.ALWAYS);
     }
 
@@ -1519,7 +1523,7 @@ public class DcTracker extends Handler {
     }
 
     // Disabled apn's still need avail/unavail notifications - send them out
-    private void notifyOffApnsOfAvailability(String reason) {
+    protected void notifyOffApnsOfAvailability(String reason) {
         for (ApnContext apnContext : mApnContexts.values()) {
             if (!mAttached.get() || !apnContext.isReady()) {
                 if (VDBG) log("notifyOffApnOfAvailability type:" + apnContext.getApnType());
@@ -2062,7 +2066,7 @@ public class DcTracker extends Handler {
         return true;
     }
 
-    private void setInitialAttachApn() {
+    protected  void setInitialAttachApn() {
         ApnSetting iaApnSetting = null;
         ApnSetting defaultApnSetting = null;
         ApnSetting firstApnSetting = null;
@@ -2302,7 +2306,7 @@ public class DcTracker extends Handler {
         return mAutoAttachOnCreation.get();
     }
 
-    private void onRecordsLoadedOrSubIdChanged() {
+    protected void onRecordsLoadedOrSubIdChanged() {
         if (DBG) log("onRecordsLoadedOrSubIdChanged: createAllApnList");
         mAutoAttachOnCreationConfig = mPhone.getContext().getResources()
                 .getBoolean(com.android.internal.R.bool.config_auto_attach_data_on_creation);
@@ -3325,7 +3329,7 @@ public class DcTracker extends Handler {
      * Based on the sim operator numeric, create a list for all possible
      * Data Connections and setup the preferredApn.
      */
-    private void createAllApnList() {
+    protected void createAllApnList() {
         mMvnoMatched = false;
         mAllApnSettings = new ArrayList<>();
         IccRecords r = mIccRecords.get();
@@ -4179,7 +4183,7 @@ public class DcTracker extends Handler {
         return true;
     }
 
-    private void log(String s) {
+    protected void log(String s) {
         Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "]" + s);
     }
 
-- 
2.17.1

