From 7586382ce34fde35dd470c3e5c0442c0cc3599ff Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 6 Nov 2018 14:54:30 +0100
Subject: [PATCH 12/13] [SQUSH][DNM] Merge tag 'android-9.0.0_r16' into
 lineage-16.0

commit a2ee5091c08c4beaa54da6c27a481f9380c16060
Merge: 1a0db62d8 c60dd86d0
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Sep 5 23:35:35 2018 +0000

    Merge cherrypicks of [4948448, 4948511, 4948299, 4947854, 4947306, 4946150, 4948531, 4946116, 4948532] into pi-qpr1-release

    Change-Id: I1686f504c66c0448cf30d915a043328d7063e7d7

commit c60dd86d0b7a2228a91e02cf22ee30664dd9aa77
Author: Jack Yu <jackyu@google.com>
Date:   Fri Aug 31 15:22:30 2018 -0700

    Added serial number and timestamp in cell broadcat metrics

    The timestamp logging helps analyzing the delivered time
    of emergency alerts among devices.

    Test: Telephony sanity tests
    Bug: 113688249
    Change-Id: Ie0b3dc7a876bbc8b14b1b85c099d94a5a9480f74
    (cherry picked from commit 9f8a1f433e57495e4ecb45d10f86a01e3d35539b)

commit 1a0db62d83ebf34ec210c37dd0ed8c7a406e4953
Merge: 50b204af1 3c8956b47
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Aug 17 03:07:18 2018 +0000

    Snap for 4959688 from 3c8956b47ad1a065d389189ef12d6f60a5b1be47 to pi-qpr1-release

    Change-Id: Ib0937c1ec4b348b2e8a95518f8cadb772a4b27d5

commit 3c8956b47ad1a065d389189ef12d6f60a5b1be47
Merge: fd7548dfe 6016bdc18
Author: Hall Liu <hallliu@google.com>
Date:   Thu Aug 16 22:57:13 2018 +0000

    Merge "Add support for auto redialing 911" into pi-dev

commit 50b204af12d6f517693a2aeb5500431019637ace
Merge: 5e18077e4 fd7548dfe
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Aug 15 03:14:45 2018 +0000

    Snap for 4954419 from fd7548dfe50fc17fe660d983acb030ad712bba1a to pi-qpr1-release

    Change-Id: If693da293a7ce2a02b763fd934c96de13bdf3f87

commit fd7548dfe50fc17fe660d983acb030ad712bba1a
Author: Siddharth Ray <siddharthr@google.com>
Date:   Fri Aug 10 17:30:32 2018 -0700

    Addition of HW Revision to Telephony Metrics

    Test:
    adb shell dumpsys activity service TelephonyDebugService --metrics
    Hardware Version: EVT2.0

    BUG:112541087
    Change-Id: I57a3b21d66c0b8412c6d857bc5011db2f97d5cd2

commit 6016bdc182c4842a3c82e331fa4fd693f402328c
Author: Hall Liu <hallliu@google.com>
Date:   Wed Jul 25 18:46:27 2018 -0700

    Add support for auto redialing 911

    When we get a SIP 380 from the modem when trying to make an emergency
    call in airplane mode with wifi calling turned on, automatically retry
    (gated on a carrier config) by turning off airplane mode then redialing.

    Bug: 111235453
    Test: manual (modify IMS stack locally to always return the 380 error
    when dialing in airplane mode)

    Change-Id: Icde9d792c3f1561d6e0fc6863c278e7bb89ddb78
    Merged-In: I37b6ac67c1459bf4e0d849333744bd2018970c97

commit 5e18077e45ebe46a7f8ed182b8934369fd77d390
Merge: 127892a40 e363bb6b0
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Mon Jul 30 03:10:59 2018 +0000

    Snap for 4920102 from e363bb6b04ea94a8f3eaeb29791117629014dfe8 to pi-qpr1-release

    Change-Id: Ie7758a7f562e7a6032c6f2b6933b46b2691ae887

commit e363bb6b04ea94a8f3eaeb29791117629014dfe8
Merge: 127892a40 371e21403
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Sat Jul 28 00:19:28 2018 +0000

    Merge "Fixed battery drain after modem reset" into pi-dev

commit 371e214031abee8757ecbbe6eb923b5b785963d4
Author: Jack Yu <jackyu@google.com>
Date:   Fri Jul 13 10:21:00 2018 -0700

    Fixed battery drain after modem reset

    After modem crashes and resets, telephony should resend
    the indication filter to the modem again. Otherwise modem
    keeps sending unnecessary indications when the screen is off,
    which causes battery drain.

    Test: Telephony sanity tests and unit tests
    Bug: 111125632
    Change-Id: I12f2561a2ca8877e2528795b1f5a1af0305657ae

commit 127892a4008d00db87fb3166c306ef0edbf57022
Author: Sooraj Sasindran <sasindran@google.com>
Date:   Thu Jun 28 14:01:21 2018 -0700

    Ignore the duplicate app

    Ignore duplicate sim app if another app of same type
    is already in ready state.

    Test: Added unit test for duplicate app
    	verified with OBDM sim card.
    	verified with normal sim card
    	Verified Hotswap
    	Verified APM on and OFF

    Bug: 110894572
    Change-Id: I056263d015d6b476c75b43fcae0954fc18af79fa

commit 0717885569b790e2ba6c50192aff8c5b350f4e7f
Merge: 02108d0aa 8d07a0df8
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jun 29 17:23:13 2018 +0000

    Merge "Use new registered_plmn carrier config." into pi-dev

commit 02108d0aa4f634dde6128563c67bb84bdcb09b50
Merge: fe8bfeb3d 9bc303348
Author: Junyu Lai <junyulai@google.com>
Date:   Thu Jun 28 05:00:32 2018 +0000

    Merge "Data activity didn't reflect UDP traffic" into pi-dev

commit fe8bfeb3dae4b31801816fae14c5b88d8036468d
Merge: 808f1058a e3b789798
Author: Hall Liu <hallliu@google.com>
Date:   Tue Jun 26 22:00:17 2018 +0000

    Merge "Fix thread leak from RttTextHandler" into pi-dev

commit 808f1058a8b772ca72f35483b8b097ce3792ad0d
Merge: 4dd19627d 6df96ddef
Author: Hall Liu <hallliu@google.com>
Date:   Tue Jun 26 21:54:54 2018 +0000

    Merge "Add null checks for getImsCall()" into pi-dev

commit 9bc303348279c9ba400da01b2eec44fdb19e0fd0
Author: junyulai <junyulai@google.com>
Date:   Mon Jun 25 21:15:58 2018 +0800

    Data activity didn't reflect UDP traffic

    Currently, the DataActivity will use the same source with data
    stall detection to count packet traffic, which is TCP only.
    However, more and more modern applications uses UDP for
    communication such as QUIC and streaming. And the data icon
    arrows did not reflect the truth that packet is transmitting.
    It should be more accurate that data icon arrows should count
    all packet traffic.

    Note that data stall detection remains the same for now since
    we don't want to break functionality for below cases:
    1. Out-going UDP packets trigger false positive, such as live
       broadcast apps or b/7903145
    2. Incoming local communications cause false negative, such as
       IPv6 Neighbor Discovery messages between modem & AP.

    Bug: 110773754
    Test: 1. play youtube and see data icon arrows in QuickSetting
          2. enable updateDataActivity debug log and make sure it
             counts.
          2. runtest frameworks-net

    Change-Id: Id2f763f396b329ab82af09bb5e084af7201f9d7c

commit e3b789798d09a9058ab8b4c029b71ffc465256b0
Author: Hall Liu <hallliu@google.com>
Date:   Mon Jun 25 19:45:53 2018 -0700

    Fix thread leak from RttTextHandler

    The reader thread for reading from in-call wasn't shutting down properly
    before. This led to interleaving of messages if RTT went on, then off
    again, then on. Add an interrupt call upon teardown so that the thread
    can properly stop.

    Change-Id: I1f0b4afe14ad218ca58e2feb3d8861f5d76ebe8e
    Fixes: 110570772
    Test: manual (follow repro steps in bug, but type really fast),treehugger

commit 4dd19627d011e502eb19c60082220e2e10afce94
Author: Rhed Jao <rhedjao@google.com>
Date:   Wed Jun 13 15:42:22 2018 +0800

    Hide system apps until installed (2/2)

    Applying this mechanism for system carrier apps to make visibility
    reasonable from the user's perspective. In other words, before
    hidden system apps have been installed, they wouldn't be listed
    via APIs in PackageManager which are used at all apps list and
    search in Settings and so on.

    Test: atest CarrierAppUtilsTest
    Test: atest PackageManagerTest
    Test: cts DeviceOwnerTest
    Test: gts ManagedProfileProvisioningHostsideTest
    Bug: 74068582
    Change-Id: I7f4436c6118c133e049acfaf6ed8ed911e48c4ae

commit 6df96ddef988f2f7c8d06299158b5827ad57415e
Author: Hall Liu <hallliu@google.com>
Date:   Mon Jun 25 15:16:53 2018 -0700

    Add null checks for getImsCall()

    When certain RTT operations are performed near the end of a call, the
    phone process may crash with a NPE since mImsCall in ImsPhoneConnection
    becomes null. Add null checks to fix this.

    Change-Id: I4da899f26ce897224429387927a48288454d0c8b
    Fixes: 110570770
    Test: manual

commit 9f6ca62d173019500d36eddc3224427cb1964bc5
Merge: b053adc25 2b545aa5b
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jun 22 21:02:41 2018 +0000

    Merge "SIM refresh of type init should not dispose CatService." into pi-dev

commit b053adc25635184f59888b75c1fabbb8d6fe3a00
Merge: 13691614d faa88f9f5
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Thu Jun 21 22:47:15 2018 +0000

    Merge "Use SIMRecords for setVoicemailNumber() over RuimRecords." into pi-dev

commit faa88f9f5b4963300f2829ddff1a44f8508063c2
Author: Amit Mahajan <amitmahajan@google.com>
Date:   Tue Jun 19 12:40:33 2018 -0700

    Use SIMRecords for setVoicemailNumber() over RuimRecords.

    RuimRecords does not support voicemail number.

    Test: Basic telephony sanity
    Bug: 109838253
    Change-Id: I04c86853a6c1b27203981f8f3bd5ad457a849ee2

commit 2b545aa5bfa00d4bdd7d4446b477b1ff54850a69
Author: Amit Mahajan <amitmahajan@google.com>
Date:   Tue Jun 19 15:23:08 2018 -0700

    SIM refresh of type init should not dispose CatService.

    Test: Basic telephony sanity
    Bug: 78240540

    Change-Id: Ied9230646c1e722ae33f50f4dfdacae77cb921c1

commit 13691614d266257f29dcf0f6b0514357189cd9cb
Author: Brad Ebinger <breadley@google.com>
Date:   Wed Jun 13 17:18:20 2018 -0700

    Revert isResolvingImsBinding code in ImsResolver

    When querying a carrier ImsService for IMS features
    after a new SIM is inserted, there is an indeterminate period
    of time where we do not know what features are supported.
    During this time telephony gets an independent
    CARRIER_CONFIG_CHANGED signal to update the IMS config to the
    modem. We were attempting to supress this signal while
    determining in the ImsResolver which ImsService MMTEL will
    be created on. This resulted in a race condition when the
    carrier ImsService only supported the RCS feature because
    the carrier config update would be suppressed and the
    ImsPhoneCallTracker would never send a config update (because
    the device ImsService is still the only MMTEL feature).

    Therefore this change reverts the code that detected this
    since it was likely that the CARRIER_CONFIG_CHANGED signal
    would be processed in other parts of telephony before it
    was even processed here.

    Bug: 109762920
    Test: Telephony GTS/Unit Tests
    Change-Id: I20a713b8858931dce2a304fc306bfe8553546f51
    Merged-In: I20a713b8858931dce2a304fc306bfe8553546f51

commit 8d07a0df8b7834a7a6ac13ac694bf659149ab830
Author: Amit Mahajan <amitmahajan@google.com>
Date:   Tue Jun 5 16:24:38 2018 -0700

    Use new registered_plmn carrier config.

    This new config is a temporary way to override registered PLMN  name
    for CDMA in home network.

    Test: manual
    Bug: 80145031
    Change-Id: I9869437df7230b48abd9a7f690bc50bee311093a

Change-Id: I783a888b0b65de1bb2a9d07f48b50dad7130468b
---
 proto/src/telephony.proto                     |   9 +
 .../telephony/CellBroadcastHandler.java       |   3 +-
 .../internal/telephony/Connection.java        |   8 +
 .../telephony/DeviceStateMonitor.java         |  11 +-
 .../internal/telephony/GsmCdmaPhone.java      |   6 +
 .../telephony/ServiceStateTracker.java        |  24 +
 .../telephony/SubscriptionInfoUpdater.java    |   9 +-
 .../telephony/dataconnection/DcTracker.java   |  17 +-
 .../internal/telephony/ims/ImsResolver.java   |  11 -
 .../internal/telephony/imsphone/ImsPhone.java |   5 +
 .../imsphone/ImsPhoneCallTracker.java         | 101 ++++-
 .../imsphone/ImsPhoneConnection.java          |  29 +-
 .../telephony/imsphone/ImsRttTextHandler.java |  16 +-
 .../telephony/metrics/TelephonyMetrics.java   |  12 +-
 .../internal/telephony/uicc/UiccCard.java     |   6 +-
 .../uicc/UiccCarrierPrivilegeRules.java       |   3 +-
 .../telephony/uicc/UiccController.java        |  13 +-
 .../internal/telephony/uicc/UiccProfile.java  |   9 +-
 .../telephony/CarrierAppUtilsTest.java        | 414 +++++++++++-------
 .../telephony/DeviceStateMonitorTest.java     |   8 +
 .../internal/telephony/GsmCdmaPhoneTest.java  |   2 +-
 .../SubscriptionInfoUpdaterTest.java          |   5 +-
 .../telephony/uicc/UiccProfileTest.java       |  39 ++
 23 files changed, 527 insertions(+), 233 deletions(-)

diff --git a/proto/src/telephony.proto b/proto/src/telephony.proto
index e441f71ca..36f188332 100644
--- a/proto/src/telephony.proto
+++ b/proto/src/telephony.proto
@@ -47,6 +47,9 @@ message TelephonyLog {
 
   // Modem power stats
   optional ModemPowerStats modem_power_stats = 8;
+
+  // Hardware revision (EVT, DVT, PVT etc.)
+  optional string hardware_revision = 9;
 }
 
 // The time information
@@ -1355,6 +1358,12 @@ message SmsSession {
 
       // Service category of CB message
       optional int32 service_category = 4;
+
+      // Message's serial number
+      optional int32 serial_number = 5;
+
+      // The delivered time (UTC) of the message
+      optional int64 delivered_timestamp_millis = 6;
     }
 
     enum CBMessageType {
diff --git a/src/java/com/android/internal/telephony/CellBroadcastHandler.java b/src/java/com/android/internal/telephony/CellBroadcastHandler.java
index 19b7b4065..55e0643e8 100644
--- a/src/java/com/android/internal/telephony/CellBroadcastHandler.java
+++ b/src/java/com/android/internal/telephony/CellBroadcastHandler.java
@@ -88,7 +88,8 @@ public class CellBroadcastHandler extends WakeLockStateMachine {
         TelephonyMetrics metrics = TelephonyMetrics.getInstance();
         metrics.writeNewCBSms(mPhone.getPhoneId(), message.getMessageFormat(),
                 message.getMessagePriority(), message.isCmasMessage(), message.isEtwsMessage(),
-                message.getServiceCategory());
+                message.getServiceCategory(), message.getSerialNumber(),
+                System.currentTimeMillis());
 
         Intent intent;
         if (message.isEmergencyMessage()) {
diff --git a/src/java/com/android/internal/telephony/Connection.java b/src/java/com/android/internal/telephony/Connection.java
index b37ad04e9..62fc5b025 100644
--- a/src/java/com/android/internal/telephony/Connection.java
+++ b/src/java/com/android/internal/telephony/Connection.java
@@ -107,6 +107,7 @@ public abstract class Connection {
         public void onDisconnect(int cause);
         public void onRttInitiated();
         public void onRttTerminated();
+        public void onOriginalConnectionReplaced(Connection newConnection);
     }
 
     /**
@@ -152,6 +153,8 @@ public abstract class Connection {
         public void onRttInitiated() {}
         @Override
         public void onRttTerminated() {}
+        @Override
+        public void onOriginalConnectionReplaced(Connection newConnection) {}
     }
 
     public static final int AUDIO_QUALITY_STANDARD = 1;
@@ -1022,6 +1025,11 @@ public abstract class Connection {
         }
     }
 
+    public void onOriginalConnectionReplaced(Connection newConnection) {
+        for (Listener l : mListeners) {
+            l.onOriginalConnectionReplaced(newConnection);
+        }
+    }
     /**
      * Notifies the connection that there was a failure while handing over to WIFI.
      */
diff --git a/src/java/com/android/internal/telephony/DeviceStateMonitor.java b/src/java/com/android/internal/telephony/DeviceStateMonitor.java
index 04e96caa1..92a78f77f 100644
--- a/src/java/com/android/internal/telephony/DeviceStateMonitor.java
+++ b/src/java/com/android/internal/telephony/DeviceStateMonitor.java
@@ -64,6 +64,7 @@ public class DeviceStateMonitor extends Handler {
     private static final int EVENT_POWER_SAVE_MODE_CHANGED      = 3;
     private static final int EVENT_CHARGING_STATE_CHANGED       = 4;
     private static final int EVENT_TETHERING_STATE_CHANGED      = 5;
+    private static final int EVENT_RADIO_AVAILABLE              = 6;
 
     // TODO(b/74006656) load hysteresis values from a property when DeviceStateMonitor starts
     private static final int HYSTERESIS_KBPS = 50;
@@ -200,6 +201,7 @@ public class DeviceStateMonitor extends Handler {
         mPhone.getContext().registerReceiver(mBroadcastReceiver, filter, null, mPhone);
 
         mPhone.mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
+        mPhone.mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
     }
 
     /**
@@ -344,7 +346,8 @@ public class DeviceStateMonitor extends Handler {
         log("handleMessage msg=" + msg, false);
         switch (msg.what) {
             case EVENT_RIL_CONNECTED:
-                onRilConnected();
+            case EVENT_RADIO_AVAILABLE:
+                onReset();
                 break;
             case EVENT_UPDATE_MODE_CHANGED:
                 onSetIndicationUpdateMode(msg.arg1, msg.arg2);
@@ -420,14 +423,14 @@ public class DeviceStateMonitor extends Handler {
     }
 
     /**
-     * Called when RIL is connected during boot up or reconnected after modem restart.
+     * Called when RIL is connected during boot up or radio becomes available after modem restart.
      *
      * When modem crashes, if the user turns the screen off before RIL reconnects, device
      * state and filter cannot be sent to modem. Resend the state here so that modem
      * has the correct state (to stop signal strength reporting, etc).
      */
-    private void onRilConnected() {
-        log("RIL connected.", true);
+    private void onReset() {
+        log("onReset.", true);
         sendDeviceState(CHARGING_STATE, mIsCharging);
         sendDeviceState(LOW_DATA_EXPECTED, mIsLowDataExpected);
         sendDeviceState(POWER_SAVE_MODE, mIsPowerSaveOn);
diff --git a/src/java/com/android/internal/telephony/GsmCdmaPhone.java b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
index 8c0caef72..9b4f5ef4a 100644
--- a/src/java/com/android/internal/telephony/GsmCdmaPhone.java
+++ b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
@@ -1682,7 +1682,13 @@ public class GsmCdmaPhone extends Phone {
         Message resp;
         mVmNumber = voiceMailNumber;
         resp = obtainMessage(EVENT_SET_VM_NUMBER_DONE, 0, 0, onComplete);
+
         IccRecords r = mIccRecords.get();
+
+        if (!isPhoneTypeGsm() && mSimRecords != null) {
+            r = mSimRecords;
+        }
+
         if (r != null) {
             r.setVoiceMailNumber(alphaTag, mVmNumber, resp);
         }
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index 4e37bb6f0..0502c95a0 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -2231,8 +2231,32 @@ public class ServiceStateTracker extends Handler {
         mNewSS.setCdmaEriIconIndex(EriInfo.ROAMING_INDICATOR_OFF);
     }
 
+    private void updateOperatorNameFromCarrierConfig() {
+        // Brand override gets a priority over carrier config. If brand override is not available,
+        // override the operator name in home network. Also do this only for CDMA. This is temporary
+        // and should be fixed in a proper way in a later release.
+        if (!mPhone.isPhoneTypeGsm() && !mSS.getRoaming()) {
+            boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null
+                    && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
+            if (!hasBrandOverride) {
+                PersistableBundle config = getCarrierConfig();
+                if (config.getBoolean(
+                        CarrierConfigManager.KEY_CDMA_HOME_REGISTERED_PLMN_NAME_OVERRIDE_BOOL)) {
+                    String operator = config.getString(
+                            CarrierConfigManager.KEY_CDMA_HOME_REGISTERED_PLMN_NAME_STRING);
+                    log("updateOperatorNameFromCarrierConfig: changing from "
+                            + mSS.getOperatorAlpha() + " to " + operator);
+                    // override long and short operator name, keeping numeric the same
+                    mSS.setOperatorName(operator, operator, mSS.getOperatorNumeric());
+                }
+            }
+        }
+    }
+
     protected void updateSpnDisplay() {
         updateOperatorNameFromEri();
+        // carrier config gets a priority over ERI
+        updateOperatorNameFromCarrierConfig();
 
         String wfcVoiceSpnFormat = null;
         String wfcDataSpnFormat = null;
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index ce3ff11ac..a205d1466 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -122,6 +122,13 @@ public class SubscriptionInfoUpdater extends Handler {
 
     public SubscriptionInfoUpdater(
             Looper looper, Context context, Phone[] phone, CommandsInterface[] ci) {
+        this(looper, context, phone, ci,
+                IPackageManager.Stub.asInterface(ServiceManager.getService("package")));
+    }
+
+    @VisibleForTesting public SubscriptionInfoUpdater(
+            Looper looper, Context context, Phone[] phone,
+            CommandsInterface[] ci, IPackageManager packageMgr) {
         super(looper);
         logd("Constructor invoked");
 
@@ -129,7 +136,7 @@ public class SubscriptionInfoUpdater extends Handler {
         mPhone = phone;
         mSubscriptionManager = SubscriptionManager.from(mContext);
         mEuiccManager = (EuiccManager) mContext.getSystemService(Context.EUICC_SERVICE);
-        mPackageManager = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+        mPackageManager = packageMgr;
 
         mCarrierServiceBindHelper = new CarrierServiceBindHelper(mContext);
         initializeCarrierApps();
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index bda8b976e..3408116de 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -356,10 +356,21 @@ public class DcTracker extends Handler {
             return "{txSum=" + txPkts + " rxSum=" + rxPkts + "}";
         }
 
-        public void updateTxRxSum() {
+        /**
+         * Get Tcp Tx/Rx packet count from TrafficStats
+         */
+        public void updateTcpTxRxSum() {
             this.txPkts = TrafficStats.getMobileTcpTxPackets();
             this.rxPkts = TrafficStats.getMobileTcpRxPackets();
         }
+
+        /**
+         * Get total Tx/Rx packet count from TrafficStats
+         */
+        public void updateTotalTxRxSum() {
+            this.txPkts = TrafficStats.getMobileTxPackets();
+            this.rxPkts = TrafficStats.getMobileRxPackets();
+        }
     }
 
     private void onActionIntentReconnectAlarm(Intent intent) {
@@ -4521,7 +4532,7 @@ public class DcTracker extends Handler {
 
         TxRxSum preTxRxSum = new TxRxSum(mTxPkts, mRxPkts);
         TxRxSum curTxRxSum = new TxRxSum();
-        curTxRxSum.updateTxRxSum();
+        curTxRxSum.updateTotalTxRxSum();
         mTxPkts = curTxRxSum.txPkts;
         mRxPkts = curTxRxSum.rxPkts;
 
@@ -4694,7 +4705,7 @@ public class DcTracker extends Handler {
         long sent, received;
 
         TxRxSum preTxRxSum = new TxRxSum(mDataStallTxRxSum);
-        mDataStallTxRxSum.updateTxRxSum();
+        mDataStallTxRxSum.updateTcpTxRxSum();
 
         if (VDBG_STALL) {
             log("updateDataStallInfo: mDataStallTxRxSum=" + mDataStallTxRxSum +
diff --git a/src/java/com/android/internal/telephony/ims/ImsResolver.java b/src/java/com/android/internal/telephony/ims/ImsResolver.java
index f0aee0141..4a030b179 100644
--- a/src/java/com/android/internal/telephony/ims/ImsResolver.java
+++ b/src/java/com/android/internal/telephony/ims/ImsResolver.java
@@ -1131,17 +1131,6 @@ public class ImsResolver implements ImsServiceController.ImsServiceControllerCal
         }
     }
 
-    /**
-     * @return true if the ImsResolver is in the process of resolving a dynamic query and should not
-     * be considered available, false if the ImsResolver is idle.
-     */
-    public boolean isResolvingBinding() {
-        return mHandler.hasMessages(HANDLER_START_DYNAMIC_FEATURE_QUERY)
-                // We haven't processed this message yet, so it is still resolving.
-                || mHandler.hasMessages(HANDLER_DYNAMIC_FEATURE_CHANGE)
-                || mFeatureQueryManager.isQueryInProgress();
-    }
-
     private String printFeatures(Set<ImsFeatureConfiguration.FeatureSlotPair> features) {
         StringBuilder featureString = new StringBuilder();
         featureString.append("features: [");
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
index 963a2e3d9..333369795 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
@@ -650,6 +650,11 @@ public class ImsPhone extends ImsPhoneBase {
         mDefaultPhone.notifyForVideoCapabilityChanged(isVideoCapable);
     }
 
+    @Override
+    public void setRadioPower(boolean on) {
+        mDefaultPhone.setRadioPower(on);
+    }
+
     @Override
     public Connection dial(String dialString, DialArgs dialArgs) throws CallStateException {
         return dialInternal(dialString, dialArgs, null);
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index 4c858cc32..7a5275c26 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -90,6 +90,7 @@ import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.Connection;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneInternalInterface;
 import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.TelephonyProperties;
 import com.android.internal.telephony.dataconnection.DataEnabledSettings;
@@ -277,11 +278,15 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     private static final int EVENT_CHECK_FOR_WIFI_HANDOVER = 25;
     private static final int EVENT_ON_FEATURE_CAPABILITY_CHANGED = 26;
     private static final int EVENT_SUPP_SERVICE_INDICATION = 27;
+    private static final int EVENT_REDIAL_WIFI_E911_CALL = 28;
+    private static final int EVENT_REDIAL_WIFI_E911_TIMEOUT = 29;
 
     private static final int TIMEOUT_HANGUP_PENDINGMO = 500;
 
     private static final int HANDOVER_TO_WIFI_TIMEOUT_MS = 60000; // ms
 
+    private static final int TIMEOUT_REDIAL_WIFI_E911_MS = 10000;
+
     //***** Instance Variables
     private ArrayList<ImsPhoneConnection> mConnections = new ArrayList<ImsPhoneConnection>();
     private RegistrantList mVoiceCallEndedRegistrants = new RegistrantList();
@@ -336,7 +341,10 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     private boolean mIgnoreDataEnabledChangedForVideoCalls = false;
     private boolean mIsViLteDataMetered = false;
     private boolean mAlwaysPlayRemoteHoldTone = false;
+    private boolean mAutoRetryFailedWifiEmergencyCall = false;
 
+    private String mLastDialString = null;
+    private PhoneInternalInterface.DialArgs mLastDialArgs = null;
     /**
      * Listeners to changes in the phone state.  Intended for use by other interested IMS components
      * without the need to register a full blown {@link android.telephony.PhoneStateListener}.
@@ -961,6 +969,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 }
             }
 
+            mLastDialString = dialString;
+            mLastDialArgs = dialArgs;
             mPendingMO = new ImsPhoneConnection(mPhone,
                     checkForTestEmergencyNumber(dialString), this, mForegroundCall,
                     isEmergencyNumber);
@@ -1096,6 +1106,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
         mAlwaysPlayRemoteHoldTone = carrierConfig.getBoolean(
                 CarrierConfigManager.KEY_ALWAYS_PLAY_REMOTE_HOLD_TONE_BOOL);
+        mAutoRetryFailedWifiEmergencyCall = carrierConfig.getBoolean(
+                CarrierConfigManager.KEY_AUTO_RETRY_FAILED_WIFI_EMERGENCY_CALL);
 
         String[] mappings = carrierConfig
                 .getStringArray(CarrierConfigManager.KEY_IMS_REASONINFO_MAPPING_STRING_ARRAY);
@@ -2215,26 +2227,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                     mPhone.initiateSilentRedial();
                     return;
                 } else {
-                    mPendingMO = null;
-                    ImsPhoneConnection conn = findConnection(imsCall);
-                    Call.State callState;
-                    if (conn != null) {
-                        callState = conn.getState();
-                    } else {
-                        // Need to fall back in case connection is null; it shouldn't be, but a sane
-                        // fallback is to assume we're dialing.  This state is only used to
-                        // determine which disconnect string to show in the case of a low battery
-                        // disconnect.
-                        callState = Call.State.DIALING;
-                    }
-                    int cause = getDisconnectCauseFromReasonInfo(reasonInfo, callState);
-
-                    if(conn != null) {
-                        conn.setPreciseDisconnectCause(
-                                getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
-                    }
-
-                    processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+                    sendCallStartFailedDisconnect(imsCall, reasonInfo);
                 }
                 mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(),
                         reasonInfo);
@@ -2317,7 +2310,21 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
             }
 
-            processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+            if (reasonInfo.getCode() == ImsReasonInfo.CODE_SIP_ALTERNATE_EMERGENCY_CALL
+                    && mAutoRetryFailedWifiEmergencyCall) {
+                Pair<ImsCall, ImsReasonInfo> callInfo = new Pair<>(imsCall, reasonInfo);
+                mPhone.getDefaultPhone().getServiceStateTracker().registerForNetworkAttached(
+                        ImsPhoneCallTracker.this, EVENT_REDIAL_WIFI_E911_CALL, callInfo);
+                sendMessageDelayed(obtainMessage(EVENT_REDIAL_WIFI_E911_TIMEOUT, callInfo),
+                        TIMEOUT_REDIAL_WIFI_E911_MS);
+                final ConnectivityManager mgr = (ConnectivityManager) mPhone.getContext()
+                        .getSystemService(Context.CONNECTIVITY_SERVICE);
+                mgr.setAirplaneMode(false);
+                return;
+            } else {
+                processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+            }
+
             if (mForegroundCall.getState() != ImsPhoneCall.State.ACTIVE) {
                 if (mRingingCall.getState().isRinging()) {
                     // Drop pending MO. We should address incoming call first
@@ -2953,6 +2960,29 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
     };
 
+    public void sendCallStartFailedDisconnect(ImsCall imsCall, ImsReasonInfo reasonInfo) {
+        mPendingMO = null;
+        ImsPhoneConnection conn = findConnection(imsCall);
+        Call.State callState;
+        if (conn != null) {
+            callState = conn.getState();
+        } else {
+            // Need to fall back in case connection is null; it shouldn't be, but a sane
+            // fallback is to assume we're dialing.  This state is only used to
+            // determine which disconnect string to show in the case of a low battery
+            // disconnect.
+            callState = Call.State.DIALING;
+        }
+        int cause = getDisconnectCauseFromReasonInfo(reasonInfo, callState);
+
+        if (conn != null) {
+            conn.setPreciseDisconnectCause(
+                    getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
+        }
+
+        processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+    }
+
     public ImsUtInterface getUtInterface() throws ImsException {
         if (mImsManager == null) {
             throw getImsManagerIsNullException();
@@ -3124,6 +3154,35 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 }
                 break;
             }
+            case EVENT_REDIAL_WIFI_E911_CALL: {
+                Pair<ImsCall, ImsReasonInfo> callInfo =
+                        (Pair<ImsCall, ImsReasonInfo>) ((AsyncResult) msg.obj).userObj;
+                removeMessages(EVENT_REDIAL_WIFI_E911_TIMEOUT);
+                mPhone.getDefaultPhone().getServiceStateTracker()
+                        .unregisterForNetworkAttached(this);
+                ImsPhoneConnection oldConnection = findConnection(callInfo.first);
+                if (oldConnection == null) {
+                    sendCallStartFailedDisconnect(callInfo.first, callInfo.second);
+                }
+                mForegroundCall.detach(oldConnection);
+                removeConnection(oldConnection);
+                try {
+                    Connection newConnection =
+                            mPhone.getDefaultPhone().dial(mLastDialString, mLastDialArgs);
+                    oldConnection.onOriginalConnectionReplaced(newConnection);
+                } catch (CallStateException e) {
+                    sendCallStartFailedDisconnect(callInfo.first, callInfo.second);
+                }
+                break;
+            }
+            case EVENT_REDIAL_WIFI_E911_TIMEOUT: {
+                Pair<ImsCall, ImsReasonInfo> callInfo = (Pair<ImsCall, ImsReasonInfo>) msg.obj;
+                mPhone.getDefaultPhone().getServiceStateTracker()
+                        .unregisterForNetworkAttached(this);
+                removeMessages(EVENT_REDIAL_WIFI_E911_CALL);
+                sendCallStartFailedDisconnect(callInfo.first, callInfo.second);
+                break;
+            }
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
index d63b9c254..47b36242d 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
@@ -458,6 +458,9 @@ public class ImsPhoneConnection extends Connection implements
                 Rlog.d(LOG_TAG, "onDisconnect: no parent");
             }
             synchronized (this) {
+                if (mRttTextHandler != null) {
+                    mRttTextHandler.tearDown();
+                }
                 if (mImsCall != null) mImsCall.close();
                 mImsCall = null;
             }
@@ -973,8 +976,11 @@ public class ImsPhoneConnection extends Connection implements
     }
 
     public void sendRttModifyRequest(android.telecom.Connection.RttTextStream textStream) {
-        getImsCall().sendRttModifyRequest();
-        setCurrentRttTextStream(textStream);
+        ImsCall imsCall = getImsCall();
+        if (imsCall != null) {
+            getImsCall().sendRttModifyRequest();
+            setCurrentRttTextStream(textStream);
+        }
     }
 
     /**
@@ -987,11 +993,13 @@ public class ImsPhoneConnection extends Connection implements
         boolean accept = textStream != null;
         ImsCall imsCall = getImsCall();
 
-        imsCall.sendRttModifyResponse(accept);
-        if (accept) {
-            setCurrentRttTextStream(textStream);
-        } else {
-            Rlog.e(LOG_TAG, "sendRttModifyResponse: foreground call has no connections");
+        if (imsCall != null) {
+            imsCall.sendRttModifyResponse(accept);
+            if (accept) {
+                setCurrentRttTextStream(textStream);
+            } else {
+                Rlog.e(LOG_TAG, "sendRttModifyResponse: foreground call has no connections");
+            }
         }
     }
 
@@ -1046,7 +1054,12 @@ public class ImsPhoneConnection extends Connection implements
     // Make sure to synchronize on ImsPhoneConnection.this before calling.
     private void createRttTextHandler() {
         mRttTextHandler = new ImsRttTextHandler(Looper.getMainLooper(),
-                (message) -> getImsCall().sendRttMessage(message));
+                (message) -> {
+                    ImsCall imsCall = getImsCall();
+                    if (imsCall != null) {
+                        imsCall.sendRttMessage(message);
+                    }
+                });
         mRttTextHandler.initialize(mRttTextStream);
     }
 
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java b/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
index 3f9e8a8b7..eff249979 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
@@ -25,6 +25,7 @@ import android.telephony.Rlog;
 import com.android.internal.annotations.VisibleForTesting;
 
 import java.io.IOException;
+import java.nio.channels.ClosedByInterruptException;
 import java.util.concurrent.CountDownLatch;
 
 public class ImsRttTextHandler extends Handler {
@@ -79,17 +80,16 @@ public class ImsRttTextHandler extends Handler {
                 String charsReceived;
                 try {
                     charsReceived = mReaderThreadRttTextStream.read();
+                } catch (ClosedByInterruptException e) {
+                    Rlog.i(LOG_TAG, "RttReaderThread - Thread interrupted. Finishing.");
+                    break;
                 } catch (IOException e) {
                     Rlog.e(LOG_TAG, "RttReaderThread - IOException encountered " +
-                            "reading from in-call: %s", e);
+                            "reading from in-call: ", e);
                     obtainMessage(TEARDOWN).sendToTarget();
                     break;
                 }
                 if (charsReceived == null) {
-                    if (Thread.currentThread().isInterrupted()) {
-                        Rlog.i(LOG_TAG, "RttReaderThread - Thread interrupted. Finishing.");
-                        break;
-                    }
                     Rlog.e(LOG_TAG, "RttReaderThread - Stream closed unexpectedly. Attempt to " +
                             "reinitialize.");
                     obtainMessage(TEARDOWN).sendToTarget();
@@ -145,7 +145,7 @@ public class ImsRttTextHandler extends Handler {
                 int numCodepointsBuffered = mBufferedTextToNetwork
                         .codePointCount(0, mBufferedTextToNetwork.length());
                 if (numCodepointsBuffered >= MAX_BUFFERED_CHARACTER_COUNT) {
-                    sendMessageAtFrontOfQueue(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
+                    sendMessage(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
                 } else {
                     sendEmptyMessageDelayed(
                             ATTEMPT_SEND_TO_NETWORK, MAX_BUFFERING_DELAY_MILLIS);
@@ -175,12 +175,13 @@ public class ImsRttTextHandler extends Handler {
             case EXPIRE_SENT_CODEPOINT_COUNT:
                 mCodepointsAvailableForTransmission += msg.arg1;
                 if (mCodepointsAvailableForTransmission > 0) {
-                    sendMessageAtFrontOfQueue(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
+                    sendMessage(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
                 }
                 break;
             case TEARDOWN:
                 try {
                     if (mReaderThread != null) {
+                        mReaderThread.interrupt();
                         mReaderThread.join(1000);
                     }
                 } catch (InterruptedException e) {
@@ -202,6 +203,7 @@ public class ImsRttTextHandler extends Handler {
     }
 
     public void initialize(Connection.RttTextStream rttTextStream) {
+        Rlog.i(LOG_TAG, "Initializing: " + this);
         obtainMessage(INITIALIZE, rttTextStream).sendToTarget();
     }
 
diff --git a/src/java/com/android/internal/telephony/metrics/TelephonyMetrics.java b/src/java/com/android/internal/telephony/metrics/TelephonyMetrics.java
index a436d25cd..75ea68fdf 100644
--- a/src/java/com/android/internal/telephony/metrics/TelephonyMetrics.java
+++ b/src/java/com/android/internal/telephony/metrics/TelephonyMetrics.java
@@ -38,6 +38,7 @@ import static com.android.internal.telephony.nano.TelephonyProto.PdpType.PDP_UNK
 import android.hardware.radio.V1_0.SetupDataCallResult;
 import android.os.Build;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.telephony.Rlog;
 import android.telephony.ServiceState;
 import android.telephony.TelephonyHistogram;
@@ -431,6 +432,7 @@ public class TelephonyMetrics {
         pw.println("Amount of time modem is in rx (ms): " + s.rxTimeMs);
         pw.println("Amount of time modem is in tx (ms): " + Arrays.toString(s.txTimeMs));
         pw.decreaseIndent();
+        pw.println("Hardware Version: " + SystemProperties.get("ro.boot.revision", ""));
     }
 
     /**
@@ -527,6 +529,9 @@ public class TelephonyMetrics {
         // Build modem power metrics
         log.modemPowerStats = new ModemPowerMetrics().buildProto();
 
+        // Log the hardware revision
+        log.hardwareRevision = SystemProperties.get("ro.boot.revision", "");
+
         // Log the starting system time
         log.startTime = new TelephonyProto.Time();
         log.startTime.systemTimestampMillis = mStartSystemTimeMs;
@@ -1761,9 +1766,12 @@ public class TelephonyMetrics {
      * @param isCMAS true if msg is CMAS
      * @param isETWS true if msg is ETWS
      * @param serviceCategory Service category of CB msg
+     * @param serialNumber Serial number of the message
+     * @param deliveredTimestamp Message's delivered timestamp
      */
     public synchronized void writeNewCBSms(int phoneId, int format, int priority, boolean isCMAS,
-                                           boolean isETWS, int serviceCategory) {
+                                           boolean isETWS, int serviceCategory, int serialNumber,
+                                           long deliveredTimestamp) {
         InProgressSmsSession smsSession = startNewSmsSessionIfNeeded(phoneId);
 
         int type;
@@ -1780,6 +1788,8 @@ public class TelephonyMetrics {
         cbm.msgPriority = priority + 1;
         cbm.msgType = type;
         cbm.serviceCategory = serviceCategory;
+        cbm.serialNumber = serialNumber;
+        cbm.deliveredTimestampMillis = deliveredTimestamp;
 
         smsSession.addEvent(new SmsSessionEventBuilder(SmsSession.Event.Type.CB_SMS_RECEIVED)
                 .setCellBroadcastMessage(cbm)
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCard.java b/src/java/com/android/internal/telephony/uicc/UiccCard.java
index e55170aa7..68463c5da 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCard.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCard.java
@@ -230,13 +230,13 @@ public class UiccCard {
      *
      * A null aid implies a card level reset - all applications must be reset.
      *
-     * @deprecated Please use {@link UiccProfile#resetAppWithAid(String)} instead.
+     * @deprecated Please use {@link UiccProfile#resetAppWithAid(String, boolean)} instead.
      */
     @Deprecated
-    public boolean resetAppWithAid(String aid) {
+    public boolean resetAppWithAid(String aid, boolean disposeCatService) {
         synchronized (mLock) {
             if (mUiccProfile != null) {
-                return mUiccProfile.resetAppWithAid(aid);
+                return mUiccProfile.resetAppWithAid(aid, disposeCatService);
             } else {
                 return false;
             }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCarrierPrivilegeRules.java b/src/java/com/android/internal/telephony/uicc/UiccCarrierPrivilegeRules.java
index a45c247aa..a7bbb955a 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCarrierPrivilegeRules.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCarrierPrivilegeRules.java
@@ -310,7 +310,8 @@ public class UiccCarrierPrivilegeRules extends Handler {
             // gained carrier privileges (as an indication that a matching SIM has been inserted).
             PackageInfo pInfo = packageManager.getPackageInfo(packageName,
                     PackageManager.GET_SIGNATURES
-                            | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS);
+                            | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                            | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS);
             return getCarrierPrivilegeStatus(pInfo);
         } catch (PackageManager.NameNotFoundException ex) {
             log("Package " + packageName + " not found for carrier privilege status check");
diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index 033f0a10f..670b85a92 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -642,14 +642,17 @@ public class UiccController extends Handler {
 
         boolean changed = false;
         switch(resp.refreshResult) {
+            // Reset the required apps when we know about the refresh so that
+            // anyone interested does not get stale state.
             case IccRefreshResponse.REFRESH_RESULT_RESET:
+                changed = uiccCard.resetAppWithAid(resp.aid, true /* disposeCatService */);
+                break;
             case IccRefreshResponse.REFRESH_RESULT_INIT:
-                 // Reset the required apps when we know about the refresh so that
-                 // anyone interested does not get stale state.
-                 changed = uiccCard.resetAppWithAid(resp.aid);
-                 break;
+                // don't dispose CatService on SIM REFRESH of type INIT
+                changed = uiccCard.resetAppWithAid(resp.aid, false /* disposeCatService */);
+                break;
             default:
-                 return;
+                return;
         }
 
         if (changed && resp.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
diff --git a/src/java/com/android/internal/telephony/uicc/UiccProfile.java b/src/java/com/android/internal/telephony/uicc/UiccProfile.java
index 3907a90c0..80248ea2e 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccProfile.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccProfile.java
@@ -1348,8 +1348,13 @@ public class UiccProfile extends IccCard {
      * Resets the application with the input AID. Returns true if any changes were made.
      *
      * A null aid implies a card level reset - all applications must be reset.
+     *
+     * @param aid aid of the application which should be reset; null imples all applications
+     * @param disposeCatService flag indicating if CatService should be disposed as part of
+     *                          this reset
+     * @return boolean indicating if there was any change made as part of the reset
      */
-    public boolean resetAppWithAid(String aid) {
+    public boolean resetAppWithAid(String aid, boolean disposeCatService) {
         synchronized (mLock) {
             boolean changed = false;
             for (int i = 0; i < mUiccApplications.length; i++) {
@@ -1366,7 +1371,7 @@ public class UiccProfile extends IccCard {
                     mCarrierPrivilegeRules = null;
                     changed = true;
                 }
-                if (mCatService != null) {
+                if (disposeCatService && mCatService != null) {
                     mCatService.dispose();
                     mCatService = null;
                     changed = true;
diff --git a/tests/telephonytests/src/com/android/internal/telephony/CarrierAppUtilsTest.java b/tests/telephonytests/src/com/android/internal/telephony/CarrierAppUtilsTest.java
index 54a56df3c..59c36bbcb 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/CarrierAppUtilsTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/CarrierAppUtilsTest.java
@@ -87,15 +87,18 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_MissingApp() throws Exception {
         Mockito.when(mPackageManager.getApplicationInfo("com.example.missing.app",
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(null);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(null);
         ArraySet<String> systemCarrierAppsDisabledUntilUsed = new ArraySet<>();
         systemCarrierAppsDisabledUntilUsed.add("com.example.missing.app");
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID,
                 systemCarrierAppsDisabledUntilUsed, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppHiddenUntilInstalled(
+                Mockito.anyString(), Mockito.anyBoolean());
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(Mockito.any(String[].class),
                         Mockito.anyInt());
@@ -107,12 +110,15 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     public void testDisableCarrierAppsUntilPrivileged_NonSystemApp() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppHiddenUntilInstalled(
+                Mockito.anyString(), Mockito.anyBoolean());
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
@@ -128,17 +134,20 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
@@ -148,37 +157,43 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     public void testDisableCarrierAppsUntilPrivileged_HasPrivileges_Disabled() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
 
-    /** Configured app has privileges, and is already enabled - should only grant permissions. */
+    /** Configured app has privileges, and is already installed - should only grant permissions. */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_HasPrivileges_Enabled() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
@@ -188,23 +203,27 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     public void testDisableCarrierAppsUntilPrivileged_HasPrivileges_UpdatedApp() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP
+                | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
 
     /**
-     * Configured app has privileges, and is in the default state - should enable. Associated app
+     * Configured app has privileges, and is in the default state - should install. Associated app
      * is missing and should not be touched.
      */
     @Test @SmallTest
@@ -212,28 +231,29 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                ASSOCIATED_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, true, USER_ID);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                ASSOCIATED_APP, true, USER_ID);
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
 
     /**
      * Configured app has privileges, and is in the default state along with associated app - should
-     * enable both.
+     * install both.
      */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_HasPrivileges_Associated_Default()
@@ -243,34 +263,38 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
                 mContentResolver, Settings.Secure.CARRIER_APPS_HANDLED, 1, USER_ID);
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(appInfo);
         ApplicationInfo associatedAppInfo = new ApplicationInfo();
         associatedAppInfo.packageName = ASSOCIATED_APP;
         associatedAppInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
         associatedAppInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(ASSOCIATED_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(associatedAppInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                ASSOCIATED_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                ASSOCIATED_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, true, USER_ID);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                ASSOCIATED_APP, true, USER_ID);
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
 
     /**
-     * Configured app has privileges, and is disabled until used - should enable. Associated app has
+     * Configured app has privileges, and is uninstalled - should install. Associated app has
      * been updated and should not be touched.
      */
     @Test @SmallTest
@@ -278,10 +302,12 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         ApplicationInfo associatedAppInfo = new ApplicationInfo();
         associatedAppInfo.packageName = ASSOCIATED_APP;
         associatedAppInfo.flags |=
@@ -289,53 +315,61 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
         associatedAppInfo.enabledSetting =
                 PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED;
         Mockito.when(mPackageManager.getApplicationInfo(ASSOCIATED_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(associatedAppInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                ASSOCIATED_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppHiddenUntilInstalled(
+                ASSOCIATED_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, true, USER_ID);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                ASSOCIATED_APP, true, USER_ID);
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
 
     /**
-     * Configured app has privileges, and is disabled until used along with associated app - should
-     * enable both.
+     * Configured app has privileges, and is uninstalled until used along with associated app -
+     * should install both.
      */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_HasPrivileges_Associated_DisabledUntilUsed()
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         ApplicationInfo associatedAppInfo = new ApplicationInfo();
         associatedAppInfo.packageName = ASSOCIATED_APP;
         associatedAppInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
         associatedAppInfo.enabledSetting =
                 PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED;
         Mockito.when(mPackageManager.getApplicationInfo(ASSOCIATED_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(associatedAppInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                ASSOCIATED_APP, PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-                PackageManager.DONT_KILL_APP, USER_ID, CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                ASSOCIATED_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, true, USER_ID);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                ASSOCIATED_APP, true, USER_ID);
         Mockito.verify(mPackageManager).grantDefaultPermissionsToEnabledCarrierApps(
                 new String[] {appInfo.packageName}, USER_ID);
     }
@@ -345,17 +379,20 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_DisabledUser() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
@@ -367,98 +404,113 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 null /* telephonyManager */, mContentResolver, USER_ID, CARRIER_APPS,
                 ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Configured app has no privileges, and was disabled - should do nothing. */
+    /** Configured app has no privileges, and was uninstalled - should do nothing. */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_Disabled() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Telephony is not initialized, and app was disabled - should do nothing. */
+    /** Telephony is not initialized, and app was uninstalled - should do nothing. */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NullPrivileges_Disabled() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 null /* telephonyManager */, mContentResolver, USER_ID, CARRIER_APPS,
                 ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Configured app has no privileges, and is explicitly enabled - should do nothing. */
+    /** Configured app has no privileges, and is explicitly installed - should do nothing. */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_Enabled() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Telephony is not initialized, and app is explicitly enabled - should do nothing. */
+    /** Telephony is not initialized, and app is explicitly installed - should do nothing. */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NullPrivileges_Enabled() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 null /* telephonyManager */, mContentResolver, USER_ID, CARRIER_APPS,
                 ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
@@ -469,17 +521,21 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_UpdatedApp() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP
+                | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
@@ -490,51 +546,60 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
     public void testDisableCarrierAppsUntilPrivileged_NullPrivileges_UpdatedApp() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+        appInfo.flags |= (ApplicationInfo.FLAG_SYSTEM
+                | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP | ApplicationInfo.FLAG_INSTALLED);
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 null /* telephonyManager */, mContentResolver, USER_ID, CARRIER_APPS,
                 ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
     /**
-     * Configured app has no privileges, and is in the default state - should disable until use.
-     * Associated app is enabled and should not be touched.
+     * Configured app has no privileges, and is in the default state - should uninstalled.
+     * Associated app is installed and should not be touched.
      */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_EnabledAssociated_Default()
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         ApplicationInfo associatedAppInfo = new ApplicationInfo();
         associatedAppInfo.packageName = ASSOCIATED_APP;
         associatedAppInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
         associatedAppInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
         Mockito.when(mPackageManager.getApplicationInfo(ASSOCIATED_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(associatedAppInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, 0, USER_ID,
-                CALLING_PACKAGE);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                ASSOCIATED_APP, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, 0,
-                USER_ID, CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                ASSOCIATED_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, false, USER_ID);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                ASSOCIATED_APP, false, USER_ID);
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
@@ -542,34 +607,39 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
 
     /**
      * Configured app has no privileges, and is in the default state along with associated app -
-     * should disable both.
+     * should uninstall both.
      */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_Associated_Default()
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         ApplicationInfo associatedAppInfo = new ApplicationInfo();
         associatedAppInfo.packageName = ASSOCIATED_APP;
-        associatedAppInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        associatedAppInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         associatedAppInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(ASSOCIATED_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(associatedAppInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, 0, USER_ID,
-                CALLING_PACKAGE);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                ASSOCIATED_APP, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, 0,
-                USER_ID, CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                ASSOCIATED_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, false, USER_ID);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                ASSOCIATED_APP, false, USER_ID);
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
@@ -577,7 +647,7 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
 
     /**
      * Configured app has no privileges, and is in the default state along with associated app, and
-     * disabling has already occurred - should only disable configured app.
+     * disabling has already occurred - should only uninstall configured app.
      */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_Associated_Default_AlreadyRun()
@@ -586,90 +656,108 @@ public class CarrierAppUtilsTest extends InstrumentationTestCase {
                 mContentResolver, Settings.Secure.CARRIER_APPS_HANDLED, 1, USER_ID);
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         ApplicationInfo associatedAppInfo = new ApplicationInfo();
         associatedAppInfo.packageName = ASSOCIATED_APP;
         associatedAppInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
         associatedAppInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(ASSOCIATED_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID))
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS, USER_ID))
                 .thenReturn(associatedAppInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, 0, USER_ID,
-                CALLING_PACKAGE);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.eq(ASSOCIATED_APP), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                ASSOCIATED_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, false, USER_ID);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.eq(ASSOCIATED_APP), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Telephony is not initialized, and app is in the default state - should disable until use. */
+    /** Telephony is not initialized, and app is in the default state - should uninstall it. */
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NullPrivileges_Default() throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 null /* telephonyManager */, mContentResolver, USER_ID, CARRIER_APPS,
                 ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager).setApplicationEnabledSetting(
-                CARRIER_APP, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, 0, USER_ID,
-                CALLING_PACKAGE);
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager).setSystemAppInstallState(
+                CARRIER_APP, false, USER_ID);
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Configured app has no privileges, and is disabled until used - should do nothing. */
+    /** Configured app has no privileges, and is disabled until used or not installed - should do
+     *  nothing.
+     **/
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NoPrivileges_DisabledUntilUsed()
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         Mockito.when(mTelephonyManager.checkCarrierPrivilegesForPackageAnyPhone(CARRIER_APP))
                 .thenReturn(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 mTelephonyManager, mContentResolver, USER_ID, CARRIER_APPS, ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
     }
 
-    /** Telephony is not initialized, and app is disabled until used - should do nothing. */
+    /** Telephony is not initialized, and app is disabled until used or not installed - should do
+     *  nothing.
+     **/
     @Test @SmallTest
     public void testDisableCarrierAppsUntilPrivileged_NullPrivileges_DisabledUntilUsed()
             throws Exception {
         ApplicationInfo appInfo = new ApplicationInfo();
         appInfo.packageName = CARRIER_APP;
-        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
+        appInfo.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_INSTALLED;
         appInfo.enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED;
         Mockito.when(mPackageManager.getApplicationInfo(CARRIER_APP,
-                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, USER_ID)).thenReturn(appInfo);
+                PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
+                        | PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS,
+                USER_ID)).thenReturn(appInfo);
         CarrierAppUtils.disableCarrierAppsUntilPrivileged(CALLING_PACKAGE, mPackageManager,
                 null /* telephonyManager */, mContentResolver, USER_ID, CARRIER_APPS,
                 ASSOCIATED_APPS);
-        Mockito.verify(mPackageManager, Mockito.never()).setApplicationEnabledSetting(
-                Mockito.anyString(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(),
-                Mockito.anyString());
+        Mockito.verify(mPackageManager).setSystemAppHiddenUntilInstalled(
+                CARRIER_APP, true);
+        Mockito.verify(mPackageManager, Mockito.never()).setSystemAppInstallState(
+                Mockito.anyString(), Mockito.anyBoolean(), Mockito.anyInt());
         Mockito.verify(mPackageManager, Mockito.never())
                 .grantDefaultPermissionsToEnabledCarrierApps(
                         Mockito.any(String[].class), Mockito.anyInt());
diff --git a/tests/telephonytests/src/com/android/internal/telephony/DeviceStateMonitorTest.java b/tests/telephonytests/src/com/android/internal/telephony/DeviceStateMonitorTest.java
index 591b1110d..1f883b8a6 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/DeviceStateMonitorTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/DeviceStateMonitorTest.java
@@ -124,4 +124,12 @@ public class DeviceStateMonitorTest extends TelephonyTest {
         verify(mSimulatedCommandsVerifier, times(1)).sendDeviceState(eq(CHARGING_STATE),
                 eq(false), nullable(Message.class));
     }
+
+    @FlakyTest
+    public void testReset() throws Exception {
+        mDSM.obtainMessage(6).sendToTarget();
+
+        verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(-1),
+                nullable(Message.class));
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
index fa8bec3e4..60bc61f74 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
@@ -487,7 +487,7 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
         // voicemail number from sharedPreference
         mPhoneUT.setVoiceMailNumber("alphaTag", voiceMailNumber, null);
         ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(mRuimRecords).setVoiceMailNumber(eq("alphaTag"), eq(voiceMailNumber),
+        verify(mSimRecords).setVoiceMailNumber(eq("alphaTag"), eq(voiceMailNumber),
                 messageArgumentCaptor.capture());
 
         Message msg = messageArgumentCaptor.getValue();
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java b/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java
index 67fea9423..a8bb8fb73 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java
@@ -36,6 +36,7 @@ import android.content.ContentProvider;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.IPackageManager;
 import android.content.pm.UserInfo;
 import android.net.Uri;
 import android.os.HandlerThread;
@@ -90,6 +91,8 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
     private EuiccController mEuiccController;
     @Mock
     private IntentBroadcaster mIntentBroadcaster;
+    @Mock
+    private IPackageManager mPackageManager;
 
     /*Custom ContentProvider */
     private class FakeSubscriptionContentProvider extends MockContentProvider {
@@ -108,7 +111,7 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
         @Override
         public void onLooperPrepared() {
             mUpdater = new SubscriptionInfoUpdater(getLooper(), mContext, new Phone[]{mPhone},
-                    new CommandsInterface[]{mSimulatedCommands});
+                    new CommandsInterface[]{mSimulatedCommands}, mPackageManager);
             setReady(true);
         }
     }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccProfileTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccProfileTest.java
index 1c4636753..37f45a6cc 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccProfileTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccProfileTest.java
@@ -426,6 +426,45 @@ public class UiccProfileTest extends TelephonyTest {
         assertEquals(State.LOADED, mUiccProfile.getState());
     }
 
+    @Test
+    @SmallTest
+    public void testUpdateUiccProfileApplicationWithDuplicateAppsInDifferentOrder() {
+        /* update app status and index */
+        IccCardApplicationStatus umtsApp = composeUiccApplicationStatus(
+                IccCardApplicationStatus.AppType.APPTYPE_USIM,
+                IccCardApplicationStatus.AppState.APPSTATE_READY, "0xA2");
+        IccCardApplicationStatus imsApp = composeUiccApplicationStatus(
+                IccCardApplicationStatus.AppType.APPTYPE_ISIM,
+                IccCardApplicationStatus.AppState.APPSTATE_READY, "0xA1");
+        IccCardApplicationStatus unknownApp = composeUiccApplicationStatus(
+                IccCardApplicationStatus.AppType.APPTYPE_UNKNOWN,
+                IccCardApplicationStatus.AppState.APPSTATE_UNKNOWN, "0xA2");
+        IccCardApplicationStatus umtsAppDup = composeUiccApplicationStatus(
+                IccCardApplicationStatus.AppType.APPTYPE_USIM,
+                AppState.APPSTATE_DETECTED, "0xA2");
+        mIccCardStatus.mApplications = new IccCardApplicationStatus[]{umtsAppDup, imsApp, umtsApp,
+                unknownApp};
+        mIccCardStatus.mCdmaSubscriptionAppIndex = -1;
+        mIccCardStatus.mImsSubscriptionAppIndex = 0;
+        mIccCardStatus.mGsmUmtsSubscriptionAppIndex = 2;
+        Message mProfileUpdate = mHandler.obtainMessage(UICCPROFILE_UPDATE_APPLICATION_EVENT);
+        setReady(false);
+        mProfileUpdate.sendToTarget();
+
+        waitUntilReady();
+
+        /* wait for the carrier privilege rules to be loaded */
+        waitForMs(50);
+        assertEquals(4, mUiccProfile.getNumApplications());
+
+        mUiccProfile.mHandler.sendMessage(
+                mUiccProfile.mHandler.obtainMessage(UiccProfile.EVENT_APP_READY));
+        waitForMs(SCARY_SLEEP_MS);
+        // state is loaded as all records are loaded right away as SimulatedCommands returns
+        // response for them right away. Ideally applications and records should be mocked.
+        assertEquals(State.LOADED, mUiccProfile.getState());
+    }
+
     @Test
     @SmallTest
     public void testUpdateUiccProfileApplicationNoApplication() {
-- 
2.17.1

