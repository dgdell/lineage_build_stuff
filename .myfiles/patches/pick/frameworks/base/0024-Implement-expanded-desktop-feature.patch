From bb64c47cf9d8732122bca04eccad317e11fa5105 Mon Sep 17 00:00:00 2001
From: Kyrylo Mikos <kiril.mik.os@gmail.com>
Date: Mon, 17 Nov 2014 13:56:05 +0200
Subject: [PATCH 24/57] Implement expanded desktop feature

Author: Kyrylo Mikos <kiril.mik.os@gmail.com>
Date:   Mon Nov 17 13:56:05 2014 +0200

    Bringup expanded desktop and implement per-user configuration.

    Change-Id: I90d834d788b3050a3f4c11dda9b6d1a7d79546cc

Author: Adnan Begovic <adnan@cyngn.com>
Date:   Wed Feb 4 01:00:06 2015 -0800

    Create configurable default expanded desktop style.

    Change-Id: I90c7f8544cda9b91fb9b700fcf146f4e58b15a26

Author: Adnan Begovic <adnan@cyngn.com>
Date:   Wed Jan 21 21:52:35 2015 -0800

    Remove unused POLICY_CONTROL_SELECTED. Unbreak public api.

Change-Id: Ib0900349115442274fb08eb172de2567a8b00295
---
 core/java/android/provider/Settings.java      |  11 +-
 core/java/android/view/WindowManager.java     |  16 ++
 .../view/WindowManagerPolicyControl.java      | 193 ++++++++++++++++--
 .../android/server/policy/BarController.java  |   6 +-
 .../policy/ImmersiveModeConfirmation.java     |   3 +-
 .../server/policy/PhoneWindowManager.java     | 112 ++++++++--
 .../server/policy/WindowManagerPolicy.java    |   2 +
 .../com/android/server/wm/DisplayFrames.java  |   4 +
 .../server/wm/WindowManagerService.java       |   5 +
 9 files changed, 309 insertions(+), 43 deletions(-)
 rename services/core/java/com/android/server/policy/PolicyControl.java => core/java/android/view/WindowManagerPolicyControl.java (58%)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 6a545fe7ece..be9e5b8d403 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -11617,7 +11617,7 @@ public final class Settings {
         /**
          * Defines global runtime overrides to window policy.
          *
-         * See {@link com.android.server.policy.PolicyControl} for value format.
+         * See {@link android.view.WindowManagerPolicyControl} for value format.
          *
          * @hide
          */
@@ -11640,6 +11640,15 @@ public final class Settings {
          */
         public static final String BLOCKED_SLICES = "blocked_slices";
 
+        /**
+         * Defines global runtime overrides to window policy style.
+         *
+         * See {@link android.view.WindowManagerPolicyControl} for value definitions.
+         *
+         * @hide
+         */
+        public static final String POLICY_CONTROL_STYLE = "policy_control_style";
+
         /**
          * Defines global zen mode.  ZEN_MODE_OFF, ZEN_MODE_IMPORTANT_INTERRUPTIONS,
          * or ZEN_MODE_NO_INTERRUPTIONS.
diff --git a/core/java/android/view/WindowManager.java b/core/java/android/view/WindowManager.java
index 7182c3f5e80..4d95563a615 100644
--- a/core/java/android/view/WindowManager.java
+++ b/core/java/android/view/WindowManager.java
@@ -1707,6 +1707,22 @@ public interface WindowManager extends ViewManager {
          */
         public static final int PRIVATE_FLAG_STATUS_BAR_EXPANDED = 0x00800000;
 
+        /**
+         * @hide
+         */
+        public static final int PRIVATE_FLAG_STATUS_HIDE_FORCED = 0x01000000;
+
+        /**
+         * @hide
+         */
+        public static final int PRIVATE_FLAG_NAV_HIDE_FORCED = 0x02000000;
+
+        /**
+         * The window had not set FULLSCREEN flag so don't handle it as fullscreen in layoutWindowLw
+         * @hide
+         */
+        public static final int PRIVATE_FLAG_WAS_NOT_FULLSCREEN = 0x04000000;
+
         /**
          * Control flags that are private to the platform.
          * @hide
diff --git a/services/core/java/com/android/server/policy/PolicyControl.java b/core/java/android/view/WindowManagerPolicyControl.java
similarity index 58%
rename from services/core/java/com/android/server/policy/PolicyControl.java
rename to core/java/android/view/WindowManagerPolicyControl.java
index 48e72bc5036..0a6072b7a15 100644
--- a/services/core/java/com/android/server/policy/PolicyControl.java
+++ b/core/java/android/view/WindowManagerPolicyControl.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.server.policy;
+package android.view;
 
 import android.app.ActivityManager;
 import android.content.Context;
@@ -22,14 +22,11 @@ import android.os.UserHandle;
 import android.provider.Settings;
 import android.util.ArraySet;
 import android.util.Slog;
-import android.view.View;
-import android.view.WindowManager;
 import android.view.WindowManager.LayoutParams;
 
-import com.android.server.policy.WindowManagerPolicy.WindowState;
-
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.Iterator;
 
 /**
  * Runtime adjustments applied to the global window policy.
@@ -48,8 +45,10 @@ import java.io.StringWriter;
  *
  * Separate multiple name-value pairs with ':'
  *   e.g. "immersive.status=apps:immersive.preconfirms=*"
+ *
+ *   @hide
  */
-public class PolicyControl {
+public class WindowManagerPolicyControl {
     private static String TAG = "PolicyControl";
     private static boolean DEBUG = false;
 
@@ -58,23 +57,34 @@ public class PolicyControl {
     private static final String NAME_IMMERSIVE_NAVIGATION = "immersive.navigation";
     private static final String NAME_IMMERSIVE_PRECONFIRMATIONS = "immersive.preconfirms";
 
+    private static int sDefaultImmersiveStyle;
     private static String sSettingValue;
     private static Filter sImmersivePreconfirmationsFilter;
     private static Filter sImmersiveStatusFilter;
     private static Filter sImmersiveNavigationFilter;
 
-    public static int getSystemUiVisibility(WindowState win, LayoutParams attrs) {
-        attrs = attrs != null ? attrs : win.getAttrs();
-        int vis = win != null ? win.getSystemUiVisibility()
-                : (attrs.systemUiVisibility | attrs.subtreeSystemUiVisibility);
-        if (sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(attrs)) {
+    /**
+     * Accessible constants for Settings
+     */
+    public final static class ImmersiveDefaultStyles {
+        public final static int IMMERSIVE_FULL = 0;
+        public final static int IMMERSIVE_STATUS = 1;
+        public final static int IMMERSIVE_NAVIGATION = 2;
+    }
+
+    public static int getSystemUiVisibility(int vis, LayoutParams attrs) {
+        if (sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(attrs)
+                && (sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_FULL ||
+                sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_STATUS))  {
             vis |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                     | View.SYSTEM_UI_FLAG_FULLSCREEN
                     | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
             vis &= ~(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                     | View.STATUS_BAR_TRANSLUCENT);
         }
-        if (sImmersiveNavigationFilter != null && sImmersiveNavigationFilter.matches(attrs)) {
+        if (sImmersiveNavigationFilter != null && sImmersiveNavigationFilter.matches(attrs)
+                && (sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_FULL ||
+                sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_NAVIGATION)) {
             vis |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                     | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                     | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
@@ -84,28 +94,75 @@ public class PolicyControl {
         return vis;
     }
 
-    public static int getWindowFlags(WindowState win, LayoutParams attrs) {
-        attrs = attrs != null ? attrs : win.getAttrs();
-        int flags = attrs.flags;
-        if (sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(attrs)) {
+    public static int getWindowFlags(int flags, LayoutParams attrs) {
+        if (sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(attrs)
+                && (sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_FULL ||
+                sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_STATUS)) {
             flags |= WindowManager.LayoutParams.FLAG_FULLSCREEN;
             flags &= ~(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
                     | WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
         }
-        if (sImmersiveNavigationFilter != null && sImmersiveNavigationFilter.matches(attrs)) {
+        if (sImmersiveNavigationFilter != null && sImmersiveNavigationFilter.matches(attrs)
+                && (sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_FULL ||
+                sDefaultImmersiveStyle == ImmersiveDefaultStyles.IMMERSIVE_NAVIGATION)) {
             flags &= ~WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;
         }
         return flags;
     }
 
-    public static int adjustClearableFlags(WindowState win, int clearableFlags) {
-        final LayoutParams attrs = win != null ? win.getAttrs() : null;
+    public static int getPrivateWindowFlags(int privateFlags, LayoutParams attrs) {
+        if (sImmersiveStatusFilter != null && sImmersiveNavigationFilter != null &&
+                sImmersiveStatusFilter.isEnabledForAll()
+                && sImmersiveNavigationFilter.isEnabledForAll()) {
+
+            if ((attrs.flags & LayoutParams.FLAG_FULLSCREEN) == 0) {
+                privateFlags |= LayoutParams.PRIVATE_FLAG_WAS_NOT_FULLSCREEN;
+            }
+
+            switch (sDefaultImmersiveStyle) {
+                case ImmersiveDefaultStyles.IMMERSIVE_FULL:
+                    privateFlags |= LayoutParams.PRIVATE_FLAG_NAV_HIDE_FORCED;
+                    privateFlags |= LayoutParams.PRIVATE_FLAG_STATUS_HIDE_FORCED;
+                    return privateFlags;
+                case ImmersiveDefaultStyles.IMMERSIVE_STATUS:
+                    privateFlags |= LayoutParams.PRIVATE_FLAG_STATUS_HIDE_FORCED;
+                    return privateFlags;
+                case ImmersiveDefaultStyles.IMMERSIVE_NAVIGATION:
+                    privateFlags |= LayoutParams.PRIVATE_FLAG_NAV_HIDE_FORCED;
+                    return privateFlags;
+                }
+        }
+
+        if (sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(attrs)) {
+            if ((attrs.flags & LayoutParams.FLAG_FULLSCREEN) == 0) {
+                privateFlags |= LayoutParams.PRIVATE_FLAG_WAS_NOT_FULLSCREEN;
+            }
+            privateFlags |= LayoutParams.PRIVATE_FLAG_STATUS_HIDE_FORCED;
+        }
+
+        if (sImmersiveNavigationFilter != null && sImmersiveNavigationFilter.matches(attrs)) {
+            privateFlags |= LayoutParams.PRIVATE_FLAG_NAV_HIDE_FORCED;
+        }
+
+        return privateFlags;
+    }
+
+    public static int adjustClearableFlags(LayoutParams attrs, int clearableFlags) {
         if (sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(attrs)) {
             clearableFlags &= ~View.SYSTEM_UI_FLAG_FULLSCREEN;
         }
         return clearableFlags;
     }
 
+    public static boolean immersiveStatusFilterMatches(String packageName) {
+        return sImmersiveStatusFilter != null && sImmersiveStatusFilter.matches(packageName);
+    }
+
+    public static boolean immersiveNavigationFilterMatches(String packageName) {
+        return sImmersiveNavigationFilter != null
+                && sImmersiveNavigationFilter.matches(packageName);
+    }
+
     public static boolean disableImmersiveConfirmation(String pkg) {
         return (sImmersivePreconfirmationsFilter != null
                 && sImmersivePreconfirmationsFilter.matches(pkg))
@@ -113,7 +170,11 @@ public class PolicyControl {
     }
 
     public static void reloadFromSetting(Context context) {
-        if (DEBUG) Slog.d(TAG, "reloadFromSetting()");
+        sDefaultImmersiveStyle = Settings.Global.getInt(context.getContentResolver(),
+                Settings.Global.POLICY_CONTROL_STYLE,
+                WindowManagerPolicyControl.ImmersiveDefaultStyles.IMMERSIVE_FULL);
+        if (DEBUG) Slog.d(TAG, "reloadStyleFromSetting " + sDefaultImmersiveStyle);
+
         String value = null;
         try {
             value = Settings.Global.getStringForUser(context.getContentResolver(),
@@ -127,6 +188,94 @@ public class PolicyControl {
         }
     }
 
+    public static void saveToSettings(Context context) {
+        StringBuilder value = new StringBuilder();
+        boolean needSemicolon = false;
+        if (sImmersiveStatusFilter != null) {
+            writeFilter(NAME_IMMERSIVE_STATUS, sImmersiveStatusFilter, value);
+            needSemicolon = true;
+        }
+        if (sImmersiveNavigationFilter != null) {
+            if (needSemicolon) {
+                value.append(":");
+            }
+            writeFilter(NAME_IMMERSIVE_NAVIGATION, sImmersiveNavigationFilter, value);
+        }
+
+        Settings.Global.putString(context.getContentResolver(),
+                Settings.Global.POLICY_CONTROL, value.toString());
+    }
+
+    public static void saveStyleToSettings(Context context, int value) {
+        Settings.Global.putInt(context.getContentResolver(),
+                Settings.Global.POLICY_CONTROL_STYLE, value);
+        sDefaultImmersiveStyle = value;
+    }
+
+    public static void addToStatusWhiteList(String packageName) {
+        if (sImmersiveStatusFilter == null) {
+            sImmersiveStatusFilter = new Filter(new ArraySet<String>(), new ArraySet<String>());
+        }
+
+        if (!sImmersiveStatusFilter.mWhitelist.contains(packageName)) {
+            sImmersiveStatusFilter.mWhitelist.add(packageName);
+        }
+    }
+
+    public static void addToNavigationWhiteList(String packageName) {
+        if (sImmersiveNavigationFilter == null) {
+            sImmersiveNavigationFilter = new Filter(new ArraySet<String>(), new ArraySet<String>());
+        }
+
+        if (!sImmersiveNavigationFilter.mWhitelist.contains(packageName)) {
+            sImmersiveNavigationFilter.mWhitelist.add(packageName);
+        }
+    }
+
+    public static void removeFromWhiteLists(String packageName) {
+        if (sImmersiveStatusFilter != null) {
+            sImmersiveStatusFilter.mWhitelist.remove(packageName);
+        }
+        if (sImmersiveNavigationFilter != null) {
+            sImmersiveNavigationFilter.mWhitelist.remove(packageName);
+        }
+    }
+
+    private static void writeFilter(String name, Filter filter, StringBuilder stringBuilder) {
+        if (filter.mWhitelist.isEmpty() && filter.mBlacklist.isEmpty()) {
+            return;
+        }
+        stringBuilder.append(name);
+        stringBuilder.append("=");
+
+        boolean needComma = false;
+        if (!filter.mWhitelist.isEmpty()) {
+            writePackages(filter.mWhitelist, stringBuilder, false);
+            needComma = true;
+        }
+        if (!filter.mBlacklist.isEmpty()) {
+            if (needComma) {
+                stringBuilder.append(",");
+            }
+            writePackages(filter.mBlacklist, stringBuilder, true);
+        }
+    }
+
+    private static void writePackages(ArraySet<String> set, StringBuilder stringBuilder,
+                                      boolean isBlackList) {
+        Iterator<String> iterator = set.iterator();
+        while (iterator.hasNext()) {
+            if (isBlackList) {
+                stringBuilder.append("-");
+            }
+            String name = iterator.next();
+            stringBuilder.append(name);
+            if (iterator.hasNext()) {
+                stringBuilder.append(",");
+            }
+        }
+    }
+
     public static void dump(String prefix, PrintWriter pw) {
         dump("sImmersiveStatusFilter", sImmersiveStatusFilter, prefix, pw);
         dump("sImmersiveNavigationFilter", sImmersiveNavigationFilter, prefix, pw);
@@ -208,6 +357,10 @@ public class PolicyControl {
             return !onBlacklist(packageName) && onWhitelist(packageName);
         }
 
+        public boolean isEnabledForAll() {
+            return mWhitelist.contains(ALL);
+        }
+
         private boolean onBlacklist(String packageName) {
             return mBlacklist.contains(packageName) || mBlacklist.contains(ALL);
         }
diff --git a/services/core/java/com/android/server/policy/BarController.java b/services/core/java/com/android/server/policy/BarController.java
index 14c985c090a..ca70816f75d 100644
--- a/services/core/java/com/android/server/policy/BarController.java
+++ b/services/core/java/com/android/server/policy/BarController.java
@@ -28,6 +28,7 @@ import android.util.Slog;
 import android.util.proto.ProtoOutputStream;
 import android.view.View;
 import android.view.WindowManager;
+import android.view.WindowManagerPolicyControl;
 
 import com.android.server.LocalServices;
 import com.android.server.policy.WindowManagerPolicy.WindowState;
@@ -138,9 +139,10 @@ public class BarController {
 
     public int applyTranslucentFlagLw(WindowState win, int vis, int oldVis) {
         if (mWin != null) {
-            if (win != null && (win.getAttrs().privateFlags
+            WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
+            if (attrs != null && (attrs.privateFlags
                     & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) == 0) {
-                int fl = PolicyControl.getWindowFlags(win, null);
+                int fl = WindowManagerPolicyControl.getWindowFlags(attrs.flags, attrs);
                 if ((fl & mTranslucentWmFlag) != 0) {
                     vis |= mTranslucentFlag;
                 } else {
diff --git a/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java b/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java
index 4aa24465215..368d1680f95 100644
--- a/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java
+++ b/services/core/java/com/android/server/policy/ImmersiveModeConfirmation.java
@@ -48,6 +48,7 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
+import android.view.WindowManagerPolicyControl;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.view.animation.Interpolator;
@@ -144,7 +145,7 @@ public class ImmersiveModeConfirmation {
             boolean userSetupComplete, boolean navBarEmpty) {
         mHandler.removeMessages(H.SHOW);
         if (isImmersiveMode) {
-            final boolean disabled = PolicyControl.disableImmersiveConfirmation(pkg);
+            final boolean disabled = WindowManagerPolicyControl.disableImmersiveConfirmation(pkg);
             if (DEBUG) Slog.d(TAG, String.format("immersiveModeChanged() disabled=%s mConfirmed=%s",
                     disabled, mConfirmed));
             if (!disabled
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 9f32f32adc4..4bab1103c19 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -75,9 +75,12 @@ import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANS
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_IS_SCREEN_DECOR;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD;
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_NAV_HIDE_FORCED;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_STATUS_BAR_EXPANDED;
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_STATUS_HIDE_FORCED;
 import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR;
+import static android.view.WindowManager.LayoutParams.PRIVATE_FLAG_WAS_NOT_FULLSCREEN;
 import static android.view.WindowManager.LayoutParams.ROTATION_ANIMATION_CROSSFADE;
 import static android.view.WindowManager.LayoutParams.ROTATION_ANIMATION_JUMPCUT;
 import static android.view.WindowManager.LayoutParams.ROTATION_ANIMATION_ROTATE;
@@ -260,6 +263,7 @@ import android.view.ViewConfiguration;
 import android.view.WindowManager;
 import android.view.WindowManager.LayoutParams;
 import android.view.WindowManagerGlobal;
+import android.view.WindowManagerPolicyControl;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityManager;
 import android.view.animation.Animation;
@@ -930,6 +934,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION = 1;
 
     private LineageHardwareManager mLineageHardware;
+    private boolean mClearedBecauseOfForceShow;
+    private boolean mTopWindowIsKeyguard;
 
     private CameraManager mCameraManager;
     private String mRearFlashCameraId;
@@ -2935,7 +2941,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
         synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
-            PolicyControl.reloadFromSetting(mContext);
+            WindowManagerPolicyControl.reloadFromSetting(mContext);
         }
         if (updateRotation) {
             updateRotation(true);
@@ -5081,9 +5087,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     public boolean getLayoutHintLw(WindowManager.LayoutParams attrs, Rect taskBounds,
             DisplayFrames displayFrames, Rect outFrame, Rect outContentInsets, Rect outStableInsets,
             Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout) {
-        final int fl = PolicyControl.getWindowFlags(null, attrs);
-        final int pfl = attrs.privateFlags;
-        final int requestedSysUiVis = PolicyControl.getSystemUiVisibility(null, attrs);
+        final int fl = getWindowFlags(null, attrs);
+        final int pfl = getPrivateWindowFlags(null, attrs);
+        final int requestedSysUiVis = getSystemUiVisibility(null, attrs);
         final int sysUiVis = requestedSysUiVis | getImpliedSysUiFlagsForLayout(attrs);
         final int displayRotation = displayFrames.mRotation;
         final int displayWidth = displayFrames.mDisplayWidth;
@@ -5587,6 +5593,19 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         pf.set((fl & FLAG_LAYOUT_IN_SCREEN) == 0 ? attached.getFrameLw() : df);
     }
 
+    private void applyForceImmersiveMode(int pfl, Rect r, DisplayFrames displayFrames) {
+        if ((pfl & PRIVATE_FLAG_STATUS_HIDE_FORCED) != 0) {
+            r.top = displayFrames.mForceImmersive.top;
+        }
+        if ((pfl & PRIVATE_FLAG_NAV_HIDE_FORCED) != 0) {
+            if (mNavigationBarPosition == NAV_BAR_BOTTOM) {
+                r.bottom = displayFrames.mForceImmersive.bottom;
+            } else {
+                r.right = displayFrames.mForceImmersive.right;
+            }
+        }
+    }
+
     private void applyStableConstraints(int sysui, int fl, Rect r, DisplayFrames displayFrames) {
         if ((sysui & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) == 0) {
             return;
@@ -5629,10 +5648,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         final int type = attrs.type;
-        final int fl = PolicyControl.getWindowFlags(win, attrs);
-        final int pfl = attrs.privateFlags;
+        final int fl = getWindowFlags(win, attrs);
+        final int pfl = getPrivateWindowFlags(win, attrs);
         final int sim = attrs.softInputMode;
-        final int requestedSysUiFl = PolicyControl.getSystemUiVisibility(null, attrs);
+        final int requestedSysUiFl = getSystemUiVisibility(null, attrs);
         final int sysUiFl = requestedSysUiFl | getImpliedSysUiFlagsForLayout(attrs);
 
         final Rect pf = mTmpParentFrame;
@@ -5798,7 +5817,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         of.set(displayFrames.mUnrestricted);
                     }
 
-                    if ((fl & FLAG_FULLSCREEN) == 0) {
+                    if ((fl & FLAG_FULLSCREEN) == 0
+                            || (pfl & PRIVATE_FLAG_WAS_NOT_FULLSCREEN) != 0) {
                         if (win.isVoiceInteraction()) {
                             cf.set(displayFrames.mVoiceContent);
                         } else {
@@ -5807,6 +5827,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             } else {
                                 cf.set(displayFrames.mContent);
                             }
+
+                            applyForceImmersiveMode(pfl, cf, displayFrames);
                         }
                     } else {
                         // Full screen windows are always given a layout that is as if the status
@@ -5820,6 +5842,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     } else {
                         vf.set(cf);
                     }
+
+                    applyForceImmersiveMode(pfl, vf, displayFrames);
                 }
             } else if (layoutInScreen || (sysUiFl
                     & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
@@ -5913,6 +5937,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 } else {
                     vf.set(cf);
                 }
+
+                applyForceImmersiveMode(pfl, vf, displayFrames);
             } else if (attached != null) {
                 if (DEBUG_LAYOUT) Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle()
                         + "): attached to " + attached);
@@ -5959,6 +5985,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     } else {
                         vf.set(cf);
                     }
+
+                    applyForceImmersiveMode(pfl, vf, displayFrames);
                 }
             }
         }
@@ -6100,6 +6128,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         top += win.getGivenContentInsetsLw().top;
         displayFrames.mContent.bottom = Math.min(displayFrames.mContent.bottom, top);
         displayFrames.mVoiceContent.bottom = Math.min(displayFrames.mVoiceContent.bottom, top);
+        displayFrames.mForceImmersive.bottom = Math.min(displayFrames.mForceImmersive.bottom, top);
         top = win.getVisibleFrameLw().top;
         top += win.getGivenVisibleInsetsLw().top;
         displayFrames.mCurrent.bottom = Math.min(displayFrames.mCurrent.bottom, top);
@@ -6139,7 +6168,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         final boolean affectsSystemUi = win.canAffectSystemUiFlags();
         if (DEBUG_LAYOUT) Slog.i(TAG, "Win " + win + ": affectsSystemUi=" + affectsSystemUi);
         applyKeyguardPolicyLw(win, imeTarget);
-        final int fl = PolicyControl.getWindowFlags(win, attrs);
+        final int fl = getWindowFlags(win, attrs);
         if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi
                 && attrs.type == TYPE_INPUT_METHOD) {
             mForcingShowNavBar = true;
@@ -6381,8 +6410,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (mTopFullscreenOpaqueWindowState == null) {
             return false;
         }
-        final int fl = PolicyControl.getWindowFlags(null,
-                mTopFullscreenOpaqueWindowState.getAttrs());
+        final int fl = getWindowFlags(null, mTopFullscreenOpaqueWindowState.getAttrs());
         if (localLOGV) {
             Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw());
             Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs()
@@ -8902,11 +8930,35 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             return 0;
         }
 
-        int tmpVisibility = PolicyControl.getSystemUiVisibility(win, null)
+        int tmpVisibility = getSystemUiVisibility(win, null)
                 & ~mResettingSystemUiFlags
                 & ~mForceClearedSystemUiFlags;
+        boolean wasCleared = mClearedBecauseOfForceShow;
         if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
-            tmpVisibility &= ~PolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
+            tmpVisibility &= ~adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
+            mClearedBecauseOfForceShow = true;
+        } else {
+            mClearedBecauseOfForceShow = false;
+        }
+
+        // The window who requested navbar force showing disappeared and next window wants
+        // to hide navbar. Instead of hiding we will make it transient. SystemUI will take care
+        // about hiding after timeout. This should not happen if next window is keyguard because
+        // transient state have more priority than translucent (why?) and cause bad UX
+        if (wasCleared && !mClearedBecauseOfForceShow
+                && (tmpVisibility & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
+            mNavigationBarController.showTransient();
+            tmpVisibility |= View.NAVIGATION_BAR_TRANSIENT;
+            mWindowManagerFuncs.addSystemUIVisibilityFlag(View.NAVIGATION_BAR_TRANSIENT);
+        }
+
+        boolean topWindowWasKeyguard = mTopWindowIsKeyguard;
+        mTopWindowIsKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
+        if (topWindowWasKeyguard && !mTopWindowIsKeyguard
+                && (tmpVisibility & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0) {
+            mStatusBarController.showTransient();
+            tmpVisibility |= View.STATUS_BAR_TRANSIENT;
+            mWindowManagerFuncs.addSystemUIVisibilityFlag(View.STATUS_BAR_TRANSIENT);
         }
 
         final int fullscreenVisibility = updateLightStatusBarLw(0 /* vis */,
@@ -8957,7 +9009,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             // If the top fullscreen-or-dimming window is also the top fullscreen, respect
             // its light flag.
             vis &= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
-            vis |= PolicyControl.getSystemUiVisibility(statusColorWin, null)
+            vis |= getSystemUiVisibility(statusColorWin, null)
                     & View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
         } else if (statusColorWin != null && statusColorWin.isDimming()) {
             // Otherwise if it's dimming, clear the light flag.
@@ -8976,7 +9028,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         final boolean imeWindowCanNavColorWindow = imeWindow != null
                 && imeWindow.isVisibleLw()
                 && navBarPosition == NAV_BAR_BOTTOM
-                && (PolicyControl.getWindowFlags(imeWindow, null)
+                && (getWindowFlags(imeWindow, null)
                 & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0;
 
         if (opaque != null && opaqueOrDimming == opaque) {
@@ -8999,7 +9051,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         // The IME window and the dimming window are competing.  Check if the dimming window can be
         // IME target or not.
-        if (LayoutParams.mayUseInputMethod(PolicyControl.getWindowFlags(opaqueOrDimming, null))) {
+        if (LayoutParams.mayUseInputMethod(getWindowFlags(opaqueOrDimming, null))) {
             // The IME window is above the dimming window.
             return imeWindow;
         } else {
@@ -9016,7 +9068,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             if (navColorWin == imeWindow || navColorWin == opaque) {
                 // Respect the light flag.
                 vis &= ~View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR;
-                vis |= PolicyControl.getSystemUiVisibility(navColorWin, null)
+                vis |= getSystemUiVisibility(navColorWin, null)
                         & View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR;
             } else if (navColorWin == opaqueOrDimming && navColorWin.isDimming()) {
                 // Clear the light flag for dimming window.
@@ -9083,7 +9135,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
         final boolean hideStatusBarWM =
                 mTopFullscreenOpaqueWindowState != null
-                && (PolicyControl.getWindowFlags(mTopFullscreenOpaqueWindowState, null)
+                && (getWindowFlags(mTopFullscreenOpaqueWindowState, null)
                         & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
         final boolean hideStatusBarSysui =
                 (vis & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
@@ -9548,7 +9600,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mGlobalKeyManager.dump(prefix, pw);
         mStatusBarController.dump(pw, prefix);
         mNavigationBarController.dump(pw, prefix);
-        PolicyControl.dump(prefix, pw);
+        WindowManagerPolicyControl.dump(prefix, pw);
 
         if (mWakeGestureListener != null) {
             mWakeGestureListener.dump(pw, prefix);
@@ -9626,6 +9678,28 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
     }
 
+    private static int getSystemUiVisibility(WindowState win, LayoutParams attrs) {
+        attrs = attrs != null ? attrs : win.getAttrs();
+        int vis = win != null ? win.getSystemUiVisibility()
+                : (attrs.systemUiVisibility | attrs.subtreeSystemUiVisibility);
+        return WindowManagerPolicyControl.getSystemUiVisibility(vis, attrs);
+    }
+
+    private static int getWindowFlags(WindowState win, LayoutParams attrs) {
+        attrs = attrs != null ? attrs : win.getAttrs();
+        return WindowManagerPolicyControl.getWindowFlags(attrs.flags, attrs);
+    }
+
+    private static int getPrivateWindowFlags(WindowState win, LayoutParams attrs) {
+        attrs = attrs != null ? attrs : win.getAttrs();
+        return WindowManagerPolicyControl.getPrivateWindowFlags(attrs.privateFlags, attrs);
+    }
+
+    private static int adjustClearableFlags(WindowState win, int clearableFlags) {
+        final LayoutParams attrs = win != null ? win.getAttrs() : null;
+        return WindowManagerPolicyControl.adjustClearableFlags(attrs, clearableFlags);
+    }
+
     private static String allowAllRotationsToString(int allowAll) {
         switch (allowAll) {
             case -1:
diff --git a/services/core/java/com/android/server/policy/WindowManagerPolicy.java b/services/core/java/com/android/server/policy/WindowManagerPolicy.java
index 809cf799168..d77248bb726 100644
--- a/services/core/java/com/android/server/policy/WindowManagerPolicy.java
+++ b/services/core/java/com/android/server/policy/WindowManagerPolicy.java
@@ -626,6 +626,8 @@ public interface WindowManagerPolicy extends WindowManagerPolicyConstants {
          */
         void screenTurningOff(ScreenOffListener listener);
 
+        void addSystemUIVisibilityFlag(int flags);
+
         /**
          * Convert the lid state to a human readable format.
          */
diff --git a/services/core/java/com/android/server/wm/DisplayFrames.java b/services/core/java/com/android/server/wm/DisplayFrames.java
index dc6b49127f7..64edfef4ed8 100644
--- a/services/core/java/com/android/server/wm/DisplayFrames.java
+++ b/services/core/java/com/android/server/wm/DisplayFrames.java
@@ -75,6 +75,9 @@ public class DisplayFrames {
      */
     public final Rect mStableFullscreen = new Rect();
 
+    // For force imersive mode
+    public final Rect mForceImmersive = new Rect();
+
     /**
      * During layout, the current screen borders with all outer decoration (status bar, input method
      * dock) accounted for.
@@ -168,6 +171,7 @@ public class DisplayFrames {
         mStable.set(mUnrestricted);
         mStableFullscreen.set(mUnrestricted);
         mCurrent.set(mUnrestricted);
+        mForceImmersive.set(mUnrestricted);
 
         mDisplayCutout = mDisplayInfoCutout;
         mDisplayCutoutSafe.set(Integer.MIN_VALUE, Integer.MIN_VALUE,
diff --git a/services/core/java/com/android/server/wm/WindowManagerService.java b/services/core/java/com/android/server/wm/WindowManagerService.java
index 136ac5486f7..06907911cad 100644
--- a/services/core/java/com/android/server/wm/WindowManagerService.java
+++ b/services/core/java/com/android/server/wm/WindowManagerService.java
@@ -3218,6 +3218,11 @@ public class WindowManagerService extends IWindowManager.Stub
         return mPointerEventDispatcher != null;
     }
 
+    @Override
+    public void addSystemUIVisibilityFlag(int flags) {
+        mLastStatusBarVisibility |= flags;
+    }
+
     // Called by window manager policy. Not exposed externally.
     @Override
     public int getLidState() {
-- 
2.17.1

