From 8b98c3aca9a73d347a10e274c8e498affcc64dbe Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 6 Nov 2018 15:31:06 +0100
Subject: [PATCH 4/4] [SQUSH][DNM] Merge tag 'android-9.0.0_r16' into
 lineage-16.0

commit 81fb83be41f270d99bd623352d3646aa5a416fdd
Merge: e4fc3f7 5dfde51
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Aug 10 03:17:08 2018 +0000

    Snap for 4945494 from 5dfde51af64df333d33a9df9897ac8e05e67da63 to pi-qpr1-release

    Change-Id: Ia1c0ef9f55f4768882ee385ceaf93993dd429460

commit 5dfde51af64df333d33a9df9897ac8e05e67da63
Merge: 75057f0 fc42a10
Author: Benedict Wong <benedictwong@google.com>
Date:   Thu Aug 9 22:37:03 2018 +0000

    Merge "Set optlen for UDP-encap check in XfrmController" into pi-dev

commit e4fc3f79435029de931a0c6e6f06b5d98b84915b
Merge: cfb6044 75057f0
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Aug 3 03:06:04 2018 +0000

    Snap for 4930082 from 75057f07bd7ad967a6cb22a1225b2a2b4121b390 to pi-qpr1-release

    Change-Id: I11d01be815265300419f136698a45cd447f1f34f

commit 75057f07bd7ad967a6cb22a1225b2a2b4121b390
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Thu Jul 26 17:20:57 2018 +0900

    Avoid infinite loop in NetlinkListener.

    Currently, NetlinkListener only reads from its socket if it gets
    POLLIN. This means that if the kernel returns POLLERR without
    POLLIN, it will get into an infinite loop.

    Fix this by responding to POLLERR by issuing a recvfrom, which
    clears the socket error, and continuing. The only error we expect
    to see here is ENOBUFS, and there's nothing we can do about that.
    There is no functional change because before we'd just call
    forEachNetlinkMessage on an empty Slice, which does nothing.

    Also increase the socket buffer to 1MB to reduce the chance of
    getting ENOBUFS and thus leaking some mCookieTagMap entries. This
    buffer size is equivalent to half the buffer size of a single TCP
    socket on LTE.

    While we're at it, don't pass POLLRDHUP, POLLERR, and POLLHUP to
    poll, since these are ignored in events and are only meaningful
    in revents.

    Bug: 111479770
    Test: netd_{unit,integration}_test pass
    Test: builds, boots, cell and wifi work
    Test: stress test does not cause infinite loop in netd
    Change-Id: I847aeb9a53095c1dfdeddadcd20c0e750b6513ff

commit cfb60444a00feeae56815dd5d3cdcba891d509f8
Merge: 4cef414 f4b7b1f
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Jul 27 03:10:32 2018 +0000

    Snap for 4916303 from f4b7b1f63e6e8ed3cfeee09570709cad81419458 to pi-qpr1-release

    Change-Id: I5b83e8357bf876fe365d885054b3da05066d5fff

commit fc42a105147310bd680952d4b71fe32974bd8506
Author: Bjoern Johansson <bjoernj@google.com>
Date:   Thu Jul 19 12:30:55 2018 -0700

    Set optlen for UDP-encap check in XfrmController

    When setting the socket owner for an encap socket XfrmController will
    first attempt to verify that the socket has the UDP-encap socket option
    set. When doing so it would pass in an uninitialized optlen parameter
    which could cause the call to not modify the option value if the optlen
    happened to be too short. So for example if the stack happened to
    contain a zero where optlen was located the check would fail and the
    socket owner would not be changed.

    Fix this by setting optlen to the size of the option value parameter.

    Test: run cts -m CtsNetTestCases
    BUG: 111650288
    Change-Id: I57b6e9dba09c1acda71e3ec2084652e961667bd9

commit f4b7b1f63e6e8ed3cfeee09570709cad81419458
Author: Erik Kline <ek@google.com>
Date:   Thu Jun 14 15:16:27 2018 +0900

    Don't continuously reevaluate DNS-over-TLS unless strict mode

    This is because sending TCP SYNs and not getting any replies can trip
    the mobile data stall detector. The data stall detection mechanism
    needs to be re-evaluated, but until such time only do reevaluation
    if a network is using strict mode.

    Additionally, revalidate failed servers whenever a DNS configuration is
    pushed down to netd.

    Test: as follows
        - built, flashed, booted
        - observed tcpdump traffic in opportunistic and strict mode
        - ./system/netd/tests/runtests.sh passes
    Bug: 64133961
    Bug: 72344805
    Bug: 109928338
    Merged-In: I729bc9cd7ba6cfc088aaf0aec3e770f14d1ac10d
    Merged-In: If62c3348fe115f9791a136bf16ccf8bacccff36e
    Change-Id: I15a9c2d328fec2910e47a477cbc1dcaa5323675a

commit 4cef4147bfc1c8708c32972191690e1cd449e2e1
Author: Tyler Wear <twear@codeaurora.org>
Date:   Mon Nov 6 18:34:11 2017 -0800

    netd: Active FTP Helper

    Enable conntrack helper for active FTP connections when
    tethering is started.

    Bug:69265432
    CRs-fixed:2136660

    Test: as follows
          - Boot device - Pass
          - Start tethering - Pass
          - Start active FTP on tethered host (USB) - Pass
          - Download file over FTP - Pass
          - make -j64 netd_unit_test
                adb shell /data/nativetest64/netd_unit_test/netd_unit_test - Pass

    Change-Id: I5c812afe9602e80ea1c42d0cafba40fe6019a995

Change-Id: I95e77ce758e4ee5bedafe8863f79b18bb69ad640
---
 server/NetlinkListener.cpp      | 14 +++++++----
 server/ResolverController.cpp   | 41 +++++++++++++++++++++++----------
 server/TetherController.cpp     |  4 ++++
 server/TetherControllerTest.cpp |  8 +++++++
 server/TrafficController.cpp    | 11 +++++++++
 5 files changed, 61 insertions(+), 17 deletions(-)

diff --git a/server/NetlinkListener.cpp b/server/NetlinkListener.cpp
index 82ed6d8..38d12df 100644
--- a/server/NetlinkListener.cpp
+++ b/server/NetlinkListener.cpp
@@ -107,7 +107,7 @@ Status NetlinkListener::run() {
 
     const auto& sys = sSyscalls.get();
     const std::array<Fd, 2> fds{{{mEvent}, {mSock}}};
-    const int events = POLLIN | POLLRDHUP | POLLERR | POLLHUP;
+    const int events = POLLIN;
     const double timeout = 3600;
     while (true) {
         ASSIGN_OR_RETURN(auto revents, sys.ppoll(fds, events, timeout));
@@ -115,11 +115,15 @@ Status NetlinkListener::run() {
         if (revents[0] & POLLIN) {
             break;
         }
-        if (revents[1] & POLLIN) {
+        if (revents[1] & (POLLIN|POLLERR)) {
             auto rx = sys.recvfrom(mSock, makeSlice(rxbuf), 0);
-            if (rx.status().code() == ENOBUFS) {
-                // Ignore ENOBUFS - the socket is still usable
-                // TODO: Users other than NFLOG may need to know about this
+            int err = rx.status().code();
+            if (err) {
+                // Ignore errors. The only error we expect to see here is ENOBUFS, and there's
+                // nothing we can do about that. The recvfrom above will already have cleared the
+                // error indication and ensured we won't get EPOLLERR again.
+                // TODO: Consider using NETLINK_NO_ENOBUFS.
+                ALOGE("Failed to read from netlink socket: %s", strerror(err));
                 continue;
             }
             forEachNetlinkMessage(rx.value(), rxHandler);
diff --git a/server/ResolverController.cpp b/server/ResolverController.cpp
index f8e1fb3..0812e7a 100644
--- a/server/ResolverController.cpp
+++ b/server/ResolverController.cpp
@@ -168,9 +168,7 @@ class PrivateDnsConfiguration {
 
         // Add any new or changed servers to the tracker, and initiate async checks for them.
         for (const auto& server : tlsServers) {
-            // Don't probe a server more than once.  This means that the only way to
-            // re-check a failed server is to remove it and re-add it from the netId.
-            if (tracker.count(server) == 0) {
+            if (needsValidation(tracker, server)) {
                 validatePrivateDnsProvider(server, tracker, netId);
             }
         }
@@ -305,7 +303,15 @@ class PrivateDnsConfiguration {
             return DONT_REEVALUATE;
         }
 
-        bool reevaluationStatus = success ? DONT_REEVALUATE : NEEDS_REEVALUATION;
+        const auto mode = mPrivateDnsModes.find(netId);
+        if (mode == mPrivateDnsModes.end()) {
+            ALOGW("netId %u has no private DNS validation mode", netId);
+            return DONT_REEVALUATE;
+        }
+        const bool modeDoesReevaluation = (mode->second == PrivateDnsMode::STRICT);
+
+        bool reevaluationStatus = (success || !modeDoesReevaluation)
+                ? DONT_REEVALUATE : NEEDS_REEVALUATION;
 
         auto& tracker = netPair->second;
         auto serverPair = tracker.find(server);
@@ -348,9 +354,10 @@ class PrivateDnsConfiguration {
             }
         } else {
             // Validation failure is expected if a user is on a captive portal.
-            // TODO: Trigger a second validation attempt after captive portal login
-            // succeeds.
-            tracker[server] = Validation::fail;
+            // A second validation attempt is triggered in opportunistic mode
+            // by the framework after captive portal login succeeds.
+            tracker[server] = (reevaluationStatus == NEEDS_REEVALUATION)
+                    ? Validation::in_process : Validation::fail;
             if (DBG) {
                 ALOGD("Validation failed for %s!", addrToString(&(server.ss)).c_str());
             }
@@ -359,6 +366,16 @@ class PrivateDnsConfiguration {
         return reevaluationStatus;
     }
 
+
+    // Start validation for newly added servers as well as any servers that have
+    // landed in Validation::fail state. Note that servers that have failed
+    // multiple validation attempts but for which there is still a validating
+    // thread running are marked as being Validation::in_process.
+    static bool needsValidation(const PrivateDnsTracker& tracker, const DnsTlsServer& server) {
+        const auto& iter = tracker.find(server);
+        return (iter == tracker.end()) || (iter->second == Validation::fail);
+    }
+
     EventReporter mEventReporter;
 
     std::mutex mPrivateDnsLock;
@@ -368,7 +385,7 @@ class PrivateDnsConfiguration {
     std::map<unsigned, PrivateDnsTracker> mPrivateDnsTransports GUARDED_BY(mPrivateDnsLock);
     android::sp<android::net::metrics::INetdEventListener>
             mNetdEventListener GUARDED_BY(mPrivateDnsLock);
-} privateDnsConfiguration;
+} sPrivateDnsConfiguration;
 
 }  // namespace
 
@@ -382,7 +399,7 @@ int ResolverController::setDnsServers(unsigned netId, const char* searchDomains,
 
 ResolverController::PrivateDnsStatus
 ResolverController::getPrivateDnsStatus(unsigned netId) const {
-    return privateDnsConfiguration.getStatus(netId);
+    return sPrivateDnsConfiguration.getStatus(netId);
 }
 
 int ResolverController::clearDnsServers(unsigned netId) {
@@ -390,7 +407,7 @@ int ResolverController::clearDnsServers(unsigned netId) {
     if (DBG) {
         ALOGD("clearDnsServers netId = %u\n", netId);
     }
-    privateDnsConfiguration.clear(netId);
+    sPrivateDnsConfiguration.clear(netId);
     return 0;
 }
 
@@ -486,7 +503,7 @@ int ResolverController::setResolverConfiguration(int32_t netId,
         return -EINVAL;
     }
 
-    const int err = privateDnsConfiguration.set(netId, tlsServers, tlsName, tlsFingerprints);
+    const int err = sPrivateDnsConfiguration.set(netId, tlsServers, tlsName, tlsFingerprints);
     if (err != 0) {
         return err;
     }
@@ -590,7 +607,7 @@ void ResolverController::dump(DumpWriter& dw, unsigned netId) {
                     static_cast<unsigned>(params.max_samples));
         }
 
-        privateDnsConfiguration.dump(dw, netId);
+        sPrivateDnsConfiguration.dump(dw, netId);
     }
     dw.decIndent();
 }
diff --git a/server/TetherController.cpp b/server/TetherController.cpp
index af8f3e1..bec8b10 100644
--- a/server/TetherController.cpp
+++ b/server/TetherController.cpp
@@ -638,6 +638,10 @@ int TetherController::setForwardRules(bool add, const char *intIface, const char
     }
 
     std::vector<std::string> v4 = {
+        "*raw",
+        StringPrintf("%s %s -p tcp --dport 21 -i %s -j CT --helper ftp",
+                     op, LOCAL_RAW_PREROUTING, intIface),
+        "COMMIT",
         "*filter",
         StringPrintf("%s %s -i %s -o %s -m state --state ESTABLISHED,RELATED -g %s",
                      op, LOCAL_FORWARD, extIface, intIface, LOCAL_TETHER_COUNTERS_CHAIN),
diff --git a/server/TetherControllerTest.cpp b/server/TetherControllerTest.cpp
index bcdb106..6e77bfe 100644
--- a/server/TetherControllerTest.cpp
+++ b/server/TetherControllerTest.cpp
@@ -127,6 +127,10 @@ protected:
             "COMMIT\n", intIf);
 
         std::vector<std::string> v4Cmds = {
+            "*raw",
+            StringPrintf("-A tetherctrl_raw_PREROUTING -p tcp --dport 21 -i %s -j CT --helper ftp",
+                         intIf),
+            "COMMIT",
             "*filter",
             StringPrintf("-A tetherctrl_FORWARD -i %s -o %s -m state --state"
                          " ESTABLISHED,RELATED -g tetherctrl_counters", extIf, intIf),
@@ -195,6 +199,10 @@ protected:
             "COMMIT\n", intIf);
 
         std::vector<std::string> v4Cmds = {
+            "*raw",
+            StringPrintf("-D tetherctrl_raw_PREROUTING -p tcp --dport 21 -i %s -j CT --helper ftp",
+                         intIf),
+            "COMMIT",
             "*filter",
             StringPrintf("-D tetherctrl_FORWARD -i %s -o %s -m state --state"
                          " ESTABLISHED,RELATED -g tetherctrl_counters", extIf, intIf),
diff --git a/server/TrafficController.cpp b/server/TrafficController.cpp
index d6a6480..0268f9b 100644
--- a/server/TrafficController.cpp
+++ b/server/TrafficController.cpp
@@ -80,6 +80,17 @@ StatusOr<std::unique_ptr<NetlinkListenerInterface>> makeSkDestroyListener() {
     const int protocol = NETLINK_INET_DIAG;
     ASSIGN_OR_RETURN(auto sock, sys.socket(domain, type, protocol));
 
+    // TODO: if too many sockets are closed too quickly, we can overflow the socket buffer, and
+    // some entries in mCookieTagMap will not be freed. In order to fix this we would need to
+    // periodically dump all sockets and remove the tag entries for sockets that have been closed.
+    // For now, set a large-enough buffer that we can close hundreds of sockets without getting
+    // ENOBUFS and leaking mCookieTagMap entries.
+    int rcvbuf = 512 * 1024;
+    auto ret = sys.setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));
+    if (!ret.ok()) {
+        ALOGW("Failed to set SkDestroyListener buffer size to %d: %s", rcvbuf, ret.msg().c_str());
+    }
+
     sockaddr_nl addr = {
         .nl_family = AF_NETLINK,
         .nl_groups = 1 << (SKNLGRP_INET_TCP_DESTROY - 1) | 1 << (SKNLGRP_INET_UDP_DESTROY - 1) |
-- 
2.17.1

