From 3e10f186348a04c81f6aebe0c314565f4db0124d Mon Sep 17 00:00:00 2001
From: Steve Kondik <shade@chemlab.org>
Date: Wed, 28 Aug 2013 14:21:49 +0800
Subject: [PATCH 079/173] camera: Touch focus support for camcorder

Author: Steve Kondik <shade@chemlab.org>
Date:   Wed Aug 28 14:21:49 2013 +0800

    camera: Touch focus support for camcorder

     * Available when video snapshots are not supported.
     * Original from CodeAurora Forum.

    Change-Id: I232c178430db08e7366aa9f91b4926d07e7c225d

Author: Dheeraj CVR <cvr.dheeraj@gmail.com>
Date:   Sat Apr 19 02:33:46 2014 +0530

    Camera2: Prevent autofocus when video snapshot is in progress

    During video recording if screen is tapped repeatedly, autofocus is
    started while the snapshot is taken. This would either result in an
    out of focus snapshot which would also disturb the focus in the recorded
    video or crash the sensors that can't handle autofocus during snapshot.

    Change-Id: If2763094f5ab7536e4409469276de54580e803c8

Author: Dheeraj CVR <cvr.dheeraj@gmail.com>
Date:   Mon Jun 23 22:00:07 2014 +0530

    Camera2: Prevent propogating CancelAutoFocus during Video Recording

    When AutoFocus is started during Video Recording, CancelAutoFocus
    is called after KEY_FOCUS_TIME seconds. CancelAutoFocus has the
    side effect of resetting the sensor AF position and will result in
    instant loss of focus which is not a desired event when AF is
    manually triggered in case of Video Recording.

    Change-Id: Icee7f6dfd4ad083c9b383ee2a4df6a34e4668de6

Author: lion0738 <lion0738@naver.com>
Date:   Sun Jan 10 16:55:01 2016 +0900

    Snap: Set parameters before starting preview

    Old parameters are used when grabbing focus mode.
    Camera parameters should be set to FocusOverlayManager before starting preview.

    Change-Id: I908559e1c2003be47b486996b0ec016b78107468

Change-Id: I8be16315ccede388e590e81e93f0dd417ae51c4a
---
 res/values/arrays.xml                       |   5 +
 src/com/android/camera/VideoController.java |   2 +
 src/com/android/camera/VideoModule.java     | 135 ++++++++++++++++++--
 src/com/android/camera/VideoUI.java         |  46 ++++++-
 4 files changed, 179 insertions(+), 9 deletions(-)

diff --git a/res/values/arrays.xml b/res/values/arrays.xml
index 2a39275d4..445aa1ec1 100644
--- a/res/values/arrays.xml
+++ b/res/values/arrays.xml
@@ -655,6 +655,11 @@
         <item>auto</item>
     </string-array>
 
+    <string-array name="pref_video_focusmode_default_array" translatable="false">
+        <item>continuous-video</item>
+        <item>auto</item>
+    </string-array>
+
     <!-- Icons for exposure compensation -->
     <array name="pref_camera_exposure_icons" translatable="false">
         <item>@drawable/ic_exposure_n3</item>
diff --git a/src/com/android/camera/VideoController.java b/src/com/android/camera/VideoController.java
index cf694a391..a5b92c1f4 100644
--- a/src/com/android/camera/VideoController.java
+++ b/src/com/android/camera/VideoController.java
@@ -40,4 +40,6 @@ public interface VideoController extends OnShutterButtonListener, OnPauseButtonL
     // Callbacks for camera preview UI events.
     public void onPreviewUIReady();
     public void onPreviewUIDestroyed();
+
+    public void onScreenSizeChanged(int width, int height);
 }
diff --git a/src/com/android/camera/VideoModule.java b/src/com/android/camera/VideoModule.java
index 3c6228c1c..0119138fb 100644
--- a/src/com/android/camera/VideoModule.java
+++ b/src/com/android/camera/VideoModule.java
@@ -61,6 +61,7 @@ import android.widget.Toast;
 import android.media.EncoderCapabilities;
 import android.media.EncoderCapabilities.VideoEncoderCap;
 
+import com.android.camera.CameraManager.CameraAFCallback;
 import com.android.camera.CameraManager.CameraPictureCallback;
 import com.android.camera.CameraManager.CameraProxy;
 import com.android.camera.app.OrientationManager;
@@ -89,6 +90,7 @@ import java.util.regex.Pattern;
 
 public class VideoModule implements CameraModule,
     VideoController,
+    FocusOverlayManager.Listener,
     CameraPreference.OnPreferenceChangedListener,
     ShutterButton.OnShutterButtonListener,
     LocationManager.Listener,
@@ -125,6 +127,8 @@ public class VideoModule implements CameraModule,
     private boolean mPaused;
     private int mCameraId;
     private Parameters mParameters;
+    private boolean mFocusAreaSupported;
+    private boolean mMeteringAreaSupported;
 
     private boolean mIsInReviewMode;
     private boolean mSnapshotInProgress = false;
@@ -184,6 +188,12 @@ public class VideoModule implements CameraModule,
     private int mDesiredPreviewHeight;
     private ContentResolver mContentResolver;
 
+    private final AutoFocusCallback mAutoFocusCallback =
+            new AutoFocusCallback();
+
+    // This handles everything about focus.
+    private FocusOverlayManager mFocusManager;
+
     private LocationManager mLocationManager;
     private OrientationManager mOrientationManager;
     private int mPendingSwitchCameraId;
@@ -272,6 +282,7 @@ public class VideoModule implements CameraModule,
         @Override
         public void run() {
             openCamera();
+            if (mFocusManager == null) initializeFocusManager();
         }
     }
 
@@ -286,6 +297,7 @@ public class VideoModule implements CameraModule,
             return;
         }
         mParameters = mCameraDevice.getParameters();
+        initializeCapabilities();
         mPreviewFocused = arePreviewControlsVisible();
     }
 
@@ -365,6 +377,10 @@ public class VideoModule implements CameraModule,
     private boolean mUnsupportedHFRVideoCodec = false;
     boolean mUnsupportedProfile = false;
 
+    public void onScreenSizeChanged(int width, int height) {
+        if (mFocusManager != null) mFocusManager.setPreviewSize(width, height);
+    }
+
     // This Handler is used to post message back onto the main thread of the
     // application
     private class MainHandler extends Handler {
@@ -575,6 +591,36 @@ public class VideoModule implements CameraModule,
         mLocationManager.recordLocation(enable);
      }
 
+    @Override
+    public void autoFocus() {
+        Log.e(TAG, "start autoFocus.");
+        mCameraDevice.autoFocus(mHandler, mAutoFocusCallback);
+    }
+
+    @Override
+    public void cancelAutoFocus() {
+        if (null != mCameraDevice) {
+            setFocusParameters();
+        }
+    }
+
+    @Override
+    public boolean capture() {
+       return true;
+    }
+
+    @Override
+    public void setFocusParameters() {
+        if (mFocusAreaSupported)
+            mParameters.setFocusAreas(mFocusManager.getFocusAreas());
+        if (mMeteringAreaSupported)
+            mParameters.setMeteringAreas(mFocusManager.getMeteringAreas());
+        if (mFocusAreaSupported || mMeteringAreaSupported) {
+            mParameters.setFocusMode(mFocusManager.getFocusMode());
+            mCameraDevice.setParameters(mParameters);
+        }
+    }
+
     @Override
     public void setPreferenceForTest(String key, String value) {
         mUI.setPreference(key, value);
@@ -586,18 +632,29 @@ public class VideoModule implements CameraModule,
     @Override
     public void onSingleTapUp(View view, int x, int y) {
         if (mMediaRecorderPausing) return;
-        takeASnapshot();
+        boolean snapped = takeASnapshot();
+        if (!snapped) {
+            // Do not trigger touch focus if popup window is opened.
+            if (mUI.removeTopLevelPopup()) {
+                return;
+            }
+
+            // Check if metering area or focus area is supported.
+            if ((mFocusAreaSupported || mMeteringAreaSupported) && !mSnapshotInProgress) {
+                mFocusManager.onSingleTapUp(x, y);
+            }
+        }
     }
 
-    private void takeASnapshot() {
+    private boolean takeASnapshot() {
         // Only take snapshots if video snapshot is supported by device
         if (CameraUtil.isVideoSnapshotSupported(mParameters) && !mIsVideoCaptureIntent) {
             if (!mMediaRecorderRecording || mPaused || mSnapshotInProgress) {
-                return;
+                return false;
             }
             MediaSaveService s = mActivity.getMediaSaveService();
             if (s == null || s.isQueueFull()) {
-                return;
+                return false;
             }
 
             // Set rotation and gps data.
@@ -615,7 +672,10 @@ public class VideoModule implements CameraModule,
             mSnapshotInProgress = true;
             UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
                     UsageStatistics.ACTION_CAPTURE_DONE, "VideoSnapshot");
+
+            return true;
         }
+        return false;
     }
 
     @Override
@@ -873,6 +933,19 @@ public class VideoModule implements CameraModule,
         }
    }
 
+    private final class AutoFocusCallback
+            implements CameraAFCallback {
+        @Override
+        public void onAutoFocus(
+                boolean focused, CameraProxy camera) {
+            Log.v(TAG, "AutoFocusCallback, mPaused=" + mPaused);
+            if (mPaused) return;
+
+            //setCameraState(IDLE);
+            mFocusManager.onAutoFocus(focused, false);
+        }
+    }
+
     private void readVideoPreferences() {
         // The preference stores values from ListPreference and is thus string type for all values.
         // We need to convert it to int manually.
@@ -1196,6 +1269,9 @@ public class VideoModule implements CameraModule,
     private void setDisplayOrientation() {
         mDisplayRotation = CameraUtil.getDisplayRotation(mActivity);
         mCameraDisplayOrientation = CameraUtil.getDisplayOrientation(mDisplayRotation, mCameraId);
+        if (mFocusManager != null) {
+            mFocusManager.setDisplayOrientation(mCameraDisplayOrientation);
+        }
         mUI.setDisplayOrientation(mCameraDisplayOrientation);
         // Change the camera display orientation
         if (mCameraDevice != null) {
@@ -1264,6 +1340,8 @@ public class VideoModule implements CameraModule,
             throw new RuntimeException("startPreview failed", ex);
         }
         mStartPrevPending = false;
+
+        mFocusManager.onPreviewStarted();
     }
 
     private void onPreviewStarted() {
@@ -1275,6 +1353,8 @@ public class VideoModule implements CameraModule,
     public void stopPreview() {
         mStopPrevPending = true;
 
+        if (mFocusManager != null) mFocusManager.onPreviewStopped();
+
         if (!mPreviewing) {
             mStopPrevPending = false;
             return;
@@ -1303,6 +1383,7 @@ public class VideoModule implements CameraModule,
         mCameraDevice = null;
         mPreviewing = false;
         mSnapshotInProgress = false;
+        mFocusManager.onCameraReleased();
         mPreviewFocused = false;
         mFaceDetectionStarted = false;
     }
@@ -1360,6 +1441,28 @@ public class VideoModule implements CameraModule,
 
     @Override
     public void onPauseAfterSuper() {
+        if (mFocusManager != null) mFocusManager.removeMessages();
+    }
+
+    /**
+     * The focus manager is the first UI related element to get initialized,
+     * and it requires the RenderOverlay, so initialize it here
+     */
+    private void initializeFocusManager() {
+        // Create FocusManager object. startPreview needs it.
+        // if mFocusManager not null, reuse it
+        // otherwise create a new instance
+        if (mFocusManager != null) {
+            mFocusManager.removeMessages();
+        } else {
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            boolean mirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
+            String[] defaultFocusModes = mActivity.getResources().getStringArray(
+                    R.array.pref_video_focusmode_default_array);
+            mFocusManager = new FocusOverlayManager(mPreferences, defaultFocusModes,
+                    mParameters, this, mirror,
+                    mActivity.getMainLooper(), mUI);
+        }
     }
 
     @Override
@@ -1493,6 +1596,7 @@ public class VideoModule implements CameraModule,
     }
 
     private void setupMediaRecorderPreviewDisplay() {
+        mFocusManager.resetTouchFocus();
         // Nothing to do here if using SurfaceTexture.
         if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
             // We stop the preview here before unlocking the device because we
@@ -2797,10 +2901,8 @@ public class VideoModule implements CameraModule,
         }
 
         // Set continuous autofocus.
-        List<String> supportedFocus = mParameters.getSupportedFocusModes();
-        if (isSupported(Parameters.FOCUS_MODE_CONTINUOUS_VIDEO, supportedFocus)) {
-            mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);
-        }
+        // Set focus mode
+        mParameters.setFocusMode(mFocusManager.getFocusMode());
 
         mParameters.set(CameraUtil.RECORDING_HINT, CameraUtil.TRUE);
 
@@ -2875,6 +2977,8 @@ public class VideoModule implements CameraModule,
 
         // Update UI based on the new parameters.
         mUI.updateOnScreenIndicators(mParameters, mPreferences);
+
+        mFocusManager.setPreviewSize(videoWidth, videoHeight);
     }
 
     @Override
@@ -2976,10 +3080,18 @@ public class VideoModule implements CameraModule,
 
         closeCamera();
         mUI.collapseCameraControls();
+        if (mFocusManager != null) mFocusManager.removeMessages();
         // Restart the camera and initialize the UI. From onCreate.
         mPreferences.setLocalId(mActivity, mCameraId);
         CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
         openCamera();
+
+        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+        boolean mirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
+        mParameters = mCameraDevice.getParameters();
+        mFocusManager.setMirror(mirror);
+        mFocusManager.setParameters(mParameters);
+
         readVideoPreferences();
         mUI.applySurfaceChange(VideoUI.SURFACE_STATUS.SURFACE_VIEW);
         startPreview();
@@ -2987,6 +3099,8 @@ public class VideoModule implements CameraModule,
         resizeForPreviewAspectRatio();
         initializeVideoControl();
 
+        initializeCapabilities();
+
         // From onResume
         mZoomValue = 0;
         mUI.initializeZoom(mParameters);
@@ -3001,6 +3115,11 @@ public class VideoModule implements CameraModule,
         mUI.showTimeLapseUI(mCaptureTimeLapse);
     }
 
+    private void initializeCapabilities() {
+        mFocusAreaSupported = CameraUtil.isFocusAreaSupported(mParameters);
+        mMeteringAreaSupported = CameraUtil.isMeteringAreaSupported(mParameters);
+    }
+
     // Preview texture has been copied. Now camera can be released and the
     // animation can be started.
     @Override
diff --git a/src/com/android/camera/VideoUI.java b/src/com/android/camera/VideoUI.java
index bf5e4ffc6..4bd38bbbe 100755
--- a/src/com/android/camera/VideoUI.java
+++ b/src/com/android/camera/VideoUI.java
@@ -44,14 +44,17 @@ import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.PopupWindow;
 import android.widget.TextView;
+import android.view.View.OnLayoutChangeListener;
 
 import com.android.camera.CameraManager.CameraProxy;
 import com.android.camera.CameraPreference.OnPreferenceChangedListener;
+import com.android.camera.FocusOverlayManager.FocusUI;
 import com.android.camera.PhotoUI.SurfaceTextureSizeChangedListener;
 import com.android.camera.ui.AbstractSettingPopup;
 import com.android.camera.ui.CameraControls;
 import com.android.camera.ui.CameraRootView;
 import com.android.camera.ui.FaceView;
+import com.android.camera.ui.FocusIndicator;
 import com.android.camera.ui.ListSubMenu;
 import com.android.camera.ui.ModuleSwitcher;
 import com.android.camera.ui.PieRenderer;
@@ -65,6 +68,7 @@ import com.android.camera.util.CameraUtil;
 public class VideoUI implements PieRenderer.PieListener,
         PreviewGestures.SingleTapListener,
         CameraRootView.MyDisplayListener,
+        FocusUI,
         SurfaceHolder.Callback,
         PauseButton.OnPauseButtonListener,
         CameraManager.CameraFaceDetectionCallback{
@@ -398,7 +402,7 @@ public class VideoUI implements PieRenderer.PieListener,
     private void layoutPreview(float ratio) {
         FrameLayout.LayoutParams lp = null;
 
-        float scaledTextureWidth, scaledTextureHeight;
+        float scaledTextureWidth = 0.0f, scaledTextureHeight = 0.0f;
         int rotation = CameraUtil.getDisplayRotation(mActivity);
         if (!CameraUtil.isDefaultToPortrait(mActivity)) {
             rotation = (rotation - 90) % 360;
@@ -504,6 +508,10 @@ public class VideoUI implements PieRenderer.PieListener,
 
         }
 
+        if (scaledTextureWidth > 0 && scaledTextureHeight > 0) {
+            mController.onScreenSizeChanged((int) scaledTextureWidth,
+                    (int) scaledTextureHeight);
+        }
     }
 
     /**
@@ -1281,4 +1289,40 @@ public class VideoUI implements PieRenderer.PieListener,
             mFaceView.clear();
         }
     }
+
+    // implement focusUI interface
+    private FocusIndicator getFocusIndicator() {
+        return mPieRenderer;
+    }
+
+    @Override
+    public boolean hasFaces() {
+        return false;
+    }
+
+    @Override
+    public void clearFocus() {
+        FocusIndicator indicator = getFocusIndicator();
+        if (indicator != null) indicator.clear();
+    }
+
+    @Override
+    public void setFocusPosition(int x, int y) {
+        mPieRenderer.setFocus(x, y);
+    }
+
+    @Override
+    public void onFocusStarted(){
+        getFocusIndicator().showStart();
+    }
+
+    @Override
+    public void onFocusSucceeded(boolean timeOut) {
+        getFocusIndicator().showSuccess(timeOut);
+    }
+
+    @Override
+    public void onFocusFailed(boolean timeOut) {
+        getFocusIndicator().showFail(timeOut);
+    }
 }
-- 
2.17.1

