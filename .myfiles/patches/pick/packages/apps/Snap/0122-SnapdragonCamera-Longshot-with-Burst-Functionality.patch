From 223793a69c07940784e118b312a7a12baa370ed9 Mon Sep 17 00:00:00 2001
From: Vijay kumar Tumati <vtumati@codeaurora.org>
Date: Mon, 13 Apr 2015 15:36:33 +0530
Subject: [PATCH 122/173] SnapdragonCamera: Longshot with Burst Functionality.

This is a new Longshot feature where in the snapshot frames
captured at ISP is @ 3fps and output JPEG encoded rate is @ 1.2 fps.

This can be enabled by setting following setprop with
the maximum number of snapshots.
adb shell setprop persist.camera.longshot.max <max_number>
e.g.:adb shell setprop persist.camera.longshot.max 10
If the number is -1, then the existing Longshot will be used.

Main changes:
1) The number of Snapshot/Preview/Metadata buffers are increased to
make sure no frames will be dropped @ ISP and to maintain burst fps.
e.g.: For max number of 10 snapshots, Snapshot buffers are increased to 9
from existing 6.
This buffer numbers are derived considering snapshot YUV frames @ 3 fps
and JPEG encoding @ 1.2 fps.
2) Shutter will be played after receiving YUV frame instead of reprocess frame.
3) New Longshot stop command is sent after receiving all the required YUV
callbacks or releasing the shutter before reaching Max number.
4) Existing Longshot off command is sent after receiving all JPEG CB.s for the issued
TakePictures() and also shutter button will be disabled until all the JPEG
callbacks are received.

Change-Id: Id0c21aeb67245530768bf3ab859d39dea7e2bc40
---
 .../camera/AndroidCameraManagerImpl.java      | 10 +++
 src/com/android/camera/CameraManager.java     |  5 ++
 src/com/android/camera/PhotoModule.java       | 62 +++++++++++++------
 .../snapcam/wrapper/CameraWrapper.java        | 17 +++++
 4 files changed, 75 insertions(+), 19 deletions(-)

diff --git a/src/com/android/camera/AndroidCameraManagerImpl.java b/src/com/android/camera/AndroidCameraManagerImpl.java
index f2cb69f67..b7288db63 100644
--- a/src/com/android/camera/AndroidCameraManagerImpl.java
+++ b/src/com/android/camera/AndroidCameraManagerImpl.java
@@ -103,6 +103,7 @@ class AndroidCameraManagerImpl implements CameraManager {
     private static final int SEND_HISTOGRAM_DATA =   602;
     //LONGSHOT
     private static final int SET_LONGSHOT = 701;
+    private static final int STOP_LONGSHOT = 702;
     private static final int SET_AUTO_HDR_MODE = 801;
 
     //HAL1 version code
@@ -425,6 +426,10 @@ class AndroidCameraManagerImpl implements CameraManager {
                         CameraWrapper.setLongshot(mCamera, (Boolean) msg.obj);
                         break;
 
+                    case STOP_LONGSHOT:
+                        CameraWrapper.stopLongshot(mCamera);
+                        break;
+
                     case SET_AUTO_HDR_MODE:
                         CameraWrapper.setMetadataCb(mCamera, (CameraMetaDataCallback) msg.obj);
                         break;
@@ -685,6 +690,11 @@ class AndroidCameraManagerImpl implements CameraManager {
                     new Boolean(enable)).sendToTarget();
         }
 
+        @Override
+        public void stopLongshot() {
+            mCameraHandler.sendEmptyMessage(STOP_LONGSHOT);
+        }
+
         @Override
         public void setHistogramMode(CameraDataCallback cb) {
             mCameraHandler.obtainMessage(SET_HISTOGRAM_MODE, cb).sendToTarget();
diff --git a/src/com/android/camera/CameraManager.java b/src/com/android/camera/CameraManager.java
index b93e7182b..2aeba7c5d 100644
--- a/src/com/android/camera/CameraManager.java
+++ b/src/com/android/camera/CameraManager.java
@@ -384,5 +384,10 @@ public interface CameraManager {
          *                 {@code false} to disable it.
         */
         public void setLongshot(boolean enable);
+        /**
+         * Stop longshot.
+         *
+        */
+        public void stopLongshot();
     }
 }
diff --git a/src/com/android/camera/PhotoModule.java b/src/com/android/camera/PhotoModule.java
index cb5af750c..68a0d9d4b 100644
--- a/src/com/android/camera/PhotoModule.java
+++ b/src/com/android/camera/PhotoModule.java
@@ -135,6 +135,7 @@ public class PhotoModule
     private int mSnapshotMode;
     private int mBurstSnapNum = 1;
     private int mReceivedSnapNum = 0;
+    private int mLongshotSnapNum = 0;
     public boolean mFaceDetectionEnabled = false;
     private boolean mLgeHdrMode = false;
     private DrawAutoHDR mDrawAutoHDR;
@@ -223,6 +224,9 @@ public class PhotoModule
 
     private static final boolean PERSIST_SKIP_MEM_CHECK = PersistUtil.isSkipMemoryCheckEnabled();
 
+    private static final String PERSIST_LONGSHOT_MAX_SNAP = "persist.camera.longshot.max";
+    private static int mLongShotMaxSnap = -1;
+
     // Constant from android.hardware.Camera.Parameters
     private static final String KEY_PICTURE_FORMAT = "picture-format";
     private SeekBar mBlurDegreeProgressBar;
@@ -1078,8 +1082,17 @@ public class PhotoModule
             Log.e(TAG, "[KPI Perf] PROFILE_SHUTTER_LAG mShutterLag = " + mShutterLag + "ms");
             synchronized(mCameraDevice) {
 
+                if (++mLongshotSnapNum >= mLongShotMaxSnap &&
+                    (mLongShotMaxSnap != -1)) {
+                    mLongshotActive = false;
+                    mUI.enableShutter(false);
+                    mCameraDevice.stopLongshot();
+                    return;
+                }
+
                 if (mCameraState != LONGSHOT ||
                     !mLongshotActive) {
+                    mCameraDevice.stopLongshot();
                     return;
                 }
 
@@ -1328,7 +1341,9 @@ public class PhotoModule
             String focusMode;
 
             mUI.stopSelfieFlash();
-            mUI.enableShutter(true);
+            if (mCameraState != LONGSHOT) {
+                mUI.enableShutter(true);
+            }
             if (mUI.isPreviewCoverVisible()) {
                  // When take picture request is sent before starting preview, onPreviewFrame()
                  // callback doesn't happen so removing preview cover here, instead.
@@ -1391,14 +1406,19 @@ public class PhotoModule
             Log.v(TAG, "mPictureDisplayedToJpegCallbackTime = "
                     + mPictureDisplayedToJpegCallbackTime + "ms");
 
+            if (isLongshotDone()) {
+                mCameraDevice.setLongshot(false);
+            }
+
             mFocusManager.updateFocusUI(); // Ensure focus indicator is hidden.
 
             boolean needRestartPreview = !mIsImageCaptureIntent
                     && !mPreviewRestartSupport
                     && (mCameraState != LONGSHOT)
                     && (mSnapshotMode != CameraInfoWrapper.CAMERA_SUPPORT_MODE_ZSL)
-                    && (mReceivedSnapNum == mBurstSnapNum);
+                    && ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT));
 
+            needRestartPreview |= (isLongshotDone() && !mFocusManager.isZslEnabled());
             needRestartPreview |= mLgeHdrMode && (mCameraState != LONGSHOT);
 
             CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
@@ -1433,8 +1453,8 @@ public class PhotoModule
                         CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(focusMode)) {
                     mCameraDevice.cancelAutoFocus();
                 }
-            } else if ((mReceivedSnapNum == mBurstSnapNum)
-                        && (mCameraState != LONGSHOT)){
+            } else if (((mCameraState != LONGSHOT) && (mReceivedSnapNum == mBurstSnapNum))
+                        || isLongshotDone()){
                 mFocusManager.restartTouchFocusTimer();
                 focusMode = mFocusManager.getFocusMode(false);
                 if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(focusMode) ||
@@ -1538,7 +1558,8 @@ public class PhotoModule
                             }
                         }
                         // Animate capture with real jpeg data instead of a preview frame.
-                        if (mCameraState != LONGSHOT) {
+                        if ((mCameraState != LONGSHOT) ||
+                            isLongshotDone()) {
                             Size pic_size = mParameters.getPictureSize();
                             if ((pic_size.width <= 352) && (pic_size.height<= 288)) {
                                 mUI.setDownFactor(2); //Downsample by 2 for CIF & below
@@ -1585,6 +1606,10 @@ public class PhotoModule
                         mJpegPictureCallbackTime = 0;
                     }
 
+                    if (isLongshotDone()) {
+                        mLongshotSnapNum = 0;
+                    }
+
                     if (mHiston && (mSnapshotMode ==CameraInfoWrapper.CAMERA_SUPPORT_MODE_ZSL)) {
                         mActivity.runOnUiThread(new Runnable() {
                         public void run() {
@@ -1751,6 +1776,7 @@ public class PhotoModule
         }
 
         if (mCameraState == LONGSHOT) {
+            mLongshotSnapNum = 0;
             mCameraDevice.setLongshot(true);
         }
 
@@ -2381,20 +2407,7 @@ public class PhotoModule
         synchronized(mCameraDevice) {
            if (mCameraState == LONGSHOT) {
                mLongshotActive = false;
-               mCameraDevice.setLongshot(false);
-               mUI.animateCapture(mLastJpegData);
-               mLastJpegData = null;
-               if (!mFocusManager.isZslEnabled()) {
-                   setupPreview();
-               } else {
-                   setCameraState(IDLE);
-                   mFocusManager.resetTouchFocus();
-                   if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(
-                           mFocusManager.getFocusMode(false))) {
-                       mCameraDevice.cancelAutoFocus();
-                   }
-                   mUI.resumeFaceDetection();
-               }
+               mUI.enableShutter(false);
            }
         }
 
@@ -3099,6 +3112,10 @@ public class PhotoModule
     @Override
     public void stopPreview() {
         if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
+            if (mCameraState == LONGSHOT) {
+                mCameraDevice.setLongshot(false);
+                mLongshotActive = false;
+            }
             Log.v(TAG, "stopPreview");
             mCameraDevice.stopPreview();
         }
@@ -3843,6 +3860,9 @@ public class PhotoModule
         mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE, bokehBlurDegree);
         Log.v(TAG, "Bokeh Mode = " + bokehMode + " bokehMpo = " + bokehMpo +
                 " bokehBlurDegree = " + bokehBlurDegree);
+
+        mLongShotMaxSnap = SystemProperties.getInt(PERSIST_LONGSHOT_MAX_SNAP, -1);
+        mParameters.set("max-longshot-snap",mLongShotMaxSnap);
     }
 
     private int estimateJpegFileSize(final Size size, final String quality) {
@@ -5305,6 +5325,10 @@ public class PhotoModule
         enableRecordingLocation(false);
     }
 
+    public boolean isLongshotDone() {
+        return ((mCameraState == LONGSHOT) && (mLongshotSnapNum == mReceivedSnapNum) &&
+                !mLongshotActive);
+    }
 }
 
 /* Below is no longer needed, except to get rid of compile error
diff --git a/src_wrapper/org/codeaurora/snapcam/wrapper/CameraWrapper.java b/src_wrapper/org/codeaurora/snapcam/wrapper/CameraWrapper.java
index 6739686e9..bbde33af2 100644
--- a/src_wrapper/org/codeaurora/snapcam/wrapper/CameraWrapper.java
+++ b/src_wrapper/org/codeaurora/snapcam/wrapper/CameraWrapper.java
@@ -119,4 +119,21 @@ public class CameraWrapper extends Wrapper{
         }
     }
 
+    private static Method method_stopLongshot = null;
+    public static final void stopLongshot(Camera camera){
+        if ( DEBUG ){
+            Log.e(TAG, "" + Camera.class + " no stopLongshot");
+            return;
+        }
+        try {
+            if (method_stopLongshot == null) {
+                method_stopLongshot =
+                        Camera.class.getDeclaredMethod("stopLongshot");
+            }
+            method_stopLongshot.invoke(camera);
+        }catch (Exception exception){
+            exception.printStackTrace();
+        }
+    }
+
 }
-- 
2.17.1

