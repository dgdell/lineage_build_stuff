From bec2eb0b71efef079cff70e9bc82ed49a6ebee47 Mon Sep 17 00:00:00 2001
From: Paul Rohde <codelogic@google.com>
Date: Fri, 5 Dec 2014 12:17:15 -0800
Subject: [PATCH 152/173] Drop new focus indicator into Camera2.

* Create a new custom focus view that interacts with physical lens diopter changes.
* Replace all occurances of the old focus indicator with the new one.

Change-Id: Ia02646ce4d1eb059ecb8a1dfccc15dfc9c167e1b
---
 res/layout/capture_module.xml                 |   4 +
 res/layout/photo_module.xml                   |   4 +
 res/layout/video_module.xml                   |   5 +
 res/raw/material_camera_focus.ogg             | Bin 0 -> 19122 bytes
 res/values/colors.xml                         |   1 +
 res/values/dimens.xml                         |   4 +
 src/com/android/camera/CaptureModule.java     |  15 +-
 src/com/android/camera/CaptureUI.java         |  93 +------
 .../android/camera/FocusOverlayManager.java   | 152 ++++-------
 .../android/camera/FocusStateListener.java    |  14 +-
 src/com/android/camera/PhotoModule.java       |  30 +--
 src/com/android/camera/PhotoUI.java           |  67 +----
 src/com/android/camera/SoundPlayer.java       |  95 +++++++
 src/com/android/camera/VideoModule.java       |   3 +-
 src/com/android/camera/VideoUI.java           |  49 +---
 .../android/camera/async/HandlerExecutor.java |  37 +++
 src/com/android/camera/async/MainThread.java  |  47 ++++
 .../camera/ui/focus/AutoFocusRing.java        | 101 ++++++++
 .../ui/focus/CameraCoordinateTransformer.java | 109 ++++++++
 .../camera/ui/focus/FocusController.java      | 128 ++++++++++
 .../android/camera/ui/focus/FocusRing.java    |  72 ++++++
 .../camera/ui/focus/FocusRingRenderer.java    | 237 ++++++++++++++++++
 .../camera/ui/focus/FocusRingView.java        | 211 ++++++++++++++++
 .../android/camera/ui/focus/FocusSound.java   |  47 ++++
 .../camera/ui/focus/LensRangeCalculator.java  |  71 ++++++
 .../camera/ui/focus/ManualFocusRing.java      |  93 +++++++
 .../camera/ui/motion/AnimationClock.java      |  39 +++
 .../camera/ui/motion/DampedSpring.java        | 145 +++++++++++
 .../camera/ui/motion/DynamicAnimation.java    |  41 +++
 .../camera/ui/motion/DynamicAnimator.java     | 116 +++++++++
 .../camera/ui/motion/InterpolateUtils.java    |  66 +++++
 .../camera/ui/motion/InterpolatorHelper.java  |  38 +++
 .../android/camera/ui/motion/Invalidator.java |  28 +++
 .../android/camera/ui/motion/LinearScale.java |  85 +++++++
 .../android/camera/ui/motion/UnitBezier.java  | 157 ++++++++++++
 .../android/camera/ui/motion/UnitCurve.java   |  41 +++
 .../android/camera/ui/motion/UnitCurves.java  |  44 ++++
 src/com/android/camera/util/CameraUtil.java   |  19 +-
 38 files changed, 2156 insertions(+), 352 deletions(-)
 create mode 100644 res/raw/material_camera_focus.ogg
 create mode 100644 src/com/android/camera/SoundPlayer.java
 create mode 100644 src/com/android/camera/async/HandlerExecutor.java
 create mode 100644 src/com/android/camera/async/MainThread.java
 create mode 100644 src/com/android/camera/ui/focus/AutoFocusRing.java
 create mode 100644 src/com/android/camera/ui/focus/CameraCoordinateTransformer.java
 create mode 100644 src/com/android/camera/ui/focus/FocusController.java
 create mode 100644 src/com/android/camera/ui/focus/FocusRing.java
 create mode 100644 src/com/android/camera/ui/focus/FocusRingRenderer.java
 create mode 100644 src/com/android/camera/ui/focus/FocusRingView.java
 create mode 100644 src/com/android/camera/ui/focus/FocusSound.java
 create mode 100644 src/com/android/camera/ui/focus/LensRangeCalculator.java
 create mode 100644 src/com/android/camera/ui/focus/ManualFocusRing.java
 create mode 100644 src/com/android/camera/ui/motion/AnimationClock.java
 create mode 100644 src/com/android/camera/ui/motion/DampedSpring.java
 create mode 100644 src/com/android/camera/ui/motion/DynamicAnimation.java
 create mode 100644 src/com/android/camera/ui/motion/DynamicAnimator.java
 create mode 100644 src/com/android/camera/ui/motion/InterpolateUtils.java
 create mode 100644 src/com/android/camera/ui/motion/InterpolatorHelper.java
 create mode 100644 src/com/android/camera/ui/motion/Invalidator.java
 create mode 100644 src/com/android/camera/ui/motion/LinearScale.java
 create mode 100644 src/com/android/camera/ui/motion/UnitBezier.java
 create mode 100644 src/com/android/camera/ui/motion/UnitCurve.java
 create mode 100644 src/com/android/camera/ui/motion/UnitCurves.java

diff --git a/res/layout/capture_module.xml b/res/layout/capture_module.xml
index 46acf2886..a1257a1be 100755
--- a/res/layout/capture_module.xml
+++ b/res/layout/capture_module.xml
@@ -107,6 +107,10 @@
             android:layout_height="200dip"
             android:layout_marginTop="50dip"
             android:layout_marginLeft="15dip" />
+        <com.android.camera.ui.focus.FocusRingView
+            android:id="@+id/focus_ring"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent" />
     </FrameLayout>
 
     <com.android.camera.ui.RenderOverlay
diff --git a/res/layout/photo_module.xml b/res/layout/photo_module.xml
index 904b15461..ba5758747 100755
--- a/res/layout/photo_module.xml
+++ b/res/layout/photo_module.xml
@@ -58,6 +58,10 @@
             android:layout_marginTop="50dip"
             android:layout_marginLeft="15dip" />
     </RelativeLayout>
+    <com.android.camera.ui.focus.FocusRingView
+        android:id="@+id/focus_ring"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
     <com.android.camera.ui.RotateImageView
         android:id="@+id/review_image"
         android:layout_width="match_parent"
diff --git a/res/layout/video_module.xml b/res/layout/video_module.xml
index 56f585787..0d8c4cb30 100755
--- a/res/layout/video_module.xml
+++ b/res/layout/video_module.xml
@@ -97,6 +97,11 @@
             android:onClick="onReviewPlayClicked"/>
     </FrameLayout>
 
+    <com.android.camera.ui.focus.FocusRingView
+        android:id="@+id/focus_ring"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+
     <include layout="@layout/camera_controls"
         android:layout_gravity="center"
         style="@style/CameraControls"/>
diff --git a/res/raw/material_camera_focus.ogg b/res/raw/material_camera_focus.ogg
new file mode 100644
index 0000000000000000000000000000000000000000..555d7f4443dae4b5083275c64299440a0ee2e1c6
GIT binary patch
literal 19122
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

literal 0
HcmV?d00001

diff --git a/res/values/colors.xml b/res/values/colors.xml
index ee79867cb..719ef7723 100644
--- a/res/values/colors.xml
+++ b/res/values/colors.xml
@@ -68,6 +68,7 @@
     <color name="face_detect_start">@color/white</color>
     <color name="face_detect_success">@color/green</color>
     <color name="face_detect_fail">@color/red</color>
+    <color name="focus_color">#ffffffff</color>
     <color name="gray">@color/grey</color>
 
     <color name="setting_list_selected">#40fafafa</color>
diff --git a/res/values/dimens.xml b/res/values/dimens.xml
index 210b4739c..29fbbe561 100755
--- a/res/values/dimens.xml
+++ b/res/values/dimens.xml
@@ -93,6 +93,10 @@
     <dimen name="toggle_size">30dp</dimen>
     <dimen name="toggle_outer_size">60dp</dimen>
     <dimen name="face_circle_stroke">2dip</dimen>
+    <dimen name="focus_circle_stroke">1.25dp</dimen>
+    <dimen name="focus_circle_min_size">24dp</dimen>
+    <dimen name="focus_circle_max_size">96dp</dimen>
+    <dimen name="focus_circle_initial_size">48dp</dimen>
     <dimen name="zoom_font_size">14pt</dimen>
     <dimen name="shutter_offset">11dp</dimen>
     <dimen name="shutter_offset_top">2dp</dimen>
diff --git a/src/com/android/camera/CaptureModule.java b/src/com/android/camera/CaptureModule.java
index feaf89eb9..d1d9183c7 100755
--- a/src/com/android/camera/CaptureModule.java
+++ b/src/com/android/camera/CaptureModule.java
@@ -114,6 +114,7 @@ import com.android.camera.imageprocessor.filter.SharpshooterFilter;
 import com.android.camera.imageprocessor.filter.StillmoreFilter;
 import com.android.camera.imageprocessor.filter.UbifocusFilter;
 import com.android.camera.ui.CountDownView;
+import com.android.camera.ui.focus.FocusRing;
 import com.android.camera.ui.ModuleSwitcher;
 import com.android.camera.ui.ProMode;
 import com.android.camera.ui.RotateTextToast;
@@ -2551,7 +2552,7 @@ public class CaptureModule implements CameraModule, PhotoController,
                     @Override
                     public void run() {
                         if (mUI.getCurrentProMode() != ProMode.MANUAL_MODE)
-                            mUI.clearFocus();
+                        mUI.getFocusRing().stopFocusAnimations();
                     }
                 });
             }
@@ -3462,10 +3463,10 @@ public class CaptureModule implements CameraModule, PhotoController,
         int[] newXY = {x, y};
         if (mUI.isOverControlRegion(newXY)) return;
         if (!mUI.isOverSurfaceView(newXY)) return;
-        mUI.setFocusPosition(x, y);
+        mUI.getFocusRing().startActiveFocus();
+        mUI.getFocusRing().setFocusLocation(x, y);
         x = newXY[0];
         y = newXY[1];
-        mUI.onFocusStarted();
         if (isBackCamera()) {
             switch (getCameraMode()) {
                 case DUAL_MODE:
@@ -3947,7 +3948,7 @@ public class CaptureModule implements CameraModule, PhotoController,
                 return;
             }
 
-            mUI.clearFocus();
+            mUI.getFocusRing().stopFocusAnimations();
             mUI.resetPauseButton();
             mRecordingTotalTime = 0L;
             mRecordingStartTime = SystemClock.uptimeMillis();
@@ -3999,7 +4000,7 @@ public class CaptureModule implements CameraModule, PhotoController,
             mHandler.post(new Runnable() {
                 @Override
                 public void run() {
-                    mUI.clearFocus();
+                    mUI.getFocusRing().stopFocusAnimations();
                     mUI.resetPauseButton();
                     mRecordingTotalTime = 0L;
                     mRecordingStartTime = SystemClock.uptimeMillis();
@@ -4114,7 +4115,7 @@ public class CaptureModule implements CameraModule, PhotoController,
 
         try {
             setUpMediaRecorder(cameraId);
-            mUI.clearFocus();
+            mUI.getFocusRing().stopFocusAnimations();
             mUI.hideUIwhileRecording();
             mCameraHandler.removeMessages(CANCEL_TOUCH_FOCUS, mCameraId[cameraId]);
             mState[cameraId] = STATE_PREVIEW;
@@ -4209,7 +4210,7 @@ public class CaptureModule implements CameraModule, PhotoController,
                                         restartSession(true);
                                         return;
                                     }
-                                    mUI.clearFocus();
+                                    mUI.getFocusRing().stopFocusAnimations();
                                     mUI.resetPauseButton();
                                     mRecordingTotalTime = 0L;
                                     mRecordingStartTime = SystemClock.uptimeMillis();
diff --git a/src/com/android/camera/CaptureUI.java b/src/com/android/camera/CaptureUI.java
index efbe58643..12b7480d5 100755
--- a/src/com/android/camera/CaptureUI.java
+++ b/src/com/android/camera/CaptureUI.java
@@ -74,7 +74,7 @@ import com.android.camera.ui.CameraControls;
 import com.android.camera.ui.OneUICameraControls;
 import com.android.camera.ui.CountDownView;
 import com.android.camera.ui.FlashToggleButton;
-import com.android.camera.ui.FocusIndicator;
+import com.android.camera.ui.focus.FocusRing;
 import com.android.camera.ui.PieRenderer;
 import com.android.camera.ui.ProMode;
 import com.android.camera.ui.RenderOverlay;
@@ -93,8 +93,7 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
-public class CaptureUI implements FocusOverlayManager.FocusUI,
-        PreviewGestures.SingleTapListener,
+public class CaptureUI implements PreviewGestures.SingleTapListener,
         CameraManager.CameraFaceDetectionCallback,
         SettingsManager.Listener,
         PauseButton.OnPauseButtonListener {
@@ -106,6 +105,7 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
     private static final int ANIMATION_DURATION = 300;
     private static final int CLICK_THRESHOLD = 200;
     private static final int AUTOMATIC_MODE = 0;
+    private final FocusRing mFocusRing;
     private CameraActivity mActivity;
     private View mRootView;
     private View mPreviewCover;
@@ -300,6 +300,8 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         mSurfaceHolderMono = mSurfaceViewMono.getHolder();
         mSurfaceHolderMono.addCallback(callbackMono);
 
+        mFocusRing = (FocusRing) mRootView.findViewById(R.id.focus_ring);
+
         mRenderOverlay = (RenderOverlay) mRootView.findViewById(R.id.render_overlay);
         mShutterButton = (ShutterButton) mRootView.findViewById(R.id.shutter_button);
         mVideoButton = (ImageView) mRootView.findViewById(R.id.video_button);
@@ -761,7 +763,6 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         if (mPreviewLayout != null && mPreviewLayout.getVisibility() == View.VISIBLE) {
             return;
         }
-        clearFocus();
         removeFilterMenu(false);
         Intent intent = new Intent(mActivity, SettingsActivity.class);
         mActivity.startActivity(intent);
@@ -807,7 +808,6 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         mSceneModeSwitcher.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                clearFocus();
                 removeFilterMenu(false);
                 Intent intent = new Intent(mActivity, SceneModeActivity.class);
                 intent.putExtra(CameraUtil.KEY_IS_SECURE_CAMERA, mActivity.isSecureCamera());
@@ -1002,7 +1002,6 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         }
     }
 
-
     public void resetTrackingFocus() {
         if(mModule.isTrackingFocusSettingOn()) {
             mTrackingFocusRenderer.setVisible(false);
@@ -1114,10 +1113,8 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
                             mSettingsManager.setValueIndex(SettingsManager
                                     .KEY_COLOR_EFFECT, j);
                             for (View v1 : views) {
-                                v1.setBackground(null);
+                                v1.setActivated(v1 == v);
                             }
-                            ImageView image = (ImageView) v.findViewById(R.id.image);
-                            image.setBackgroundColor(HIGHLIGHT_COLOR);
                         }
                     }
                     return true;
@@ -1125,10 +1122,8 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
             });
 
             views[j] = imageView;
-            if (i == init)
-                imageView.setBackgroundColor(HIGHLIGHT_COLOR);
+            imageView.setActivated(i == init);
             TextView label = (TextView) filterBox.findViewById(R.id.label);
-
             imageView.setImageResource(thumbnails[i]);
             label.setText(entries[i]);
             gridLayout.addView(filterBox);
@@ -1143,7 +1138,7 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
 
     public void animateFadeIn(View v) {
         ViewPropertyAnimator vp = v.animate();
-        vp.alpha(0.85f).setDuration(ANIMATION_DURATION);
+        vp.alpha(1f).setDuration(ANIMATION_DURATION);
         vp.start();
     }
 
@@ -1280,7 +1275,6 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         if (!mUIhidden)
             return;
         mUIhidden = false;
-        mPieRenderer.setBlockFocus(false);
         mCameraControls.showUI();
     }
 
@@ -1288,7 +1282,6 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         if (mUIhidden)
             return;
         mUIhidden = true;
-        mPieRenderer.setBlockFocus(true);
         mCameraControls.hideUI();
     }
 
@@ -1526,74 +1519,8 @@ public class CaptureUI implements FocusOverlayManager.FocusUI,
         mCameraControls.showRefocusToast(show);
     }
 
-    private FocusIndicator getFocusIndicator() {
-        if (mModule.isTrackingFocusSettingOn()) {
-            if (mPieRenderer != null) {
-                mPieRenderer.clear();
-            }
-            return mTrackingFocusRenderer;
-        }
-        FocusIndicator focusIndicator;
-        if (mFaceView != null && mFaceView.faceExists() && !mIsTouchAF) {
-            if (mPieRenderer != null) {
-                mPieRenderer.clear();
-            }
-            focusIndicator = mFaceView;
-        } else {
-            focusIndicator = mPieRenderer;
-        }
-
-        return focusIndicator;
-    }
-
-    @Override
-    public boolean hasFaces() {
-        return (mFaceView != null && mFaceView.faceExists());
-    }
-
-    public void clearFaces() {
-        if (mFaceView != null) mFaceView.clear();
-    }
-
-    @Override
-    public void clearFocus() {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.clear();
-        mIsTouchAF = false;
-    }
-
-    @Override
-    public void setFocusPosition(int x, int y) {
-        mPieRenderer.setFocus(x, y);
-        mIsTouchAF = true;
-    }
-
-    @Override
-    public void onFocusStarted() {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.showStart();
-    }
-
-    @Override
-    public void onFocusSucceeded(boolean timeout) {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.showSuccess(timeout);
-    }
-
-    @Override
-    public void onFocusFailed(boolean timeOut) {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.showFail(timeOut);
-
-    }
-
-    @Override
-    public void pauseFaceDetection() {
-
-    }
-
-    @Override
-    public void resumeFaceDetection() {
+    public FocusRing getFocusRing() {
+        return mFocusRing;
     }
 
     public void onStartFaceDetection(int orientation, boolean mirror, Rect cameraBound,
diff --git a/src/com/android/camera/FocusOverlayManager.java b/src/com/android/camera/FocusOverlayManager.java
index 34a8521e2..1b4bed133 100644
--- a/src/com/android/camera/FocusOverlayManager.java
+++ b/src/com/android/camera/FocusOverlayManager.java
@@ -16,15 +16,12 @@
 
 package com.android.camera;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.graphics.Matrix;
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.graphics.RectF;
 import android.hardware.Camera.Area;
 import android.hardware.Camera.Parameters;
-import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -32,6 +29,8 @@ import android.util.Log;
 import org.codeaurora.snapcam.R;
 
 import com.android.camera.app.CameraApp;
+import com.android.camera.ui.focus.CameraCoordinateTransformer;
+import com.android.camera.ui.focus.FocusRing;
 import com.android.camera.util.CameraUtil;
 import com.android.camera.util.UsageStatistics;
 
@@ -65,6 +64,9 @@ public class FocusOverlayManager {
 
     private static final int RESET_TOUCH_FOCUS = 0;
 
+    public static final float AF_REGION_BOX = 0.2f;
+    public static final float AE_REGION_BOX = 0.3f;
+
     private int mState = STATE_IDLE;
     public static final int STATE_IDLE = 0; // Focus is not active.
     public static final int STATE_FOCUSING = 1; // Focus is in progress.
@@ -78,7 +80,7 @@ public class FocusOverlayManager {
     private boolean mMeteringAreaSupported;
     private boolean mLockAeAwbNeeded;
     private boolean mAeAwbLock;
-    private Matrix mMatrix;
+    private CameraCoordinateTransformer mCoordinateTransformer;
 
     private boolean mMirror; // true if the camera is front-facing.
     private int mDisplayOrientation;
@@ -96,20 +98,9 @@ public class FocusOverlayManager {
     private boolean mTouchAFRunning = false;
     private boolean mIsAFRunning = false;
 
-    private FocusUI mUI;
+    private FocusRing mFocusRing;
     private final Rect mPreviewRect = new Rect(0, 0, 0, 0);
 
-    public  interface FocusUI {
-        public boolean hasFaces();
-        public void clearFocus();
-        public void setFocusPosition(int x, int y);
-        public void onFocusStarted();
-        public void onFocusSucceeded(boolean timeOut);
-        public void onFocusFailed(boolean timeOut);
-        public void pauseFaceDetection();
-        public void resumeFaceDetection();
-    }
-
     private int mFocusTime; // time after touch-to-focus
     private Point mDispSize;
     private int mBottomMargin;
@@ -143,15 +134,13 @@ public class FocusOverlayManager {
 
     public FocusOverlayManager(ComboPreferences preferences, String[] defaultFocusModes,
             Parameters parameters, Listener listener,
-            boolean mirror, Looper looper, FocusUI ui, CameraActivity activity) {
+            boolean mirror, Looper looper, FocusRing focusRing, CameraActivity activity) {
         mHandler = new MainHandler(looper);
-        mMatrix = new Matrix();
         mPreferences = preferences;
         mDefaultFocusModes = defaultFocusModes;
         setParameters(parameters);
         mListener = listener;
         setMirror(mirror);
-        mUI = ui;
         mDispSize = new Point();
         activity.getWindowManager().getDefaultDisplay().getRealSize(mDispSize);
         Context context = CameraApp.getContext();
@@ -159,10 +148,11 @@ public class FocusOverlayManager {
             context.getResources().getDimensionPixelSize(R.dimen.preview_bottom_margin);
         mTopMargin =
             context.getResources().getDimensionPixelSize(R.dimen.preview_top_margin);
+        mFocusRing = focusRing;
     }
 
-    public void setPhotoUI(FocusUI ui) {
-        mUI = ui;
+    public void setFocusRing(FocusRing focusRing) {
+        mFocusRing = focusRing;
     }
 
     public void setParameters(Parameters parameters) {
@@ -188,35 +178,28 @@ public class FocusOverlayManager {
     public void setPreviewRect(Rect previewRect) {
         if (!mPreviewRect.equals(previewRect)) {
             mPreviewRect.set(previewRect);
-            setMatrix();
+            resetCoordinateTransformer();
+            mInitialized = true;
         }
     }
 
-    /** Returns a copy of mPreviewRect so that outside class cannot modify preview
-     *  rect except deliberately doing so through the setter. */
-    public Rect getPreviewRect() {
-        return new Rect(mPreviewRect);
-    }
-
     public void setMirror(boolean mirror) {
         mMirror = mirror;
-        setMatrix();
+        resetCoordinateTransformer();
     }
 
     public void setDisplayOrientation(int displayOrientation) {
         mDisplayOrientation = displayOrientation;
-        setMatrix();
+        resetCoordinateTransformer();
     }
 
-    private void setMatrix() {
-        if (mPreviewRect.width() != 0 && mPreviewRect.height() != 0) {
-            Matrix matrix = new Matrix();
-            CameraUtil.prepareMatrix(matrix, mMirror, mDisplayOrientation, getPreviewRect());
-            // In face detection, the matrix converts the driver coordinates to UI
-            // coordinates. In tap focus, the inverted matrix converts the UI
-            // coordinates to driver coordinates.
-            matrix.invert(mMatrix);
-            mInitialized = true;
+    private void resetCoordinateTransformer() {
+        if (mPreviewRect.width() > 0 && mPreviewRect.height() > 0) {
+            mCoordinateTransformer = new CameraCoordinateTransformer(mMirror, mDisplayOrientation,
+                    CameraUtil.rectToRectF(mPreviewRect));
+        } else {
+            Log.w(TAG, "The coordinate transformer could not be built because the preview rect"
+                    + "did not have a width and height");
         }
     }
 
@@ -307,7 +290,6 @@ public class FocusOverlayManager {
             } else {
                 mState = STATE_FAIL;
             }
-            updateFocusUI();
             capture();
         } else if (mState == STATE_FOCUSING) {
             // This happens when (1) user is half-pressing the focus key or
@@ -323,7 +305,6 @@ public class FocusOverlayManager {
             } else {
                 mState = STATE_FAIL;
             }
-            updateFocusUI();
             // If this is triggered by touch focus, cancel focus after a
             // while.
             if (mFocusArea != null) {
@@ -343,32 +324,31 @@ public class FocusOverlayManager {
         if (!mInitialized) return;
 
 
-        // Ignore if the camera has detected some faces.
-        if (mUI.hasFaces()) {
-            mUI.clearFocus();
-            if (mIsAFRunning) {
-                mUI.onFocusSucceeded(true);
-                mIsAFRunning = false;
-            }
-            return;
-        }
-
         // Ignore if we have requested autofocus. This method only handles
         // continuous autofocus.
         if (mState != STATE_IDLE) return;
 
         // animate on false->true trasition only b/8219520
         if (moving && !mPreviousMoving) {
-            mUI.onFocusStarted();
+            mFocusRing.startPassiveFocus();
             mIsAFRunning = true;
         } else if (!moving) {
-            mUI.onFocusSucceeded(true);
+            mFocusRing.stopFocusAnimations();
             mIsAFRunning = false;
         }
         mPreviousMoving = moving;
     }
 
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    /** Returns width of auto focus region in pixels. */
+    private int getAFRegionSizePx() {
+        return (int) (Math.min(mPreviewRect.width(), mPreviewRect.height()) * AF_REGION_BOX);
+    }
+
+    /** Returns width of metering region in pixels. */
+    private int getAERegionSizePx() {
+        return (int) (Math.min(mPreviewRect.width(), mPreviewRect.height()) * AE_REGION_BOX);
+    }
+
     private void initializeFocusAreas(int x, int y) {
         if (mFocusArea == null) {
             mFocusArea = new ArrayList<Object>();
@@ -376,10 +356,9 @@ public class FocusOverlayManager {
         }
 
         // Convert the coordinates to driver format.
-        calculateTapArea(x, y, 1f, ((Area) mFocusArea.get(0)).rect);
+        ((Area) mFocusArea.get(0)).rect = computeCameraRectFromPreviewCoordinates(x, y, getAFRegionSizePx());
     }
 
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     private void initializeMeteringAreas(int x, int y) {
         if (mMeteringArea == null) {
             mMeteringArea = new ArrayList<Object>();
@@ -389,7 +368,7 @@ public class FocusOverlayManager {
         // Convert the coordinates to driver format.
         // AE area is bigger because exposure is sensitive and
         // easy to over- or underexposure if area is too small.
-        calculateTapArea(x, y, 1.5f, ((Area) mMeteringArea.get(0)).rect);
+        ((Area) mMeteringArea.get(0)).rect = computeCameraRectFromPreviewCoordinates(x, y, getAERegionSizePx());
     }
 
     private void resetMeteringAreas() {
@@ -421,8 +400,8 @@ public class FocusOverlayManager {
             initializeMeteringAreas(x, y);
         }
 
-        // Use margin to set the focus indicator to the touched area.
-        mUI.setFocusPosition(x, y);
+        mFocusRing.startActiveFocus();
+        mFocusRing.setFocusLocation(x, y);
 
         if (mZslEnabled) {
             mTouchAFRunning = true;
@@ -441,7 +420,6 @@ public class FocusOverlayManager {
         if (mFocusAreaSupported) {
             autoFocus();
         } else {  // Just show the indicator in all other cases.
-            updateFocusUI();
             mHandler.removeMessages(RESET_TOUCH_FOCUS);
             mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, mFocusTime);
         }
@@ -455,7 +433,6 @@ public class FocusOverlayManager {
         // If auto focus was in progress, it would have been stopped.
         mState = STATE_IDLE;
         resetTouchFocus();
-        updateFocusUI();
     }
 
     public void onCameraReleased() {
@@ -467,7 +444,8 @@ public class FocusOverlayManager {
         Log.v(TAG, "Start autofocus.");
         mListener.autoFocus();
         mState = STATE_FOCUSING;
-        updateFocusUI();
+        // Pause the face view because the driver will keep sending face
+        // callbacks after the focus completes.
         mHandler.removeMessages(RESET_TOUCH_FOCUS);
     }
 
@@ -480,9 +458,7 @@ public class FocusOverlayManager {
         resetTouchFocus();
         setAeAwbLock(false);
         mListener.cancelAutoFocus();
-        mUI.resumeFaceDetection();
         mState = STATE_IDLE;
-        updateFocusUI();
         mHandler.removeMessages(RESET_TOUCH_FOCUS);
     }
 
@@ -552,41 +528,9 @@ public class FocusOverlayManager {
         }
     }
 
-    public void updateFocusUI() {
-        if (!mInitialized) return;
-        // Show only focus indicator or face indicator.
-
-        if (mState == STATE_IDLE) {
-            if (mFocusArea == null) {
-                mUI.clearFocus();
-            } else {
-                // Users touch on the preview and the indicator represents the
-                // metering area. Either focus area is not supported or
-                // autoFocus call is not required.
-                mUI.onFocusStarted();
-            }
-        } else if (mState == STATE_FOCUSING || mState == STATE_FOCUSING_SNAP_ON_FINISH) {
-            mUI.onFocusStarted();
-        } else {
-            if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusMode)) {
-                // TODO: check HAL behavior and decide if this can be removed.
-                mUI.onFocusSucceeded(false);
-            } else if (mState == STATE_SUCCESS) {
-                mUI.onFocusSucceeded(false);
-            } else if (mState == STATE_FAIL) {
-                mUI.onFocusFailed(false);
-            }
-        }
-    }
-
     public void resetTouchFocus() {
         if (!mInitialized) return;
 
-        // Put focus indicator to the center. clear reset position
-        if (mUI != null) {
-            mUI.clearFocus();
-        }
-        // Initialize mFocusArea.
         mFocusArea = null;
         // Initialize mMeteringArea.
         mMeteringArea = null;
@@ -601,16 +545,14 @@ public class FocusOverlayManager {
         }
     }
 
-    private void calculateTapArea(int x, int y, float areaMultiple, Rect rect) {
-        int areaSize = (int) (getAreaSize() * areaMultiple);
-        int left = CameraUtil.clamp(x - areaSize / 2, mPreviewRect.left,
-                mPreviewRect.right - areaSize);
-        int top = CameraUtil.clamp(y - areaSize / 2, mPreviewRect.top,
-                mPreviewRect.bottom - areaSize);
+    private Rect computeCameraRectFromPreviewCoordinates(int x, int y, int size) {
+        int left = CameraUtil.clamp(x - size / 2, mPreviewRect.left,
+                mPreviewRect.right - size);
+        int top = CameraUtil.clamp(y - size / 2, mPreviewRect.top,
+                mPreviewRect.bottom - size);
 
-        RectF rectF = new RectF(left, top, left + areaSize, top + areaSize);
-        mMatrix.mapRect(rectF);
-        CameraUtil.rectFToRect(rectF, rect);
+        RectF rectF = new RectF(left, top, left + size, top + size);
+        return CameraUtil.rectFToRect(mCoordinateTransformer.toCameraSpace(rectF));
     }
 
     private int getAreaSize() {
diff --git a/src/com/android/camera/FocusStateListener.java b/src/com/android/camera/FocusStateListener.java
index 6c536c53b..459e4ec23 100644
--- a/src/com/android/camera/FocusStateListener.java
+++ b/src/com/android/camera/FocusStateListener.java
@@ -44,31 +44,31 @@ public class FocusStateListener {
         switch (focusState) {
             case CaptureResult.CONTROL_AF_STATE_ACTIVE_SCAN:
                 Log.d(TAG, "CONTROL_AF_STATE_ACTIVE_SCAN onFocusStarted");
-                mUI.onFocusStarted();
+                mUI.getFocusRing().startActiveFocus();
                 break;
             case CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED:
                 Log.d(TAG, "CONTROL_AF_STATE_FOCUSED_LOCKED onFocusSucceeded");
-                mUI.onFocusSucceeded(false);
+                mUI.getFocusRing().stopFocusAnimations();
                 break;
             case CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED:
                 Log.d(TAG, "CONTROL_AF_STATE_NOT_FOCUSED_LOCKED onFocusFailed");
-                mUI.onFocusFailed(false);
+                mUI.getFocusRing().stopFocusAnimations();
                 break;
             case CaptureResult.CONTROL_AF_STATE_PASSIVE_FOCUSED:
                 Log.d(TAG, "CONTROL_AF_STATE_PASSIVE_FOCUSED onFocusSucceeded");
-                mUI.onFocusSucceeded(true);
+                mUI.getFocusRing().stopFocusAnimations();
                 break;
             case CaptureResult.CONTROL_AF_STATE_PASSIVE_SCAN:
                 Log.d(TAG, "CONTROL_AF_STATE_PASSIVE_SCAN onFocusStarted");
-                mUI.onFocusStarted();
+                mUI.getFocusRing().startPassiveFocus();
                 break;
             case CaptureResult.CONTROL_AF_STATE_PASSIVE_UNFOCUSED:
                 Log.d(TAG, "CONTROL_AF_STATE_PASSIVE_UNFOCUSED onFocusFailed");
-                mUI.onFocusFailed(true);
+                mUI.getFocusRing().stopFocusAnimations();
                 break;
             case CaptureResult.CONTROL_AF_STATE_INACTIVE:
                 Log.d(TAG, "CONTROL_AF_STATE_INACTIVE clearFocus");
-                mUI.clearFocus();
+                mUI.getFocusRing().stopFocusAnimations();
                 break;
         }
     }
diff --git a/src/com/android/camera/PhotoModule.java b/src/com/android/camera/PhotoModule.java
index 30e1581ef..72831a3ff 100644
--- a/src/com/android/camera/PhotoModule.java
+++ b/src/com/android/camera/PhotoModule.java
@@ -741,7 +741,7 @@ public class PhotoModule
         Log.v(TAG, "onCameraOpened");
         openCameraCommon();
         resizeForPreviewAspectRatio();
-        updateFocusManager(mUI);
+        mFocusManager.setFocusRing(mUI.getFocusRing());
     }
 
     private void switchCamera() {
@@ -765,7 +765,6 @@ public class PhotoModule
         }
         closeCamera();
         mUI.collapseCameraControls();
-        mUI.clearFaces();
         if (mFocusManager != null) mFocusManager.removeMessages();
 
         // Restart the camera and initialize the UI. From onCreate.
@@ -1031,7 +1030,6 @@ public class PhotoModule
         if (mParameters.getMaxNumDetectedFaces() > 0) {
             mFaceDetectionStarted = false;
             mCameraDevice.setFaceDetectionCallback(null, null);
-            mUI.pauseFaceDetection();
             mCameraDevice.stopFaceDetection();
             mUI.onStopFaceDetection();
         }
@@ -1264,8 +1262,6 @@ public class PhotoModule
                 return;
             }
 
-            mFocusManager.updateFocusUI(); // Ensure focus indicator is hidden.
-
             String jpegFilePath = new String(jpegData);
             mNamedImages.nameNewImage(mCaptureStartTime);
             NamedEntity name = mNamedImages.getNextNameEntity();
@@ -1424,8 +1420,6 @@ public class PhotoModule
                 mCameraDevice.setLongshot(false);
             }
 
-            mFocusManager.updateFocusUI(); // Ensure focus indicator is hidden.
-
             boolean needRestartPreview = !mIsImageCaptureIntent
                     && !mPreviewRestartSupport
                     && (mCameraState != LONGSHOT)
@@ -1475,7 +1469,6 @@ public class PhotoModule
                         CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(focusMode)) {
                     mCameraDevice.cancelAutoFocus();
                 }
-                mUI.resumeFaceDetection();
                 if (!mIsImageCaptureIntent) {
                     setCameraState(IDLE);
                 }
@@ -2817,28 +2810,12 @@ public class PhotoModule
                 if (mFocusManager == null) {
                     mFocusManager = new FocusOverlayManager(mPreferences, defaultFocusModes,
                             mInitialParams, this, mMirror,
-                            mActivity.getMainLooper(), mUI, mActivity);
+                            mActivity.getMainLooper(), mUI != null ? mUI.getFocusRing() : null, mActivity);
                 }
             }
         }
     }
 
-    private void updateFocusManager(PhotoUI mUI) {
-        // Idea here is to let focus manager create in camera open thread
-        // (in initializeFocusManager) even if photoUI is null by that time so
-        // as to not block start preview process. Once UI creation is done,
-        // we will update focus manager with proper UI.
-        if (mFocusManager != null && mUI != null) {
-            mFocusManager.setPhotoUI(mUI);
-
-            View root = mUI.getRootView();
-            // These depend on camera parameters.
-            int width = root.getWidth();
-            int height = root.getHeight();
-            mFocusManager.setPreviewSize(width, height);
-        }
-    }
-
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         Log.v(TAG, "onConfigurationChanged");
@@ -2912,7 +2889,6 @@ public class PhotoModule
         }
         // Check if metering area or focus area is supported.
         if (!mFocusAreaSupported && !mMeteringAreaSupported) return;
-        if (! mFocusManager.getPreviewRect().contains(x, y)) return;
         mFocusManager.onSingleTapUp(x, y);
     }
 
@@ -3800,7 +3776,7 @@ public class PhotoModule
 
         if(!mFocusManager.getFocusMode(false).equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) &&
             !mFocusManager.isFocusCompleted()) {
-            mUI.clearFocus();
+            mUI.getFocusRing().stopFocusAnimations();
         }
 
         String bokehMode = mPreferences.getString(
diff --git a/src/com/android/camera/PhotoUI.java b/src/com/android/camera/PhotoUI.java
index b63e6525f..57c11aa1b 100755
--- a/src/com/android/camera/PhotoUI.java
+++ b/src/com/android/camera/PhotoUI.java
@@ -58,7 +58,6 @@ import android.widget.PopupWindow;
 import android.widget.Toast;
 
 import com.android.camera.CameraPreference.OnPreferenceChangedListener;
-import com.android.camera.FocusOverlayManager.FocusUI;
 import com.android.camera.TsMakeupManager.MakeupLevelListener;
 import com.android.camera.ui.AbstractSettingPopup;
 import com.android.camera.ui.CameraControls;
@@ -77,11 +76,11 @@ import com.android.camera.ui.RotateLayout;
 import com.android.camera.ui.RotateTextToast;
 import com.android.camera.ui.SelfieFlashView;
 import com.android.camera.ui.ZoomRenderer;
+import com.android.camera.ui.focus.FocusRing;
 import com.android.camera.util.CameraUtil;
 
 public class PhotoUI implements PieListener,
         PreviewGestures.SingleTapListener,
-        FocusUI,
         SurfaceHolder.Callback,
         CameraRootView.MyDisplayListener,
         CameraManager.CameraFaceDetectionCallback {
@@ -89,6 +88,7 @@ public class PhotoUI implements PieListener,
     private static final String TAG = "CAM_UI";
     private int mDownSampleFactor = 4;
     private final AnimationManager mAnimationManager;
+    private final FocusRing mFocusRing;
     private CameraActivity mActivity;
     private PhotoController mController;
     private PreviewGestures mGestures;
@@ -291,6 +291,7 @@ public class PhotoUI implements PieListener,
             mFaceView = (FaceView) mRootView.findViewById(R.id.face_view);
             setSurfaceTextureSizeChangedListener(mFaceView);
         }
+        mFocusRing = (FocusRing) mRootView.findViewById(R.id.focus_ring);
         mAnimationManager = new AnimationManager();
         mOrientationResize = false;
         mPrevOrientationResize = false;
@@ -543,8 +544,9 @@ public class PhotoUI implements PieListener,
                 @Override
                 public void onClick(View v) {
                     if (!CameraControls.isAnimating()
-                            && mController.getCameraState() != PhotoController.SNAPSHOT_IN_PROGRESS)
+                            && mController.getCameraState() != PhotoController.SNAPSHOT_IN_PROGRESS) {
                         mActivity.gotoGallery();
+                    }
                 }
             });
         }
@@ -948,7 +950,6 @@ public class PhotoUI implements PieListener,
         CameraUtil.fadeIn(mReviewRetakeButton);
         setOrientation(mOrientation, true);
         mMenu.hideTopMenu(true);
-        pauseFaceDetection();
     }
 
     protected void hidePostCaptureAlert() {
@@ -964,7 +965,6 @@ public class PhotoUI implements PieListener,
         CameraUtil.fadeOut(mReviewDoneButton);
         mShutterButton.setVisibility(View.VISIBLE);
         CameraUtil.fadeOut(mReviewRetakeButton);
-        resumeFaceDetection();
     }
 
     public void setDisplayOrientation(int orientation) {
@@ -1171,61 +1171,8 @@ public class PhotoUI implements PieListener,
         ((CameraRootView) mRootView).removeDisplayChangeListener();
     }
 
-    // focus UI implementation
-
-    private FocusIndicator getFocusIndicator() {
-        return (mFaceView != null && mFaceView.faceExists()) ? mFaceView : mPieRenderer;
-    }
-
-    @Override
-    public boolean hasFaces() {
-        return (mFaceView != null && mFaceView.faceExists());
-    }
-
-    public void clearFaces() {
-        if (mFaceView != null) mFaceView.clear();
-    }
-
-    @Override
-    public void clearFocus() {
-        FocusIndicator indicator = mPieRenderer;
-        if (hasFaces()) {
-            mFaceView.showStart();
-        }
-        if (indicator != null) indicator.clear();
-    }
-
-    @Override
-    public void setFocusPosition(int x, int y) {
-        mPieRenderer.setFocus(x, y);
-    }
-
-    @Override
-    public void onFocusStarted() {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.showStart();
-    }
-
-    @Override
-    public void onFocusSucceeded(boolean timeout) {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.showSuccess(timeout);
-    }
-
-    @Override
-    public void onFocusFailed(boolean timeout) {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.showFail(timeout);
-    }
-
-    @Override
-    public void pauseFaceDetection() {
-        if (mFaceView != null) mFaceView.pause();
-    }
-
-    @Override
-    public void resumeFaceDetection() {
-        if (mFaceView != null) mFaceView.resume();
+    public FocusRing getFocusRing() {
+        return mFocusRing;
     }
 
     public void onStartFaceDetection(int orientation, boolean mirror) {
diff --git a/src/com/android/camera/SoundPlayer.java b/src/com/android/camera/SoundPlayer.java
new file mode 100644
index 000000000..ff3f37f7a
--- /dev/null
+++ b/src/com/android/camera/SoundPlayer.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.content.Context;
+import android.media.AudioManager;
+import android.media.SoundPool;
+import android.util.SparseIntArray;
+
+import com.android.camera.util.ApiHelper;
+
+/**
+ * Loads a plays custom sounds. For playing system-standard sounds for various
+ * camera actions, please refer to {@link SoundClips}.
+ */
+public class SoundPlayer {
+    private final Context mAppContext;
+    private final SoundPool mSoundPool;
+    /** Keeps a mapping from sound resource ID to sound ID */
+    private final SparseIntArray mResourceToSoundId = new SparseIntArray();
+    private boolean mIsReleased = false;
+
+    /**
+     * Construct a new sound player.
+     */
+    public SoundPlayer(Context appContext) {
+        mAppContext = appContext;
+        final int audioType = getAudioTypeForSoundPool();
+        mSoundPool = new SoundPool(1 /* max streams */, audioType, 0 /* quality */);
+    }
+
+    /**
+     * Load the sound from a resource.
+     */
+    public void loadSound(int resourceId) {
+        int soundId = mSoundPool.load(mAppContext, resourceId, 1/* priority */);
+        mResourceToSoundId.put(resourceId, soundId);
+    }
+
+    /**
+     * Play the sound with the given resource. The resource has to be loaded
+     * before it can be played, otherwise an exception will be thrown.
+     */
+    public void play(int resourceId, float volume) {
+        Integer soundId = mResourceToSoundId.get(resourceId);
+        if (soundId == null) {
+            throw new IllegalStateException("Sound not loaded. Must call #loadSound first.");
+        }
+        mSoundPool.play(soundId, volume, volume, 0 /* priority */, 0 /* loop */, 1 /* rate */);
+    }
+
+    /**
+     * Unload the given sound if it's not needed anymore to release memory.
+     */
+    public void unloadSound(int resourceId) {
+        Integer soundId = mResourceToSoundId.get(resourceId);
+        if (soundId == null) {
+            throw new IllegalStateException("Sound not loaded. Must call #loadSound first.");
+        }
+        mSoundPool.unload(soundId);
+    }
+
+    /**
+     * Call this if you don't need the SoundPlayer anymore. All memory will be
+     * released and the object cannot be re-used.
+     */
+    public void release() {
+        mIsReleased = true;
+        mSoundPool.release();
+    }
+
+    public boolean isReleased() {
+        return mIsReleased;
+    }
+
+    private static int getAudioTypeForSoundPool() {
+        // STREAM_SYSTEM_ENFORCED is hidden API.
+        return ApiHelper.getIntFieldIfExists(AudioManager.class,
+                "STREAM_SYSTEM_ENFORCED", null, AudioManager.STREAM_RING);
+    }
+}
diff --git a/src/com/android/camera/VideoModule.java b/src/com/android/camera/VideoModule.java
index 12e045440..71ded0596 100644
--- a/src/com/android/camera/VideoModule.java
+++ b/src/com/android/camera/VideoModule.java
@@ -1481,7 +1481,7 @@ public class VideoModule implements CameraModule,
                     R.array.pref_video_focusmode_default_array);
             mFocusManager = new FocusOverlayManager(mPreferences, defaultFocusModes,
                     mParameters, this, mirror,
-                    mActivity.getMainLooper(), mUI, mActivity);
+                    mActivity.getMainLooper(), mUI.getFocusRing(), mActivity);
         }
     }
 
@@ -3405,7 +3405,6 @@ public class VideoModule implements CameraModule,
         if (mParameters.getMaxNumDetectedFaces() > 0) {
             mFaceDetectionStarted = false;
             mCameraDevice.setFaceDetectionCallback(null, null);
-            mUI.pauseFaceDetection();
             mCameraDevice.stopFaceDetection();
             mUI.onStopFaceDetection();
         }
diff --git a/src/com/android/camera/VideoUI.java b/src/com/android/camera/VideoUI.java
index 3e24f8510..66e73c60b 100755
--- a/src/com/android/camera/VideoUI.java
+++ b/src/com/android/camera/VideoUI.java
@@ -48,7 +48,6 @@ import android.view.View.OnLayoutChangeListener;
 
 import com.android.camera.CameraManager.CameraProxy;
 import com.android.camera.CameraPreference.OnPreferenceChangedListener;
-import com.android.camera.FocusOverlayManager.FocusUI;
 import com.android.camera.PhotoUI.SurfaceTextureSizeChangedListener;
 import com.android.camera.ui.AbstractSettingPopup;
 import com.android.camera.ui.CameraControls;
@@ -63,17 +62,18 @@ import com.android.camera.ui.RotateImageView;
 import com.android.camera.ui.RotateLayout;
 import com.android.camera.ui.RotateTextToast;
 import com.android.camera.ui.ZoomRenderer;
+import com.android.camera.ui.focus.FocusRing;
 import com.android.camera.util.CameraUtil;
 
 public class VideoUI implements PieRenderer.PieListener,
         PreviewGestures.SingleTapListener,
         CameraRootView.MyDisplayListener,
-        FocusUI,
         SurfaceHolder.Callback,
         PauseButton.OnPauseButtonListener,
         CameraManager.CameraFaceDetectionCallback{
     private static final String TAG = "CAM_VideoUI";
     // module fields
+    private final FocusRing mFocusRing;
     private CameraActivity mActivity;
     private View mRootView;
     private SurfaceHolder mSurfaceHolder;
@@ -246,6 +246,7 @@ public class VideoUI implements PieRenderer.PieListener,
             }
         });
 
+        mFocusRing = (FocusRing) mRootView.findViewById(R.id.focus_ring);
         mFlashOverlay = mRootView.findViewById(R.id.flash_overlay);
         mShutterButton = (ShutterButton) mRootView.findViewById(R.id.shutter_button);
         mSwitcher = (ModuleSwitcher) mRootView.findViewById(R.id.camera_switcher);
@@ -1241,14 +1242,6 @@ public class VideoUI implements PieRenderer.PieListener,
         mFaceView.setFaces(faces);
     }
 
-    public void pauseFaceDetection() {
-        if (mFaceView != null) mFaceView.pause();
-    }
-
-    public void resumeFaceDetection() {
-        if (mFaceView != null) mFaceView.resume();
-    }
-
     public void onStartFaceDetection(int orientation, boolean mirror) {
         mFaceView.setBlockDraw(false);
         mFaceView.clear();
@@ -1265,39 +1258,7 @@ public class VideoUI implements PieRenderer.PieListener,
         }
     }
 
-    // implement focusUI interface
-    private FocusIndicator getFocusIndicator() {
-        return mPieRenderer;
-    }
-
-    @Override
-    public boolean hasFaces() {
-        return false;
-    }
-
-    @Override
-    public void clearFocus() {
-        FocusIndicator indicator = getFocusIndicator();
-        if (indicator != null) indicator.clear();
-    }
-
-    @Override
-    public void setFocusPosition(int x, int y) {
-        mPieRenderer.setFocus(x, y);
-    }
-
-    @Override
-    public void onFocusStarted(){
-        getFocusIndicator().showStart();
-    }
-
-    @Override
-    public void onFocusSucceeded(boolean timeOut) {
-        getFocusIndicator().showSuccess(timeOut);
-    }
-
-    @Override
-    public void onFocusFailed(boolean timeOut) {
-        getFocusIndicator().showFail(timeOut);
+    public FocusRing getFocusRing() {
+        return mFocusRing;
     }
 }
diff --git a/src/com/android/camera/async/HandlerExecutor.java b/src/com/android/camera/async/HandlerExecutor.java
new file mode 100644
index 000000000..87c8c0ce0
--- /dev/null
+++ b/src/com/android/camera/async/HandlerExecutor.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.async;
+
+import java.util.concurrent.Executor;
+
+import android.os.Handler;
+
+/**
+ * An {@link Executor} which posts to a {@link Handler}.
+ */
+public class HandlerExecutor implements Executor {
+    private final Handler mHandler;
+
+    public HandlerExecutor(Handler handler) {
+        mHandler = handler;
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+        mHandler.post(runnable);
+    }
+}
diff --git a/src/com/android/camera/async/MainThread.java b/src/com/android/camera/async/MainThread.java
new file mode 100644
index 000000000..7fdb3ec9b
--- /dev/null
+++ b/src/com/android/camera/async/MainThread.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.async;
+
+import android.os.Handler;
+import android.os.Looper;
+
+public class MainThread extends HandlerExecutor {
+    private MainThread(Handler handler) {
+        super(handler);
+    }
+
+    public static MainThread create() {
+        return new MainThread(new Handler(Looper.getMainLooper()));
+    }
+
+    /**
+     * Caches whether or not the current thread is the main thread.
+     */
+    private static final ThreadLocal<Boolean> sIsMainThread = new ThreadLocal<Boolean>() {
+        @Override
+        protected Boolean initialValue() {
+            return Looper.getMainLooper().getThread() == Thread.currentThread();
+        }
+    };
+
+    /**
+     * Returns true if the method is run on the main android thread.
+     */
+    public static boolean isMainThread() {
+        return sIsMainThread.get();
+    }
+}
diff --git a/src/com/android/camera/ui/focus/AutoFocusRing.java b/src/com/android/camera/ui/focus/AutoFocusRing.java
new file mode 100644
index 000000000..ff09ebc65
--- /dev/null
+++ b/src/com/android/camera/ui/focus/AutoFocusRing.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+
+import com.android.camera.ui.motion.InterpolateUtils;
+import com.android.camera.ui.motion.Invalidator;
+
+/**
+ * Passive focus ring animation renderer.
+ */
+class AutoFocusRing extends FocusRingRenderer {
+    private static final String TAG = "AutoFocusRing";
+
+    /**
+     * The auto focus ring encapsulates the animation logic for visualizing
+     * a focus event when triggered by the camera subsystem.
+     *
+     * @param invalidator the object to invalidate while running.
+     * @param ringPaint the paint to draw the ring with.
+     * @param enterDurationMillis the fade in time in milliseconds.
+     * @param exitDurationMillis the fade out time in milliseconds.
+     */
+    public AutoFocusRing(Invalidator invalidator, Paint ringPaint, float enterDurationMillis,
+          float exitDurationMillis) {
+        super(invalidator, ringPaint, enterDurationMillis, exitDurationMillis);
+    }
+
+    @Override
+    public void draw(long t, long dt, Canvas canvas) {
+        float ringRadius = mRingRadius.update(dt);
+        processStates(t);
+
+        if (!isActive()) {
+            return;
+        }
+
+        mInvalidator.invalidate();
+        int ringAlpha = 255;
+
+        if (mFocusState == FocusState.STATE_ENTER) {
+            float rFade = InterpolateUtils.unitRatio(t, mEnterStartMillis, mEnterDurationMillis);
+            ringAlpha = (int) InterpolateUtils
+                  .lerp(0, 255, mEnterOpacityCurve.valueAt(rFade));
+        } else if (mFocusState == FocusState.STATE_FADE_OUT) {
+            float rFade = InterpolateUtils.unitRatio(t, mExitStartMillis, mExitDurationMillis);
+            ringAlpha = (int) InterpolateUtils
+                  .lerp(255, 0, mExitOpacityCurve.valueAt(rFade));
+        } else if (mFocusState == FocusState.STATE_HARD_STOP) {
+            float rFade = InterpolateUtils
+                  .unitRatio(t, mHardExitStartMillis, mHardExitDurationMillis);
+            ringAlpha = (int) InterpolateUtils
+                  .lerp(255, 0, mExitOpacityCurve.valueAt(rFade));
+        } else if (mFocusState == FocusState.STATE_INACTIVE) {
+            ringAlpha = 0;
+        }
+
+        mRingPaint.setAlpha(ringAlpha);
+        canvas.drawCircle(getCenterX(), getCenterY(), ringRadius, mRingPaint);
+    }
+
+    private void processStates(long t) {
+        if (mFocusState == FocusState.STATE_INACTIVE) {
+            return;
+        }
+
+        if (mFocusState == FocusState.STATE_ENTER && t > mEnterStartMillis + mEnterDurationMillis) {
+            mFocusState = FocusState.STATE_ACTIVE;
+        }
+
+        if (mFocusState == FocusState.STATE_ACTIVE && !mRingRadius.isActive()) {
+            mFocusState = FocusState.STATE_FADE_OUT;
+            mExitStartMillis = t;
+        }
+
+        if (mFocusState == FocusState.STATE_FADE_OUT && t > mExitStartMillis + mExitDurationMillis) {
+            mFocusState = FocusState.STATE_INACTIVE;
+        }
+
+        if (mFocusState == FocusState.STATE_HARD_STOP
+              && t > mHardExitStartMillis + mHardExitDurationMillis) {
+            mFocusState = FocusState.STATE_INACTIVE;
+        }
+    }
+}
diff --git a/src/com/android/camera/ui/focus/CameraCoordinateTransformer.java b/src/com/android/camera/ui/focus/CameraCoordinateTransformer.java
new file mode 100644
index 000000000..809503c9a
--- /dev/null
+++ b/src/com/android/camera/ui/focus/CameraCoordinateTransformer.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.graphics.Matrix;
+import android.graphics.RectF;
+
+/**
+ * Transform coordinates to and from preview coordinate space and camera driver
+ * coordinate space.
+ */
+public class CameraCoordinateTransformer {
+    // http://developer.android.com/guide/topics/media/camera.html#metering-focus-areas
+    private static final RectF CAMERA_DRIVER_RECT = new RectF(-1000, -1000, 1000, 1000);
+
+    private final Matrix mCameraToPreviewTransform;
+    private final Matrix mPreviewToCameraTransform;
+
+    /**
+     * Convert rectangles to / from camera coordinate and preview coordinate space.
+     *
+     * @param mirrorX if the preview is mirrored along the X axis.
+     * @param displayOrientation orientation in degrees.
+     * @param previewRect the preview rectangle size and position.
+     */
+    public CameraCoordinateTransformer(boolean mirrorX, int displayOrientation,
+          RectF previewRect) {
+        if (!hasNonZeroArea(previewRect)) {
+            throw new IllegalArgumentException("previewRect");
+        }
+
+        mCameraToPreviewTransform = cameraToPreviewTransform(mirrorX, displayOrientation,
+              previewRect);
+        mPreviewToCameraTransform = inverse(mCameraToPreviewTransform);
+    }
+
+    /**
+     * Transform a rectangle in camera space into a new rectangle in preview
+     * view space.
+     *
+     * @param source the rectangle in camera space
+     * @return the rectangle in preview view space.
+     */
+    public RectF toPreviewSpace(RectF source) {
+        RectF result = new RectF();
+        mCameraToPreviewTransform.mapRect(result, source);
+        return result;
+    }
+
+    /**
+     * Transform a rectangle in preview view space into a new rectangle in
+     * camera view space.
+     *
+     * @param source the rectangle in preview view space
+     * @return the rectangle in camera view space.
+     */
+    public RectF toCameraSpace(RectF source) {
+        RectF result = new RectF();
+        mPreviewToCameraTransform.mapRect(result, source);
+        return result;
+    }
+
+    private Matrix cameraToPreviewTransform(boolean mirrorX, int displayOrientation,
+          RectF previewRect) {
+        Matrix transform = new Matrix();
+
+        // Need mirror for front camera.
+        transform.setScale(mirrorX ? -1 : 1, 1);
+
+        // Apply a rotate transform.
+        // This is the value for android.hardware.Camera.setDisplayOrientation.
+        transform.postRotate(displayOrientation);
+
+        // Map camera driver coordinates to preview rect coordinates
+        Matrix fill = new Matrix();
+        fill.setRectToRect(CAMERA_DRIVER_RECT,
+              previewRect,
+              Matrix.ScaleToFit.FILL);
+
+        // Concat the previous transform on top of the fill behavior.
+        transform.setConcat(fill, transform);
+
+        return transform;
+    }
+
+    private Matrix inverse(Matrix source) {
+        Matrix newMatrix = new Matrix();
+        source.invert(newMatrix);
+        return newMatrix;
+    }
+
+    private boolean hasNonZeroArea(RectF rect) {
+        return rect.width() != 0 && rect.height() != 0;
+    }
+}
diff --git a/src/com/android/camera/ui/focus/FocusController.java b/src/com/android/camera/ui/focus/FocusController.java
new file mode 100644
index 000000000..a0c103443
--- /dev/null
+++ b/src/com/android/camera/ui/focus/FocusController.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.graphics.RectF;
+import android.util.Log;
+
+import com.android.camera.async.MainThread;
+import com.android.camera.ui.motion.LinearScale;
+
+/**
+ * The focus controller interacts with the focus ring UI element.
+ */
+public class FocusController {
+    private static final String TAG = "FocusController";
+
+    private final FocusRing mFocusRing;
+    private final FocusSound mFocusSound;
+    private final MainThread mMainThread;
+
+    public FocusController(FocusRing focusRing, FocusSound focusSound, MainThread mainThread) {
+        mFocusRing = focusRing;
+        mFocusSound = focusSound;
+        mMainThread = mainThread;
+    }
+
+    /**
+     * Show a passive focus animation at the center of the active area.
+     * This will likely be different than the view bounds due to varying image
+     * ratios and dimensions.
+     */
+    public void showPassiveFocusAtCenter() {
+        mMainThread.execute(new Runnable() {
+            @Override
+            public void run() {
+                Log.v(TAG, "Running showPassiveFocusAtCenter()");
+                mFocusRing.startPassiveFocus();
+                mFocusRing.centerFocusLocation();
+            }
+        });
+    }
+
+    /**
+     * Show a passive focus animation at the given viewX and viewY position.
+     * This is usually indicates the camera subsystem kicked off an auto-focus
+     * at the given screen position.
+     *
+     * @param viewX the view's x coordinate
+     * @param viewY the view's y coordinate
+     */
+    public void showPassiveFocusAt(final int viewX, final int viewY) {
+        mMainThread.execute(new Runnable() {
+            @Override
+            public void run() {
+                Log.v(TAG, "Running showPassiveFocusAt(" + viewX + ", " + viewY + ")");
+                mFocusRing.startPassiveFocus();
+                mFocusRing.setFocusLocation(viewX, viewY);
+            }
+        });
+    }
+
+    /**
+     * Show an active focus animation at the given viewX and viewY position.
+     * This is normally initiated by the user touching the screen at a given
+     * point.
+     *
+     * @param viewX the view's x coordinate
+     * @param viewY the view's y coordinate
+     */
+    public void showActiveFocusAt(final int viewX, final int viewY) {
+        mMainThread.execute(new Runnable() {
+            @Override
+            public void run() {
+                Log.v(TAG, "showActiveFocusAt(" + viewX + ", " + viewY + ")");
+                mFocusRing.startActiveFocus();
+                mFocusRing.setFocusLocation(viewX, viewY);
+
+                // TODO: Enable focus sound when better audio controls exist.
+                // mFocusSound.play();
+            }
+        });
+    }
+
+    /**
+     * Computing the correct location for the focus ring requires knowing
+     * the screen position and size of the preview area so the drawing
+     * operations can be clipped correctly.
+     */
+    public void configurePreviewDimensions(final RectF previewArea) {
+        mMainThread.execute(new Runnable() {
+            @Override
+            public void run() {
+               Log.v(TAG, "configurePreviewDimensions(" + previewArea + ")");
+               mFocusRing.configurePreviewDimensions(previewArea);
+            }
+        });
+    }
+
+    /**
+     * Set the radius of the focus ring as a radius between 0 and 1.
+     * This will map to the min and max values computed for the UI.
+     */
+    public void setFocusRatio(final float ratio) {
+        mMainThread.execute(new Runnable() {
+            @Override
+            public void run() {
+                if (mFocusRing.isPassiveFocusRunning() ||
+                      mFocusRing.isActiveFocusRunning()) {
+                    mFocusRing.setRadiusRatio(ratio);
+                }
+            }
+        });
+    }
+}
diff --git a/src/com/android/camera/ui/focus/FocusRing.java b/src/com/android/camera/ui/focus/FocusRing.java
new file mode 100644
index 000000000..89de357ad
--- /dev/null
+++ b/src/com/android/camera/ui/focus/FocusRing.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.graphics.RectF;
+
+/**
+ * Primary interface for interacting with the focus ring UI.
+ */
+public interface FocusRing {
+    /**
+     * Check the state of the passive focus ring animation.
+     *
+     * @return whether the passive focus animation is running.
+     */
+    public boolean isPassiveFocusRunning();
+    /**
+     * Check the state of the active focus ring animation.
+     *
+     * @return whether the active focus animation is running.
+     */
+    public boolean isActiveFocusRunning();
+    /**
+     * Start a passive focus animation.
+     */
+    public void startPassiveFocus();
+    /**
+     * Start an active focus animation.
+     */
+    public void startActiveFocus();
+    /**
+     * Stop any currently running focus animations.
+     */
+    public void stopFocusAnimations();
+    /**
+     * Set the location of the focus ring animation center.
+     */
+    public void setFocusLocation(float viewX, float viewY);
+
+    /**
+     * Set the location of the focus ring animation center.
+     */
+    public void centerFocusLocation();
+
+    /**
+     * Set the target radius as a ratio of min to max visible radius
+     * which will internally convert and clamp the value to the
+     * correct pixel radius.
+     */
+    public void setRadiusRatio(float ratio);
+
+    /**
+     * The physical size of preview can vary and does not map directly
+     * to the size of the view. This allows for conversions between view
+     * and preview space for values that are provided in preview space.
+     */
+    void configurePreviewDimensions(RectF previewArea);
+}
\ No newline at end of file
diff --git a/src/com/android/camera/ui/focus/FocusRingRenderer.java b/src/com/android/camera/ui/focus/FocusRingRenderer.java
new file mode 100644
index 000000000..264af2ace
--- /dev/null
+++ b/src/com/android/camera/ui/focus/FocusRingRenderer.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.graphics.Paint;
+import android.util.Log;
+
+import com.android.camera.ui.motion.DampedSpring;
+import com.android.camera.ui.motion.DynamicAnimation;
+import com.android.camera.ui.motion.Invalidator;
+import com.android.camera.ui.motion.UnitCurve;
+import com.android.camera.ui.motion.UnitCurves;
+
+/**
+ * Base class for defining the focus ring states, enter and exit durations, and
+ * positioning logic.
+ */
+abstract class FocusRingRenderer implements DynamicAnimation {
+    private static final String TAG = "FocusRingRenderer";
+
+    /**
+     * Primary focus states that a focus ring renderer can go through.
+     */
+    protected static enum FocusState {
+        STATE_INACTIVE,
+        STATE_ENTER,
+        STATE_ACTIVE,
+        STATE_FADE_OUT,
+        STATE_HARD_STOP,
+    }
+
+    protected final Invalidator mInvalidator;
+    protected final Paint mRingPaint;
+    protected final DampedSpring mRingRadius;
+    protected final UnitCurve mEnterOpacityCurve;
+    protected final UnitCurve mExitOpacityCurve;
+    protected final UnitCurve mHardExitOpacityCurve;
+    protected final float mEnterDurationMillis;
+    protected final float mExitDurationMillis;
+    protected final float mHardExitDurationMillis = 64;
+
+    private int mCenterX;
+    private int mCenterY;
+    protected long mEnterStartMillis = 0;
+    protected long mExitStartMillis = 0;
+    protected long mHardExitStartMillis = 0;
+
+    protected FocusState mFocusState = FocusState.STATE_INACTIVE;
+
+    /**
+     * A dynamic, configurable, self contained ring render that will inform
+     * via invalidation if it should continue to be receive updates
+     * and re-draws.
+     *
+     * @param invalidator the object to inform if it requires more draw calls.
+     * @param ringPaint the paint to use to draw the ring.
+     * @param enterDurationMillis the fade in duration in milliseconds
+     * @param exitDurationMillis the fade out duration in milliseconds.
+     */
+    FocusRingRenderer(Invalidator invalidator, Paint ringPaint, float enterDurationMillis,
+          float exitDurationMillis) {
+        mInvalidator = invalidator;
+        mRingPaint = ringPaint;
+        mEnterDurationMillis = enterDurationMillis;
+        mExitDurationMillis = exitDurationMillis;
+
+        mEnterOpacityCurve = UnitCurves.FAST_OUT_SLOW_IN;
+        mExitOpacityCurve = UnitCurves.FAST_OUT_LINEAR_IN;
+        mHardExitOpacityCurve = UnitCurves.FAST_OUT_LINEAR_IN;
+
+        mRingRadius = new DampedSpring();
+    }
+
+    /**
+     * Set the centerX position for this focus ring renderer.
+     *
+     * @param value the x position
+     */
+    public void setCenterX(int value) {
+        mCenterX = value;
+    }
+
+    protected int getCenterX() {
+        return mCenterX;
+    }
+
+    /**
+     * Set the centerY position for this focus ring renderer.
+     *
+     * @param value the y position
+     */
+    public void setCenterY(int value) {
+        mCenterY = value;
+    }
+
+    protected int getCenterY() {
+        return mCenterY;
+    }
+
+    /**
+     * Set the physical radius of this ring.
+     *
+     * @param value the radius of the ring.
+     */
+    public void setRadius(long tMs, float value) {
+        if (mFocusState == FocusState.STATE_FADE_OUT
+              && Math.abs(mRingRadius.getTarget() - value) > 0.1) {
+            Log.v(TAG, "FOCUS STATE ENTER VIA setRadius(" + tMs + ", " + value + ")");
+            mFocusState = FocusState.STATE_ENTER;
+            mEnterStartMillis = computeEnterStartTimeMillis(tMs, mEnterDurationMillis);
+        }
+
+        mRingRadius.setTarget(value);
+    }
+
+    /**
+     * returns true if the renderer is not in an inactive state.
+     */
+    @Override
+    public boolean isActive() {
+        return mFocusState != FocusState.STATE_INACTIVE;
+    }
+
+    /**
+     * returns true if the renderer is in an exit state.
+     */
+    public boolean isExiting() {
+        return mFocusState == FocusState.STATE_FADE_OUT
+              || mFocusState == FocusState.STATE_HARD_STOP;
+    }
+
+    /**
+     * returns true if the renderer is in an enter state.
+     */
+    public boolean isEntering() {
+        return mFocusState == FocusState.STATE_ENTER;
+    }
+
+    /**
+     * Initialize and start the animation with the given start and
+     * target radius.
+     */
+    public void start(long startMs, float initialRadius, float targetRadius) {
+        if (mFocusState != FocusState.STATE_INACTIVE) {
+            Log.w(TAG, "start() called while the ring was still focusing!");
+        }
+        mRingRadius.stop();
+        mRingRadius.setValue(initialRadius);
+        mRingRadius.setTarget(targetRadius);
+        mEnterStartMillis = startMs;
+
+        mFocusState = FocusState.STATE_ENTER;
+        mInvalidator.invalidate();
+    }
+
+    /**
+     * Put the animation in the exit state regardless of the current
+     * dynamic transition. If the animation is currently in an enter state
+     * this will compute an exit start time such that the exit time lines
+     * up with the enter time at the current transition value.
+     *
+     * @param t the current animation time.
+     */
+    public void exit(long t) {
+        if (mRingRadius.isActive()) {
+            mRingRadius.stop();
+        }
+
+        mFocusState = FocusState.STATE_FADE_OUT;
+        mExitStartMillis = computeExitStartTimeMs(t, mExitDurationMillis);
+    }
+
+    /**
+     * Put the animation in the hard stop state regardless of the current
+     * dynamic transition. If the animation is currently in an enter state
+     * this will compute an exit start time such that the exit time lines
+     * up with the enter time at the current transition value.
+     *
+     * @param tMillis the current animation time in milliseconds.
+     */
+    public void stop(long tMillis) {
+        if (mRingRadius.isActive()) {
+            mRingRadius.stop();
+        }
+
+        mFocusState = FocusState.STATE_HARD_STOP;
+        mHardExitStartMillis = computeExitStartTimeMs(tMillis, mHardExitDurationMillis);
+    }
+
+    private long computeExitStartTimeMs(long tMillis, float exitDuration) {
+        if (mEnterStartMillis + mEnterDurationMillis <= tMillis) {
+            return tMillis;
+        }
+
+        // Compute the current progress on the enter animation.
+        float enterT = (tMillis - mEnterStartMillis) / mEnterDurationMillis;
+
+        // Find a time on the exit curve such that it will produce the same value.
+        float exitT = UnitCurves.mapEnterCurveToExitCurveAtT(mEnterOpacityCurve, mExitOpacityCurve,
+              enterT);
+
+        // Compute the a start time before tMs such that the ratio of time completed
+        // equals the computed exit curve animation position.
+        return tMillis - (long) (exitT * exitDuration);
+    }
+
+    private long computeEnterStartTimeMillis(long tMillis, float enterDuration) {
+        if (mExitStartMillis + mExitDurationMillis <= tMillis) {
+            return tMillis;
+        }
+
+        // Compute the current progress on the enter animation.
+        float exitT = (tMillis - mExitStartMillis) / mExitDurationMillis;
+
+        // Find a time on the exit curve such that it will produce the same value.
+        float enterT = UnitCurves.mapEnterCurveToExitCurveAtT(mExitOpacityCurve, mEnterOpacityCurve,
+              exitT);
+
+        // Compute the a start time before tMs such that the ratio of time completed
+        // equals the computed exit curve animation position.
+        return tMillis - (long) (enterT * enterDuration);
+    }
+}
diff --git a/src/com/android/camera/ui/focus/FocusRingView.java b/src/com/android/camera/ui/focus/FocusRingView.java
new file mode 100644
index 000000000..14a7f6cc9
--- /dev/null
+++ b/src/com/android/camera/ui/focus/FocusRingView.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.RectF;
+import android.graphics.Region;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+
+import com.android.camera.ui.motion.AnimationClock.SystemTimeClock;
+import com.android.camera.ui.motion.DynamicAnimator;
+import com.android.camera.ui.motion.Invalidator;
+import com.android.camera.ui.motion.LinearScale;
+
+import org.codeaurora.snapcam.R;
+
+/**
+ * Custom view for running the focus ring animations.
+ */
+public class FocusRingView extends View implements Invalidator, FocusRing {
+    private static final String TAG = "FocusRingView";
+    private static final float FADE_IN_DURATION_MILLIS = 1000f;
+    private static final float FADE_OUT_DURATION_MILLIS = 250f;
+
+    private final AutoFocusRing mAutoFocusRing;
+    private final ManualFocusRing mManualFocusRing;
+    private final DynamicAnimator mAnimator;
+    private final LinearScale mRatioScale;
+    private final float mDefaultRadiusPx;
+
+    private FocusRingRenderer currentFocusAnimation;
+    private boolean isFirstDraw;
+    private float mLastRadiusPx;
+
+    private RectF mPreviewSize;
+
+    public FocusRingView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        Resources res = getResources();
+        Paint paint = makePaint(res, R.color.focus_color);
+
+        float focusCircleMinSize = res.getDimensionPixelSize(R.dimen.focus_circle_min_size);
+        float focusCircleMaxSize = res.getDimensionPixelSize(R.dimen.focus_circle_max_size);
+        mDefaultRadiusPx = res.getDimensionPixelSize(R.dimen.focus_circle_initial_size);
+
+        mRatioScale = new LinearScale(0, 1, focusCircleMinSize, focusCircleMaxSize);
+        mAnimator = new DynamicAnimator(this, new SystemTimeClock());
+
+        mAutoFocusRing = new AutoFocusRing(mAnimator, paint,
+              FADE_IN_DURATION_MILLIS,
+              FADE_OUT_DURATION_MILLIS);
+        mManualFocusRing = new ManualFocusRing(mAnimator, paint,
+              FADE_OUT_DURATION_MILLIS);
+
+        mAnimator.animations.add(mAutoFocusRing);
+        mAnimator.animations.add(mManualFocusRing);
+
+        isFirstDraw = true;
+        mLastRadiusPx = mDefaultRadiusPx;
+    }
+
+    @Override
+    public boolean isPassiveFocusRunning() {
+        return mAutoFocusRing.isActive();
+    }
+
+    @Override
+    public boolean isActiveFocusRunning() {
+        return mManualFocusRing.isActive();
+    }
+
+    @Override
+    public void startPassiveFocus() {
+        mAnimator.invalidate();
+        long tMs = mAnimator.getTimeMillis();
+
+        if (mManualFocusRing.isActive() && !mManualFocusRing.isExiting()) {
+            mManualFocusRing.stop(tMs);
+        }
+
+        mAutoFocusRing.start(tMs, mLastRadiusPx, mLastRadiusPx);
+        currentFocusAnimation = mAutoFocusRing;
+    }
+
+    @Override
+    public void startActiveFocus() {
+        mAnimator.invalidate();
+        long tMs = mAnimator.getTimeMillis();
+
+        if (mAutoFocusRing.isActive() && !mAutoFocusRing.isExiting()) {
+            mAutoFocusRing.stop(tMs);
+        }
+
+        mManualFocusRing.start(tMs, 0.0f, mLastRadiusPx);
+        currentFocusAnimation = mManualFocusRing;
+    }
+
+    @Override
+    public void stopFocusAnimations() {
+        long tMs = mAnimator.getTimeMillis();
+        if (mManualFocusRing.isActive() && !mManualFocusRing.isExiting()
+              && !mManualFocusRing.isEntering()) {
+            mManualFocusRing.exit(tMs);
+        }
+
+        if (mAutoFocusRing.isActive() && !mAutoFocusRing.isExiting()) {
+            mAutoFocusRing.exit(tMs);
+        }
+    }
+
+    @Override
+    public void setFocusLocation(float viewX, float viewY) {
+        mAutoFocusRing.setCenterX((int) viewX);
+        mAutoFocusRing.setCenterY((int) viewY);
+        mManualFocusRing.setCenterX((int) viewX);
+        mManualFocusRing.setCenterY((int) viewY);
+    }
+
+    @Override
+    public void centerFocusLocation() {
+        Point center = computeCenter();
+        mAutoFocusRing.setCenterX(center.x);
+        mAutoFocusRing.setCenterY(center.y);
+        mManualFocusRing.setCenterX(center.x);
+        mManualFocusRing.setCenterY(center.y);
+    }
+
+    @Override
+    public void setRadiusRatio(float ratio) {
+        setRadius(mRatioScale.scale(mRatioScale.clamp(ratio)));
+    }
+
+    @Override
+    public void configurePreviewDimensions(RectF previewArea) {
+        mPreviewSize = previewArea;
+        mLastRadiusPx = mDefaultRadiusPx;
+
+        if (!isFirstDraw) {
+            centerAutofocusRing();
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (isFirstDraw) {
+            isFirstDraw = false;
+            centerAutofocusRing();
+        }
+
+        if (mPreviewSize != null) {
+            canvas.clipRect(mPreviewSize, Region.Op.REPLACE);
+        }
+
+        mAnimator.draw(canvas);
+    }
+
+    private void setRadius(float radiusPx) {
+        long tMs = mAnimator.getTimeMillis();
+        // Some devices return zero for invalid or "unknown" diopter values.
+        if (currentFocusAnimation != null && radiusPx > 0.1f) {
+            currentFocusAnimation.setRadius(tMs, radiusPx);
+            mLastRadiusPx = radiusPx;
+        }
+    }
+
+    private void centerAutofocusRing() {
+        Point center = computeCenter();
+        mAutoFocusRing.setCenterX(center.x);
+        mAutoFocusRing.setCenterY(center.y);
+    }
+
+    private Point computeCenter() {
+        if (mPreviewSize != null && (mPreviewSize.width() * mPreviewSize.height() > 0.01f)) {
+            Log.i(TAG, "Computing center via preview size.");
+            return new Point((int) mPreviewSize.centerX(), (int) mPreviewSize.centerY());
+        }
+        Log.i(TAG, "Computing center via view bounds.");
+        return new Point(getWidth() / 2, getHeight() / 2);
+    }
+
+    private Paint makePaint(Resources res, int color) {
+        Paint paint = new Paint();
+        paint.setAntiAlias(true);
+        paint.setColor(res.getColor(color));
+        paint.setStyle(Paint.Style.STROKE);
+        paint.setStrokeCap(Paint.Cap.ROUND);
+        paint.setStrokeWidth(res.getDimension(R.dimen.focus_circle_stroke));
+        return paint;
+    }
+}
diff --git a/src/com/android/camera/ui/focus/FocusSound.java b/src/com/android/camera/ui/focus/FocusSound.java
new file mode 100644
index 000000000..c3ff0107d
--- /dev/null
+++ b/src/com/android/camera/ui/focus/FocusSound.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import com.android.camera.SoundPlayer;
+
+/**
+ * Wraps the focus sound and the player into a single object that can
+ * be played on demand.
+ *
+ * TODO: This needs some way to better manage the sound lifetimes
+ */
+public class FocusSound {
+    private static final float DEFAULT_VOLUME = 0.6f;
+    private final SoundPlayer mPlayer;
+    private final int mSoundId;
+    public FocusSound(SoundPlayer player, int soundId) {
+        mPlayer = player;
+        mSoundId = soundId;
+
+        mPlayer.loadSound(mSoundId);
+    }
+
+    /**
+     * Play the focus sound with the sound player at the default
+     * volume.
+     */
+    public void play() {
+        if(!mPlayer.isReleased()) {
+            mPlayer.play(mSoundId, DEFAULT_VOLUME);
+        }
+    }
+}
diff --git a/src/com/android/camera/ui/focus/LensRangeCalculator.java b/src/com/android/camera/ui/focus/LensRangeCalculator.java
new file mode 100644
index 000000000..ef9cbaec7
--- /dev/null
+++ b/src/com/android/camera/ui/focus/LensRangeCalculator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.annotation.TargetApi;
+import android.hardware.camera2.CameraCharacteristics;
+import android.os.Build.VERSION_CODES;
+
+import com.android.camera.ui.motion.LinearScale;
+
+/**
+ * Compute diopter range scale to convert lens focus distances into
+ * a ratio value.
+ */
+@TargetApi(VERSION_CODES.LOLLIPOP)
+public class LensRangeCalculator {
+
+    /**
+     * A NoOp linear scale for computing diopter values will always return 0
+     */
+    public static LinearScale getNoOp() {
+        return new LinearScale(0, 0, 0, 0);
+    }
+
+    /**
+     * Compute the focus range from the camera characteristics and build
+     * a linear scale model that maps a focus distance to a ratio between
+     * the min and max range.
+     */
+    public static LinearScale getDiopterToRatioCalculator(CameraCharacteristics characteristics) {
+        // From the android documentation:
+        //
+        // 0.0f represents farthest focus, and LENS_INFO_MINIMUM_FOCUS_DISTANCE
+        // represents the nearest focus the device can achieve.
+        //
+        // Example:
+        //
+        // Infinity    Hyperfocal                 Minimum   Camera
+        //  <----------|-----------------------------|         |
+        // [0.0]     [0.31]                       [14.29]
+        Float nearest = characteristics.get(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE);
+        Float hyperfocal = characteristics.get(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE);
+
+        if (nearest == null && hyperfocal == null) {
+            return getNoOp();
+        }
+
+        nearest = (nearest == null) ? 0.0f : nearest;
+        hyperfocal = (hyperfocal == null) ? 0.0f : hyperfocal;
+
+        if (nearest > hyperfocal) {
+            return new LinearScale(hyperfocal, nearest, 0, 1);
+        }
+
+        return new LinearScale(nearest, hyperfocal, 0, 1);
+    }
+}
diff --git a/src/com/android/camera/ui/focus/ManualFocusRing.java b/src/com/android/camera/ui/focus/ManualFocusRing.java
new file mode 100644
index 000000000..0133d8e09
--- /dev/null
+++ b/src/com/android/camera/ui/focus/ManualFocusRing.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.focus;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+
+import com.android.camera.ui.motion.InterpolateUtils;
+import com.android.camera.ui.motion.Invalidator;
+
+/**
+ * Manual focus ring animation renderer.
+ */
+class ManualFocusRing extends FocusRingRenderer {
+    /**
+     * The manual focus ring encapsulates the animation logic for visualizing
+     * a focus event when triggered by a physical screen touch.
+     *
+     * @param invalidator the object to invalidate while running.
+     * @param ringPaint the paint to draw the ring with.
+     * @param exitDurationMillis the fade out time in milliseconds.
+     */
+    public ManualFocusRing(Invalidator invalidator, Paint ringPaint,
+          float exitDurationMillis) {
+        super(invalidator, ringPaint, 0.0f, exitDurationMillis);
+    }
+
+    @Override
+    public void draw(long t, long dt, Canvas canvas) {
+        float ringRadius = mRingRadius.update(dt);
+        processStates(t);
+
+        if (!isActive()) {
+            return;
+        }
+
+        mInvalidator.invalidate();
+        int ringAlpha = 255;
+
+        if (mFocusState == FocusState.STATE_FADE_OUT) {
+            float rFade = InterpolateUtils.unitRatio(t, mExitStartMillis, mExitDurationMillis);
+            ringAlpha = (int) InterpolateUtils.lerp(255, 0, mExitOpacityCurve.valueAt(rFade));
+        } else if (mFocusState == FocusState.STATE_HARD_STOP) {
+            float rFade = InterpolateUtils.unitRatio(t, mHardExitStartMillis,
+                  mHardExitDurationMillis);
+            ringAlpha = (int) InterpolateUtils.lerp(255, 0, mExitOpacityCurve.valueAt(rFade));
+        } else if (mFocusState == FocusState.STATE_INACTIVE) {
+            ringAlpha = 0;
+        }
+
+        mRingPaint.setAlpha(ringAlpha);
+        canvas.drawCircle(getCenterX(), getCenterY(), ringRadius, mRingPaint);
+    }
+
+    private void processStates(long t) {
+        if (mFocusState == FocusState.STATE_INACTIVE) {
+            return;
+        }
+
+        if (mFocusState == FocusState.STATE_ENTER
+              && (t > mEnterStartMillis + mEnterDurationMillis)) {
+            mFocusState = FocusState.STATE_ACTIVE;
+        }
+
+        if (mFocusState == FocusState.STATE_ACTIVE && !mRingRadius.isActive()) {
+            mFocusState = FocusState.STATE_FADE_OUT;
+            mExitStartMillis = t;
+        }
+
+        if (mFocusState == FocusState.STATE_FADE_OUT && t > mExitStartMillis + mExitDurationMillis) {
+            mFocusState = FocusState.STATE_INACTIVE;
+        }
+
+        if (mFocusState == FocusState.STATE_HARD_STOP
+              && t > mHardExitStartMillis + mHardExitDurationMillis) {
+            mFocusState = FocusState.STATE_INACTIVE;
+        }
+    }
+}
diff --git a/src/com/android/camera/ui/motion/AnimationClock.java b/src/com/android/camera/ui/motion/AnimationClock.java
new file mode 100644
index 000000000..d2504de6b
--- /dev/null
+++ b/src/com/android/camera/ui/motion/AnimationClock.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+import android.os.SystemClock;
+
+/**
+ * Wraps the SystemClock static time methods so they can be exercised in tests.
+ */
+public abstract class AnimationClock {
+
+    public abstract long getTimeMillis();
+
+    /**
+     * Forwards calls to SystemClock.uptimeMillis() since it is the most consistent clock for
+     * animations.
+     */
+    public static class SystemTimeClock extends AnimationClock {
+
+        @Override
+        public long getTimeMillis() {
+            return SystemClock.uptimeMillis();
+        }
+    }
+}
diff --git a/src/com/android/camera/ui/motion/DampedSpring.java b/src/com/android/camera/ui/motion/DampedSpring.java
new file mode 100644
index 000000000..84cbfa6f8
--- /dev/null
+++ b/src/com/android/camera/ui/motion/DampedSpring.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * This models a value after the behavior of a spring. The value tracks the current value, a target
+ * value, and the current velocity and applies both a directional force and a damping force to the
+ * value on each update call.
+ */
+public class DampedSpring {
+    public static final float DEFAULT_TIME_TO_90_PERCENT_MILLIS = 200.0f;
+    public static final float DEFAULT_SPRING_STIFFNESS = 3.75f;
+    public static final float EPSILON = 0.01f;
+
+    private final float mSpringStiffness;
+    private final float mTimeTo90PercentMs;
+
+    private float mTarget = 0f;
+    private float mVelocity = 0f;
+    private float mValue = 0f;
+
+    public DampedSpring() {
+        this(DEFAULT_TIME_TO_90_PERCENT_MILLIS, DEFAULT_SPRING_STIFFNESS);
+    }
+
+    public DampedSpring(float timeTo90PercentMs) {
+        this(timeTo90PercentMs, DEFAULT_SPRING_STIFFNESS);
+    }
+
+    public DampedSpring(float timeTo90PercentMs, float springStiffness) {
+        // TODO: Assert timeTo90PercentMs >= 1ms, it might behave badly at low values.
+        // TODO: Assert springStiffness > 2.0f
+
+        mTimeTo90PercentMs = timeTo90PercentMs;
+        mSpringStiffness = springStiffness;
+
+        if (springStiffness > timeTo90PercentMs) {
+            throw new IllegalArgumentException("Creating a spring value with "
+                  + "excessive stiffness will oscillate endlessly.");
+        }
+    }
+
+    /**
+     * @return the current value.
+     */
+    public float getValue() {
+        return mValue;
+    }
+
+    /**
+     * @param value the value to set this instance's current state too.
+     */
+    public void setValue(float value) {
+        mValue = value;
+    }
+
+    /**
+     * @return the current target value.
+     */
+    public float getTarget() {
+        return mTarget;
+    }
+
+    /**
+     * Set a target value. The current value will maintain any existing velocity values and will
+     * move towards the new target value. To forcibly stopAt the value use the stopAt() method.
+     *
+     * @param value the new value to move the current value towards.
+     */
+    public void setTarget(float value) {
+        mTarget = value;
+    }
+
+    /**
+     * Update the current value, moving it towards the actual value over the given
+     * time delta (in milliseconds) since the last update. This works off of the
+     * principle of a critically damped spring such that any given current value
+     * will move elastically towards the target value. The current value maintains
+     * and applies velocity, acceleration, and a damping force to give a continuous,
+     * smooth transition towards the target value.
+     *
+     * @param dtMs the time since the last update, or zero.
+     * @return the current value after the update occurs.
+     */
+    public float update(float dtMs) {
+        float dt = dtMs / mTimeTo90PercentMs;
+        float dts = dt * mSpringStiffness;
+
+        // If the dts > 1, and the velocity is zero, the force will exceed the
+        // distance to the target value and it will overshoot the value, causing
+        // weird behavior and unintended oscillation. since a critically damped
+        // spring should never overshoot the value, simply the current value to the
+        // target value.
+        if (dts > 1.0f || dts < 0.0f) {
+            stop();
+            return mValue;
+        }
+
+        float delta = (mTarget - mValue);
+        float force = delta - 2.0f * mVelocity;
+
+        mVelocity += force * dts;
+        mValue += mVelocity * dts;
+
+        // If we get close enough to the actual value, simply set the current value
+        // to the current target value and stop.
+        if (!isActive()) {
+            stop();
+        }
+
+        return mValue;
+    }
+
+    /**
+     * @return true if this instance has velocity or it is not at the target value.
+     */
+    public boolean isActive() {
+        boolean hasVelocity = Math.abs(mVelocity) >= EPSILON;
+        boolean atTarget = Math.abs(mTarget - mValue) < EPSILON;
+        return hasVelocity || !atTarget;
+    }
+
+    /**
+     * Stop the spring motion wherever it is currently at. Sets target to the
+     * current value and sets the velocity to zero.
+     */
+    public void stop() {
+        mTarget = mValue;
+        mVelocity = 0.0f;
+    }
+}
diff --git a/src/com/android/camera/ui/motion/DynamicAnimation.java b/src/com/android/camera/ui/motion/DynamicAnimation.java
new file mode 100644
index 000000000..57d5a1021
--- /dev/null
+++ b/src/com/android/camera/ui/motion/DynamicAnimation.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+import android.graphics.Canvas;
+
+/**
+ * Rendering object that can be driven by an animator instance.
+ */
+public interface DynamicAnimation {
+
+    /**
+     * Check to determine if this animation is currently in a stable state.
+     *
+     * @return true if the animation is stable, false if it should continue to be redrawn.
+     */
+    boolean isActive();
+
+    /**
+     * Update and draw the animation onto the given canvas.
+     *
+     * @param t current animation frame time.
+     * @param dt delta since the last update.
+     * @param canvas the canvas to draw the animation onto.
+     */
+    void draw(long t, long dt, Canvas canvas);
+}
diff --git a/src/com/android/camera/ui/motion/DynamicAnimator.java b/src/com/android/camera/ui/motion/DynamicAnimator.java
new file mode 100644
index 000000000..542ac1e37
--- /dev/null
+++ b/src/com/android/camera/ui/motion/DynamicAnimator.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+import android.graphics.Canvas;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Designed to handle the lifecycle of a view that needs a continuous update /
+ * redraw cycle that does not have a defined start / end time.
+ *
+ * Fixed length animations should NOT use this class.
+ */
+public class DynamicAnimator implements Invalidator {
+
+    public final List<DynamicAnimation> animations = new ArrayList<>();
+
+    private final Invalidator mInvalidator;
+    private final AnimationClock mClock;
+
+    private boolean mUpdateRequested = false;
+    private boolean mIsDrawing = false;
+    private long mLastDrawTimeMillis = 0;
+    private long mDrawTimeMillis = 0;
+
+    public DynamicAnimator(Invalidator invalidator, AnimationClock clock) {
+        mInvalidator = invalidator;
+        mClock = clock;
+    }
+
+    public void draw(Canvas canvas) {
+        mIsDrawing = true;
+        mUpdateRequested = false;
+
+        mDrawTimeMillis = mClock.getTimeMillis();
+
+        if (mLastDrawTimeMillis <= 0) {
+            mLastDrawTimeMillis = mDrawTimeMillis; // On the initial draw, dt is zero.
+        }
+
+        long dt = mDrawTimeMillis - mLastDrawTimeMillis;
+        mLastDrawTimeMillis = mDrawTimeMillis;
+
+        // Run the animation
+        for (DynamicAnimation renderer : animations) {
+            if (renderer.isActive()) {
+                renderer.draw(mDrawTimeMillis, dt, canvas);
+            }
+        }
+
+        // If either the update or the draw methods requested new frames, then
+        // invalidate the view which should give us another frame to work with.
+        // Otherwise, stopAt the last update time.
+        if (mUpdateRequested) {
+            mInvalidator.invalidate();
+        } else {
+            mLastDrawTimeMillis = -1;
+        }
+
+        mIsDrawing = false;
+    }
+
+    /**
+     * If a scheduleNewFrame request comes in outside of the animation loop,
+     * and we didn't schedule a frame after the previous loop (or it's the
+     * first time we've used this instance), invalidate the view and set the
+     * last update time to the current time. Theoretically, a few milliseconds
+     * have elapsed before the view gets updated.
+     */
+    @Override
+    public void invalidate() {
+        if (!mIsDrawing && !mUpdateRequested) {
+            mInvalidator.invalidate();
+            mLastDrawTimeMillis = mClock.getTimeMillis();
+        }
+
+        mUpdateRequested = true;
+    }
+
+    /**
+     * This will return the "best guess" for the most current animation frame
+     * time.  If the loop is currently drawing, then it will return the time the
+     * draw began, and if an update is currently requested it will return the
+     * time that the update was requested at, and if neither of these are true
+     * it will return the current system clock time.
+     *
+     * This method will not trigger a new update.
+     */
+    public long getTimeMillis() {
+        if (mIsDrawing) {
+            return mDrawTimeMillis;
+        }
+
+        if (mUpdateRequested) {
+            return mLastDrawTimeMillis;
+        }
+
+        return mClock.getTimeMillis();
+    }
+}
diff --git a/src/com/android/camera/ui/motion/InterpolateUtils.java b/src/com/android/camera/ui/motion/InterpolateUtils.java
new file mode 100644
index 000000000..3c3cd532f
--- /dev/null
+++ b/src/com/android/camera/ui/motion/InterpolateUtils.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * Various static helper functions for interpolating between values.
+ */
+public class InterpolateUtils {
+
+    private InterpolateUtils() {
+    }
+
+    /**
+     * Linear interpolation from v0 to v1 as t goes from 0...1
+     *
+     * @param v0 the value at t=0
+     * @param v1 the value at t=1
+     * @param t value in the range of 0 to 1.
+     * @return the value between v0 and v1 as a ratio between 0 and 1 defined by t.
+     */
+    public static float lerp(float v0, float v1, float t) {
+        return v0 + t * (v1 - v0);
+    }
+
+    /**
+     * Project a value that is within the in(Min/Max) number space into the to(Min/Max) number
+     * space.
+     *
+     * @param v value to scale into the 'to' number space.
+     * @param vMin min value of the values number space.
+     * @param vMax max value of the values number space.
+     * @param pMin min value of the projection number space.
+     * @param pMax max value of the projection number space.
+     * @return the ratio of the value in the source number space as a value in the to(Min/Max)
+     * number space.
+     */
+    public static float scale(float v, float vMin, float vMax, float pMin, float pMax) {
+        return (pMax - pMin) * (v - vMin) / (vMax - vMin) + pMin;
+    }
+
+    /**
+     * Value between 0 and 1 as a ratio between tBegin over tDuration
+     * with no upper bound.
+     */
+    public static float unitRatio(long t, long tBegin, float tDuration) {
+        if (t <= tBegin) {
+            return 0.0f;
+        }
+
+        return (t - tBegin) / tDuration;
+    }
+}
diff --git a/src/com/android/camera/ui/motion/InterpolatorHelper.java b/src/com/android/camera/ui/motion/InterpolatorHelper.java
new file mode 100644
index 000000000..84114cb03
--- /dev/null
+++ b/src/com/android/camera/ui/motion/InterpolatorHelper.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+import android.content.Context;
+import android.view.animation.AnimationUtils;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.Interpolator;
+
+import com.android.camera.util.ApiHelper;
+
+public class InterpolatorHelper {
+    private static Interpolator LINEAR_OUT_SLOW_IN = null;
+
+    public static Interpolator getLinearOutSlowInInterpolator(final Context context) {
+        if (LINEAR_OUT_SLOW_IN != null) {
+            return LINEAR_OUT_SLOW_IN;
+        }
+
+        LINEAR_OUT_SLOW_IN = AnimationUtils.loadInterpolator(
+                context, android.R.interpolator.linear_out_slow_in);
+        return LINEAR_OUT_SLOW_IN;
+    }
+}
diff --git a/src/com/android/camera/ui/motion/Invalidator.java b/src/com/android/camera/ui/motion/Invalidator.java
new file mode 100644
index 000000000..fdb548748
--- /dev/null
+++ b/src/com/android/camera/ui/motion/Invalidator.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * Basic interface for objects that can be invalidated.
+ */
+public interface Invalidator {
+    /**
+     * Request that the object should be redrawn whenever it gets
+     * the chance.
+     */
+    void invalidate();
+}
diff --git a/src/com/android/camera/ui/motion/LinearScale.java b/src/com/android/camera/ui/motion/LinearScale.java
new file mode 100644
index 000000000..5886f6882
--- /dev/null
+++ b/src/com/android/camera/ui/motion/LinearScale.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * Represents a discrete linear scale function.
+ */
+public final class LinearScale {
+    private final float mDomainA;
+    private final float mDomainB;
+    private final float mRangeA;
+    private final float mRangeB;
+
+    private final float mScale;
+
+    public LinearScale(float domainA, float domainB, float rangeA, float rangeB) {
+        mDomainA = domainA;
+        mDomainB = domainB;
+        mRangeA = rangeA;
+        mRangeB = rangeB;
+
+        // Precomputed ratio between input domain and output range.
+        float scale = (mRangeB - mRangeA) / (mDomainB - mDomainA);
+        mScale = Float.isNaN(scale) ? 0.0f : scale;
+    }
+
+    /**
+     * Clamp a given domain value to the given domain.
+     */
+    public float clamp(float domainValue) {
+        if (mDomainA > mDomainB) {
+            return Math.max(mDomainB, Math.min(mDomainA, domainValue));
+        }
+
+        return Math.max(mDomainA, Math.min(mDomainB, domainValue));
+    }
+
+    /**
+     * Returns true if the value is within the domain.
+     */
+    public boolean isInDomain(float domainValue) {
+        if (mDomainA > mDomainB) {
+            return domainValue <= mDomainA && domainValue >= mDomainB;
+        }
+        return domainValue >= mDomainA && domainValue <= mDomainB;
+    }
+
+    /**
+     * Linearly scale a given domain value into the output range.
+     */
+    public float scale(float domainValue) {
+        return mRangeA + (domainValue - mDomainA) * mScale;
+    }
+
+    /**
+     * For the current domain and range parameters produce a new scale function
+     * that is the inverse of the current scale function.
+     */
+    public LinearScale inverse() {
+        return new LinearScale(mRangeA, mRangeB, mDomainA, mDomainB);
+    }
+
+    @Override
+    public String toString() {
+        return "LinearScale{" +
+              "mDomainA=" + mDomainA +
+              ", mDomainB=" + mDomainB +
+              ", mRangeA=" + mRangeA +
+              ", mRangeB=" + mRangeB + "}";
+    }
+}
\ No newline at end of file
diff --git a/src/com/android/camera/ui/motion/UnitBezier.java b/src/com/android/camera/ui/motion/UnitBezier.java
new file mode 100644
index 000000000..242f54556
--- /dev/null
+++ b/src/com/android/camera/ui/motion/UnitBezier.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * This represents is a precomputed cubic bezier curve starting at (0,0) and
+ * going to (1,1) with two configurable control points. Once the instance is
+ * created, the control points cannot be modified.
+ *
+ * Generally, this will be used for computing timing curves for with control
+ * points where an x value will be provide from 0.0 - 1.0, and the y value will
+ * be solved for where y is used as the timing value in some linear
+ * interpolation of a value.
+ */
+public class UnitBezier implements UnitCurve {
+
+    private static final float EPSILON = 1e-6f;
+
+    private final DerivableFloatFn mXFn;
+    private final DerivableFloatFn mYFn;
+
+    /**
+     * Build and pre-compute a unit bezier. This assumes a starting point of
+     * (0, 0) and end point of (1.0, 1.0).
+     *
+     * @param c0x control point x value for p0
+     * @param c0y control point y value for p0
+     * @param c1x control point x value for p1
+     * @param c1y control point y value for p1
+     */
+    public UnitBezier(float c0x, float c0y, float c1x, float c1y) {
+        mXFn = new CubicBezierFn(c0x, c1x);
+        mYFn = new CubicBezierFn(c0y, c1y);
+    }
+
+    /**
+     * Given a unit bezier curve find the height of the curve at t (which is
+     * internally represented as the xAxis).
+     *
+     * @param t the x position between 0 and 1 to solve for y.
+     * @return the closest approximate height of the curve at x.
+     */
+    @Override
+    public float valueAt(float t) {
+        return mYFn.value(solve(t, mXFn));
+    }
+
+    /**
+     * Given a unit bezier curve find a value along the x axis such that
+     * valueAt(result) produces the input value.
+     *
+     * @param value the y position between 0 and 1 to solve for x
+     * @return the closest approximate input that will produce value when provided
+     * to the valueAt function.
+     */
+    @Override
+    public float tAt(float value) {
+        return mXFn.value(solve(value, mYFn));
+    }
+
+    private float solve(float target, DerivableFloatFn fn) {
+        // For a linear fn, t = value. This makes value a good starting guess.
+        float input = target;
+
+        // Newton's method (Faster than bisection)
+        for (int i = 0; i < 8; i++) {
+            float value = fn.value(input) - target;
+            if (Math.abs(value) < EPSILON) {
+                return input;
+            }
+            float derivative = fn.derivative(input);
+            if (Math.abs(derivative) < EPSILON) {
+                break;
+            }
+            input = input - value / derivative;
+        }
+
+        // Fallback on bi-section
+        float min = 0.0f;
+        float max = 1.0f;
+        input = target;
+
+        if (input < min) {
+            return min;
+        }
+        if (input > max) {
+            return max;
+        }
+
+        while (min < max) {
+            float value = fn.value(input);
+            if (Math.abs(value - target) < EPSILON) {
+                return input;
+            }
+
+            if (target > value) {
+                min = input;
+            } else {
+                max = input;
+            }
+
+            input = (max - min) * .5f + min;
+        }
+
+        // Give up, return the closest match we got too.
+        return input;
+    }
+
+    private interface DerivableFloatFn {
+        float value(float x);
+        float derivative(float x);
+    }
+
+    /**
+     * Precomputed constants for a given set of control points along a given
+     * cubic bezier axis.
+     */
+    private static class CubicBezierFn implements DerivableFloatFn {
+        private final float c;
+        private final float a;
+        private final float b;
+
+        /**
+         * Build and pre-compute a single axis for a unit bezier. This assumes p0
+         * is 0 and p1 is 1.
+         *
+         * @param c0 start control point.
+         * @param c1 end control point.
+         */
+        public CubicBezierFn(float c0, float c1) {
+            c = 3.0f * c0;
+            b = 3.0f * (c1 - c0) - c;
+            a = 1.0f - c - b;
+        }
+
+        public float value(float x) {
+            return ((a * x + b) * x + c) * x;
+        }
+        public float derivative(float x) {
+            return (3.0f * a * x + 2.0f * b) * x + c;
+        }
+    }
+}
diff --git a/src/com/android/camera/ui/motion/UnitCurve.java b/src/com/android/camera/ui/motion/UnitCurve.java
new file mode 100644
index 000000000..d89f1fa4d
--- /dev/null
+++ b/src/com/android/camera/ui/motion/UnitCurve.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * Simple functions that produce values along a curve for any given input and can compute input
+ * times for a given output value.
+ */
+public interface UnitCurve {
+
+    /**
+     * Produce a unit value of this curve at time t. The function should always return a valid
+     * return value for any valid t input.
+     *
+     * @param t ratio of time passed from (0..1)
+     * @return the unit value at t.
+     */
+    float valueAt(float t);
+
+    /**
+     * If possible, find a value for t such that valueAt(t) == value or best guess.
+     *
+     * @param value to match to the output of valueAt(t)
+     * @return t where valueAt(t) == value or throw.
+     */
+    float tAt(float value);
+}
diff --git a/src/com/android/camera/ui/motion/UnitCurves.java b/src/com/android/camera/ui/motion/UnitCurves.java
new file mode 100644
index 000000000..a1117fa96
--- /dev/null
+++ b/src/com/android/camera/ui/motion/UnitCurves.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera.ui.motion;
+
+/**
+ * Predefined material curves and animations.
+ */
+public class UnitCurves {
+    public static final UnitCurve FAST_OUT_SLOW_IN = new UnitBezier(0.4f, 0.0f, 0.2f, 1.0f);
+    public static final UnitCurve LINEAR_OUT_SLOW_IN = new UnitBezier(0.0f, 0.0f, 0.2f, 1.0f);
+    public static final UnitCurve FAST_OUT_LINEAR_IN = new UnitBezier(0.4f, 0.0f, 1.0f, 1.0f);
+    public static final UnitCurve LINEAR = new UnitBezier(0.0f, 0.0f, 1.0f, 1.0f);
+
+    /**
+     * Given two curves (from and to) and a time along the from curve, compute
+     * the time at t, and find a t along the 'toCurve' that will produce the
+     * same output. This is useful when interpolating between two different curves
+     * when the animation is not at the beginning or end.
+     *
+     * @param enterCurve the curve to compute the value from
+     * @param exitCurve the curve to find a time t on that matches output of
+     *                  enterCurve at T.
+     * @param t the time at which to compute the value (0..1)
+     * @return the time along the exitCurve.
+     */
+    public static float mapEnterCurveToExitCurveAtT(UnitCurve enterCurve, UnitCurve exitCurve,
+          float t) {
+        return exitCurve.tAt(1 - enterCurve.valueAt(t));
+    }
+}
diff --git a/src/com/android/camera/util/CameraUtil.java b/src/com/android/camera/util/CameraUtil.java
index 490087537..4d9cb70d9 100755
--- a/src/com/android/camera/util/CameraUtil.java
+++ b/src/com/android/camera/util/CameraUtil.java
@@ -951,7 +951,7 @@ public class CameraUtil {
                 + "," + rect.right + "," + rect.bottom + ")");
     }
 
-    public static void rectFToRect(RectF rectF, Rect rect) {
+    public static void inlineRectToRectF(RectF rectF, Rect rect) {
         rect.left = Math.round(rectF.left);
         rect.top = Math.round(rectF.top);
         rect.right = Math.round(rectF.right);
@@ -960,7 +960,7 @@ public class CameraUtil {
 
     public static Rect rectFToRect(RectF rectF) {
         Rect rect = new Rect();
-        rectFToRect(rectF, rect);
+        inlineRectToRectF(rectF, rect);
         return rect;
     }
 
@@ -980,21 +980,6 @@ public class CameraUtil {
         matrix.postTranslate(viewWidth / 2f, viewHeight / 2f);
     }
 
-    public static void prepareMatrix(Matrix matrix, boolean mirror, int displayOrientation,
-                                     Rect previewRect) {
-        // Need mirror for front camera.
-        matrix.setScale(mirror ? -1 : 1, 1);
-        // This is the value for android.hardware.Camera.setDisplayOrientation.
-        matrix.postRotate(displayOrientation);
-
-        // Camera driver coordinates range from (-1000, -1000) to (1000, 1000).
-        // We need to map camera driver coordinates to preview rect coordinates
-        Matrix mapping = new Matrix();
-        mapping.setRectToRect(new RectF(-1000, -1000, 1000, 1000), rectToRectF(previewRect),
-                Matrix.ScaleToFit.FILL);
-        matrix.setConcat(mapping, matrix);
-    }
-
     public static String createJpegName(long dateTaken, boolean refocus) {
         synchronized (sImageFileNamer) {
             return sImageFileNamer.generateName(dateTaken, refocus);
-- 
2.17.1

