From 87916d452a3b17312d4f1a36ef8d054611caf7d6 Mon Sep 17 00:00:00 2001
From: Ted <tedwang@google.com>
Date: Thu, 2 Aug 2018 16:34:54 +0800
Subject: [PATCH 3/3] Clean up variables when closing BT

Clean up variables when closing BT to prevent using wrong objects.

Bug: 111716107
Test: manually adjust volume after unpair/pair
Change-Id: I3fd7de74aecbdacede3e73a5200568c265c0e202
(cherry picked from commit 2a592673f48b8e78a92f982884df64be845a8548)
---
 jni/com_android_bluetooth_avrcp_target.cpp | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/jni/com_android_bluetooth_avrcp_target.cpp b/jni/com_android_bluetooth_avrcp_target.cpp
index 2532be2f..8ac04e4f 100644
--- a/jni/com_android_bluetooth_avrcp_target.cpp
+++ b/jni/com_android_bluetooth_avrcp_target.cpp
@@ -62,6 +62,15 @@ static void volumeDeviceConnected(
 static void volumeDeviceDisconnected(const RawAddress& address);
 static void setVolume(int8_t volume);
 
+// Local Variables
+// TODO (apanicke): Use a map here to store the callback in order to
+// support multi-browsing
+SetBrowsedPlayerCb set_browsed_player_cb;
+using map_entry = std::pair<std::string, GetFolderItemsCb>;
+std::map<std::string, GetFolderItemsCb> get_folder_items_cb_map;
+std::map<RawAddress, ::bluetooth::avrcp::VolumeInterface::VolumeChangedCb>
+    volumeCallbackMap;
+
 // TODO (apanicke): In the future, this interface should guarantee that
 // all calls happen on the JNI Thread. Right now this is very difficult
 // as it is hard to get a handle on the JNI thread from here.
@@ -249,6 +258,9 @@ static void cleanupNative(JNIEnv* env, jobject object) {
   std::unique_lock<std::shared_timed_mutex> interface_lock(interface_mutex);
   std::unique_lock<std::shared_timed_mutex> callbacks_lock(callbacks_mutex);
 
+  get_folder_items_cb_map.clear();
+  volumeCallbackMap.clear();
+
   sServiceInterface->Cleanup();
   env->DeleteGlobalRef(mJavaInterface);
   mJavaInterface = nullptr;
@@ -593,10 +605,6 @@ static std::vector<MediaPlayerInfo> getMediaPlayerList() {
   return ret_list;
 }
 
-// TODO (apanicke): Use a map here to store the callback in order to
-// support multi-browsing
-SetBrowsedPlayerCb set_browsed_player_cb;
-
 static void setBrowsedPlayer(uint16_t player_id, SetBrowsedPlayerCb cb) {
   ALOGD("%s", __func__);
   std::shared_lock<std::shared_timed_mutex> lock(callbacks_mutex);
@@ -623,9 +631,6 @@ static void setBrowsedPlayerResponseNative(JNIEnv* env, jobject object,
   set_browsed_player_cb.Run(success == JNI_TRUE, root, num_items);
 }
 
-using map_entry = std::pair<std::string, GetFolderItemsCb>;
-std::map<std::string, GetFolderItemsCb> get_folder_items_cb_map;
-
 static void getFolderItemsResponseNative(JNIEnv* env, jobject object,
                                          jstring parent_id, jobject list) {
   ALOGD("%s", __func__);
@@ -751,9 +756,6 @@ static void volumeDeviceConnected(const RawAddress& address) {
                                j_bdaddr, JNI_FALSE);
 }
 
-std::map<RawAddress, ::bluetooth::avrcp::VolumeInterface::VolumeChangedCb>
-    volumeCallbackMap;
-
 static void volumeDeviceConnected(
     const RawAddress& address,
     ::bluetooth::avrcp::VolumeInterface::VolumeChangedCb cb) {
-- 
2.17.1

