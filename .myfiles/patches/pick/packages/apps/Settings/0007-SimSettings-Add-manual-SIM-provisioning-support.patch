From cd80ed7f18318016a70d82751a5b898dcfbf4743 Mon Sep 17 00:00:00 2001
From: Bruno Martins <bgcngm@gmail.com>
Date: Sat, 13 Oct 2018 15:55:48 +0100
Subject: [PATCH 07/19] SimSettings: Add manual SIM provisioning support

Author: Chaitanya Saggurthi <csaggurt@codeaurora.org>
Date:   Thu Jul 16 16:33:34 2015 +0530

    Telephony(MSIM): Add Manual provisioning support

    Add toggle switch UI option in SimSettings screen to
    enable/disable SIM cards

    Change-Id: Id07271aedb12eabc0b106ac278ba2e12c71cfe03

Author: Sandeep Gutta <sangutta@codeaurora.org>
Date:   Mon Aug 10 15:09:59 2015 +0530

    Telephony(MSIM): Manual provision related fixes

    - Consider Manual provision state while displaying
      active sub info list.
    - Enable sms/data user preference option only
    - Enable sms/data user preference option only
      if more than one subscription active.
    - Introduce below system proeprty to control AOSP
      behavior of user selection of fallback preference
      for sms/data
      "persist.radio.aosp_usr_pref_sel"

    Change-Id: I2b308b801f3f677c5a3ffaee5a8e6beda12aedd2

Author: Sandeep Gutta <sangutta@codeaurora.org>
Date:   Sun Sep 13 22:09:23 2015 +0530

    Telephony(MSIM): Fix to do not allow both SIM deactivation

    Use proper SubInfo record object to do not allow
    user to deactivate both SIMs on DSDS devices.

    Change-Id: I6f56d819367272b3a009c7a8133709c643e8bd84
    CRs-Fixed: 893504

Author: Sandeep Gutta <sangutta@codeaurora.org>
Date:   Mon Sep 14 20:14:07 2015 +0530

    Telephony(MSIM): Select preferred primary sub.

    Add UI to select preferred primary sub.
    It is used when two SIM cards inserted have same
    priority as per policy.

    Change-Id: I5726fe9f4df03e680dc2406854d08da77297444d

Author: Ricardo Cerqueira <ricardo@cyngn.com>
Date:   Thu Nov 5 18:23:52 2015 +0000

    Break MSIM dependency on qci-telephony-framework

    If the provisioning state is invalid, the framework is most likely
    absent. Consider the card as provisioned to pass all relevant checks.

    Change-Id: I975ff156e4328e9d3f6e2626a863bbacb29e3337

Author: LuK1337 <priv.luk@gmail.com>
Date:   Sun Jan 3 22:32:00 2016 +0100

    Hide manual provisioning switch when extphone framework is not present

    * It doesn't work without it.

    Change-Id: Iec11ec2006059f26668f2a6fee4c2c9ca6650119

Author: LuK1337 <priv.luk@gmail.com>
Date:   Sun Jul 3 22:11:26 2016 +0200

    Settings: Don't set the icon for sim activation / deactivation dialog

    * This icon doesn't look any good.
      It's better to just get rid of it.

    Change-Id: I47f70a80136695e9aa61ff98999a2cf770390079

Author: Luca Stefani <luca.stefani.ge1@gmail.com>
Date:   Sun Jul 3 21:56:08 2016 +0200

    Settings: Disable sim switch if subscription isn't valid

    Change-Id: I22ba9a3270da13f77fdd43586b7dc487f0929453

Author: Venkatraman Nerellapalli <venkataraman.nerellapalli@codeaurora.org>
Date:   Sat Jan 9 17:20:00 2016 +0530

    Telephony(MSIM): Fix ANR on SIM deactivation

    Dismiss dialog box on confirmation.
    SIM activation & deactivation in background thread.

    Change-Id: I0268a710f35e30b2abec3dd671942b52fc0e0b46
    CRs-Fixed: 957308

Author: Ricardo Cerqueira <ricardo@cyngn.com>
Date:   Thu Jul 28 12:29:40 2016 +0100

    SimSettings: Make provisioning optional even if qti-telephony is present

    Current code assumes the manual provisioning options should come
    up if the qti-telephony blob is present. Don't make that assumption.

    Change-Id: I5e4f28b628e3fe3fe9e506631e92c85103e87ccf

Author: Danny Baumann <dannybaumann@web.de>
Date:   Tue Feb 28 12:26:37 2017 +0100

    Clean up SIM enable toggle implementation

    - Move strings to cm_strings.xml
    - Improve string wording
    - Remove unused code
    - Streamline implementation

    Change-Id: I58fc3002cfcc37dd1798819223289cc541bed211

Author: Danny Baumann <dannybaumann@web.de>
Date:   Thu Feb 16 14:50:56 2017 +0100

    Fix possible NPE on SIM settings shutdown.

    Change-Id: Ibf6b54fc2b97a780cfd7ace17c54855ef7e70c57

Author: xyyx <xyyx@mail.ru>
Date:   Fri Jan 19 23:31:36 2018 +0800

    SimSettings: Correctly disable sim switch without SIM card

    * Code extracted from MM CAF

    Change-Id: I59924806302c57e5652b18235e50c9569153dbd3

Author: maxwen <max.weninger@gmail.com>
Date:   Sat Jan 20 13:39:17 2018 +0100

    SimSettings: Improve dialogs

    Squash of:

    Settings: no need to show a success alert dialog on sim switch

    very 'un-android-like' :)

    Change-Id: Ie68eed174464d7acf67171a509a19045e0d9c669

    Settings: fix neverending progress on sim activation change

    what a stupid bug....

    and while we are here - also the confirm dialog on
    deactivation is actually useless - using the switch
    should be more enough to not always ask and anoy user
    if he really knows what he is doing

    Change-Id: I38eb17cf8d12259f34b339da2ad807d12a5c0d41

Author: LuK1337 <priv.luk@gmail.com>
Date:   Fri Jan 26 18:39:50 2018 +0100

    SimSettings: Handle NoClassDefFoundError on devices without telephony-ext

    Change-Id: I9f4a2c773d8ad1d82993ea19bf9ee5e70e5d0516

Author: Bruno Martins <bgcngm@gmail.com>
Date:   Tue Jun 5 18:51:25 2018 +0100

    SimSettings: Use TelephonyExtUtils helper methods

     * TelephonyExtUtils class was recently added to Lineage SDK,
       thus allowing to clean up much of the code introduced
       for manual SIM provisioning.

    Change-Id: Id6eaffffb3c2b2b2dead36e0f56d8547e6188690

Change-Id: I42e76651da449a6a82f95d6930384693cb04b26d
---
 res/layout/custom_sim_switch.xml              |  39 ++
 res/values/cm_strings.xml                     |  17 +
 res/values/lineage_config.xml                 |   7 +
 src/com/android/settings/sim/SimSettings.java | 510 +++++++++++++++++-
 4 files changed, 565 insertions(+), 8 deletions(-)
 create mode 100644 res/layout/custom_sim_switch.xml

diff --git a/res/layout/custom_sim_switch.xml b/res/layout/custom_sim_switch.xml
new file mode 100644
index 0000000000..8e540c3835
--- /dev/null
+++ b/res/layout/custom_sim_switch.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ /* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+-->
+<Switch xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/sub_switch_widget"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_gravity="center"
+    android:clickable="true"
+    android:focusable="false"
+    android:padding="8dip" />
diff --git a/res/values/cm_strings.xml b/res/values/cm_strings.xml
index 2208da2747..951b067b7e 100644
--- a/res/values/cm_strings.xml
+++ b/res/values/cm_strings.xml
@@ -308,6 +308,23 @@
     <!-- Lock screen visualizer -->
     <string name="lockscreen_visualizer_title">Display music visualizer</string>
 
+    <!-- Manual provisioning support -->
+    <string name="sim_enabler_summary"><xliff:g id="displayName">%1$s</xliff:g> is <xliff:g id="status" example="disabled">%2$s</xliff:g></string>
+    <string name="sim_disabled">disabled</string>
+    <string name="sim_missing">missing or faulty</string>
+    <string name="sim_enabler_need_disable_sim">SIM card will be deactivated. Do you want to continue?</string>
+    <string name="sim_enabler_will_disable_sim_title">Attention</string>
+    <string name="sim_enabler_need_switch_data_service">This SIM will be disabled and SIM <xliff:g id="slotid">%1$s</xliff:g> will be used for data services. Are you sure you want to continue?</string>
+    <string name="sim_enabler_airplane_on">Unable to perform the operation while airplane mode is on.</string>
+    <string name="sim_enabler_in_call">Unable to perform the operation while in call.</string>
+    <string name="sim_enabler_both_inactive">Can\'t disable all SIM cards</string>
+    <string name="sim_enabler_enabling">Activating\u2026</string>
+    <string name="sim_enabler_disabling">Deactivating\u2026</string>
+    <string name="sub_activate_success">SIM activated.</string>
+    <string name="sub_activate_failed">Activation failed.</string>
+    <string name="sub_deactivate_success">SIM deactivated.</string>
+    <string name="sub_deactivate_failed">Deactivation failed.</string>
+
     <!-- Per-app data restrictions -->
     <string name="data_usage_app_restrict_data">Cellular data</string>
     <string name="data_usage_app_restrict_data_summary">Enable usage of cellular data</string>
diff --git a/res/values/lineage_config.xml b/res/values/lineage_config.xml
index 1d1f200319..0e1f0348fa 100644
--- a/res/values/lineage_config.xml
+++ b/res/values/lineage_config.xml
@@ -24,4 +24,11 @@
          3 = right side
     -->
     <integer name="config_fingerprintSensorLocation">0</integer>
+
+    <!-- Does the device allow for manual subscription provisioning? Only works for multi-sim devices,
+         and currently depends on QC's proprietary telephony stack -->
+    <bool name="config_enableManualSubProvisioning">true</bool>
+
+    <!-- Whether notify user that switch data service -->
+    <bool name="confirm_to_switch_data_service">false</bool>
 </resources>
diff --git a/src/com/android/settings/sim/SimSettings.java b/src/com/android/settings/sim/SimSettings.java
index 3d6bfb162a..212a647a46 100644
--- a/src/com/android/settings/sim/SimSettings.java
+++ b/src/com/android/settings/sim/SimSettings.java
@@ -16,15 +16,28 @@
 
 package com.android.settings.sim;
 
+import static org.lineageos.internal.util.TelephonyExtUtils.PROVISIONED;
+import static org.lineageos.internal.util.TelephonyExtUtils.NOT_PROVISIONED;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.ProgressDialog;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.res.Resources;
 import android.graphics.drawable.BitmapDrawable;
+import android.os.AsyncTask;
 import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
 import android.os.SystemProperties;
 import android.provider.SearchIndexableResource;
+import android.provider.Settings;
 import android.support.v7.preference.Preference;
+import android.support.v7.preference.PreferenceGroup;
 import android.support.v7.preference.PreferenceScreen;
+import android.support.v7.preference.PreferenceViewHolder;
 import android.telecom.PhoneAccountHandle;
 import android.telecom.TelecomManager;
 import android.telephony.PhoneNumberUtils;
@@ -34,6 +47,9 @@ import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.Log;
+import android.view.View;
+import android.widget.CompoundButton;
+import android.widget.CompoundButton.OnCheckedChangeListener;
 
 import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
 import com.android.internal.telephony.TelephonyProperties;
@@ -43,10 +59,14 @@ import com.android.settings.Utils;
 import com.android.settings.search.BaseSearchIndexProvider;
 import com.android.settings.search.Indexable;
 
+import org.lineageos.internal.util.TelephonyExtUtils;
+import org.lineageos.internal.util.TelephonyExtUtils.ProvisioningChangedListener;
+
 import java.util.ArrayList;
 import java.util.List;
 
-public class SimSettings extends RestrictedSettingsFragment implements Indexable {
+public class SimSettings extends RestrictedSettingsFragment implements Indexable,
+        ProvisioningChangedListener {
     private static final String TAG = "SimSettings";
     private static final boolean DBG = false;
 
@@ -66,7 +86,7 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
     private List<SubscriptionInfo> mAvailableSubInfos = null;
     private List<SubscriptionInfo> mSubInfoList = null;
     private List<SubscriptionInfo> mSelectableSubInfos = null;
-    private PreferenceScreen mSimCards = null;
+    private PreferenceGroup mSimCards = null;
     private SubscriptionManager mSubscriptionManager;
     private int mNumSlots;
     private Context mContext;
@@ -75,6 +95,11 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
     private int[] mCallState = new int[mPhoneCount];
     private PhoneStateListener[] mPhoneStateListener = new PhoneStateListener[mPhoneCount];
 
+    private AlertDialog mAlertDialog = null;
+    private ProgressDialog mProgressDialog = null;
+    private boolean mNeedsUpdate = false;
+    private int[] mUiccProvisionStatus = new int[mPhoneCount];
+
     public SimSettings() {
         super(DISALLOW_CONFIG_SIM);
     }
@@ -95,10 +120,23 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         addPreferencesFromResource(R.xml.sim_settings);
 
         mNumSlots = tm.getSimCount();
-        mSimCards = (PreferenceScreen)findPreference(SIM_CARD_CATEGORY);
+        mSimCards = (PreferenceGroup)findPreference(SIM_CARD_CATEGORY);
         mAvailableSubInfos = new ArrayList<SubscriptionInfo>(mNumSlots);
         mSelectableSubInfos = new ArrayList<SubscriptionInfo>();
         SimSelectNotification.cancelNotification(getActivity());
+
+        TelephonyExtUtils.getInstance(mContext).addListener(this);
+    }
+
+    @Override
+    public void onDestroy() {
+        TelephonyExtUtils.getInstance(mContext).removeListener(this);
+        super.onDestroy();
+    }
+
+    @Override
+    public void onProvisioningChanged(int slotId, boolean isProvisioned) {
+        updateSubscriptions();
     }
 
     private final SubscriptionManager.OnSubscriptionsChangedListener mOnSubscriptionsChangeListener
@@ -106,7 +144,9 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         @Override
         public void onSubscriptionsChanged() {
             if (DBG) log("onSubscriptionsChanged:");
-            updateSubscriptions();
+            if (isAdded()) {
+                updateSubscriptions();
+            }
         }
     };
 
@@ -124,11 +164,11 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         for (int i = 0; i < mNumSlots; ++i) {
             final SubscriptionInfo sir = mSubscriptionManager
                     .getActiveSubscriptionInfoForSimSlotIndex(i);
-            SimPreference simPreference = new SimPreference(getPrefContext(), sir, i);
+            SimPreference simPreference = new SimEnablerPreference(getPrefContext(), sir, i);
             simPreference.setOrder(i-mNumSlots);
             mSimCards.addPreference(simPreference);
             mAvailableSubInfos.add(sir);
-            if (sir != null) {
+            if (sir != null && mUiccProvisionStatus[i] == PROVISIONED) {
                 mSelectableSubInfos.add(sir);
             }
         }
@@ -234,6 +274,14 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
                 mPhoneStateListener[i] = null;
             }
         }
+
+        for (int i = 0; i < mSimCards.getPreferenceCount(); ++i) {
+            Preference pref = mSimCards.getPreference(i);
+            if (pref instanceof SimEnablerPreference) {
+                // Calling cleanUp() here to dismiss/cleanup any pending dialog exists.
+                ((SimEnablerPreference)pref).cleanUpPendingDialogs();
+            }
+        }
     }
 
     private PhoneStateListener getPhoneStateListener(int phoneId, int subId) {
@@ -277,9 +325,26 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
         return true;
     }
 
+    @Override
+    public void onAttach(Context context) {
+        super.onAttach(context);
+        if (mNeedsUpdate) {
+            mNeedsUpdate = false;
+            updateAllOptions();
+        }
+    }
+
+    private void simEnablerUpdate() {
+        if (isAdded()) {
+            updateAllOptions();
+        } else {
+            mNeedsUpdate = true;
+        }
+    }
+
     private class SimPreference extends Preference {
-        private SubscriptionInfo mSubInfoRecord;
-        private int mSlotId;
+        SubscriptionInfo mSubInfoRecord;
+        int mSlotId;
         Context mContext;
 
         public SimPreference(Context context, SubscriptionInfo subInfoRecord, int slotId) {
@@ -305,6 +370,7 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
                             PhoneNumberUtils.createTtsSpannable(getPhoneNumber(mSubInfoRecord)));
                     setEnabled(true);
                 }
+                setSummary(determineSummary());
                 setIcon(new BitmapDrawable(res, (mSubInfoRecord.createIconBitmap(mContext))));
             } else {
                 setSummary(R.string.sim_slot_empty);
@@ -313,11 +379,439 @@ public class SimSettings extends RestrictedSettingsFragment implements Indexable
             }
         }
 
+        protected boolean isValid() {
+            return mSubInfoRecord != null;
+        }
+
+        protected CharSequence determineSummary() {
+            CharSequence number = getPhoneNumber(mSubInfoRecord);
+            if (TextUtils.isEmpty(number)) {
+                return mSubInfoRecord.getDisplayName();
+            } else {
+                return mSubInfoRecord.getDisplayName() + " - " +
+                        PhoneNumberUtils.createTtsSpannable(number);
+            }
+        }
+
         private int getSlotId() {
             return mSlotId;
         }
     }
 
+    // This is to show SIM Enable options on/off on UI for user selection.
+    // User can activate/de-activate through SIM on/off options.
+    private class SimEnablerPreference extends SimPreference implements OnCheckedChangeListener {
+        private static final int EVT_UPDATE = 1;
+        private static final int EVT_SHOW_RESULT_DLG = 2;
+        private static final int EVT_SHOW_PROGRESS_DLG = 3;
+        private static final int EVT_PROGRESS_DLG_TIME_OUT = 4;
+
+        private static final int CONFIRM_ALERT_DLG_ID = 1;
+        private static final int ERROR_ALERT_DLG_ID = 2;
+        private static final int RESULT_ALERT_DLG_ID = 3;
+
+        private boolean mCurrentUiccProvisionState;
+        private boolean mIsChecked;
+
+        private boolean mCmdInProgress = false;
+        private CompoundButton mSwitch;
+        //Delay for progress dialog to dismiss
+        private static final int PROGRESS_DLG_TIME_OUT = 30000;
+        private static final int MSG_DELAY_TIME = 2000;
+
+        public SimEnablerPreference(Context context, SubscriptionInfo sir, int slotId) {
+            super(context, sir, slotId);
+            setWidgetLayoutResource(R.layout.custom_sim_switch);
+        }
+
+        private void sendMessage(int event, Handler handler, int delay) {
+            Message message = handler.obtainMessage(event);
+            handler.sendMessageDelayed(message, delay);
+        }
+
+        private void sendMessage(int event, Handler handler, int delay, int arg1, int arg2) {
+            Message message = handler.obtainMessage(event, arg1, arg2);
+            handler.sendMessageDelayed(message, delay);
+        }
+
+        private boolean hasCard() {
+            return TelephonyManager.getDefault().hasIccCard(mSlotId);
+        }
+
+        private boolean isAirplaneModeOn() {
+            return (Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.AIRPLANE_MODE_ON, 0) != 0);
+        }
+
+        private boolean isSlotProvisioned(int slotId) {
+            return getProvisionStatus(slotId) == PROVISIONED;
+        }
+
+        private int getProvisionStatus(int slotId) {
+            return mUiccProvisionStatus[slotId];
+        }
+
+        @Override
+        public void onBindViewHolder(PreferenceViewHolder holder) {
+            super.onBindViewHolder(holder);
+            logd("onBindView....");
+            mSwitch = (CompoundButton) holder.findViewById(R.id.sub_switch_widget);
+            mSwitch.setOnCheckedChangeListener(this);
+
+            // Hide manual provisioning if the extphone framework
+            // is not present, as the operation relies on said framework.
+            if (!TelephonyExtUtils.getInstance(mContext).hasService() ||
+                   !mContext.getResources().getBoolean(R.bool.config_enableManualSubProvisioning)) {
+                mSwitch.setVisibility(View.GONE);
+            } else {
+                mSwitch.setVisibility(View.VISIBLE);
+                if (isAirplaneModeOn() || (!isCurrentSubValid())) {
+                    mSwitch.setEnabled(false);
+                } else {
+                    mSwitch.setEnabled(true);
+                }
+                setChecked(isSlotProvisioned(mSlotId));
+            }
+        }
+
+        @Override
+        public void update() {
+            logd("update()" + mSubInfoRecord);
+
+            // Get current provision state of the SIM,
+            // assuming it as provisioned if extphone framework is not present
+            TelephonyExtUtils extTelephony = TelephonyExtUtils.getInstance(mContext);
+            mUiccProvisionStatus[mSlotId] = extTelephony.hasService() ?
+                    extTelephony.getCurrentUiccCardProvisioningStatus(mSlotId) :
+                    PROVISIONED;
+
+            super.update();
+        }
+
+        // This method returns true if SubScription record corresponds to this
+        // Preference screen has a valid SIM and slot index/SubId.
+        private boolean isCurrentSubValid() {
+            boolean isSubValid = false;
+            if (hasCard()) {
+                SubscriptionInfo sir = mSubscriptionManager.
+                        getActiveSubscriptionInfoForSimSlotIndex(mSlotId);
+                if (sir != null ) {
+                    mSubInfoRecord = sir;
+                    if (SubscriptionManager.isValidSubscriptionId(mSubInfoRecord.getSubscriptionId())
+                            && mSubInfoRecord.getSimSlotIndex() >= 0
+                            && getProvisionStatus(mSubInfoRecord.getSimSlotIndex()) >= 0) {
+                        isSubValid = true;
+                    }
+                }
+            }
+            return isSubValid;
+        }
+
+        // Based on the received SIM provision state this method
+        // sets the check box on Sim Preference UI and updates new
+        // state to mCurrentUiccProvisionState.
+        private void setChecked(boolean uiccProvisionState) {
+            logd("setChecked: uiccProvisionState " + uiccProvisionState + "sir:" + mSubInfoRecord);
+            if (mSwitch != null) {
+                mSwitch.setOnCheckedChangeListener(null);
+                // Do not update update checkstatus again in progress
+                if (!mCmdInProgress) {
+                    mSwitch.setChecked(uiccProvisionState);
+                }
+                mSwitch.setOnCheckedChangeListener(this);
+                mCurrentUiccProvisionState = uiccProvisionState;
+            }
+        }
+
+        @Override
+        protected CharSequence determineSummary() {
+            if (!isSlotProvisioned(mSlotId)) {
+                CharSequence state = mContext.getString(
+                        hasCard() ? R.string.sim_disabled : R.string.sim_missing);
+                return mContext.getString(R.string.sim_enabler_summary,
+                        mSubInfoRecord.getDisplayName(), state);
+            } else {
+                return super.determineSummary();
+            }
+        }
+
+        /**
+        * get number of Subs provisioned on the device
+        * @param context
+        * @return
+        */
+        public int getNumOfSubsProvisioned() {
+            int activeSubInfoCount = 0;
+            List<SubscriptionInfo> subInfoLists =
+                    mSubscriptionManager.getActiveSubscriptionInfoList();
+            if (subInfoLists != null) {
+                for (SubscriptionInfo subInfo : subInfoLists) {
+                    if (isSlotProvisioned(subInfo.getSimSlotIndex())) {
+                        activeSubInfoCount++;
+                    }
+                }
+            }
+            return activeSubInfoCount;
+        }
+
+        @Override
+        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+            mIsChecked = isChecked;
+            logd("onClick: " + isChecked);
+
+            handleUserRequest();
+        }
+
+        // This internal method called when user changes preference from UI
+        // 1. For activation/deactivation request from User, if device in APM mode OR
+        //    if voice call active on any SIM it dispay error dialog and returns.
+        // 2. For deactivation request it returns error dialog if only one SUB in active state.
+        // 3. In other cases it sends user request to framework.
+        private void handleUserRequest() {
+            if (isAirplaneModeOn()) {
+                // do nothing but warning
+                logd("APM is on, EXIT!");
+                showAlertDialog(ERROR_ALERT_DLG_ID, R.string.sim_enabler_airplane_on);
+                return;
+            }
+            for (int i = 0; i < mPhoneCount; i++) {
+                int[] subId = SubscriptionManager.getSubId(i);
+                //when voice call in progress, subscription can't be activate/deactivate.
+                if (TelephonyManager.getDefault().getCallState(subId[0])
+                        != TelephonyManager.CALL_STATE_IDLE) {
+                    logd("Call state for phoneId: " + i + " is not idle, EXIT!");
+                    showAlertDialog(ERROR_ALERT_DLG_ID, R.string.sim_enabler_in_call);
+                    return;
+                }
+            }
+
+            if (!mIsChecked) {
+                if (getNumOfSubsProvisioned() > 1) {
+                    logd("More than one sub is active, Deactivation possible.");
+                    sendUiccProvisioningRequest();
+                } else {
+                    logd("Only one sub is active. Deactivation not possible.");
+                    showAlertDialog(ERROR_ALERT_DLG_ID, R.string.sim_enabler_both_inactive);
+                    return;
+                }
+            } else {
+                logd("Activate the sub");
+                sendUiccProvisioningRequest();
+            }
+        }
+
+        private void sendUiccProvisioningRequest() {
+            if (!mSwitch.isEnabled()) {
+                return;
+            }
+            new SimEnablerDisabler().execute();
+        }
+
+        private class SimEnablerDisabler extends AsyncTask<Void, Void, Integer> {
+
+            int newProvisionedState = NOT_PROVISIONED;
+
+            @Override
+            protected void onPreExecute() {
+                super.onPreExecute();
+                mCmdInProgress = true;
+                showProgressDialog();
+                setEnabled(false);
+            }
+
+            @Override
+            protected Integer doInBackground(Void... params) {
+                TelephonyExtUtils extTelephony = TelephonyExtUtils.getInstance(mContext);
+                int result = mIsChecked ?
+                        extTelephony.activateUiccCard(mSlotId) :
+                        extTelephony.deactivateUiccCard(mSlotId);
+                newProvisionedState =
+                        extTelephony.getCurrentUiccCardProvisioningStatus(mSlotId);
+                return result;
+            }
+
+            @Override
+            protected void onPostExecute(Integer result) {
+                processSetUiccDone(result.intValue(), newProvisionedState);
+            }
+        }
+
+        private void processSetUiccDone(int result, int newProvisionedState) {
+            sendMessage(EVT_UPDATE, mHandler, MSG_DELAY_TIME);
+            sendMessage(EVT_SHOW_RESULT_DLG, mHandler, MSG_DELAY_TIME, result, newProvisionedState);
+            mCmdInProgress = false;
+        }
+
+        private void showAlertDialog(int dialogId, int msgId) {
+            String title = mSubInfoRecord.getDisplayName().toString();
+            // Confirm only one AlertDialog instance to show.
+            dismissDialog(mAlertDialog);
+            dismissDialog(mProgressDialog);
+            AlertDialog.Builder builder = new AlertDialog.Builder(mContext).setTitle(title);
+
+            switch(dialogId) {
+                case CONFIRM_ALERT_DLG_ID:
+                    String message;
+                    if (mContext.getResources().getBoolean(
+                            R.bool.confirm_to_switch_data_service)) {
+                        if (SubscriptionManager.getDefaultDataSubscriptionId() ==
+                                mSubInfoRecord.getSubscriptionId()) {
+                            message = mContext.getString(
+                                    R.string.sim_enabler_need_switch_data_service,
+                                    getProvisionedSlotId());
+                        } else {
+                            message = mContext.getString(R.string.sim_enabler_need_disable_sim);
+                        }
+                        builder.setTitle(R.string.sim_enabler_will_disable_sim_title);
+                    } else {
+                        message = mContext.getString(R.string.sim_enabler_need_disable_sim);
+                    }
+                    builder.setMessage(message);
+                    builder.setPositiveButton(android.R.string.ok, mDialogClickListener);
+                    builder.setNegativeButton(android.R.string.no, mDialogClickListener);
+                    builder.setOnCancelListener(mDialogCanceListener);
+                    break;
+
+                case ERROR_ALERT_DLG_ID:
+                    builder.setMessage(mContext.getString(msgId));
+                    builder.setNeutralButton(android.R.string.ok, mDialogClickListener);
+                    builder.setOnCancelListener(mDialogCanceListener);
+                    break;
+
+                case RESULT_ALERT_DLG_ID:
+                    String msg = mCurrentUiccProvisionState ?
+                            mContext.getString(R.string.sub_activate_success) :
+                            mContext.getString(R.string.sub_deactivate_success);
+                    builder.setMessage(msg);
+                    builder.setNeutralButton(android.R.string.ok, null);
+                    break;
+                default:
+                    break;
+            }
+
+            mAlertDialog = builder.create();
+            mAlertDialog.setCanceledOnTouchOutside(false);
+            mAlertDialog.show();
+        }
+
+        private int getProvisionedSlotId() {
+            int activeSlotId = -1;
+            List<SubscriptionInfo> subInfoLists =
+                    mSubscriptionManager.getActiveSubscriptionInfoList();
+            if (subInfoLists != null) {
+                for (SubscriptionInfo subInfo : subInfoLists) {
+                    if (isSlotProvisioned(subInfo.getSimSlotIndex())
+                            && subInfo.getSubscriptionId() != mSubInfoRecord.getSubscriptionId())
+                        activeSlotId = subInfo.getSimSlotIndex() + 1;
+                }
+            }
+            return activeSlotId;
+        }
+
+        private void showProgressDialog() {
+            String title = mSubInfoRecord.getDisplayName().toString();
+
+            String msg = mContext.getString(mIsChecked ?
+                    R.string.sim_enabler_enabling : R.string.sim_enabler_disabling);
+            dismissDialog(mProgressDialog);
+            mProgressDialog = new ProgressDialog(mContext);
+            mProgressDialog.setIndeterminate(true);
+            mProgressDialog.setTitle(title);
+            mProgressDialog.setMessage(msg);
+            mProgressDialog.setCancelable(false);
+            mProgressDialog.setCanceledOnTouchOutside(false);
+            mProgressDialog.show();
+
+            sendMessage(EVT_PROGRESS_DLG_TIME_OUT, mHandler, PROGRESS_DLG_TIME_OUT);
+        }
+
+        private void dismissDialog(Dialog dialog) {
+            if (dialog != null && dialog.isShowing()) {
+                dialog.dismiss();
+                dialog = null;
+            }
+        }
+
+        public void cleanUpPendingDialogs() {
+            dismissDialog(mProgressDialog);
+            dismissDialog(mAlertDialog);
+        }
+
+        private DialogInterface.OnClickListener mDialogClickListener =
+                new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                        if (which == DialogInterface.BUTTON_POSITIVE) {
+                            dismissDialog(mAlertDialog);
+                            sendUiccProvisioningRequest();
+                        } else if (which == DialogInterface.BUTTON_NEGATIVE) {
+                            update();
+                        } else if (which == DialogInterface.BUTTON_NEUTRAL) {
+                            update();
+                        }
+                    }
+                };
+
+        private DialogInterface.OnCancelListener mDialogCanceListener =
+                new DialogInterface.OnCancelListener() {
+                    public void onCancel(DialogInterface dialog) {
+                        update();
+                    }
+                };
+
+
+        private Handler mHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+
+                    switch(msg.what) {
+                        case EVT_UPDATE:
+                            simEnablerUpdate();
+
+                        case EVT_SHOW_RESULT_DLG:
+                            int result = msg.arg1;
+                            int newProvisionedState = msg.arg2;
+                            logd("EVT_SHOW_RESULT_DLG result: " + result +
+                                    " new provisioned state " + newProvisionedState);
+                            update();
+                            if (result != 0) {
+                                int msgId = (newProvisionedState == PROVISIONED) ?
+                                        R.string.sub_activate_failed :
+                                        R.string.sub_deactivate_failed;
+                                showAlertDialog(ERROR_ALERT_DLG_ID, msgId);
+                            } else {
+                                mCurrentUiccProvisionState = newProvisionedState == PROVISIONED;
+                                cleanUpPendingDialogs();
+                            }
+                            mHandler.removeMessages(EVT_PROGRESS_DLG_TIME_OUT);
+                            break;
+
+                        case EVT_SHOW_PROGRESS_DLG:
+                            logd("EVT_SHOW_PROGRESS_DLG");
+                            showProgressDialog();
+                            break;
+
+                        case EVT_PROGRESS_DLG_TIME_OUT:
+                            logd("EVT_PROGRESS_DLG_TIME_OUT");
+                            dismissDialog(mProgressDialog);
+                            // Must update UI when time out
+                            update();
+                            break;
+
+                        default:
+                        break;
+                    }
+                }
+            };
+
+        private void logd(String msg) {
+            if (DBG) Log.d(TAG + "(" + mSlotId + ")", msg);
+        }
+
+        private void loge(String msg) {
+            if (DBG) Log.e(TAG + "(" + mSlotId + ")", msg);
+        }
+    }
+
     // Returns the line1Number. Line1number should always be read from TelephonyManager since it can
     // be overridden for display purposes.
     private String getPhoneNumber(SubscriptionInfo info) {
-- 
2.17.1

