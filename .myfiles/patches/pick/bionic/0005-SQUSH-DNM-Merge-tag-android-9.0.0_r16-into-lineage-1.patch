From 53ca35df2c722d01c4275273d5001835b6e16ca9 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 6 Nov 2018 14:42:54 +0100
Subject: [PATCH 5/5] [SQUSH][DNM] Merge tag 'android-9.0.0_r16' into
 lineage-16.0

commit dbf4b11b1158137e55342d250f624196a8912e07
Merge: 252878e88 fbe26c723
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Mon Jul 30 03:00:37 2018 +0000

    Snap for 4920102 from fbe26c723af60b101a6df9c066c1b661b6ab966c to pi-qpr1-release

    Change-Id: Ifd7027234368d31d675303934b1f0f8b6e23d714

commit fbe26c723af60b101a6df9c066c1b661b6ab966c
Merge: 6fffb2332 495993289
Author: TreeHugger Robot <treehugger-gerrit@google.com>
Date:   Fri Jul 27 19:36:50 2018 +0000

    Merge "remove bionic-compile-time-tests-g++" into pi-dev

commit 252878e88968a67291099078862824dae7dc75c0
Merge: 866374163 6fffb2332
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Fri Jul 27 03:03:53 2018 +0000

    Snap for 4916303 from 6fffb2332ca3be3abee84810b389a29b731887ee to pi-qpr1-release

    Change-Id: If8971618ca5839bb3044dd35acbd31189ebb613e

commit 4959932899064afd107737bb54cbf146f2a5a518
Author: Sajid Dalvi <sdalvi@google.com>
Date:   Mon Jul 23 10:33:40 2018 -0500

    remove bionic-compile-time-tests-g++

    make checkbuild gives the following error:
    bionic/tests/fortify_filecheck_diagnostics_test.cpp:1:0: error: unknown value 'cortex-a55' for -mcpu

    The error is because we have a clang to support the new architecture,
    but not a corresponding GCC. It is not trivial to filter out an invalid
    CPU, and since there is no platform code built with GCC any more, its
    better to remove bionic-compile-time-tests-g++

    Bug: 74404306
    Change-Id: I6aa181c652abeef782fec6380dfadd066140b8b9

commit 6fffb2332ca3be3abee84810b389a29b731887ee
Author: Christopher Ferris <cferris@google.com>
Date:   Tue Jul 10 14:45:24 2018 -0700

    Disable malloc debug intercepts when exiting.

    There is a hang when enabling leak_track since the dumping of the
    leak data can wind up doing an allocation.

    Add new system unit test to make sure this doesn't happen again.

    Bug: 111146059

    Test: Test program that leaks does not hang forever.
    Test: Unit tests pass.
    Change-Id: Icf99be58ba5db98ee124a471b957a086045f5870
    Merged-In: Icf99be58ba5db98ee124a471b957a086045f5870
    (cherry picked from commit 97b474710225bc4853ab314c3d9ca812dc375525)

commit 866374163a1164e1113a4d2e9e0453d68a06dfa3
Merge: 03cb53a17 9893d6d0f
Author: Tom Cherry <tomcherry@google.com>
Date:   Mon Jul 2 16:02:52 2018 +0000

    Merge "Reland "Remove a check for AIDs in the OEM range."" into pi-dev

commit 9893d6d0ff2be5a6cdfb944df17b394678a7e340
Author: Tom Cherry <tomcherry@google.com>
Date:   Fri Jun 29 10:39:43 2018 -0700

    Reland "Remove a check for AIDs in the OEM range."

    There may be vendor extensions to the system image which would need to
    use these IDs.

    This reverts commit 41986a013a10c6f79822002800a9afe90efba4f2.

    Bug: 110856218
    Test: these tests

Change-Id: Ic8a77512f4e1fc8f3999cbaaa121e5754c1286df
---
 libc/malloc_debug/Android.bp                  |  23 ++
 libc/malloc_debug/malloc_debug.cpp            |   9 +-
 .../tests/malloc_debug_system_tests.cpp       | 211 ++++++++++++++++++
 tests/Android.mk                              |  19 --
 tests/grp_pwd_test.cpp                        |  18 +-
 5 files changed, 254 insertions(+), 26 deletions(-)
 create mode 100644 libc/malloc_debug/tests/malloc_debug_system_tests.cpp

diff --git a/libc/malloc_debug/Android.bp b/libc/malloc_debug/Android.bp
index 899987c42..bd2f4fdb1 100644
--- a/libc/malloc_debug/Android.bp
+++ b/libc/malloc_debug/Android.bp
@@ -123,3 +123,26 @@ cc_test {
         "-Wno-error=format-zero-length",
     ],
 }
+
+// ==============================================================
+// System Tests
+// ==============================================================
+cc_test {
+    name: "malloc_debug_system_tests",
+
+    srcs: [
+        "tests/malloc_debug_system_tests.cpp",
+    ],
+
+    shared_libs: [
+        "libbase",
+        "liblog",
+        "libunwindstack",
+    ],
+
+    cflags: [
+        "-Wall",
+        "-Werror",
+        "-O0",
+    ],
+}
diff --git a/libc/malloc_debug/malloc_debug.cpp b/libc/malloc_debug/malloc_debug.cpp
index e83f73c32..b866e54fa 100644
--- a/libc/malloc_debug/malloc_debug.cpp
+++ b/libc/malloc_debug/malloc_debug.cpp
@@ -237,6 +237,9 @@ void debug_finalize() {
     return;
   }
 
+  // Turn off capturing allocations calls.
+  DebugDisableSet(true);
+
   if (g_debug->config().options() & FREE_TRACK) {
     PointerData::VerifyAllFreed();
   }
@@ -246,15 +249,11 @@ void debug_finalize() {
   }
 
   if ((g_debug->config().options() & BACKTRACE) && g_debug->config().backtrace_dump_on_exit()) {
-    ScopedDisableDebugCalls disable;
     debug_dump_heap(android::base::StringPrintf("%s.%d.exit.txt",
                                                 g_debug->config().backtrace_dump_prefix().c_str(),
-                                                getpid())
-                        .c_str());
+                                                getpid()).c_str());
   }
 
-  DebugDisableSet(true);
-
   backtrace_shutdown();
 
   delete g_debug;
diff --git a/libc/malloc_debug/tests/malloc_debug_system_tests.cpp b/libc/malloc_debug/tests/malloc_debug_system_tests.cpp
new file mode 100644
index 000000000..ccefb25d2
--- /dev/null
+++ b/libc/malloc_debug/tests/malloc_debug_system_tests.cpp
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <gtest/gtest.h>
+
+#include <log/log.h>
+
+#include <string>
+#include <vector>
+
+static constexpr time_t kTimeoutSeconds = 5;
+
+static void Exec(const char* test_name, const char* debug_options, pid_t* pid) {
+  int fds[2];
+  ASSERT_NE(-1, pipe(fds));
+  ASSERT_NE(-1, fcntl(fds[0], F_SETFL, O_NONBLOCK));
+  if ((*pid = fork()) == 0) {
+    ASSERT_EQ(0, setenv("LIBC_DEBUG_MALLOC_OPTIONS", debug_options, 1));
+    close(fds[0]);
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
+    ASSERT_NE(0, dup2(fds[1], STDOUT_FILENO));
+    ASSERT_NE(0, dup2(fds[1], STDERR_FILENO));
+
+    std::vector<const char*> args;
+    args.push_back(testing::internal::GetArgvs()[0].c_str());
+    args.push_back("--gtest_also_run_disabled_tests");
+    std::string filter_arg = std::string("--gtest_filter=") + test_name;
+    args.push_back(filter_arg.c_str());
+    args.push_back(nullptr);
+    execv(args[0], reinterpret_cast<char* const*>(const_cast<char**>(args.data())));
+    exit(1);
+  }
+  ASSERT_NE(-1, *pid);
+  close(fds[1]);
+
+  std::string output;
+  std::vector<char> buffer(4096);
+  time_t start_time = time(nullptr);
+  bool done = false;
+  while (true) {
+    struct pollfd read_fd = {.fd = fds[0], .events = POLLIN};
+    if (TEMP_FAILURE_RETRY(poll(&read_fd, 1, 1)) > 0) {
+      ssize_t bytes = TEMP_FAILURE_RETRY(read(fds[0], buffer.data(), sizeof(buffer) - 1));
+      if (bytes == -1 && errno == EAGAIN) {
+        continue;
+      }
+      ASSERT_NE(-1, bytes);
+      if (bytes == 0) {
+        done = true;
+        break;
+      }
+      output.append(buffer.data(), bytes);
+    }
+
+    if ((time(nullptr) - start_time) > kTimeoutSeconds) {
+      break;
+    }
+  }
+  EXPECT_TRUE(done) << "Timed out while reading data, output:\n" << output;
+
+  done = false;
+  int status;
+  start_time = time(nullptr);
+  while (true) {
+    int wait_pid = waitpid(*pid, &status, WNOHANG);
+    if (*pid == wait_pid) {
+      done = true;
+      break;
+    }
+    if ((time(nullptr) - start_time) > kTimeoutSeconds) {
+      break;
+    }
+  }
+  if (!done) {
+    kill(*pid, SIGKILL);
+    start_time = time(nullptr);
+    while (true) {
+      int kill_status;
+      int wait_pid = waitpid(*pid, &kill_status, WNOHANG);
+      if (wait_pid == *pid || (time(nullptr) - start_time) > kTimeoutSeconds) {
+        break;
+      }
+    }
+  }
+
+  ASSERT_TRUE(done) << "Timed out waiting for waitpid, output:\n" << output;
+  ASSERT_EQ(0, WEXITSTATUS(status)) << "Output:\n" << output;
+}
+
+static void GetLogStr(pid_t pid, std::string* log_str) {
+  log_str->clear();
+
+  logger_list* list;
+  list = android_logger_list_open(LOG_ID_MAIN, ANDROID_LOG_RDONLY | ANDROID_LOG_NONBLOCK, 1000, pid);
+  ASSERT_TRUE(list != nullptr);
+
+  while (true) {
+    log_msg msg;
+    ssize_t actual = android_logger_list_read(list, &msg);
+    if (actual < 0) {
+      if (actual == -EINTR) {
+        // Interrupted retry.
+        continue;
+      } else if (actual == -EAGAIN) {
+        // Non-blocking EOF, finished.
+        break;
+      } else {
+        break;
+      }
+    } else if (actual == 0) {
+      break;
+    }
+    ASSERT_EQ(msg.entry.pid, pid);
+
+    char* msg_str = msg.msg();
+    if (msg_str != nullptr) {
+      char* tag = msg_str + 1;
+      msg_str = tag + strlen(tag) + 1;
+      *log_str += msg_str;
+      if (log_str->back() != '\n') {
+        *log_str += '\n';
+      }
+    }
+  }
+
+  android_logger_list_close(list);
+}
+
+static void FindStrings(pid_t pid, std::vector<const char*> match_strings) {
+  std::string log_str;
+  time_t start = time(nullptr);
+  bool found_all;
+  while (true) {
+    GetLogStr(pid, &log_str);
+    found_all = true;
+    for (auto str : match_strings) {
+      if (log_str.find(str) == std::string::npos) {
+        found_all = false;
+        break;
+      }
+    }
+    if (found_all) {
+      return;
+    }
+    if ((time(nullptr) - start) > kTimeoutSeconds) {
+      break;
+    }
+  }
+  ASSERT_TRUE(found_all) << "Didn't find expected log output:\n" + log_str;
+}
+
+TEST(MallocTests, DISABLED_smoke) {}
+
+TEST(MallocDebugSystemTest, smoke) {
+  pid_t pid;
+  ASSERT_NO_FATAL_FAILURE(Exec("MallocTests.DISABLED_smoke", "backtrace", &pid));
+
+  ASSERT_NO_FATAL_FAILURE(FindStrings(pid, std::vector<const char*>{"malloc debug enabled"}));
+}
+
+TEST(MallocTests, DISABLED_leak_memory) {
+  void* ptr = malloc(1123);
+  ASSERT_TRUE(ptr != nullptr);
+  memset(ptr, 0, 1123);
+}
+
+TEST(MallocDebugSystemTest, verify_leak) {
+  pid_t pid;
+  ASSERT_NO_FATAL_FAILURE(Exec("MallocTests.DISABLED_leak_memory", "backtrace leak_track", &pid));
+
+  ASSERT_NO_FATAL_FAILURE(FindStrings(
+      pid, std::vector<const char*>{"malloc debug enabled", "leaked block of size 1123 at"}));
+}
diff --git a/tests/Android.mk b/tests/Android.mk
index c945bab70..fc7b94011 100644
--- a/tests/Android.mk
+++ b/tests/Android.mk
@@ -62,25 +62,6 @@ ifeq ($(HOST_OS)-$(HOST_ARCH),$(filter $(HOST_OS)-$(HOST_ARCH),linux-x86 linux-x
 # Some of these are intentionally using = instead of := since we need access to
 # some variables not initialtized until we're in the build system.
 
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := \
-    $(LOCAL_PATH)/Android.mk \
-    $(LOCAL_PATH)/file-check-cxx \
-    | $(HOST_OUT_EXECUTABLES)/FileCheck$(HOST_EXECUTABLE_SUFFIX) \
-
-LOCAL_CXX = $(LOCAL_PATH)/file-check-cxx \
-    $(HOST_OUT_EXECUTABLES)/FileCheck \
-    $($(LOCAL_2ND_ARCH_VAR_PREFIX)TARGET_CXX) \
-    GCC \
-
-LOCAL_CLANG := false
-LOCAL_MODULE := bionic-compile-time-tests-g++
-LOCAL_CPPFLAGS := -Wall -Werror
-# Disable color diagnostics so the warnings output matches the source
-LOCAL_CPPFLAGS += -fdiagnostics-color=never
-LOCAL_SRC_FILES := fortify_filecheck_diagnostics_test.cpp
-include $(BUILD_STATIC_LIBRARY)
-
 include $(CLEAR_VARS)
 LOCAL_ADDITIONAL_DEPENDENCIES := \
     $(LOCAL_PATH)/Android.mk \
diff --git a/tests/grp_pwd_test.cpp b/tests/grp_pwd_test.cpp
index fa8a662f2..6316387f0 100644
--- a/tests/grp_pwd_test.cpp
+++ b/tests/grp_pwd_test.cpp
@@ -275,7 +275,14 @@ TEST(pwd, getpwent_iterate) {
       EXPECT_STREQ("/data", pwd->pw_dir) << "pwd->pw_uid: " << pwd->pw_uid;
     }
 
-    EXPECT_EQ(0U, uids.count(pwd->pw_uid)) << "pwd->pw_uid: " << pwd->pw_uid;
+    // TODO(b/27999086): fix this check with the OEM range
+    // If OEMs add their own AIDs to private/android_filesystem_config.h, this check will fail.
+    // Long term we want to create a better solution for OEMs adding AIDs, but we're not there
+    // yet, so therefore we do not check for uid's in the OEM range.
+    if (!(pwd->pw_uid >= 2900 && pwd->pw_uid <= 2999) &&
+        !(pwd->pw_uid >= 5000 && pwd->pw_uid <= 5999)) {
+      EXPECT_EQ(0U, uids.count(pwd->pw_uid)) << "pwd->pw_uid: " << pwd->pw_uid;
+    }
     uids.emplace(pwd->pw_uid);
   }
   endpwent();
@@ -518,7 +525,14 @@ TEST(grp, getgrent_iterate) {
     EXPECT_STREQ(grp->gr_name, grp->gr_mem[0]) << "grp->gr_gid: " << grp->gr_gid;
     EXPECT_TRUE(grp->gr_mem[1] == NULL) << "grp->gr_gid: " << grp->gr_gid;
 
-    EXPECT_EQ(0U, gids.count(grp->gr_gid)) << "grp->gr_gid: " << grp->gr_gid;
+    // TODO(b/27999086): fix this check with the OEM range
+    // If OEMs add their own AIDs to private/android_filesystem_config.h, this check will fail.
+    // Long term we want to create a better solution for OEMs adding AIDs, but we're not there
+    // yet, so therefore we do not check for gid's in the OEM range.
+    if (!(grp->gr_gid >= 2900 && grp->gr_gid <= 2999) &&
+        !(grp->gr_gid >= 5000 && grp->gr_gid <= 5999)) {
+      EXPECT_EQ(0U, gids.count(grp->gr_gid)) << "grp->gr_gid: " << grp->gr_gid;
+    }
     gids.emplace(grp->gr_gid);
   }
   endgrent();
-- 
2.17.1

